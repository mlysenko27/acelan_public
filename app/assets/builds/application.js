(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));

  // node_modules/@rails/actioncable/src/adapters.js
  var adapters_default;
  var init_adapters = __esm({
    "node_modules/@rails/actioncable/src/adapters.js"() {
      adapters_default = {
        logger: self.console,
        WebSocket: self.WebSocket
      };
    }
  });

  // node_modules/@rails/actioncable/src/logger.js
  var logger_default;
  var init_logger = __esm({
    "node_modules/@rails/actioncable/src/logger.js"() {
      init_adapters();
      logger_default = {
        log(...messages) {
          if (this.enabled) {
            messages.push(Date.now());
            adapters_default.logger.log("[ActionCable]", ...messages);
          }
        }
      };
    }
  });

  // node_modules/@rails/actioncable/src/connection_monitor.js
  var now, secondsSince, ConnectionMonitor, connection_monitor_default;
  var init_connection_monitor = __esm({
    "node_modules/@rails/actioncable/src/connection_monitor.js"() {
      init_logger();
      now = () => (/* @__PURE__ */ new Date()).getTime();
      secondsSince = (time) => (now() - time) / 1e3;
      ConnectionMonitor = class {
        constructor(connection) {
          this.visibilityDidChange = this.visibilityDidChange.bind(this);
          this.connection = connection;
          this.reconnectAttempts = 0;
        }
        start() {
          if (!this.isRunning()) {
            this.startedAt = now();
            delete this.stoppedAt;
            this.startPolling();
            addEventListener("visibilitychange", this.visibilityDidChange);
            logger_default.log(`ConnectionMonitor started. stale threshold = ${this.constructor.staleThreshold} s`);
          }
        }
        stop() {
          if (this.isRunning()) {
            this.stoppedAt = now();
            this.stopPolling();
            removeEventListener("visibilitychange", this.visibilityDidChange);
            logger_default.log("ConnectionMonitor stopped");
          }
        }
        isRunning() {
          return this.startedAt && !this.stoppedAt;
        }
        recordPing() {
          this.pingedAt = now();
        }
        recordConnect() {
          this.reconnectAttempts = 0;
          this.recordPing();
          delete this.disconnectedAt;
          logger_default.log("ConnectionMonitor recorded connect");
        }
        recordDisconnect() {
          this.disconnectedAt = now();
          logger_default.log("ConnectionMonitor recorded disconnect");
        }
        // Private
        startPolling() {
          this.stopPolling();
          this.poll();
        }
        stopPolling() {
          clearTimeout(this.pollTimeout);
        }
        poll() {
          this.pollTimeout = setTimeout(
            () => {
              this.reconnectIfStale();
              this.poll();
            },
            this.getPollInterval()
          );
        }
        getPollInterval() {
          const { staleThreshold, reconnectionBackoffRate } = this.constructor;
          const backoff = Math.pow(1 + reconnectionBackoffRate, Math.min(this.reconnectAttempts, 10));
          const jitterMax = this.reconnectAttempts === 0 ? 1 : reconnectionBackoffRate;
          const jitter = jitterMax * Math.random();
          return staleThreshold * 1e3 * backoff * (1 + jitter);
        }
        reconnectIfStale() {
          if (this.connectionIsStale()) {
            logger_default.log(`ConnectionMonitor detected stale connection. reconnectAttempts = ${this.reconnectAttempts}, time stale = ${secondsSince(this.refreshedAt)} s, stale threshold = ${this.constructor.staleThreshold} s`);
            this.reconnectAttempts++;
            if (this.disconnectedRecently()) {
              logger_default.log(`ConnectionMonitor skipping reopening recent disconnect. time disconnected = ${secondsSince(this.disconnectedAt)} s`);
            } else {
              logger_default.log("ConnectionMonitor reopening");
              this.connection.reopen();
            }
          }
        }
        get refreshedAt() {
          return this.pingedAt ? this.pingedAt : this.startedAt;
        }
        connectionIsStale() {
          return secondsSince(this.refreshedAt) > this.constructor.staleThreshold;
        }
        disconnectedRecently() {
          return this.disconnectedAt && secondsSince(this.disconnectedAt) < this.constructor.staleThreshold;
        }
        visibilityDidChange() {
          if (document.visibilityState === "visible") {
            setTimeout(
              () => {
                if (this.connectionIsStale() || !this.connection.isOpen()) {
                  logger_default.log(`ConnectionMonitor reopening stale connection on visibilitychange. visibilityState = ${document.visibilityState}`);
                  this.connection.reopen();
                }
              },
              200
            );
          }
        }
      };
      ConnectionMonitor.staleThreshold = 6;
      ConnectionMonitor.reconnectionBackoffRate = 0.15;
      connection_monitor_default = ConnectionMonitor;
    }
  });

  // node_modules/@rails/actioncable/src/internal.js
  var internal_default;
  var init_internal = __esm({
    "node_modules/@rails/actioncable/src/internal.js"() {
      internal_default = {
        "message_types": {
          "welcome": "welcome",
          "disconnect": "disconnect",
          "ping": "ping",
          "confirmation": "confirm_subscription",
          "rejection": "reject_subscription"
        },
        "disconnect_reasons": {
          "unauthorized": "unauthorized",
          "invalid_request": "invalid_request",
          "server_restart": "server_restart"
        },
        "default_mount_path": "/cable",
        "protocols": [
          "actioncable-v1-json",
          "actioncable-unsupported"
        ]
      };
    }
  });

  // node_modules/@rails/actioncable/src/connection.js
  var message_types, protocols, supportedProtocols, indexOf, Connection, connection_default;
  var init_connection = __esm({
    "node_modules/@rails/actioncable/src/connection.js"() {
      init_adapters();
      init_connection_monitor();
      init_internal();
      init_logger();
      ({ message_types, protocols } = internal_default);
      supportedProtocols = protocols.slice(0, protocols.length - 1);
      indexOf = [].indexOf;
      Connection = class {
        constructor(consumer2) {
          this.open = this.open.bind(this);
          this.consumer = consumer2;
          this.subscriptions = this.consumer.subscriptions;
          this.monitor = new connection_monitor_default(this);
          this.disconnected = true;
        }
        send(data) {
          if (this.isOpen()) {
            this.webSocket.send(JSON.stringify(data));
            return true;
          } else {
            return false;
          }
        }
        open() {
          if (this.isActive()) {
            logger_default.log(`Attempted to open WebSocket, but existing socket is ${this.getState()}`);
            return false;
          } else {
            logger_default.log(`Opening WebSocket, current state is ${this.getState()}, subprotocols: ${protocols}`);
            if (this.webSocket) {
              this.uninstallEventHandlers();
            }
            this.webSocket = new adapters_default.WebSocket(this.consumer.url, protocols);
            this.installEventHandlers();
            this.monitor.start();
            return true;
          }
        }
        close({ allowReconnect } = { allowReconnect: true }) {
          if (!allowReconnect) {
            this.monitor.stop();
          }
          if (this.isOpen()) {
            return this.webSocket.close();
          }
        }
        reopen() {
          logger_default.log(`Reopening WebSocket, current state is ${this.getState()}`);
          if (this.isActive()) {
            try {
              return this.close();
            } catch (error2) {
              logger_default.log("Failed to reopen WebSocket", error2);
            } finally {
              logger_default.log(`Reopening WebSocket in ${this.constructor.reopenDelay}ms`);
              setTimeout(this.open, this.constructor.reopenDelay);
            }
          } else {
            return this.open();
          }
        }
        getProtocol() {
          if (this.webSocket) {
            return this.webSocket.protocol;
          }
        }
        isOpen() {
          return this.isState("open");
        }
        isActive() {
          return this.isState("open", "connecting");
        }
        // Private
        isProtocolSupported() {
          return indexOf.call(supportedProtocols, this.getProtocol()) >= 0;
        }
        isState(...states) {
          return indexOf.call(states, this.getState()) >= 0;
        }
        getState() {
          if (this.webSocket) {
            for (let state in adapters_default.WebSocket) {
              if (adapters_default.WebSocket[state] === this.webSocket.readyState) {
                return state.toLowerCase();
              }
            }
          }
          return null;
        }
        installEventHandlers() {
          for (let eventName in this.events) {
            const handler = this.events[eventName].bind(this);
            this.webSocket[`on${eventName}`] = handler;
          }
        }
        uninstallEventHandlers() {
          for (let eventName in this.events) {
            this.webSocket[`on${eventName}`] = function() {
            };
          }
        }
      };
      Connection.reopenDelay = 500;
      Connection.prototype.events = {
        message(event) {
          if (!this.isProtocolSupported()) {
            return;
          }
          const { identifier, message, reason, reconnect, type } = JSON.parse(event.data);
          switch (type) {
            case message_types.welcome:
              this.monitor.recordConnect();
              return this.subscriptions.reload();
            case message_types.disconnect:
              logger_default.log(`Disconnecting. Reason: ${reason}`);
              return this.close({ allowReconnect: reconnect });
            case message_types.ping:
              return this.monitor.recordPing();
            case message_types.confirmation:
              this.subscriptions.confirmSubscription(identifier);
              return this.subscriptions.notify(identifier, "connected");
            case message_types.rejection:
              return this.subscriptions.reject(identifier);
            default:
              return this.subscriptions.notify(identifier, "received", message);
          }
        },
        open() {
          logger_default.log(`WebSocket onopen event, using '${this.getProtocol()}' subprotocol`);
          this.disconnected = false;
          if (!this.isProtocolSupported()) {
            logger_default.log("Protocol is unsupported. Stopping monitor and disconnecting.");
            return this.close({ allowReconnect: false });
          }
        },
        close(event) {
          logger_default.log("WebSocket onclose event");
          if (this.disconnected) {
            return;
          }
          this.disconnected = true;
          this.monitor.recordDisconnect();
          return this.subscriptions.notifyAll("disconnected", { willAttemptReconnect: this.monitor.isRunning() });
        },
        error() {
          logger_default.log("WebSocket onerror event");
        }
      };
      connection_default = Connection;
    }
  });

  // node_modules/@rails/actioncable/src/subscription.js
  var extend, Subscription;
  var init_subscription = __esm({
    "node_modules/@rails/actioncable/src/subscription.js"() {
      extend = function(object, properties) {
        if (properties != null) {
          for (let key in properties) {
            const value = properties[key];
            object[key] = value;
          }
        }
        return object;
      };
      Subscription = class {
        constructor(consumer2, params = {}, mixin) {
          this.consumer = consumer2;
          this.identifier = JSON.stringify(params);
          extend(this, mixin);
        }
        // Perform a channel action with the optional data passed as an attribute
        perform(action, data = {}) {
          data.action = action;
          return this.send(data);
        }
        send(data) {
          return this.consumer.send({ command: "message", identifier: this.identifier, data: JSON.stringify(data) });
        }
        unsubscribe() {
          return this.consumer.subscriptions.remove(this);
        }
      };
    }
  });

  // node_modules/@rails/actioncable/src/subscription_guarantor.js
  var SubscriptionGuarantor, subscription_guarantor_default;
  var init_subscription_guarantor = __esm({
    "node_modules/@rails/actioncable/src/subscription_guarantor.js"() {
      init_logger();
      SubscriptionGuarantor = class {
        constructor(subscriptions) {
          this.subscriptions = subscriptions;
          this.pendingSubscriptions = [];
        }
        guarantee(subscription) {
          if (this.pendingSubscriptions.indexOf(subscription) == -1) {
            logger_default.log(`SubscriptionGuarantor guaranteeing ${subscription.identifier}`);
            this.pendingSubscriptions.push(subscription);
          } else {
            logger_default.log(`SubscriptionGuarantor already guaranteeing ${subscription.identifier}`);
          }
          this.startGuaranteeing();
        }
        forget(subscription) {
          logger_default.log(`SubscriptionGuarantor forgetting ${subscription.identifier}`);
          this.pendingSubscriptions = this.pendingSubscriptions.filter((s) => s !== subscription);
        }
        startGuaranteeing() {
          this.stopGuaranteeing();
          this.retrySubscribing();
        }
        stopGuaranteeing() {
          clearTimeout(this.retryTimeout);
        }
        retrySubscribing() {
          this.retryTimeout = setTimeout(
            () => {
              if (this.subscriptions && typeof this.subscriptions.subscribe === "function") {
                this.pendingSubscriptions.map((subscription) => {
                  logger_default.log(`SubscriptionGuarantor resubscribing ${subscription.identifier}`);
                  this.subscriptions.subscribe(subscription);
                });
              }
            },
            500
          );
        }
      };
      subscription_guarantor_default = SubscriptionGuarantor;
    }
  });

  // node_modules/@rails/actioncable/src/subscriptions.js
  var Subscriptions;
  var init_subscriptions = __esm({
    "node_modules/@rails/actioncable/src/subscriptions.js"() {
      init_subscription();
      init_subscription_guarantor();
      init_logger();
      Subscriptions = class {
        constructor(consumer2) {
          this.consumer = consumer2;
          this.guarantor = new subscription_guarantor_default(this);
          this.subscriptions = [];
        }
        create(channelName, mixin) {
          const channel = channelName;
          const params = typeof channel === "object" ? channel : { channel };
          const subscription = new Subscription(this.consumer, params, mixin);
          return this.add(subscription);
        }
        // Private
        add(subscription) {
          this.subscriptions.push(subscription);
          this.consumer.ensureActiveConnection();
          this.notify(subscription, "initialized");
          this.subscribe(subscription);
          return subscription;
        }
        remove(subscription) {
          this.forget(subscription);
          if (!this.findAll(subscription.identifier).length) {
            this.sendCommand(subscription, "unsubscribe");
          }
          return subscription;
        }
        reject(identifier) {
          return this.findAll(identifier).map((subscription) => {
            this.forget(subscription);
            this.notify(subscription, "rejected");
            return subscription;
          });
        }
        forget(subscription) {
          this.guarantor.forget(subscription);
          this.subscriptions = this.subscriptions.filter((s) => s !== subscription);
          return subscription;
        }
        findAll(identifier) {
          return this.subscriptions.filter((s) => s.identifier === identifier);
        }
        reload() {
          return this.subscriptions.map((subscription) => this.subscribe(subscription));
        }
        notifyAll(callbackName, ...args) {
          return this.subscriptions.map((subscription) => this.notify(subscription, callbackName, ...args));
        }
        notify(subscription, callbackName, ...args) {
          let subscriptions;
          if (typeof subscription === "string") {
            subscriptions = this.findAll(subscription);
          } else {
            subscriptions = [subscription];
          }
          return subscriptions.map((subscription2) => typeof subscription2[callbackName] === "function" ? subscription2[callbackName](...args) : void 0);
        }
        subscribe(subscription) {
          if (this.sendCommand(subscription, "subscribe")) {
            this.guarantor.guarantee(subscription);
          }
        }
        confirmSubscription(identifier) {
          logger_default.log(`Subscription confirmed ${identifier}`);
          this.findAll(identifier).map((subscription) => this.guarantor.forget(subscription));
        }
        sendCommand(subscription, command) {
          const { identifier } = subscription;
          return this.consumer.send({ command, identifier });
        }
      };
    }
  });

  // node_modules/@rails/actioncable/src/consumer.js
  function createWebSocketURL(url) {
    if (typeof url === "function") {
      url = url();
    }
    if (url && !/^wss?:/i.test(url)) {
      const a = document.createElement("a");
      a.href = url;
      a.href = a.href;
      a.protocol = a.protocol.replace("http", "ws");
      return a.href;
    } else {
      return url;
    }
  }
  var Consumer;
  var init_consumer = __esm({
    "node_modules/@rails/actioncable/src/consumer.js"() {
      init_connection();
      init_subscriptions();
      Consumer = class {
        constructor(url) {
          this._url = url;
          this.subscriptions = new Subscriptions(this);
          this.connection = new connection_default(this);
        }
        get url() {
          return createWebSocketURL(this._url);
        }
        send(data) {
          return this.connection.send(data);
        }
        connect() {
          return this.connection.open();
        }
        disconnect() {
          return this.connection.close({ allowReconnect: false });
        }
        ensureActiveConnection() {
          if (!this.connection.isActive()) {
            return this.connection.open();
          }
        }
      };
    }
  });

  // node_modules/@rails/actioncable/src/index.js
  var src_exports = {};
  __export(src_exports, {
    Connection: () => connection_default,
    ConnectionMonitor: () => connection_monitor_default,
    Consumer: () => Consumer,
    INTERNAL: () => internal_default,
    Subscription: () => Subscription,
    SubscriptionGuarantor: () => subscription_guarantor_default,
    Subscriptions: () => Subscriptions,
    adapters: () => adapters_default,
    createConsumer: () => createConsumer,
    createWebSocketURL: () => createWebSocketURL,
    getConfig: () => getConfig,
    logger: () => logger_default
  });
  function createConsumer(url = getConfig("url") || internal_default.default_mount_path) {
    return new Consumer(url);
  }
  function getConfig(name) {
    const element = document.head.querySelector(`meta[name='action-cable-${name}']`);
    if (element) {
      return element.getAttribute("content");
    }
  }
  var init_src = __esm({
    "node_modules/@rails/actioncable/src/index.js"() {
      init_connection();
      init_connection_monitor();
      init_consumer();
      init_internal();
      init_subscription();
      init_subscriptions();
      init_subscription_guarantor();
      init_adapters();
      init_logger();
    }
  });

  // node_modules/@editorjs/editorjs/dist/editor.js
  var require_editor = __commonJS({
    "node_modules/@editorjs/editorjs/dist/editor.js"(exports, module) {
      !function(t, e) {
        "object" == typeof exports && "object" == typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define([], e) : "object" == typeof exports ? exports.EditorJS = e() : t.EditorJS = e();
      }(window, function() {
        return function(t) {
          var e = {};
          function n(o) {
            if (e[o])
              return e[o].exports;
            var r = e[o] = { i: o, l: false, exports: {} };
            return t[o].call(r.exports, r, r.exports, n), r.l = true, r.exports;
          }
          return n.m = t, n.c = e, n.d = function(t2, e2, o) {
            n.o(t2, e2) || Object.defineProperty(t2, e2, { enumerable: true, get: o });
          }, n.r = function(t2) {
            "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t2, "__esModule", { value: true });
          }, n.t = function(t2, e2) {
            if (1 & e2 && (t2 = n(t2)), 8 & e2)
              return t2;
            if (4 & e2 && "object" == typeof t2 && t2 && t2.__esModule)
              return t2;
            var o = /* @__PURE__ */ Object.create(null);
            if (n.r(o), Object.defineProperty(o, "default", { enumerable: true, value: t2 }), 2 & e2 && "string" != typeof t2)
              for (var r in t2)
                n.d(o, r, function(e3) {
                  return t2[e3];
                }.bind(null, r));
            return o;
          }, n.n = function(t2) {
            var e2 = t2 && t2.__esModule ? function() {
              return t2.default;
            } : function() {
              return t2;
            };
            return n.d(e2, "a", e2), e2;
          }, n.o = function(t2, e2) {
            return Object.prototype.hasOwnProperty.call(t2, e2);
          }, n.p = "", n(n.s = 187);
        }([function(t, e, n) {
          var o = n(10), r = n(17), i = n(27), a = n(23), s = n(31), l = function(t2, e2, n2) {
            var c, u, f, d, p = t2 & l.F, h = t2 & l.G, v = t2 & l.S, g = t2 & l.P, y = t2 & l.B, b = h ? o : v ? o[e2] || (o[e2] = {}) : (o[e2] || {}).prototype, m = h ? r : r[e2] || (r[e2] = {}), k = m.prototype || (m.prototype = {});
            for (c in h && (n2 = e2), n2)
              f = ((u = !p && b && void 0 !== b[c]) ? b : n2)[c], d = y && u ? s(f, o) : g && "function" == typeof f ? s(Function.call, f) : f, b && a(b, c, f, t2 & l.U), m[c] != f && i(m, c, d), g && k[c] != f && (k[c] = f);
          };
          o.core = r, l.F = 1, l.G = 2, l.S = 4, l.P = 8, l.B = 16, l.W = 32, l.U = 64, l.R = 128, t.exports = l;
        }, function(t, e) {
          t.exports = function(t2) {
            return t2 && t2.__esModule ? t2 : { default: t2 };
          };
        }, function(t, e) {
          t.exports = function(t2, e2) {
            if (!(t2 instanceof e2))
              throw new TypeError("Cannot call a class as a function");
          };
        }, function(t, e) {
          function n(t2, e2) {
            for (var n2 = 0; n2 < e2.length; n2++) {
              var o = e2[n2];
              o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(t2, o.key, o);
            }
          }
          t.exports = function(t2, e2, o) {
            return e2 && n(t2.prototype, e2), o && n(t2, o), t2;
          };
        }, function(t, e) {
          function n(e2) {
            return t.exports = n = Object.setPrototypeOf ? Object.getPrototypeOf : function(t2) {
              return t2.__proto__ || Object.getPrototypeOf(t2);
            }, n(e2);
          }
          t.exports = n;
        }, function(t, e, n) {
          var o = n(110);
          t.exports = function(t2, e2) {
            if ("function" != typeof e2 && null !== e2)
              throw new TypeError("Super expression must either be null or a function");
            t2.prototype = Object.create(e2 && e2.prototype, { constructor: { value: t2, writable: true, configurable: true } }), e2 && o(t2, e2);
          };
        }, function(t, e, n) {
          var o = n(59), r = n(152);
          t.exports = function(t2, e2) {
            return !e2 || "object" !== o(e2) && "function" != typeof e2 ? r(t2) : e2;
          };
        }, function(t, e, n) {
          var o, r, i;
          "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self && self, r = [e, n(20), n(371), n(21), n(403), n(14)], void 0 === (i = "function" == typeof (o = function(t2, e2, o2, r2, i2, a) {
            "use strict";
            var s, l = n(1);
            function c(t3, e3) {
              var n2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "log", o3 = arguments.length > 3 ? arguments[3] : void 0, r3 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : "color: inherit";
              if ("console" in window && window.console[n2]) {
                var i3 = ["info", "log", "warn", "error"].includes(n2), a2 = [];
                switch (c.logLevel) {
                  case s.ERROR:
                    if ("error" !== n2)
                      return;
                    break;
                  case s.WARN:
                    if (!["error", "warn"].includes(n2))
                      return;
                    break;
                  case s.INFO:
                    if (!i3 || t3)
                      return;
                }
                o3 && a2.push(o3);
                var l2 = "Editor.js ".concat("2.25.0"), u2 = "line-height: 1em;\n            color: #006FEA;\n            display: inline-block;\n            font-size: 11px;\n            line-height: 1em;\n            background-color: #fff;\n            padding: 4px 9px;\n            border-radius: 30px;\n            border: 1px solid rgba(56, 138, 229, 0.16);\n            margin: 4px 5px 4px 0;";
                t3 && (i3 ? (a2.unshift(u2, r3), e3 = "%c".concat(l2, "%c ").concat(e3)) : e3 = "( ".concat(l2, " )").concat(e3));
                try {
                  if (i3)
                    if (o3) {
                      var f2;
                      (f2 = console)[n2].apply(f2, ["".concat(e3, " %o")].concat(a2));
                    } else {
                      var d2;
                      (d2 = console)[n2].apply(d2, [e3].concat(a2));
                    }
                  else
                    console[n2](e3);
                } catch (t4) {
                }
              }
            }
            Object.defineProperty(t2, "__esModule", { value: true }), t2.setLogLevel = function(t3) {
              c.logLevel = t3;
            }, t2.typeOf = d, t2.isFunction = p, t2.isObject = h, t2.isString = function(t3) {
              return "string" === d(t3);
            }, t2.isBoolean = function(t3) {
              return "boolean" === d(t3);
            }, t2.isNumber = function(t3) {
              return "number" === d(t3);
            }, t2.isUndefined = v, t2.isClass = function(t3) {
              return p(t3) && /^\s*class\s+/.test(t3.toString());
            }, t2.isEmpty = function(t3) {
              return !t3 || 0 === Object.keys(t3).length && t3.constructor === Object;
            }, t2.isPromise = function(t3) {
              return Promise.resolve(t3) === t3;
            }, t2.isPrintableKey = function(t3) {
              return t3 > 47 && t3 < 58 || 32 === t3 || 13 === t3 || 229 === t3 || t3 > 64 && t3 < 91 || t3 > 95 && t3 < 112 || t3 > 185 && t3 < 193 || t3 > 218 && t3 < 223;
            }, t2.sequence = function(t3) {
              return g.apply(this, arguments);
            }, t2.array = function(t3) {
              return Array.prototype.slice.call(t3);
            }, t2.delay = function(t3, e3) {
              return function() {
                var n2 = this, o3 = arguments;
                window.setTimeout(function() {
                  return t3.apply(n2, o3);
                }, e3);
              };
            }, t2.getFileExtension = function(t3) {
              return t3.name.split(".").pop();
            }, t2.isValidMimeType = function(t3) {
              return /^[-\w]+\/([-+\w]+|\*)$/.test(t3);
            }, t2.debounce = function(t3, e3, n2) {
              var o3, r3 = this;
              return function() {
                for (var i3 = arguments.length, a2 = new Array(i3), s2 = 0; s2 < i3; s2++)
                  a2[s2] = arguments[s2];
                var l2 = r3, c2 = function() {
                  o3 = null, n2 || t3.apply(l2, a2);
                }, u2 = n2 && !o3;
                window.clearTimeout(o3), o3 = window.setTimeout(c2, e3), u2 && t3.apply(l2, a2);
              };
            }, t2.throttle = function(t3, e3) {
              var n2, o3, r3, i3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : void 0, a2 = null, s2 = 0;
              i3 || (i3 = {});
              var l2 = function() {
                s2 = false === i3.leading ? 0 : Date.now(), a2 = null, r3 = t3.apply(n2, o3), a2 || (n2 = o3 = null);
              };
              return function() {
                var c2 = Date.now();
                s2 || false !== i3.leading || (s2 = c2);
                var u2 = e3 - (c2 - s2);
                return n2 = this, o3 = arguments, u2 <= 0 || u2 > e3 ? (a2 && (clearTimeout(a2), a2 = null), s2 = c2, r3 = t3.apply(n2, o3), a2 || (n2 = o3 = null)) : a2 || false === i3.trailing || (a2 = setTimeout(l2, u2)), r3;
              };
            }, t2.copyTextToClipboard = function(t3) {
              var e3 = a.default.make("div", "codex-editor-clipboard", { innerHTML: t3 });
              document.body.appendChild(e3);
              var n2 = window.getSelection(), o3 = document.createRange();
              o3.selectNode(e3), window.getSelection().removeAllRanges(), n2.addRange(o3), document.execCommand("copy"), document.body.removeChild(e3);
            }, t2.getUserOS = y, t2.capitalize = function(t3) {
              return t3[0].toUpperCase() + t3.slice(1);
            }, t2.deepMerge = function t3(e3) {
              for (var n2 = arguments.length, r3 = new Array(n2 > 1 ? n2 - 1 : 0), i3 = 1; i3 < n2; i3++)
                r3[i3 - 1] = arguments[i3];
              if (!r3.length)
                return e3;
              var a2 = r3.shift();
              if (h(e3) && h(a2))
                for (var s2 in a2)
                  h(a2[s2]) ? (e3[s2] || Object.assign(e3, (0, o2.default)({}, s2, {})), t3(e3[s2], a2[s2])) : Object.assign(e3, (0, o2.default)({}, s2, a2[s2]));
              return t3.apply(void 0, [e3].concat(r3));
            }, t2.beautifyShortcut = function(t3) {
              var e3 = y();
              return t3 = t3.replace(/shift/gi, "\u21E7").replace(/backspace/gi, "\u232B").replace(/enter/gi, "\u23CE").replace(/up/gi, "\u2191").replace(/left/gi, "\u2192").replace(/down/gi, "\u2193").replace(/right/gi, "\u2190").replace(/escape/gi, "\u238B").replace(/insert/gi, "Ins").replace(/delete/gi, "\u2421").replace(/\+/gi, " + "), t3 = e3.mac ? t3.replace(/ctrl|cmd/gi, "\u2318").replace(/alt/gi, "\u2325") : t3.replace(/cmd/gi, "Ctrl").replace(/windows/gi, "WIN");
            }, t2.getValidUrl = function(t3) {
              try {
                return new URL(t3).href;
              } catch (t4) {
              }
              return "//" === t3.substring(0, 2) ? window.location.protocol + t3 : window.location.origin + t3;
            }, t2.generateBlockId = function() {
              return (0, i2.nanoid)(10);
            }, t2.openTab = function(t3) {
              window.open(t3, "_blank");
            }, t2.generateId = function() {
              var t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "";
              return "".concat(t3).concat(Math.floor(1e8 * Math.random()).toString(16));
            }, t2.deprecationAssert = function(t3, e3, n2) {
              var o3 = "\xAB".concat(e3, "\xBB is deprecated and will be removed in the next major release. Please use the \xAB").concat(n2, "\xBB instead.");
              t3 && f(o3, "warn");
            }, t2.cacheable = function(t3, e3, n2) {
              var o3 = n2.value ? "value" : "get", r3 = n2[o3], i3 = "#".concat(e3, "Cache");
              if (n2[o3] = function() {
                if (void 0 === this[i3]) {
                  for (var t4 = arguments.length, e4 = new Array(t4), n3 = 0; n3 < t4; n3++)
                    e4[n3] = arguments[n3];
                  this[i3] = r3.apply.apply(r3, [this].concat(e4));
                }
                return this[i3];
              }, "get" === o3 && n2.set) {
                var a2 = n2.set;
                n2.set = function(e4) {
                  delete t3[i3], a2.apply(this, e4);
                };
              }
              return n2;
            }, t2.isMobileScreen = function() {
              return window.matchMedia("(max-width: 650px)").matches;
            }, t2.equals = function(t3, e3) {
              var n2 = Array.isArray(t3) || h(t3), o3 = Array.isArray(e3) || h(e3);
              return n2 || o3 ? JSON.stringify(t3) === JSON.stringify(e3) : t3 === e3;
            }, t2.isIosDevice = t2.isTouchSupported = t2.logLabeled = t2.log = t2.mouseButtons = t2.keyCodes = t2.LogLevels = void 0, e2 = l(e2), o2 = l(o2), r2 = l(r2), a = l(a), t2.LogLevels = s, function(t3) {
              t3.VERBOSE = "VERBOSE", t3.INFO = "INFO", t3.WARN = "WARN", t3.ERROR = "ERROR";
            }(s || (t2.LogLevels = s = {})), t2.keyCodes = { BACKSPACE: 8, TAB: 9, ENTER: 13, SHIFT: 16, CTRL: 17, ALT: 18, ESC: 27, SPACE: 32, LEFT: 37, UP: 38, DOWN: 40, RIGHT: 39, DELETE: 46, META: 91 }, t2.mouseButtons = { LEFT: 0, WHEEL: 1, RIGHT: 2, BACKWARD: 3, FORWARD: 4 }, c.logLevel = s.VERBOSE;
            var u = c.bind(window, false);
            t2.log = u;
            var f = c.bind(window, true);
            function d(t3) {
              return Object.prototype.toString.call(t3).match(/\s([a-zA-Z]+)/)[1].toLowerCase();
            }
            function p(t3) {
              return "function" === d(t3) || "asyncfunction" === d(t3);
            }
            function h(t3) {
              return "object" === d(t3);
            }
            function v(t3) {
              return "undefined" === d(t3);
            }
            function g() {
              return (g = (0, r2.default)(e2.default.mark(function t3(n2) {
                var o3, i3, a2, s2, l2 = arguments;
                return e2.default.wrap(function(t4) {
                  for (; ; )
                    switch (t4.prev = t4.next) {
                      case 0:
                        return s2 = function() {
                          return (s2 = (0, r2.default)(e2.default.mark(function t5(n3, o4, r3) {
                            return e2.default.wrap(function(t6) {
                              for (; ; )
                                switch (t6.prev = t6.next) {
                                  case 0:
                                    return t6.prev = 0, t6.next = 3, n3.function(n3.data);
                                  case 3:
                                    return t6.next = 5, o4(v(n3.data) ? {} : n3.data);
                                  case 5:
                                    t6.next = 10;
                                    break;
                                  case 7:
                                    t6.prev = 7, t6.t0 = t6.catch(0), r3(v(n3.data) ? {} : n3.data);
                                  case 10:
                                  case "end":
                                    return t6.stop();
                                }
                            }, t5, null, [[0, 7]]);
                          }))).apply(this, arguments);
                        }, a2 = function(t5, e3, n3) {
                          return s2.apply(this, arguments);
                        }, o3 = l2.length > 1 && void 0 !== l2[1] ? l2[1] : function() {
                        }, i3 = l2.length > 2 && void 0 !== l2[2] ? l2[2] : function() {
                        }, t4.abrupt("return", n2.reduce(function() {
                          var t5 = (0, r2.default)(e2.default.mark(function t6(n3, r3) {
                            return e2.default.wrap(function(t7) {
                              for (; ; )
                                switch (t7.prev = t7.next) {
                                  case 0:
                                    return t7.next = 2, n3;
                                  case 2:
                                    return t7.abrupt("return", a2(r3, o3, i3));
                                  case 3:
                                  case "end":
                                    return t7.stop();
                                }
                            }, t6);
                          }));
                          return function(e3, n3) {
                            return t5.apply(this, arguments);
                          };
                        }(), Promise.resolve()));
                      case 5:
                      case "end":
                        return t4.stop();
                    }
                }, t3);
              }))).apply(this, arguments);
            }
            function y() {
              var t3 = { win: false, mac: false, x11: false, linux: false }, e3 = Object.keys(t3).find(function(t4) {
                return -1 !== navigator.appVersion.toLowerCase().indexOf(t4);
              });
              return e3 ? (t3[e3] = true, t3) : t3;
            }
            t2.logLabeled = f;
            var b = "ontouchstart" in document.documentElement;
            t2.isTouchSupported = b;
            var m = "undefined" != typeof window && window.navigator && window.navigator.platform && (/iP(ad|hone|od)/.test(window.navigator.platform) || "MacIntel" === window.navigator.platform && window.navigator.maxTouchPoints > 1);
            t2.isIosDevice = m;
          }) ? o.apply(e, r) : o) || (t.exports = i);
        }, function(t, e, n) {
          var o = n(59);
          function r() {
            if ("function" != typeof WeakMap)
              return null;
            var t2 = /* @__PURE__ */ new WeakMap();
            return r = function() {
              return t2;
            }, t2;
          }
          t.exports = function(t2) {
            if (t2 && t2.__esModule)
              return t2;
            if (null === t2 || "object" !== o(t2) && "function" != typeof t2)
              return { default: t2 };
            var e2 = r();
            if (e2 && e2.has(t2))
              return e2.get(t2);
            var n2 = {}, i = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var a in t2)
              if (Object.prototype.hasOwnProperty.call(t2, a)) {
                var s = i ? Object.getOwnPropertyDescriptor(t2, a) : null;
                s && (s.get || s.set) ? Object.defineProperty(n2, a, s) : n2[a] = t2[a];
              }
            return n2.default = t2, e2 && e2.set(t2, n2), n2;
          };
        }, function(t, e, n) {
          var o, r, i;
          "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self && self, r = [e, n(2), n(3), n(111)], void 0 === (i = "function" == typeof (o = function(o2, r2, i2, a) {
            "use strict";
            var s = n(1);
            function l(t2) {
              if ("undefined" == typeof Symbol || null == t2[Symbol.iterator]) {
                if (Array.isArray(t2) || (t2 = function(t3, e3) {
                  if (t3) {
                    if ("string" == typeof t3)
                      return c(t3, e3);
                    var n3 = Object.prototype.toString.call(t3).slice(8, -1);
                    return "Object" === n3 && t3.constructor && (n3 = t3.constructor.name), "Map" === n3 || "Set" === n3 ? Array.from(n3) : "Arguments" === n3 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n3) ? c(t3, e3) : void 0;
                  }
                }(t2))) {
                  var e2 = 0, n2 = function() {
                  };
                  return { s: n2, n: function() {
                    return e2 >= t2.length ? { done: true } : { done: false, value: t2[e2++] };
                  }, e: function(t3) {
                    throw t3;
                  }, f: n2 };
                }
                throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
              }
              var o3, r3, i3 = true, a2 = false;
              return { s: function() {
                o3 = t2[Symbol.iterator]();
              }, n: function() {
                var t3 = o3.next();
                return i3 = t3.done, t3;
              }, e: function(t3) {
                a2 = true, r3 = t3;
              }, f: function() {
                try {
                  i3 || null == o3.return || o3.return();
                } finally {
                  if (a2)
                    throw r3;
                }
              } };
            }
            function c(t2, e2) {
              (null == e2 || e2 > t2.length) && (e2 = t2.length);
              for (var n2 = 0, o3 = new Array(e2); n2 < e2; n2++)
                o3[n2] = t2[n2];
              return o3;
            }
            Object.defineProperty(o2, "__esModule", { value: true }), o2.default = void 0, r2 = s(r2), i2 = s(i2), a = s(a);
            var u = function() {
              function t2(e2) {
                var n2 = this, o3 = e2.config, i3 = e2.eventsDispatcher;
                if ((0, r2.default)(this, t2), this.nodes = {}, this.listeners = new a.default(), this.readOnlyMutableListeners = { on: function(t3, e3, o4) {
                  var r3 = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
                  n2.mutableListenerIds.push(n2.listeners.on(t3, e3, o4, r3));
                }, clearAll: function() {
                  var t3, e3 = l(n2.mutableListenerIds);
                  try {
                    for (e3.s(); !(t3 = e3.n()).done; ) {
                      var o4 = t3.value;
                      n2.listeners.offById(o4);
                    }
                  } catch (t4) {
                    e3.e(t4);
                  } finally {
                    e3.f();
                  }
                  n2.mutableListenerIds = [];
                } }, this.mutableListenerIds = [], (this instanceof t2 ? this.constructor : void 0) === t2)
                  throw new TypeError("Constructors for abstract class Module are not allowed.");
                this.config = o3, this.eventsDispatcher = i3;
              }
              return (0, i2.default)(t2, [{ key: "removeAllNodes", value: function() {
                for (var t3 in this.nodes) {
                  var e2 = this.nodes[t3];
                  e2 instanceof HTMLElement && e2.remove();
                }
              } }, { key: "state", set: function(t3) {
                this.Editor = t3;
              } }, { key: "isRtl", get: function() {
                return "rtl" === this.config.i18n.direction;
              } }]), t2;
            }();
            o2.default = u, u.displayName = "Module", t.exports = e.default;
          }) ? o.apply(e, r) : o) || (t.exports = i);
        }, function(t, e) {
          var n = t.exports = "undefined" != typeof window && window.Math == Math ? window : "undefined" != typeof self && self.Math == Math ? self : Function("return this")();
          "number" == typeof __g && (__g = n);
        }, function(t, e) {
          t.exports = function(t2) {
            try {
              return !!t2();
            } catch (t3) {
              return true;
            }
          };
        }, function(t, e, n) {
          var o = n(13);
          t.exports = function(t2) {
            if (!o(t2))
              throw TypeError(t2 + " is not an object!");
            return t2;
          };
        }, function(t, e) {
          t.exports = function(t2) {
            return "object" == typeof t2 ? null !== t2 : "function" == typeof t2;
          };
        }, function(t, e, n) {
          var o, r, i;
          "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self && self, r = [e, n(42), n(2), n(3), n(7)], void 0 === (i = "function" == typeof (o = function(o2, r2, i2, a, s) {
            "use strict";
            var l = n(8), c = n(1);
            Object.defineProperty(o2, "__esModule", { value: true }), o2.default = void 0, r2 = c(r2), i2 = c(i2), a = c(a), s = l(s);
            var u = function() {
              function t2() {
                (0, i2.default)(this, t2);
              }
              return (0, a.default)(t2, null, [{ key: "isSingleTag", value: function(t3) {
                return t3.tagName && ["AREA", "BASE", "BR", "COL", "COMMAND", "EMBED", "HR", "IMG", "INPUT", "KEYGEN", "LINK", "META", "PARAM", "SOURCE", "TRACK", "WBR"].includes(t3.tagName);
              } }, { key: "isLineBreakTag", value: function(t3) {
                return t3 && t3.tagName && ["BR", "WBR"].includes(t3.tagName);
              } }, { key: "make", value: function(t3) {
                var e2, n2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, o3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, i3 = document.createElement(t3);
                for (var a2 in Array.isArray(n2) ? (e2 = i3.classList).add.apply(e2, (0, r2.default)(n2)) : n2 && i3.classList.add(n2), o3)
                  Object.prototype.hasOwnProperty.call(o3, a2) && (i3[a2] = o3[a2]);
                return i3;
              } }, { key: "text", value: function(t3) {
                return document.createTextNode(t3);
              } }, { key: "svg", value: function(t3) {
                var e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 14, n2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 14, o3 = document.createElementNS("http://www.w3.org/2000/svg", "svg");
                return o3.classList.add("icon", "icon--" + t3), o3.setAttribute("width", e2 + "px"), o3.setAttribute("height", n2 + "px"), o3.innerHTML = '<use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#'.concat(t3, '"></use>'), o3;
              } }, { key: "append", value: function(t3, e2) {
                Array.isArray(e2) ? e2.forEach(function(e3) {
                  return t3.appendChild(e3);
                }) : t3.appendChild(e2);
              } }, { key: "prepend", value: function(t3, e2) {
                Array.isArray(e2) ? (e2 = e2.reverse()).forEach(function(e3) {
                  return t3.prepend(e3);
                }) : t3.prepend(e2);
              } }, { key: "swap", value: function(t3, e2) {
                var n2 = document.createElement("div"), o3 = t3.parentNode;
                o3.insertBefore(n2, t3), o3.insertBefore(t3, e2), o3.insertBefore(e2, n2), o3.removeChild(n2);
              } }, { key: "find", value: function() {
                var t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : document, e2 = arguments.length > 1 ? arguments[1] : void 0;
                return t3.querySelector(e2);
              } }, { key: "get", value: function(t3) {
                return document.getElementById(t3);
              } }, { key: "findAll", value: function() {
                var t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : document, e2 = arguments.length > 1 ? arguments[1] : void 0;
                return t3.querySelectorAll(e2);
              } }, { key: "findAllInputs", value: function(e2) {
                return s.array(e2.querySelectorAll(t2.allInputsSelector)).reduce(function(e3, n2) {
                  return t2.isNativeInput(n2) || t2.containsOnlyInlineElements(n2) ? [].concat((0, r2.default)(e3), [n2]) : [].concat((0, r2.default)(e3), (0, r2.default)(t2.getDeepestBlockElements(n2)));
                }, []);
              } }, { key: "getDeepestNode", value: function(e2) {
                var n2 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], o3 = n2 ? "lastChild" : "firstChild", r3 = n2 ? "previousSibling" : "nextSibling";
                if (e2 && e2.nodeType === Node.ELEMENT_NODE && e2[o3]) {
                  var i3 = e2[o3];
                  if (t2.isSingleTag(i3) && !t2.isNativeInput(i3) && !t2.isLineBreakTag(i3))
                    if (i3[r3])
                      i3 = i3[r3];
                    else {
                      if (!i3.parentNode[r3])
                        return i3.parentNode;
                      i3 = i3.parentNode[r3];
                    }
                  return this.getDeepestNode(i3, n2);
                }
                return e2;
              } }, { key: "isElement", value: function(t3) {
                return !s.isNumber(t3) && t3 && t3.nodeType && t3.nodeType === Node.ELEMENT_NODE;
              } }, { key: "isFragment", value: function(t3) {
                return !s.isNumber(t3) && t3 && t3.nodeType && t3.nodeType === Node.DOCUMENT_FRAGMENT_NODE;
              } }, { key: "isContentEditable", value: function(t3) {
                return "true" === t3.contentEditable;
              } }, { key: "isNativeInput", value: function(t3) {
                return !(!t3 || !t3.tagName) && ["INPUT", "TEXTAREA"].includes(t3.tagName);
              } }, { key: "canSetCaret", value: function(e2) {
                var n2 = true;
                if (t2.isNativeInput(e2))
                  switch (e2.type) {
                    case "file":
                    case "checkbox":
                    case "radio":
                    case "hidden":
                    case "submit":
                    case "button":
                    case "image":
                    case "reset":
                      n2 = false;
                  }
                else
                  n2 = t2.isContentEditable(e2);
                return n2;
              } }, { key: "isNodeEmpty", value: function(t3) {
                return !(this.isSingleTag(t3) && !this.isLineBreakTag(t3)) && 0 === (this.isElement(t3) && this.isNativeInput(t3) ? t3.value : t3.textContent.replace("\u200B", "")).trim().length;
              } }, { key: "isLeaf", value: function(t3) {
                return !!t3 && 0 === t3.childNodes.length;
              } }, { key: "isEmpty", value: function(t3) {
                t3.normalize();
                for (var e2 = [t3]; e2.length > 0; )
                  if (t3 = e2.shift()) {
                    if (this.isLeaf(t3) && !this.isNodeEmpty(t3))
                      return false;
                    t3.childNodes && e2.push.apply(e2, (0, r2.default)(Array.from(t3.childNodes)));
                  }
                return true;
              } }, { key: "isHTMLString", value: function(e2) {
                var n2 = t2.make("div");
                return n2.innerHTML = e2, n2.childElementCount > 0;
              } }, { key: "getContentLength", value: function(e2) {
                return t2.isNativeInput(e2) ? e2.value.length : e2.nodeType === Node.TEXT_NODE ? e2.length : e2.textContent.length;
              } }, { key: "containsOnlyInlineElements", value: function(e2) {
                var n2;
                return s.isString(e2) ? (n2 = document.createElement("div")).innerHTML = e2 : n2 = e2, Array.from(n2.children).every(function e3(n3) {
                  return !t2.blockElements.includes(n3.tagName.toLowerCase()) && Array.from(n3.children).every(e3);
                });
              } }, { key: "getDeepestBlockElements", value: function(e2) {
                return t2.containsOnlyInlineElements(e2) ? [e2] : Array.from(e2.children).reduce(function(e3, n2) {
                  return [].concat((0, r2.default)(e3), (0, r2.default)(t2.getDeepestBlockElements(n2)));
                }, []);
              } }, { key: "getHolder", value: function(t3) {
                return s.isString(t3) ? document.getElementById(t3) : t3;
              } }, { key: "isExtensionNode", value: function(t3) {
                return t3 && ["GRAMMARLY-EXTENSION"].includes(t3.nodeName);
              } }, { key: "isAnchor", value: function(t3) {
                return "a" === t3.tagName.toLowerCase();
              } }, { key: "offset", value: function(t3) {
                var e2 = t3.getBoundingClientRect(), n2 = window.pageXOffset || document.documentElement.scrollLeft, o3 = window.pageYOffset || document.documentElement.scrollTop, r3 = e2.top + o3, i3 = e2.left + n2;
                return { top: r3, left: i3, bottom: r3 + e2.height, right: i3 + e2.width };
              } }, { key: "allInputsSelector", get: function() {
                return "[contenteditable=true], textarea, input:not([type]), " + ["text", "password", "email", "number", "search", "tel", "url"].map(function(t3) {
                  return 'input[type="'.concat(t3, '"]');
                }).join(", ");
              } }, { key: "blockElements", get: function() {
                return ["address", "article", "aside", "blockquote", "canvas", "div", "dl", "dt", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "header", "hgroup", "hr", "li", "main", "nav", "noscript", "ol", "output", "p", "pre", "ruby", "section", "table", "tr", "tfoot", "ul", "video"];
              } }]), t2;
            }();
            o2.default = u, u.displayName = "Dom", t.exports = e.default;
          }) ? o.apply(e, r) : o) || (t.exports = i);
        }, function(t, e, n) {
          var o = n(69)("wks"), r = n(44), i = n(10).Symbol, a = "function" == typeof i;
          (t.exports = function(t2) {
            return o[t2] || (o[t2] = a && i[t2] || (a ? i : r)("Symbol." + t2));
          }).store = o;
        }, function(t, e, n) {
          var o = n(33), r = Math.min;
          t.exports = function(t2) {
            return t2 > 0 ? r(o(t2), 9007199254740991) : 0;
          };
        }, function(t, e) {
          var n = t.exports = { version: "2.6.11" };
          "number" == typeof __e && (__e = n);
        }, function(t, e, n) {
          t.exports = !n(11)(function() {
            return 7 != Object.defineProperty({}, "a", { get: function() {
              return 7;
            } }).a;
          });
        }, function(t, e, n) {
          var o = n(12), r = n(116), i = n(40), a = Object.defineProperty;
          e.f = n(18) ? Object.defineProperty : function(t2, e2, n2) {
            if (o(t2), e2 = i(e2, true), o(n2), r)
              try {
                return a(t2, e2, n2);
              } catch (t3) {
              }
            if ("get" in n2 || "set" in n2)
              throw TypeError("Accessors not supported!");
            return "value" in n2 && (t2[e2] = n2.value), t2;
          };
        }, function(t, e, n) {
          t.exports = n(147);
        }, function(t, e) {
          function n(t2, e2, n2, o, r, i, a) {
            try {
              var s = t2[i](a), l = s.value;
            } catch (t3) {
              return void n2(t3);
            }
            s.done ? e2(l) : Promise.resolve(l).then(o, r);
          }
          t.exports = function(t2) {
            return function() {
              var e2 = this, o = arguments;
              return new Promise(function(r, i) {
                var a = t2.apply(e2, o);
                function s(t3) {
                  n(a, r, i, s, l, "next", t3);
                }
                function l(t3) {
                  n(a, r, i, s, l, "throw", t3);
                }
                s(void 0);
              });
            };
          };
        }, function(t, e, n) {
          var o = n(38);
          t.exports = function(t2) {
            return Object(o(t2));
          };
        }, function(t, e, n) {
          var o = n(10), r = n(27), i = n(26), a = n(44)("src"), s = n(192), l = ("" + s).split("toString");
          n(17).inspectSource = function(t2) {
            return s.call(t2);
          }, (t.exports = function(t2, e2, n2, s2) {
            var c = "function" == typeof n2;
            c && (i(n2, "name") || r(n2, "name", e2)), t2[e2] !== n2 && (c && (i(n2, a) || r(n2, a, t2[e2] ? "" + t2[e2] : l.join(String(e2)))), t2 === o ? t2[e2] = n2 : s2 ? t2[e2] ? t2[e2] = n2 : r(t2, e2, n2) : (delete t2[e2], r(t2, e2, n2)));
          })(Function.prototype, "toString", function() {
            return "function" == typeof this && this[a] || s.call(this);
          });
        }, function(t, e, n) {
          var o = n(0), r = n(11), i = n(38), a = /"/g, s = function(t2, e2, n2, o2) {
            var r2 = String(i(t2)), s2 = "<" + e2;
            return "" !== n2 && (s2 += " " + n2 + '="' + String(o2).replace(a, "&quot;") + '"'), s2 + ">" + r2 + "</" + e2 + ">";
          };
          t.exports = function(t2, e2) {
            var n2 = {};
            n2[t2] = e2(s), o(o.P + o.F * r(function() {
              var e3 = ""[t2]('"');
              return e3 !== e3.toLowerCase() || e3.split('"').length > 3;
            }), "String", n2);
          };
        }, function(t, e, n) {
          var o, r, i;
          "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self && self, r = [e, n(2), n(3), n(7), n(14)], void 0 === (i = "function" == typeof (o = function(o2, r2, i2, a, s) {
            "use strict";
            var l = n(8), c = n(1);
            Object.defineProperty(o2, "__esModule", { value: true }), o2.default = void 0, r2 = c(r2), i2 = c(i2), a = l(a), s = c(s);
            var u = function() {
              function t2() {
                (0, r2.default)(this, t2), this.instance = null, this.selection = null, this.savedSelectionRange = null, this.isFakeBackgroundEnabled = false, this.commandBackground = "backColor", this.commandRemoveFormat = "removeFormat";
              }
              return (0, i2.default)(t2, [{ key: "removeFakeBackground", value: function() {
                this.isFakeBackgroundEnabled && (this.isFakeBackgroundEnabled = false, document.execCommand(this.commandRemoveFormat));
              } }, { key: "setFakeBackground", value: function() {
                document.execCommand(this.commandBackground, false, "#a8d6ff"), this.isFakeBackgroundEnabled = true;
              } }, { key: "save", value: function() {
                this.savedSelectionRange = t2.range;
              } }, { key: "restore", value: function() {
                if (this.savedSelectionRange) {
                  var t3 = window.getSelection();
                  t3.removeAllRanges(), t3.addRange(this.savedSelectionRange);
                }
              } }, { key: "clearSaved", value: function() {
                this.savedSelectionRange = null;
              } }, { key: "collapseToEnd", value: function() {
                var t3 = window.getSelection(), e2 = document.createRange();
                e2.selectNodeContents(t3.focusNode), e2.collapse(false), t3.removeAllRanges(), t3.addRange(e2);
              } }, { key: "findParentTag", value: function(t3, e2) {
                var n2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 10, o3 = window.getSelection(), r3 = null;
                if (!o3 || !o3.anchorNode || !o3.focusNode)
                  return null;
                var i3 = [o3.anchorNode, o3.focusNode];
                return i3.forEach(function(o4) {
                  for (var i4 = n2; i4 > 0 && o4.parentNode && (o4.tagName !== t3 || (r3 = o4, e2 && o4.classList && !o4.classList.contains(e2) && (r3 = null), !r3)); )
                    o4 = o4.parentNode, i4--;
                }), r3;
              } }, { key: "expandToTag", value: function(t3) {
                var e2 = window.getSelection();
                e2.removeAllRanges();
                var n2 = document.createRange();
                n2.selectNodeContents(t3), e2.addRange(n2);
              } }], [{ key: "isSelectionAtEditor", value: function(e2) {
                if (!e2)
                  return false;
                var n2 = e2.anchorNode || e2.focusNode;
                n2 && n2.nodeType === Node.TEXT_NODE && (n2 = n2.parentNode);
                var o3 = null;
                return n2 && n2 instanceof Element && (o3 = n2.closest(".".concat(t2.CSS.editorZone))), !!o3 && o3.nodeType === Node.ELEMENT_NODE;
              } }, { key: "isRangeAtEditor", value: function(e2) {
                if (e2) {
                  var n2 = e2.startContainer;
                  n2 && n2.nodeType === Node.TEXT_NODE && (n2 = n2.parentNode);
                  var o3 = null;
                  return n2 && n2 instanceof Element && (o3 = n2.closest(".".concat(t2.CSS.editorZone))), !!o3 && o3.nodeType === Node.ELEMENT_NODE;
                }
              } }, { key: "getRangeFromSelection", value: function(t3) {
                return t3 && t3.rangeCount ? t3.getRangeAt(0) : null;
              } }, { key: "get", value: function() {
                return window.getSelection();
              } }, { key: "setCursor", value: function(t3) {
                var e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, n2 = document.createRange(), o3 = window.getSelection();
                if (s.default.isNativeInput(t3)) {
                  if (!s.default.canSetCaret(t3))
                    return;
                  return t3.focus(), t3.selectionStart = t3.selectionEnd = e2, t3.getBoundingClientRect();
                }
                return n2.setStart(t3, e2), n2.setEnd(t3, e2), o3.removeAllRanges(), o3.addRange(n2), n2.getBoundingClientRect();
              } }, { key: "addFakeCursor", value: function(e2) {
                var n2 = t2.range, o3 = s.default.make("span", "codex-editor__fake-cursor");
                o3.dataset.mutationFree = "true", !n2 || e2 && !e2.contains(n2.startContainer) || (n2.collapse(), n2.insertNode(o3));
              } }, { key: "removeFakeCursor", value: function() {
                var t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : document.body, e2 = s.default.find(t3, ".codex-editor__fake-cursor");
                e2 && e2.remove();
              } }, { key: "CSS", get: function() {
                return { editorWrapper: "codex-editor", editorZone: "codex-editor__redactor" };
              } }, { key: "anchorNode", get: function() {
                var t3 = window.getSelection();
                return t3 ? t3.anchorNode : null;
              } }, { key: "anchorElement", get: function() {
                var t3 = window.getSelection();
                if (!t3)
                  return null;
                var e2 = t3.anchorNode;
                return e2 ? s.default.isElement(e2) ? e2 : e2.parentElement : null;
              } }, { key: "anchorOffset", get: function() {
                var t3 = window.getSelection();
                return t3 ? t3.anchorOffset : null;
              } }, { key: "isCollapsed", get: function() {
                var t3 = window.getSelection();
                return t3 ? t3.isCollapsed : null;
              } }, { key: "isAtEditor", get: function() {
                return this.isSelectionAtEditor(t2.get());
              } }, { key: "isSelectionExists", get: function() {
                return !!t2.get().anchorNode;
              } }, { key: "range", get: function() {
                return this.getRangeFromSelection(this.get());
              } }, { key: "rect", get: function() {
                var t3, e2 = document.selection, n2 = { x: 0, y: 0, width: 0, height: 0 };
                if (e2 && "Control" !== e2.type)
                  return t3 = (e2 = e2).createRange(), n2.x = t3.boundingLeft, n2.y = t3.boundingTop, n2.width = t3.boundingWidth, n2.height = t3.boundingHeight, n2;
                if (!window.getSelection)
                  return a.log("Method window.getSelection is not supported", "warn"), n2;
                if (null === (e2 = window.getSelection()).rangeCount || isNaN(e2.rangeCount))
                  return a.log("Method SelectionUtils.rangeCount is not supported", "warn"), n2;
                if (0 === e2.rangeCount)
                  return n2;
                if ((t3 = e2.getRangeAt(0).cloneRange()).getBoundingClientRect && (n2 = t3.getBoundingClientRect()), 0 === n2.x && 0 === n2.y) {
                  var o3 = document.createElement("span");
                  if (o3.getBoundingClientRect) {
                    o3.appendChild(document.createTextNode("\u200B")), t3.insertNode(o3), n2 = o3.getBoundingClientRect();
                    var r3 = o3.parentNode;
                    r3.removeChild(o3), r3.normalize();
                  }
                }
                return n2;
              } }, { key: "text", get: function() {
                return window.getSelection ? window.getSelection().toString() : "";
              } }]), t2;
            }();
            o2.default = u, u.displayName = "SelectionUtils", t.exports = e.default;
          }) ? o.apply(e, r) : o) || (t.exports = i);
        }, function(t, e) {
          var n = {}.hasOwnProperty;
          t.exports = function(t2, e2) {
            return n.call(t2, e2);
          };
        }, function(t, e, n) {
          var o = n(19), r = n(43);
          t.exports = n(18) ? function(t2, e2, n2) {
            return o.f(t2, e2, r(1, n2));
          } : function(t2, e2, n2) {
            return t2[e2] = n2, t2;
          };
        }, function(t, e, n) {
          var o = n(63), r = n(38);
          t.exports = function(t2) {
            return o(r(t2));
          };
        }, function(t, e, n) {
          "use strict";
          var o = n(11);
          t.exports = function(t2, e2) {
            return !!t2 && o(function() {
              e2 ? t2.call(null, function() {
              }, 1) : t2.call(null);
            });
          };
        }, function(t, e, n) {
          var o = n(361), r = n(362), i = n(148), a = n(363);
          t.exports = function(t2, e2) {
            return o(t2) || r(t2, e2) || i(t2, e2) || a();
          };
        }, function(t, e, n) {
          var o = n(32);
          t.exports = function(t2, e2, n2) {
            if (o(t2), void 0 === e2)
              return t2;
            switch (n2) {
              case 1:
                return function(n3) {
                  return t2.call(e2, n3);
                };
              case 2:
                return function(n3, o2) {
                  return t2.call(e2, n3, o2);
                };
              case 3:
                return function(n3, o2, r) {
                  return t2.call(e2, n3, o2, r);
                };
            }
            return function() {
              return t2.apply(e2, arguments);
            };
          };
        }, function(t, e) {
          t.exports = function(t2) {
            if ("function" != typeof t2)
              throw TypeError(t2 + " is not a function!");
            return t2;
          };
        }, function(t, e) {
          var n = Math.ceil, o = Math.floor;
          t.exports = function(t2) {
            return isNaN(t2 = +t2) ? 0 : (t2 > 0 ? o : n)(t2);
          };
        }, function(t, e, n) {
          var o = n(64), r = n(43), i = n(28), a = n(40), s = n(26), l = n(116), c = Object.getOwnPropertyDescriptor;
          e.f = n(18) ? c : function(t2, e2) {
            if (t2 = i(t2), e2 = a(e2, true), l)
              try {
                return c(t2, e2);
              } catch (t3) {
              }
            if (s(t2, e2))
              return r(!o.f.call(t2, e2), t2[e2]);
          };
        }, function(t, e, n) {
          var o = n(0), r = n(17), i = n(11);
          t.exports = function(t2, e2) {
            var n2 = (r.Object || {})[t2] || Object[t2], a = {};
            a[t2] = e2(n2), o(o.S + o.F * i(function() {
              n2(1);
            }), "Object", a);
          };
        }, function(t, e, n) {
          var o = n(31), r = n(63), i = n(22), a = n(16), s = n(132);
          t.exports = function(t2, e2) {
            var n2 = 1 == t2, l = 2 == t2, c = 3 == t2, u = 4 == t2, f = 6 == t2, d = 5 == t2 || f, p = e2 || s;
            return function(e3, s2, h) {
              for (var v, g, y = i(e3), b = r(y), m = o(s2, h, 3), k = a(b.length), x = 0, w = n2 ? p(e3, k) : l ? p(e3, 0) : void 0; k > x; x++)
                if ((d || x in b) && (g = m(v = b[x], x, y), t2)) {
                  if (n2)
                    w[x] = g;
                  else if (g)
                    switch (t2) {
                      case 3:
                        return true;
                      case 5:
                        return v;
                      case 6:
                        return x;
                      case 2:
                        w.push(v);
                    }
                  else if (u)
                    return false;
                }
              return f ? -1 : c || u ? u : w;
            };
          };
        }, function(t, e) {
          var n = {}.toString;
          t.exports = function(t2) {
            return n.call(t2).slice(8, -1);
          };
        }, function(t, e) {
          t.exports = function(t2) {
            if (null == t2)
              throw TypeError("Can't call method on  " + t2);
            return t2;
          };
        }, function(t, e, n) {
          "use strict";
          if (n(18)) {
            var o = n(45), r = n(10), i = n(11), a = n(0), s = n(80), l = n(109), c = n(31), u = n(57), f = n(43), d = n(27), p = n(58), h = n(33), v = n(16), g = n(143), y = n(47), b = n(40), m = n(26), k = n(65), x = n(13), w = n(22), S = n(101), T = n(48), E = n(50), B = n(49).f, C = n(103), _2 = n(44), I = n(15), O = n(36), M = n(70), R = n(66), A = n(105), N = n(55), L = n(73), P = n(56), D = n(104), j = n(134), F = n(19), H = n(34), U = F.f, z = H.f, W = r.RangeError, Y = r.TypeError, V = r.Uint8Array, X = Array.prototype, K = l.ArrayBuffer, G = l.DataView, Z = O(0), q = O(2), J = O(3), $ = O(4), Q = O(5), tt = O(6), et = M(true), nt = M(false), ot = A.values, rt = A.keys, it = A.entries, at = X.lastIndexOf, st = X.reduce, lt = X.reduceRight, ct = X.join, ut = X.sort, ft = X.slice, dt = X.toString, pt = X.toLocaleString, ht = I("iterator"), vt = I("toStringTag"), gt = _2("typed_constructor"), yt = _2("def_constructor"), bt = s.CONSTR, mt = s.TYPED, kt = s.VIEW, xt = O(1, function(t2, e2) {
              return Bt(R(t2, t2[yt]), e2);
            }), wt = i(function() {
              return 1 === new V(new Uint16Array([1]).buffer)[0];
            }), St = !!V && !!V.prototype.set && i(function() {
              new V(1).set({});
            }), Tt = function(t2, e2) {
              var n2 = h(t2);
              if (n2 < 0 || n2 % e2)
                throw W("Wrong offset!");
              return n2;
            }, Et = function(t2) {
              if (x(t2) && mt in t2)
                return t2;
              throw Y(t2 + " is not a typed array!");
            }, Bt = function(t2, e2) {
              if (!x(t2) || !(gt in t2))
                throw Y("It is not a typed array constructor!");
              return new t2(e2);
            }, Ct = function(t2, e2) {
              return _t(R(t2, t2[yt]), e2);
            }, _t = function(t2, e2) {
              for (var n2 = 0, o2 = e2.length, r2 = Bt(t2, o2); o2 > n2; )
                r2[n2] = e2[n2++];
              return r2;
            }, It = function(t2, e2, n2) {
              U(t2, e2, { get: function() {
                return this._d[n2];
              } });
            }, Ot = function(t2) {
              var e2, n2, o2, r2, i2, a2, s2 = w(t2), l2 = arguments.length, u2 = l2 > 1 ? arguments[1] : void 0, f2 = void 0 !== u2, d2 = C(s2);
              if (null != d2 && !S(d2)) {
                for (a2 = d2.call(s2), o2 = [], e2 = 0; !(i2 = a2.next()).done; e2++)
                  o2.push(i2.value);
                s2 = o2;
              }
              for (f2 && l2 > 2 && (u2 = c(u2, arguments[2], 2)), e2 = 0, n2 = v(s2.length), r2 = Bt(this, n2); n2 > e2; e2++)
                r2[e2] = f2 ? u2(s2[e2], e2) : s2[e2];
              return r2;
            }, Mt = function() {
              for (var t2 = 0, e2 = arguments.length, n2 = Bt(this, e2); e2 > t2; )
                n2[t2] = arguments[t2++];
              return n2;
            }, Rt = !!V && i(function() {
              pt.call(new V(1));
            }), At = function() {
              return pt.apply(Rt ? ft.call(Et(this)) : Et(this), arguments);
            }, Nt = { copyWithin: function(t2, e2) {
              return j.call(Et(this), t2, e2, arguments.length > 2 ? arguments[2] : void 0);
            }, every: function(t2) {
              return $(Et(this), t2, arguments.length > 1 ? arguments[1] : void 0);
            }, fill: function(t2) {
              return D.apply(Et(this), arguments);
            }, filter: function(t2) {
              return Ct(this, q(Et(this), t2, arguments.length > 1 ? arguments[1] : void 0));
            }, find: function(t2) {
              return Q(Et(this), t2, arguments.length > 1 ? arguments[1] : void 0);
            }, findIndex: function(t2) {
              return tt(Et(this), t2, arguments.length > 1 ? arguments[1] : void 0);
            }, forEach: function(t2) {
              Z(Et(this), t2, arguments.length > 1 ? arguments[1] : void 0);
            }, indexOf: function(t2) {
              return nt(Et(this), t2, arguments.length > 1 ? arguments[1] : void 0);
            }, includes: function(t2) {
              return et(Et(this), t2, arguments.length > 1 ? arguments[1] : void 0);
            }, join: function(t2) {
              return ct.apply(Et(this), arguments);
            }, lastIndexOf: function(t2) {
              return at.apply(Et(this), arguments);
            }, map: function(t2) {
              return xt(Et(this), t2, arguments.length > 1 ? arguments[1] : void 0);
            }, reduce: function(t2) {
              return st.apply(Et(this), arguments);
            }, reduceRight: function(t2) {
              return lt.apply(Et(this), arguments);
            }, reverse: function() {
              for (var t2, e2 = Et(this).length, n2 = Math.floor(e2 / 2), o2 = 0; o2 < n2; )
                t2 = this[o2], this[o2++] = this[--e2], this[e2] = t2;
              return this;
            }, some: function(t2) {
              return J(Et(this), t2, arguments.length > 1 ? arguments[1] : void 0);
            }, sort: function(t2) {
              return ut.call(Et(this), t2);
            }, subarray: function(t2, e2) {
              var n2 = Et(this), o2 = n2.length, r2 = y(t2, o2);
              return new (R(n2, n2[yt]))(n2.buffer, n2.byteOffset + r2 * n2.BYTES_PER_ELEMENT, v((void 0 === e2 ? o2 : y(e2, o2)) - r2));
            } }, Lt = function(t2, e2) {
              return Ct(this, ft.call(Et(this), t2, e2));
            }, Pt = function(t2) {
              Et(this);
              var e2 = Tt(arguments[1], 1), n2 = this.length, o2 = w(t2), r2 = v(o2.length), i2 = 0;
              if (r2 + e2 > n2)
                throw W("Wrong length!");
              for (; i2 < r2; )
                this[e2 + i2] = o2[i2++];
            }, Dt = { entries: function() {
              return it.call(Et(this));
            }, keys: function() {
              return rt.call(Et(this));
            }, values: function() {
              return ot.call(Et(this));
            } }, jt = function(t2, e2) {
              return x(t2) && t2[mt] && "symbol" != typeof e2 && e2 in t2 && String(+e2) == String(e2);
            }, Ft = function(t2, e2) {
              return jt(t2, e2 = b(e2, true)) ? f(2, t2[e2]) : z(t2, e2);
            }, Ht = function(t2, e2, n2) {
              return !(jt(t2, e2 = b(e2, true)) && x(n2) && m(n2, "value")) || m(n2, "get") || m(n2, "set") || n2.configurable || m(n2, "writable") && !n2.writable || m(n2, "enumerable") && !n2.enumerable ? U(t2, e2, n2) : (t2[e2] = n2.value, t2);
            };
            bt || (H.f = Ft, F.f = Ht), a(a.S + a.F * !bt, "Object", { getOwnPropertyDescriptor: Ft, defineProperty: Ht }), i(function() {
              dt.call({});
            }) && (dt = pt = function() {
              return ct.call(this);
            });
            var Ut = p({}, Nt);
            p(Ut, Dt), d(Ut, ht, Dt.values), p(Ut, { slice: Lt, set: Pt, constructor: function() {
            }, toString: dt, toLocaleString: At }), It(Ut, "buffer", "b"), It(Ut, "byteOffset", "o"), It(Ut, "byteLength", "l"), It(Ut, "length", "e"), U(Ut, vt, { get: function() {
              return this[mt];
            } }), t.exports = function(t2, e2, n2, l2) {
              var c2 = t2 + ((l2 = !!l2) ? "Clamped" : "") + "Array", f2 = "get" + t2, p2 = "set" + t2, h2 = r[c2], y2 = h2 || {}, b2 = h2 && E(h2), m2 = !h2 || !s.ABV, w2 = {}, S2 = h2 && h2.prototype, C2 = function(t3, n3) {
                U(t3, n3, { get: function() {
                  return function(t4, n4) {
                    var o2 = t4._d;
                    return o2.v[f2](n4 * e2 + o2.o, wt);
                  }(this, n3);
                }, set: function(t4) {
                  return function(t5, n4, o2) {
                    var r2 = t5._d;
                    l2 && (o2 = (o2 = Math.round(o2)) < 0 ? 0 : o2 > 255 ? 255 : 255 & o2), r2.v[p2](n4 * e2 + r2.o, o2, wt);
                  }(this, n3, t4);
                }, enumerable: true });
              };
              m2 ? (h2 = n2(function(t3, n3, o2, r2) {
                u(t3, h2, c2, "_d");
                var i2, a2, s2, l3, f3 = 0, p3 = 0;
                if (x(n3)) {
                  if (!(n3 instanceof K || "ArrayBuffer" == (l3 = k(n3)) || "SharedArrayBuffer" == l3))
                    return mt in n3 ? _t(h2, n3) : Ot.call(h2, n3);
                  i2 = n3, p3 = Tt(o2, e2);
                  var y3 = n3.byteLength;
                  if (void 0 === r2) {
                    if (y3 % e2)
                      throw W("Wrong length!");
                    if ((a2 = y3 - p3) < 0)
                      throw W("Wrong length!");
                  } else if ((a2 = v(r2) * e2) + p3 > y3)
                    throw W("Wrong length!");
                  s2 = a2 / e2;
                } else
                  s2 = g(n3), i2 = new K(a2 = s2 * e2);
                for (d(t3, "_d", { b: i2, o: p3, l: a2, e: s2, v: new G(i2) }); f3 < s2; )
                  C2(t3, f3++);
              }), S2 = h2.prototype = T(Ut), d(S2, "constructor", h2)) : i(function() {
                h2(1);
              }) && i(function() {
                new h2(-1);
              }) && L(function(t3) {
                new h2(), new h2(null), new h2(1.5), new h2(t3);
              }, true) || (h2 = n2(function(t3, n3, o2, r2) {
                var i2;
                return u(t3, h2, c2), x(n3) ? n3 instanceof K || "ArrayBuffer" == (i2 = k(n3)) || "SharedArrayBuffer" == i2 ? void 0 !== r2 ? new y2(n3, Tt(o2, e2), r2) : void 0 !== o2 ? new y2(n3, Tt(o2, e2)) : new y2(n3) : mt in n3 ? _t(h2, n3) : Ot.call(h2, n3) : new y2(g(n3));
              }), Z(b2 !== Function.prototype ? B(y2).concat(B(b2)) : B(y2), function(t3) {
                t3 in h2 || d(h2, t3, y2[t3]);
              }), h2.prototype = S2, o || (S2.constructor = h2));
              var _3 = S2[ht], I2 = !!_3 && ("values" == _3.name || null == _3.name), O2 = Dt.values;
              d(h2, gt, true), d(S2, mt, c2), d(S2, kt, true), d(S2, yt, h2), (l2 ? new h2(1)[vt] == c2 : vt in S2) || U(S2, vt, { get: function() {
                return c2;
              } }), w2[c2] = h2, a(a.G + a.W + a.F * (h2 != y2), w2), a(a.S, c2, { BYTES_PER_ELEMENT: e2 }), a(a.S + a.F * i(function() {
                y2.of.call(h2, 1);
              }), c2, { from: Ot, of: Mt }), "BYTES_PER_ELEMENT" in S2 || d(S2, "BYTES_PER_ELEMENT", e2), a(a.P, c2, Nt), P(c2), a(a.P + a.F * St, c2, { set: Pt }), a(a.P + a.F * !I2, c2, Dt), o || S2.toString == dt || (S2.toString = dt), a(a.P + a.F * i(function() {
                new h2(1).slice();
              }), c2, { slice: Lt }), a(a.P + a.F * (i(function() {
                return [1, 2].toLocaleString() != new h2([1, 2]).toLocaleString();
              }) || !i(function() {
                S2.toLocaleString.call([1, 2]);
              })), c2, { toLocaleString: At }), N[c2] = I2 ? _3 : O2, o || I2 || d(S2, ht, O2);
            };
          } else
            t.exports = function() {
            };
        }, function(t, e, n) {
          var o = n(13);
          t.exports = function(t2, e2) {
            if (!o(t2))
              return t2;
            var n2, r;
            if (e2 && "function" == typeof (n2 = t2.toString) && !o(r = n2.call(t2)))
              return r;
            if ("function" == typeof (n2 = t2.valueOf) && !o(r = n2.call(t2)))
              return r;
            if (!e2 && "function" == typeof (n2 = t2.toString) && !o(r = n2.call(t2)))
              return r;
            throw TypeError("Can't convert object to primitive value");
          };
        }, function(t, e, n) {
          var o = n(44)("meta"), r = n(13), i = n(26), a = n(19).f, s = 0, l = Object.isExtensible || function() {
            return true;
          }, c = !n(11)(function() {
            return l(Object.preventExtensions({}));
          }), u = function(t2) {
            a(t2, o, { value: { i: "O" + ++s, w: {} } });
          }, f = t.exports = { KEY: o, NEED: false, fastKey: function(t2, e2) {
            if (!r(t2))
              return "symbol" == typeof t2 ? t2 : ("string" == typeof t2 ? "S" : "P") + t2;
            if (!i(t2, o)) {
              if (!l(t2))
                return "F";
              if (!e2)
                return "E";
              u(t2);
            }
            return t2[o].i;
          }, getWeak: function(t2, e2) {
            if (!i(t2, o)) {
              if (!l(t2))
                return true;
              if (!e2)
                return false;
              u(t2);
            }
            return t2[o].w;
          }, onFreeze: function(t2) {
            return c && f.NEED && l(t2) && !i(t2, o) && u(t2), t2;
          } };
        }, function(t, e, n) {
          var o = n(368), r = n(369), i = n(148), a = n(370);
          t.exports = function(t2) {
            return o(t2) || r(t2) || i(t2) || a();
          };
        }, function(t, e) {
          t.exports = function(t2, e2) {
            return { enumerable: !(1 & t2), configurable: !(2 & t2), writable: !(4 & t2), value: e2 };
          };
        }, function(t, e) {
          var n = 0, o = Math.random();
          t.exports = function(t2) {
            return "Symbol(".concat(void 0 === t2 ? "" : t2, ")_", (++n + o).toString(36));
          };
        }, function(t, e) {
          t.exports = false;
        }, function(t, e, n) {
          var o = n(118), r = n(88);
          t.exports = Object.keys || function(t2) {
            return o(t2, r);
          };
        }, function(t, e, n) {
          var o = n(33), r = Math.max, i = Math.min;
          t.exports = function(t2, e2) {
            return (t2 = o(t2)) < 0 ? r(t2 + e2, 0) : i(t2, e2);
          };
        }, function(t, e, n) {
          var o = n(12), r = n(119), i = n(88), a = n(87)("IE_PROTO"), s = function() {
          }, l = function() {
            var t2, e2 = n(85)("iframe"), o2 = i.length;
            for (e2.style.display = "none", n(89).appendChild(e2), e2.src = "javascript:", (t2 = e2.contentWindow.document).open(), t2.write("<script>document.F=Object<\/script>"), t2.close(), l = t2.F; o2--; )
              delete l.prototype[i[o2]];
            return l();
          };
          t.exports = Object.create || function(t2, e2) {
            var n2;
            return null !== t2 ? (s.prototype = o(t2), n2 = new s(), s.prototype = null, n2[a] = t2) : n2 = l(), void 0 === e2 ? n2 : r(n2, e2);
          };
        }, function(t, e, n) {
          var o = n(118), r = n(88).concat("length", "prototype");
          e.f = Object.getOwnPropertyNames || function(t2) {
            return o(t2, r);
          };
        }, function(t, e, n) {
          var o = n(26), r = n(22), i = n(87)("IE_PROTO"), a = Object.prototype;
          t.exports = Object.getPrototypeOf || function(t2) {
            return t2 = r(t2), o(t2, i) ? t2[i] : "function" == typeof t2.constructor && t2 instanceof t2.constructor ? t2.constructor.prototype : t2 instanceof Object ? a : null;
          };
        }, function(t, e, n) {
          var o = n(15)("unscopables"), r = Array.prototype;
          null == r[o] && n(27)(r, o, {}), t.exports = function(t2) {
            r[o][t2] = true;
          };
        }, function(t, e, n) {
          var o = n(13);
          t.exports = function(t2, e2) {
            if (!o(t2) || t2._t !== e2)
              throw TypeError("Incompatible receiver, " + e2 + " required!");
            return t2;
          };
        }, function(t, e, n) {
          var o = n(19).f, r = n(26), i = n(15)("toStringTag");
          t.exports = function(t2, e2, n2) {
            t2 && !r(t2 = n2 ? t2 : t2.prototype, i) && o(t2, i, { configurable: true, value: e2 });
          };
        }, function(t, e, n) {
          var o = n(0), r = n(38), i = n(11), a = n(91), s = "[" + a + "]", l = RegExp("^" + s + s + "*"), c = RegExp(s + s + "*$"), u = function(t2, e2, n2) {
            var r2 = {}, s2 = i(function() {
              return !!a[t2]() || "\u200B\x85" != "\u200B\x85"[t2]();
            }), l2 = r2[t2] = s2 ? e2(f) : a[t2];
            n2 && (r2[n2] = l2), o(o.P + o.F * s2, "String", r2);
          }, f = u.trim = function(t2, e2) {
            return t2 = String(r(t2)), 1 & e2 && (t2 = t2.replace(l, "")), 2 & e2 && (t2 = t2.replace(c, "")), t2;
          };
          t.exports = u;
        }, function(t, e) {
          t.exports = {};
        }, function(t, e, n) {
          "use strict";
          var o = n(10), r = n(19), i = n(18), a = n(15)("species");
          t.exports = function(t2) {
            var e2 = o[t2];
            i && e2 && !e2[a] && r.f(e2, a, { configurable: true, get: function() {
              return this;
            } });
          };
        }, function(t, e) {
          t.exports = function(t2, e2, n, o) {
            if (!(t2 instanceof e2) || void 0 !== o && o in t2)
              throw TypeError(n + ": incorrect invocation!");
            return t2;
          };
        }, function(t, e, n) {
          var o = n(23);
          t.exports = function(t2, e2, n2) {
            for (var r in e2)
              o(t2, r, e2[r], n2);
            return t2;
          };
        }, function(t, e) {
          function n(e2) {
            return "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? t.exports = n = function(t2) {
              return typeof t2;
            } : t.exports = n = function(t2) {
              return t2 && "function" == typeof Symbol && t2.constructor === Symbol && t2 !== Symbol.prototype ? "symbol" : typeof t2;
            }, n(e2);
          }
          t.exports = n;
        }, function(t, e, n) {
          var o, r, i;
          "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self && self, r = [e, n(2), n(3), n(150)], void 0 === (i = "function" == typeof (o = function(o2, r2, i2, a) {
            "use strict";
            var s = n(1);
            Object.defineProperty(o2, "__esModule", { value: true }), o2.default = void 0, r2 = s(r2), i2 = s(i2), a = s(a);
            var l = function() {
              function t2() {
                (0, r2.default)(this, t2);
              }
              return (0, i2.default)(t2, null, [{ key: "ui", value: function(e2, n2) {
                return t2._t(e2, n2);
              } }, { key: "t", value: function(e2, n2) {
                return t2._t(e2, n2);
              } }, { key: "setDictionary", value: function(e2) {
                t2.currentDictionary = e2;
              } }, { key: "_t", value: function(e2, n2) {
                var o3 = t2.getNamespace(e2);
                return o3 && o3[n2] ? o3[n2] : n2;
              } }, { key: "getNamespace", value: function(e2) {
                return e2.split(".").reduce(function(t3, e3) {
                  return t3 && Object.keys(t3).length ? t3[e3] : {};
                }, t2.currentDictionary);
              } }]), t2;
            }();
            o2.default = l, l.displayName = "I18n", l.currentDictionary = a.default, t.exports = e.default;
          }) ? o.apply(e, r) : o) || (t.exports = i);
        }, function(t, e, n) {
          var o, r, i;
          "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self && self, r = [e, n(30), n(20), n(21), n(42), n(2), n(3), n(152), n(113), n(5), n(6), n(4), n(14), n(7), n(112), n(25), n(81)], void 0 === (i = "function" == typeof (o = function(t2, e2, o2, r2, i2, a, s, l, c, u, f, d, p, h, v, g, y) {
            "use strict";
            var b, m = n(8), k = n(1);
            function x() {
              if ("undefined" == typeof Reflect || !Reflect.construct)
                return false;
              if (Reflect.construct.sham)
                return false;
              if ("function" == typeof Proxy)
                return true;
              try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
                })), true;
              } catch (t3) {
                return false;
              }
            }
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = t2.BlockToolAPI = void 0, e2 = k(e2), o2 = k(o2), r2 = k(r2), i2 = k(i2), a = k(a), s = k(s), l = k(l), c = k(c), u = k(u), f = k(f), d = k(d), p = k(p), h = m(h), v = k(v), g = k(g), y = k(y), t2.BlockToolAPI = b, function(t3) {
              t3.APPEND_CALLBACK = "appendCallback", t3.RENDERED = "rendered", t3.MOVED = "moved", t3.UPDATED = "updated", t3.REMOVED = "removed", t3.ON_PASTE = "onPaste";
            }(b || (t2.BlockToolAPI = b = {}));
            var w = function(t3) {
              (0, u.default)(T, t3);
              var n2, y2, m2, k2, w2, S = (n2 = T, function() {
                var t4, e3 = (0, d.default)(n2);
                if (x()) {
                  var o3 = (0, d.default)(this).constructor;
                  t4 = Reflect.construct(e3, arguments, o3);
                } else
                  t4 = e3.apply(this, arguments);
                return (0, f.default)(this, t4);
              });
              function T(t4) {
                var e3, n3 = t4.id, o3 = void 0 === n3 ? h.generateBlockId() : n3, r3 = t4.data, s2 = t4.tool, c2 = t4.api, u2 = t4.readOnly, f2 = t4.tunesData;
                return (0, a.default)(this, T), (e3 = S.call(this)).cachedInputs = [], e3.tunesInstances = /* @__PURE__ */ new Map(), e3.defaultTunesInstances = /* @__PURE__ */ new Map(), e3.unavailableTunesData = {}, e3.inputIndex = 0, e3.modificationDebounceTimer = 450, e3.didMutated = h.debounce(function() {
                  var t5 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [], n4 = t5 instanceof InputEvent || !t5.some(function(t6) {
                    var e4 = t6.addedNodes, n5 = void 0 === e4 ? [] : e4, o4 = t6.removedNodes;
                    return [].concat((0, i2.default)(Array.from(n5)), (0, i2.default)(Array.from(o4))).some(function(t7) {
                      return p.default.isElement(t7) && "true" === t7.dataset.mutationFree;
                    });
                  });
                  n4 && (e3.cachedInputs = [], e3.updateCurrentInput(), e3.call(b.UPDATED), e3.emit("didMutated", (0, l.default)(e3)));
                }, e3.modificationDebounceTimer), e3.handleFocus = function() {
                  e3.cachedInputs = [], e3.updateCurrentInput();
                }, e3.name = s2.name, e3.id = o3, e3.settings = s2.settings, e3.config = s2.settings.config || {}, e3.api = c2, e3.blockAPI = new v.default((0, l.default)(e3)), e3.mutationObserver = new MutationObserver(e3.didMutated), e3.tool = s2, e3.toolInstance = s2.create(r3, e3.blockAPI, u2), e3.tunes = s2.tunes, e3.composeTunes(f2), e3.holder = e3.compose(), e3;
              }
              return (0, s.default)(T, [{ key: "call", value: function(t4, e3) {
                if (h.isFunction(this.toolInstance[t4])) {
                  t4 === b.APPEND_CALLBACK && h.log("`appendCallback` hook is deprecated and will be removed in the next major release. Use `rendered` hook instead", "warn");
                  try {
                    this.toolInstance[t4].call(this.toolInstance, e3);
                  } catch (e4) {
                    h.log("Error during '".concat(t4, "' call: ").concat(e4.message), "error");
                  }
                }
              } }, { key: "mergeWith", value: (w2 = (0, r2.default)(o2.default.mark(function t4(e3) {
                return o2.default.wrap(function(t5) {
                  for (; ; )
                    switch (t5.prev = t5.next) {
                      case 0:
                        return t5.next = 2, this.toolInstance.merge(e3);
                      case 2:
                      case "end":
                        return t5.stop();
                    }
                }, t4, this);
              })), function(t4) {
                return w2.apply(this, arguments);
              }) }, { key: "save", value: (k2 = (0, r2.default)(o2.default.mark(function t4() {
                var n3, r3, a2, s2, l2 = this;
                return o2.default.wrap(function(t5) {
                  for (; ; )
                    switch (t5.prev = t5.next) {
                      case 0:
                        return t5.next = 2, this.toolInstance.save(this.pluginsContent);
                      case 2:
                        return n3 = t5.sent, r3 = this.unavailableTunesData, [].concat((0, i2.default)(this.tunesInstances.entries()), (0, i2.default)(this.defaultTunesInstances.entries())).forEach(function(t6) {
                          var n4 = (0, e2.default)(t6, 2), o3 = n4[0], i3 = n4[1];
                          if (h.isFunction(i3.save))
                            try {
                              r3[o3] = i3.save();
                            } catch (t7) {
                              h.log("Tune ".concat(i3.constructor.name, " save method throws an Error %o"), "warn", t7);
                            }
                        }), a2 = window.performance.now(), t5.abrupt("return", Promise.resolve(n3).then(function(t6) {
                          return s2 = window.performance.now(), { id: l2.id, tool: l2.name, data: t6, tunes: r3, time: s2 - a2 };
                        }).catch(function(t6) {
                          h.log("Saving proccess for ".concat(l2.name, " tool failed due to the ").concat(t6), "log", "red");
                        }));
                      case 7:
                      case "end":
                        return t5.stop();
                    }
                }, t4, this);
              })), function() {
                return k2.apply(this, arguments);
              }) }, { key: "validate", value: (m2 = (0, r2.default)(o2.default.mark(function t4(e3) {
                var n3;
                return o2.default.wrap(function(t5) {
                  for (; ; )
                    switch (t5.prev = t5.next) {
                      case 0:
                        if (n3 = true, !(this.toolInstance.validate instanceof Function)) {
                          t5.next = 5;
                          break;
                        }
                        return t5.next = 4, this.toolInstance.validate(e3);
                      case 4:
                        n3 = t5.sent;
                      case 5:
                        return t5.abrupt("return", n3);
                      case 6:
                      case "end":
                        return t5.stop();
                    }
                }, t4, this);
              })), function(t4) {
                return m2.apply(this, arguments);
              }) }, { key: "renderTunes", value: function() {
                var t4 = document.createDocumentFragment(), e3 = document.createDocumentFragment();
                return this.tunesInstances.forEach(function(e4) {
                  p.default.append(t4, e4.render());
                }), this.defaultTunesInstances.forEach(function(t5) {
                  p.default.append(e3, t5.render());
                }), [t4, e3];
              } }, { key: "updateCurrentInput", value: function() {
                this.currentInput = p.default.isNativeInput(document.activeElement) || !g.default.anchorNode ? document.activeElement : g.default.anchorNode;
              } }, { key: "willSelect", value: function() {
                this.mutationObserver.observe(this.holder.firstElementChild, { childList: true, subtree: true, characterData: true, attributes: true }), this.addInputEvents();
              } }, { key: "willUnselect", value: function() {
                this.mutationObserver.disconnect(), this.removeInputEvents();
              } }, { key: "dispatchChange", value: function() {
                this.didMutated();
              } }, { key: "destroy", value: function() {
                (0, c.default)((0, d.default)(T.prototype), "destroy", this).call(this), h.isFunction(this.toolInstance.destroy) && this.toolInstance.destroy();
              } }, { key: "renderSettings", value: function() {
                if (h.isFunction(this.toolInstance.renderSettings))
                  return this.toolInstance.renderSettings();
              } }, { key: "getActiveToolboxEntry", value: (y2 = (0, r2.default)(o2.default.mark(function t4() {
                var n3, r3, i3;
                return o2.default.wrap(function(t5) {
                  for (; ; )
                    switch (t5.prev = t5.next) {
                      case 0:
                        if (1 !== (n3 = this.tool.toolbox).length) {
                          t5.next = 3;
                          break;
                        }
                        return t5.abrupt("return", Promise.resolve(this.tool.toolbox[0]));
                      case 3:
                        return t5.next = 5, this.data;
                      case 5:
                        return r3 = t5.sent, i3 = n3, t5.abrupt("return", i3.find(function(t6) {
                          return Object.entries(t6.data).some(function(t7) {
                            var n4 = (0, e2.default)(t7, 2), o3 = n4[0], i4 = n4[1];
                            return r3[o3] && h.equals(r3[o3], i4);
                          });
                        }));
                      case 8:
                      case "end":
                        return t5.stop();
                    }
                }, t4, this);
              })), function() {
                return y2.apply(this, arguments);
              }) }, { key: "compose", value: function() {
                var t4 = p.default.make("div", T.CSS.wrapper), e3 = p.default.make("div", T.CSS.content), n3 = this.toolInstance.render();
                e3.appendChild(n3);
                var o3 = e3;
                return [].concat((0, i2.default)(this.tunesInstances.values()), (0, i2.default)(this.defaultTunesInstances.values())).forEach(function(t5) {
                  if (h.isFunction(t5.wrap))
                    try {
                      o3 = t5.wrap(o3);
                    } catch (e4) {
                      h.log("Tune ".concat(t5.constructor.name, " wrap method throws an Error %o"), "warn", e4);
                    }
                }), t4.appendChild(o3), t4;
              } }, { key: "composeTunes", value: function(t4) {
                var n3 = this;
                Array.from(this.tunes.values()).forEach(function(e3) {
                  (e3.isInternal ? n3.defaultTunesInstances : n3.tunesInstances).set(e3.name, e3.create(t4[e3.name], n3.blockAPI));
                }), Object.entries(t4).forEach(function(t5) {
                  var o3 = (0, e2.default)(t5, 2), r3 = o3[0], i3 = o3[1];
                  n3.tunesInstances.has(r3) || (n3.unavailableTunesData[r3] = i3);
                });
              } }, { key: "addInputEvents", value: function() {
                var t4 = this;
                this.inputs.forEach(function(e3) {
                  e3.addEventListener("focus", t4.handleFocus), p.default.isNativeInput(e3) && e3.addEventListener("input", t4.didMutated);
                });
              } }, { key: "removeInputEvents", value: function() {
                var t4 = this;
                this.inputs.forEach(function(e3) {
                  e3.removeEventListener("focus", t4.handleFocus), p.default.isNativeInput(e3) && e3.removeEventListener("input", t4.didMutated);
                });
              } }, { key: "inputs", get: function() {
                if (0 !== this.cachedInputs.length)
                  return this.cachedInputs;
                var t4 = p.default.findAllInputs(this.holder);
                return this.inputIndex > t4.length - 1 && (this.inputIndex = t4.length - 1), this.cachedInputs = t4, t4;
              } }, { key: "currentInput", get: function() {
                return this.inputs[this.inputIndex];
              }, set: function(t4) {
                var e3 = this.inputs.findIndex(function(e4) {
                  return e4 === t4 || e4.contains(t4);
                });
                -1 !== e3 && (this.inputIndex = e3);
              } }, { key: "firstInput", get: function() {
                return this.inputs[0];
              } }, { key: "lastInput", get: function() {
                var t4 = this.inputs;
                return t4[t4.length - 1];
              } }, { key: "nextInput", get: function() {
                return this.inputs[this.inputIndex + 1];
              } }, { key: "previousInput", get: function() {
                return this.inputs[this.inputIndex - 1];
              } }, { key: "data", get: function() {
                return this.save().then(function(t4) {
                  return t4 && !h.isEmpty(t4.data) ? t4.data : {};
                });
              } }, { key: "sanitize", get: function() {
                return this.tool.sanitizeConfig;
              } }, { key: "mergeable", get: function() {
                return h.isFunction(this.toolInstance.merge);
              } }, { key: "isEmpty", get: function() {
                var t4 = p.default.isEmpty(this.pluginsContent), e3 = !this.hasMedia;
                return t4 && e3;
              } }, { key: "hasMedia", get: function() {
                return !!this.holder.querySelector(["img", "iframe", "video", "audio", "source", "input", "textarea", "twitterwidget"].join(","));
              } }, { key: "focused", set: function(t4) {
                this.holder.classList.toggle(T.CSS.focused, t4);
              }, get: function() {
                return this.holder.classList.contains(T.CSS.focused);
              } }, { key: "selected", set: function(t4) {
                t4 ? (this.holder.classList.add(T.CSS.selected), g.default.addFakeCursor(this.holder)) : (this.holder.classList.remove(T.CSS.selected), g.default.removeFakeCursor(this.holder));
              }, get: function() {
                return this.holder.classList.contains(T.CSS.selected);
              } }, { key: "stretched", set: function(t4) {
                this.holder.classList.toggle(T.CSS.wrapperStretched, t4);
              }, get: function() {
                return this.holder.classList.contains(T.CSS.wrapperStretched);
              } }, { key: "dropTarget", set: function(t4) {
                this.holder.classList.toggle(T.CSS.dropTarget, t4);
              } }, { key: "pluginsContent", get: function() {
                var t4 = this.holder.querySelector(".".concat(T.CSS.content));
                if (t4 && t4.childNodes.length)
                  for (var e3 = t4.childNodes.length - 1; e3 >= 0; e3--) {
                    var n3 = t4.childNodes[e3];
                    if (!p.default.isExtensionNode(n3))
                      return n3;
                  }
                return null;
              } }], [{ key: "CSS", get: function() {
                return { wrapper: "ce-block", wrapperStretched: "ce-block--stretched", content: "ce-block__content", focused: "ce-block--focused", selected: "ce-block--selected", dropTarget: "ce-block--drop-target" };
              } }]), T;
            }(y.default);
            t2.default = w, w.displayName = "Block";
          }) ? o.apply(e, r) : o) || (t.exports = i);
        }, function(t, e, n) {
          var o, r, i;
          "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self && self, r = [e, n(2), n(3), n(381), n(7)], void 0 === (i = "function" == typeof (o = function(o2, r2, i2, a, s) {
            "use strict";
            var l = n(8), c = n(1);
            Object.defineProperty(o2, "__esModule", { value: true }), o2.default = void 0, r2 = c(r2), i2 = c(i2), a = c(a), s = l(s);
            var u = function() {
              function t2(e2) {
                var n2 = this;
                (0, r2.default)(this, t2), this.iterator = null, this.activated = false, this.onKeyDown = function(e3) {
                  if (n2.isEventReadyForHandling(e3))
                    switch (t2.usedKeys.includes(e3.keyCode) && e3.preventDefault(), e3.keyCode) {
                      case s.keyCodes.TAB:
                        n2.handleTabPress(e3);
                        break;
                      case s.keyCodes.LEFT:
                      case s.keyCodes.UP:
                        n2.flipLeft();
                        break;
                      case s.keyCodes.RIGHT:
                      case s.keyCodes.DOWN:
                        n2.flipRight();
                        break;
                      case s.keyCodes.ENTER:
                        n2.handleEnterPress(e3);
                    }
                }, this.iterator = new a.default(e2.items, e2.focusedItemClass), this.activateCallback = e2.activateCallback, this.allowedKeys = e2.allowedKeys || t2.usedKeys;
              }
              return (0, i2.default)(t2, [{ key: "activate", value: function(t3) {
                this.activated = true, t3 && this.iterator.setItems(t3), document.addEventListener("keydown", this.onKeyDown);
              } }, { key: "deactivate", value: function() {
                this.activated = false, this.dropCursor(), document.removeEventListener("keydown", this.onKeyDown);
              } }, { key: "focusFirst", value: function() {
                this.dropCursor(), this.flipRight();
              } }, { key: "flipLeft", value: function() {
                this.iterator.previous(), this.flipCallback();
              } }, { key: "flipRight", value: function() {
                this.iterator.next(), this.flipCallback();
              } }, { key: "hasFocus", value: function() {
                return !!this.iterator.currentItem;
              } }, { key: "dropCursor", value: function() {
                this.iterator.dropCursor();
              } }, { key: "isEventReadyForHandling", value: function(t3) {
                return this.activated && this.allowedKeys.includes(t3.keyCode);
              } }, { key: "handleTabPress", value: function(t3) {
                switch (t3.shiftKey ? a.default.directions.LEFT : a.default.directions.RIGHT) {
                  case a.default.directions.RIGHT:
                    this.flipRight();
                    break;
                  case a.default.directions.LEFT:
                    this.flipLeft();
                }
              } }, { key: "handleEnterPress", value: function(t3) {
                this.activated && (this.iterator.currentItem && this.iterator.currentItem.click(), s.isFunction(this.activateCallback) && this.activateCallback(this.iterator.currentItem), t3.preventDefault(), t3.stopPropagation());
              } }, { key: "flipCallback", value: function() {
                this.iterator.currentItem && this.iterator.currentItem.scrollIntoViewIfNeeded();
              } }], [{ key: "usedKeys", get: function() {
                return [s.keyCodes.TAB, s.keyCodes.LEFT, s.keyCodes.RIGHT, s.keyCodes.ENTER, s.keyCodes.UP, s.keyCodes.DOWN];
              } }]), t2;
            }();
            o2.default = u, u.displayName = "Flipper", t.exports = e.default;
          }) ? o.apply(e, r) : o) || (t.exports = i);
        }, function(t, e, n) {
          var o = n(37);
          t.exports = Object("z").propertyIsEnumerable(0) ? Object : function(t2) {
            return "String" == o(t2) ? t2.split("") : Object(t2);
          };
        }, function(t, e) {
          e.f = {}.propertyIsEnumerable;
        }, function(t, e, n) {
          var o = n(37), r = n(15)("toStringTag"), i = "Arguments" == o(/* @__PURE__ */ function() {
            return arguments;
          }());
          t.exports = function(t2) {
            var e2, n2, a;
            return void 0 === t2 ? "Undefined" : null === t2 ? "Null" : "string" == typeof (n2 = function(t3, e3) {
              try {
                return t3[e3];
              } catch (t4) {
              }
            }(e2 = Object(t2), r)) ? n2 : i ? o(e2) : "Object" == (a = o(e2)) && "function" == typeof e2.callee ? "Arguments" : a;
          };
        }, function(t, e, n) {
          var o = n(12), r = n(32), i = n(15)("species");
          t.exports = function(t2, e2) {
            var n2, a = o(t2).constructor;
            return void 0 === a || null == (n2 = o(a)[i]) ? e2 : r(n2);
          };
        }, function(t, e, n) {
          var o, r, i;
          "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self && self, r = [e, n(7), n(379)], void 0 === (i = "function" == typeof (o = function(t2, e2, o2) {
            "use strict";
            var r2 = n(1), i2 = n(8);
            function a(t3) {
              var e3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, n2 = { tags: e3 }, r3 = new o2.default(n2);
              return r3.clean(t3);
            }
            function s(t3, n2) {
              return Array.isArray(t3) ? (i3 = n2, t3.map(function(t4) {
                return s(t4, i3);
              })) : e2.isObject(t3) ? function(t4, n3) {
                var o4, r4 = {};
                for (var i4 in t4)
                  if (Object.prototype.hasOwnProperty.call(t4, i4)) {
                    var a2 = t4[i4], l = (o4 = n3[i4], e2.isObject(o4) || e2.isBoolean(o4) || e2.isFunction(o4) ? n3[i4] : n3);
                    r4[i4] = s(a2, l);
                  }
                return r4;
              }(t3, n2) : e2.isString(t3) ? (o3 = t3, r3 = n2, e2.isObject(r3) ? a(o3, r3) : false === r3 ? a(o3, {}) : o3) : t3;
              var o3, r3, i3;
            }
            Object.defineProperty(t2, "__esModule", { value: true }), t2.sanitizeBlocks = function(t3, n2) {
              return t3.map(function(t4) {
                var o3 = e2.isFunction(n2) ? n2(t4.tool) : n2;
                return e2.isEmpty(o3) || (t4.data = s(t4.data, o3)), t4;
              });
            }, t2.clean = a, e2 = i2(e2), o2 = r2(o2);
          }) ? o.apply(e, r) : o) || (t.exports = i);
        }, function(t, e, n) {
          var o, r, i;
          "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self && self, r = [e, n(2), n(3), n(7)], void 0 === (i = "function" == typeof (o = function(t2, e2, o2, r2) {
            "use strict";
            var i2, a, s, l, c, u, f = n(8), d = n(1);
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = t2.InternalTuneSettings = t2.InternalInlineToolSettings = t2.InternalBlockToolSettings = t2.CommonInternalSettings = t2.UserSettings = t2.ToolType = void 0, e2 = d(e2), o2 = d(o2), r2 = f(r2), t2.ToolType = i2, function(t3) {
              t3[t3.Block = 0] = "Block", t3[t3.Inline = 1] = "Inline", t3[t3.Tune = 2] = "Tune";
            }(i2 || (t2.ToolType = i2 = {})), t2.UserSettings = a, function(t3) {
              t3.Shortcut = "shortcut", t3.Toolbox = "toolbox", t3.EnabledInlineTools = "inlineToolbar", t3.EnabledBlockTunes = "tunes", t3.Config = "config";
            }(a || (t2.UserSettings = a = {})), t2.CommonInternalSettings = s, function(t3) {
              t3.Shortcut = "shortcut", t3.SanitizeConfig = "sanitize";
            }(s || (t2.CommonInternalSettings = s = {})), t2.InternalBlockToolSettings = l, function(t3) {
              t3.IsEnabledLineBreaks = "enableLineBreaks", t3.Toolbox = "toolbox", t3.ConversionConfig = "conversionConfig", t3.IsReadOnlySupported = "isReadOnlySupported", t3.PasteConfig = "pasteConfig";
            }(l || (t2.InternalBlockToolSettings = l = {})), t2.InternalInlineToolSettings = c, function(t3) {
              t3.IsInline = "isInline", t3.Title = "title";
            }(c || (t2.InternalInlineToolSettings = c = {})), t2.InternalTuneSettings = u, function(t3) {
              t3.IsTune = "isTune";
            }(u || (t2.InternalTuneSettings = u = {}));
            var p = function() {
              function t3(n2) {
                var o3 = n2.name, r3 = n2.constructable, i3 = n2.config, a2 = n2.api, s2 = n2.isDefault, l2 = n2.isInternal, c2 = void 0 !== l2 && l2, u2 = n2.defaultPlaceholder;
                (0, e2.default)(this, t3), this.api = a2, this.name = o3, this.constructable = r3, this.config = i3, this.isDefault = s2, this.isInternal = c2, this.defaultPlaceholder = u2;
              }
              return (0, o2.default)(t3, [{ key: "reset", value: function() {
                if (r2.isFunction(this.constructable.reset))
                  return this.constructable.reset();
              } }, { key: "prepare", value: function() {
                if (r2.isFunction(this.constructable.prepare))
                  return this.constructable.prepare({ toolName: this.name, config: this.settings });
              } }, { key: "isInline", value: function() {
                return this.type === i2.Inline;
              } }, { key: "isBlock", value: function() {
                return this.type === i2.Block;
              } }, { key: "isTune", value: function() {
                return this.type === i2.Tune;
              } }, { key: "settings", get: function() {
                var t4 = this.config[a.Config] || {};
                return this.isDefault && !("placeholder" in t4) && this.defaultPlaceholder && (t4.placeholder = this.defaultPlaceholder), t4;
              } }, { key: "shortcut", get: function() {
                var t4 = this.constructable[s.Shortcut];
                return this.config[a.Shortcut] || t4;
              } }, { key: "sanitizeConfig", get: function() {
                return this.constructable[s.SanitizeConfig] || {};
              } }]), t3;
            }();
            t2.default = p, p.displayName = "BaseTool";
          }) ? o.apply(e, r) : o) || (t.exports = i);
        }, function(t, e, n) {
          var o = n(17), r = n(10), i = r["__core-js_shared__"] || (r["__core-js_shared__"] = {});
          (t.exports = function(t2, e2) {
            return i[t2] || (i[t2] = void 0 !== e2 ? e2 : {});
          })("versions", []).push({ version: o.version, mode: n(45) ? "pure" : "global", copyright: "\xA9 2019 Denis Pushkarev (zloirock.ru)" });
        }, function(t, e, n) {
          var o = n(28), r = n(16), i = n(47);
          t.exports = function(t2) {
            return function(e2, n2, a) {
              var s, l = o(e2), c = r(l.length), u = i(a, c);
              if (t2 && n2 != n2) {
                for (; c > u; )
                  if ((s = l[u++]) != s)
                    return true;
              } else
                for (; c > u; u++)
                  if ((t2 || u in l) && l[u] === n2)
                    return t2 || u || 0;
              return !t2 && -1;
            };
          };
        }, function(t, e) {
          e.f = Object.getOwnPropertySymbols;
        }, function(t, e, n) {
          var o = n(37);
          t.exports = Array.isArray || function(t2) {
            return "Array" == o(t2);
          };
        }, function(t, e, n) {
          var o = n(15)("iterator"), r = false;
          try {
            var i = [7][o]();
            i.return = function() {
              r = true;
            }, Array.from(i, function() {
              throw 2;
            });
          } catch (t2) {
          }
          t.exports = function(t2, e2) {
            if (!e2 && !r)
              return false;
            var n2 = false;
            try {
              var i2 = [7], a = i2[o]();
              a.next = function() {
                return { done: n2 = true };
              }, i2[o] = function() {
                return a;
              }, t2(i2);
            } catch (t3) {
            }
            return n2;
          };
        }, function(t, e, n) {
          "use strict";
          var o = n(12);
          t.exports = function() {
            var t2 = o(this), e2 = "";
            return t2.global && (e2 += "g"), t2.ignoreCase && (e2 += "i"), t2.multiline && (e2 += "m"), t2.unicode && (e2 += "u"), t2.sticky && (e2 += "y"), e2;
          };
        }, function(t, e, n) {
          "use strict";
          var o = n(65), r = RegExp.prototype.exec;
          t.exports = function(t2, e2) {
            var n2 = t2.exec;
            if ("function" == typeof n2) {
              var i = n2.call(t2, e2);
              if ("object" != typeof i)
                throw new TypeError("RegExp exec method returned something other than an Object or null");
              return i;
            }
            if ("RegExp" !== o(t2))
              throw new TypeError("RegExp#exec called on incompatible receiver");
            return r.call(t2, e2);
          };
        }, function(t, e, n) {
          "use strict";
          n(136);
          var o = n(23), r = n(27), i = n(11), a = n(38), s = n(15), l = n(106), c = s("species"), u = !i(function() {
            var t2 = /./;
            return t2.exec = function() {
              var t3 = [];
              return t3.groups = { a: "7" }, t3;
            }, "7" !== "".replace(t2, "$<a>");
          }), f = function() {
            var t2 = /(?:)/, e2 = t2.exec;
            t2.exec = function() {
              return e2.apply(this, arguments);
            };
            var n2 = "ab".split(t2);
            return 2 === n2.length && "a" === n2[0] && "b" === n2[1];
          }();
          t.exports = function(t2, e2, n2) {
            var d = s(t2), p = !i(function() {
              var e3 = {};
              return e3[d] = function() {
                return 7;
              }, 7 != ""[t2](e3);
            }), h = p ? !i(function() {
              var e3 = false, n3 = /a/;
              return n3.exec = function() {
                return e3 = true, null;
              }, "split" === t2 && (n3.constructor = {}, n3.constructor[c] = function() {
                return n3;
              }), n3[d](""), !e3;
            }) : void 0;
            if (!p || !h || "replace" === t2 && !u || "split" === t2 && !f) {
              var v = /./[d], g = n2(a, d, ""[t2], function(t3, e3, n3, o2, r2) {
                return e3.exec === l ? p && !r2 ? { done: true, value: v.call(e3, n3, o2) } : { done: true, value: t3.call(n3, e3, o2) } : { done: false };
              }), y = g[0], b = g[1];
              o(String.prototype, t2, y), r(RegExp.prototype, d, 2 == e2 ? function(t3, e3) {
                return b.call(t3, this, e3);
              } : function(t3) {
                return b.call(t3, this);
              });
            }
          };
        }, function(t, e, n) {
          var o = n(31), r = n(131), i = n(101), a = n(12), s = n(16), l = n(103), c = {}, u = {};
          (e = t.exports = function(t2, e2, n2, f, d) {
            var p, h, v, g, y = d ? function() {
              return t2;
            } : l(t2), b = o(n2, f, e2 ? 2 : 1), m = 0;
            if ("function" != typeof y)
              throw TypeError(t2 + " is not iterable!");
            if (i(y)) {
              for (p = s(t2.length); p > m; m++)
                if ((g = e2 ? b(a(h = t2[m])[0], h[1]) : b(t2[m])) === c || g === u)
                  return g;
            } else
              for (v = y.call(t2); !(h = v.next()).done; )
                if ((g = r(v, b, h.value, e2)) === c || g === u)
                  return g;
          }).BREAK = c, e.RETURN = u;
        }, function(t, e, n) {
          var o = n(10).navigator;
          t.exports = o && o.userAgent || "";
        }, function(t, e, n) {
          "use strict";
          var o = n(10), r = n(0), i = n(23), a = n(58), s = n(41), l = n(77), c = n(57), u = n(13), f = n(11), d = n(73), p = n(53), h = n(92);
          t.exports = function(t2, e2, n2, v, g, y) {
            var b = o[t2], m = b, k = g ? "set" : "add", x = m && m.prototype, w = {}, S = function(t3) {
              var e3 = x[t3];
              i(x, t3, "delete" == t3 || "has" == t3 ? function(t4) {
                return !(y && !u(t4)) && e3.call(this, 0 === t4 ? 0 : t4);
              } : "get" == t3 ? function(t4) {
                return y && !u(t4) ? void 0 : e3.call(this, 0 === t4 ? 0 : t4);
              } : "add" == t3 ? function(t4) {
                return e3.call(this, 0 === t4 ? 0 : t4), this;
              } : function(t4, n3) {
                return e3.call(this, 0 === t4 ? 0 : t4, n3), this;
              });
            };
            if ("function" == typeof m && (y || x.forEach && !f(function() {
              new m().entries().next();
            }))) {
              var T = new m(), E = T[k](y ? {} : -0, 1) != T, B = f(function() {
                T.has(1);
              }), C = d(function(t3) {
                new m(t3);
              }), _2 = !y && f(function() {
                for (var t3 = new m(), e3 = 5; e3--; )
                  t3[k](e3, e3);
                return !t3.has(-0);
              });
              C || ((m = e2(function(e3, n3) {
                c(e3, m, t2);
                var o2 = h(new b(), e3, m);
                return null != n3 && l(n3, g, o2[k], o2), o2;
              })).prototype = x, x.constructor = m), (B || _2) && (S("delete"), S("has"), g && S("get")), (_2 || E) && S(k), y && x.clear && delete x.clear;
            } else
              m = v.getConstructor(e2, t2, g, k), a(m.prototype, n2), s.NEED = true;
            return p(m, t2), w[t2] = m, r(r.G + r.W + r.F * (m != b), w), y || v.setStrong(m, t2, g), m;
          };
        }, function(t, e, n) {
          for (var o, r = n(10), i = n(27), a = n(44), s = a("typed_array"), l = a("view"), c = !(!r.ArrayBuffer || !r.DataView), u = c, f = 0, d = "Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array".split(","); f < 9; )
            (o = r[d[f++]]) ? (i(o.prototype, s, true), i(o.prototype, l, true)) : u = false;
          t.exports = { ABV: c, CONSTR: u, TYPED: s, VIEW: l };
        }, function(t, e, n) {
          var o, r, i;
          "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self && self, r = [e, n(2), n(3), n(7)], void 0 === (i = "function" == typeof (o = function(o2, r2, i2, a) {
            "use strict";
            var s = n(1);
            Object.defineProperty(o2, "__esModule", { value: true }), o2.default = void 0, r2 = s(r2), i2 = s(i2);
            var l = function() {
              function t2() {
                (0, r2.default)(this, t2), this.subscribers = {};
              }
              return (0, i2.default)(t2, [{ key: "on", value: function(t3, e2) {
                t3 in this.subscribers || (this.subscribers[t3] = []), this.subscribers[t3].push(e2);
              } }, { key: "once", value: function(t3, e2) {
                var n2 = this;
                t3 in this.subscribers || (this.subscribers[t3] = []), this.subscribers[t3].push(function o3(r3) {
                  var i3 = e2(r3), a2 = n2.subscribers[t3].indexOf(o3);
                  return -1 !== a2 && n2.subscribers[t3].splice(a2, 1), i3;
                });
              } }, { key: "emit", value: function(t3, e2) {
                !(0, a.isEmpty)(this.subscribers) && this.subscribers[t3] && this.subscribers[t3].reduce(function(t4, e3) {
                  return e3(t4) || t4;
                }, e2);
              } }, { key: "off", value: function(t3, e2) {
                for (var n2 = 0; n2 < this.subscribers[t3].length; n2++)
                  if (this.subscribers[t3][n2] === e2) {
                    delete this.subscribers[t3][n2];
                    break;
                  }
              } }, { key: "destroy", value: function() {
                this.subscribers = null;
              } }]), t2;
            }();
            o2.default = l, l.displayName = "EventsDispatcher", t.exports = e.default;
          }) ? o.apply(e, r) : o) || (t.exports = i);
        }, function(t, e, n) {
          var o, r, i;
          "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self && self, r = [e, n(2), n(3), n(5), n(6), n(4), n(9)], void 0 === (i = "function" == typeof (o = function(o2, r2, i2, a, s, l, c) {
            "use strict";
            var u = n(1);
            function f() {
              if ("undefined" == typeof Reflect || !Reflect.construct)
                return false;
              if (Reflect.construct.sham)
                return false;
              if ("function" == typeof Proxy)
                return true;
              try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
                })), true;
              } catch (t2) {
                return false;
              }
            }
            Object.defineProperty(o2, "__esModule", { value: true }), o2.default = void 0, r2 = u(r2), i2 = u(i2), a = u(a), s = u(s), l = u(l);
            var d = function(t2) {
              (0, a.default)(o3, t2);
              var e2, n2 = (e2 = o3, function() {
                var t3, n3 = (0, l.default)(e2);
                if (f()) {
                  var o4 = (0, l.default)(this).constructor;
                  t3 = Reflect.construct(n3, arguments, o4);
                } else
                  t3 = n3.apply(this, arguments);
                return (0, s.default)(this, t3);
              });
              function o3() {
                return (0, r2.default)(this, o3), n2.apply(this, arguments);
              }
              return (0, i2.default)(o3, [{ key: "getMethodsForTool", value: function(t3) {
                return Object.assign(this.methods, { i18n: this.Editor.I18nAPI.getMethodsForTool(t3) });
              } }, { key: "methods", get: function() {
                return { blocks: this.Editor.BlocksAPI.methods, caret: this.Editor.CaretAPI.methods, events: this.Editor.EventsAPI.methods, listeners: this.Editor.ListenersAPI.methods, notifier: this.Editor.NotifierAPI.methods, sanitizer: this.Editor.SanitizerAPI.methods, saver: this.Editor.SaverAPI.methods, selection: this.Editor.SelectionAPI.methods, styles: this.Editor.StylesAPI.classes, toolbar: this.Editor.ToolbarAPI.methods, inlineToolbar: this.Editor.InlineToolbarAPI.methods, tooltip: this.Editor.TooltipAPI.methods, i18n: this.Editor.I18nAPI.methods, readOnly: this.Editor.ReadOnlyAPI.methods, ui: this.Editor.UiAPI.methods };
              } }]), o3;
            }((c = u(c)).default);
            o2.default = d, d.displayName = "API", t.exports = e.default;
          }) ? o.apply(e, r) : o) || (t.exports = i);
        }, function(t, e, n) {
          var o, r, i;
          "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self && self, r = [e, n(2), n(3), n(5), n(6), n(4), n(9), n(14), n(7), n(60), n(84), n(114), n(385)], void 0 === (i = "function" == typeof (o = function(o2, r2, i2, a, s, l, c, u, f, d, p, h, v) {
            "use strict";
            var g = n(8), y = n(1);
            function b() {
              if ("undefined" == typeof Reflect || !Reflect.construct)
                return false;
              if (Reflect.construct.sham)
                return false;
              if ("function" == typeof Proxy)
                return true;
              try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
                })), true;
              } catch (t2) {
                return false;
              }
            }
            Object.defineProperty(o2, "__esModule", { value: true }), o2.default = void 0, r2 = y(r2), i2 = y(i2), a = y(a), s = y(s), l = y(l), c = y(c), u = y(u), f = g(f), d = y(d), h = y(h), v = g(v);
            var m = function(t2) {
              (0, a.default)(o3, t2);
              var e2, n2 = (e2 = o3, function() {
                var t3, n3 = (0, l.default)(e2);
                if (b()) {
                  var o4 = (0, l.default)(this).constructor;
                  t3 = Reflect.construct(n3, arguments, o4);
                } else
                  t3 = n3.apply(this, arguments);
                return (0, s.default)(this, t3);
              });
              function o3(t3) {
                var e3, i3 = t3.config, a2 = t3.eventsDispatcher;
                return (0, r2.default)(this, o3), (e3 = n2.call(this, { config: i3, eventsDispatcher: a2 })).tooltip = new h.default(), e3;
              }
              return (0, i2.default)(o3, [{ key: "toggleReadOnly", value: function(t3) {
                t3 ? (this.destroy(), this.Editor.BlockSettings.destroy(), this.disableModuleBindings()) : (this.drawUI(), this.enableModuleBindings());
              } }, { key: "moveAndOpen", value: function() {
                var t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.Editor.BlockManager.currentBlock;
                if (this.toolboxInstance.close(), this.Editor.BlockSettings.close(), t3) {
                  this.hoveredBlock = t3;
                  var e3, n3 = t3.holder, o4 = this.Editor.UI.isMobile, r3 = t3.pluginsContent, i3 = window.getComputedStyle(r3), a2 = parseInt(i3.paddingTop, 10), s2 = n3.offsetHeight;
                  e3 = o4 ? n3.offsetTop + s2 : n3.offsetTop + a2, this.nodes.wrapper.style.top = "".concat(Math.floor(e3), "px"), 1 === this.Editor.BlockManager.blocks.length && t3.isEmpty ? this.blockTunesToggler.hide() : this.blockTunesToggler.show(), this.open();
                }
              } }, { key: "close", value: function() {
                this.Editor.ReadOnly.isEnabled || (this.nodes.wrapper.classList.remove(this.CSS.toolbarOpened), this.blockActions.hide(), this.toolboxInstance.close(), this.Editor.BlockSettings.close());
              } }, { key: "open", value: function() {
                var t3 = this, e3 = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
                !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], f.delay(function() {
                  t3.nodes.wrapper.classList.add(t3.CSS.toolbarOpened), e3 ? t3.blockActions.show() : t3.blockActions.hide();
                }, 50)();
              } }, { key: "make", value: function() {
                var t3 = this;
                this.nodes.wrapper = u.default.make("div", this.CSS.toolbar), ["content", "actions"].forEach(function(e4) {
                  t3.nodes[e4] = u.default.make("div", t3.CSS[e4]);
                }), u.default.append(this.nodes.wrapper, this.nodes.content), u.default.append(this.nodes.content, this.nodes.actions), this.nodes.plusButton = u.default.make("div", this.CSS.plusButton), u.default.append(this.nodes.plusButton, u.default.svg("plus", 16, 16)), u.default.append(this.nodes.actions, this.nodes.plusButton), this.readOnlyMutableListeners.on(this.nodes.plusButton, "click", function() {
                  t3.tooltip.hide(true), t3.plusButtonClicked();
                }, false);
                var e3 = u.default.make("div");
                e3.appendChild(document.createTextNode(d.default.ui(p.I18nInternalNS.ui.toolbar.toolbox, "Add"))), e3.appendChild(u.default.make("div", this.CSS.plusButtonShortcut, { textContent: "\u21E5 Tab" })), this.tooltip.onHover(this.nodes.plusButton, e3, { hidingDelay: 400 }), this.nodes.settingsToggler = u.default.make("span", this.CSS.settingsToggler);
                var n3 = u.default.svg("dots", 16, 16);
                u.default.append(this.nodes.settingsToggler, n3), u.default.append(this.nodes.actions, this.nodes.settingsToggler), this.tooltip.onHover(this.nodes.settingsToggler, d.default.ui(p.I18nInternalNS.ui.blockTunes.toggler, "Click to tune"), { hidingDelay: 400 }), u.default.append(this.nodes.actions, this.makeToolbox()), u.default.append(this.nodes.actions, this.Editor.BlockSettings.nodes.wrapper), u.default.append(this.Editor.UI.nodes.wrapper, this.nodes.wrapper);
              } }, { key: "makeToolbox", value: function() {
                var t3 = this;
                return this.toolboxInstance = new v.default({ api: this.Editor.API.methods, tools: this.Editor.Tools.blockTools, i18nLabels: { filter: d.default.ui(p.I18nInternalNS.ui.toolbar.toolbox, "Filter"), nothingFound: d.default.ui(p.I18nInternalNS.ui.toolbar.toolbox, "Nothing found") } }), this.toolboxInstance.on(v.ToolboxEvent.Opened, function() {
                  t3.Editor.UI.nodes.wrapper.classList.add(t3.CSS.openedToolboxHolderModifier);
                }), this.toolboxInstance.on(v.ToolboxEvent.Closed, function() {
                  t3.Editor.UI.nodes.wrapper.classList.remove(t3.CSS.openedToolboxHolderModifier);
                }), this.toolboxInstance.on(v.ToolboxEvent.BlockAdded, function(e3) {
                  var n3 = e3.block, o4 = t3.Editor, r3 = o4.BlockManager, i3 = o4.Caret, a2 = r3.getBlockById(n3.id);
                  0 === a2.inputs.length && (a2 === r3.lastBlock ? (r3.insertAtEnd(), i3.setToBlock(r3.lastBlock)) : i3.setToBlock(r3.nextBlock));
                }), this.toolboxInstance.make();
              } }, { key: "plusButtonClicked", value: function() {
                this.Editor.BlockManager.currentBlock = this.hoveredBlock, this.toolboxInstance.toggle();
              } }, { key: "enableModuleBindings", value: function() {
                var t3 = this;
                this.readOnlyMutableListeners.on(this.nodes.settingsToggler, "mousedown", function(e3) {
                  e3.stopPropagation(), t3.settingsTogglerClicked(), t3.toolboxInstance.close(), t3.tooltip.hide(true);
                }, true), f.isMobileScreen() || this.eventsDispatcher.on(this.Editor.UI.events.blockHovered, function(e3) {
                  t3.Editor.BlockSettings.opened || t3.toolboxInstance.opened || t3.moveAndOpen(e3.block);
                });
              } }, { key: "disableModuleBindings", value: function() {
                this.readOnlyMutableListeners.clearAll();
              } }, { key: "settingsTogglerClicked", value: function() {
                this.Editor.BlockManager.currentBlock = this.hoveredBlock, this.Editor.BlockSettings.opened ? this.Editor.BlockSettings.close() : this.Editor.BlockSettings.open(this.hoveredBlock);
              } }, { key: "drawUI", value: function() {
                this.Editor.BlockSettings.make(), this.make();
              } }, { key: "destroy", value: function() {
                this.removeAllNodes(), this.toolboxInstance && this.toolboxInstance.destroy(), this.tooltip.destroy();
              } }, { key: "CSS", get: function() {
                return { toolbar: "ce-toolbar", content: "ce-toolbar__content", actions: "ce-toolbar__actions", actionsOpened: "ce-toolbar__actions--opened", toolbarOpened: "ce-toolbar--opened", openedToolboxHolderModifier: "codex-editor--toolbox-opened", plusButton: "ce-toolbar__plus", plusButtonShortcut: "ce-toolbar__plus-shortcut", settingsToggler: "ce-toolbar__settings-btn", settingsTogglerHidden: "ce-toolbar__settings-btn--hidden" };
              } }, { key: "opened", get: function() {
                return this.nodes.wrapper.classList.contains(this.CSS.toolbarOpened);
              } }, { key: "toolbox", get: function() {
                var t3 = this;
                return { opened: this.toolboxInstance.opened, close: function() {
                  t3.toolboxInstance.close();
                }, open: function() {
                  t3.Editor.BlockManager.currentBlock = t3.hoveredBlock, t3.toolboxInstance.open();
                }, toggle: function() {
                  return t3.toolboxInstance.toggle();
                }, hasFocus: function() {
                  return t3.toolboxInstance.hasFocus();
                } };
              } }, { key: "blockActions", get: function() {
                var t3 = this;
                return { hide: function() {
                  t3.nodes.actions.classList.remove(t3.CSS.actionsOpened);
                }, show: function() {
                  t3.nodes.actions.classList.add(t3.CSS.actionsOpened);
                } };
              } }, { key: "blockTunesToggler", get: function() {
                var t3 = this;
                return { hide: function() {
                  return t3.nodes.settingsToggler.classList.add(t3.CSS.settingsTogglerHidden);
                }, show: function() {
                  return t3.nodes.settingsToggler.classList.remove(t3.CSS.settingsTogglerHidden);
                } };
              } }]), o3;
            }(c.default);
            o2.default = m, m.displayName = "Toolbar", t.exports = e.default;
          }) ? o.apply(e, r) : o) || (t.exports = i);
        }, function(t, e, n) {
          var o, r, i;
          "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self && self, r = [e, n(30), n(150), n(7)], void 0 === (i = "function" == typeof (o = function(t2, e2, o2, r2) {
            "use strict";
            var i2 = n(1);
            Object.defineProperty(t2, "__esModule", { value: true }), t2.I18nInternalNS = void 0, e2 = i2(e2);
            var a = function t3(n2, o3) {
              var i3 = {};
              return Object.entries(n2).forEach(function(n3) {
                var a2 = (0, e2.default)(n3, 2), s = a2[0], l = a2[1];
                if ((0, r2.isObject)(l)) {
                  var c = o3 ? "".concat(o3, ".").concat(s) : s, u = Object.values(l).every(function(t4) {
                    return (0, r2.isString)(t4);
                  });
                  i3[s] = u ? c : t3(l, c);
                } else
                  i3[s] = l;
              }), i3;
            }((o2 = i2(o2)).default);
            t2.I18nInternalNS = a;
          }) ? o.apply(e, r) : o) || (t.exports = i);
        }, function(t, e, n) {
          var o = n(13), r = n(10).document, i = o(r) && o(r.createElement);
          t.exports = function(t2) {
            return i ? r.createElement(t2) : {};
          };
        }, function(t, e, n) {
          e.f = n(15);
        }, function(t, e, n) {
          var o = n(69)("keys"), r = n(44);
          t.exports = function(t2) {
            return o[t2] || (o[t2] = r(t2));
          };
        }, function(t, e) {
          t.exports = "constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",");
        }, function(t, e, n) {
          var o = n(10).document;
          t.exports = o && o.documentElement;
        }, function(t, e, n) {
          var o = n(13), r = n(12), i = function(t2, e2) {
            if (r(t2), !o(e2) && null !== e2)
              throw TypeError(e2 + ": can't set as prototype!");
          };
          t.exports = { set: Object.setPrototypeOf || ("__proto__" in {} ? function(t2, e2, o2) {
            try {
              (o2 = n(31)(Function.call, n(34).f(Object.prototype, "__proto__").set, 2))(t2, []), e2 = !(t2 instanceof Array);
            } catch (t3) {
              e2 = true;
            }
            return function(t3, n2) {
              return i(t3, n2), e2 ? t3.__proto__ = n2 : o2(t3, n2), t3;
            };
          }({}, false) : void 0), check: i };
        }, function(t, e) {
          t.exports = "	\n\v\f\r \xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF";
        }, function(t, e, n) {
          var o = n(13), r = n(90).set;
          t.exports = function(t2, e2, n2) {
            var i, a = e2.constructor;
            return a !== n2 && "function" == typeof a && (i = a.prototype) !== n2.prototype && o(i) && r && r(t2, i), t2;
          };
        }, function(t, e, n) {
          "use strict";
          var o = n(33), r = n(38);
          t.exports = function(t2) {
            var e2 = String(r(this)), n2 = "", i = o(t2);
            if (i < 0 || i == 1 / 0)
              throw RangeError("Count can't be negative");
            for (; i > 0; (i >>>= 1) && (e2 += e2))
              1 & i && (n2 += e2);
            return n2;
          };
        }, function(t, e) {
          t.exports = Math.sign || function(t2) {
            return 0 == (t2 = +t2) || t2 != t2 ? t2 : t2 < 0 ? -1 : 1;
          };
        }, function(t, e) {
          var n = Math.expm1;
          t.exports = !n || n(10) > 22025.465794806718 || n(10) < 22025.465794806718 || -2e-17 != n(-2e-17) ? function(t2) {
            return 0 == (t2 = +t2) ? t2 : t2 > -1e-6 && t2 < 1e-6 ? t2 + t2 * t2 / 2 : Math.exp(t2) - 1;
          } : n;
        }, function(t, e, n) {
          var o = n(33), r = n(38);
          t.exports = function(t2) {
            return function(e2, n2) {
              var i, a, s = String(r(e2)), l = o(n2), c = s.length;
              return l < 0 || l >= c ? t2 ? "" : void 0 : (i = s.charCodeAt(l)) < 55296 || i > 56319 || l + 1 === c || (a = s.charCodeAt(l + 1)) < 56320 || a > 57343 ? t2 ? s.charAt(l) : i : t2 ? s.slice(l, l + 2) : a - 56320 + (i - 55296 << 10) + 65536;
            };
          };
        }, function(t, e, n) {
          "use strict";
          var o = n(45), r = n(0), i = n(23), a = n(27), s = n(55), l = n(130), c = n(53), u = n(50), f = n(15)("iterator"), d = !([].keys && "next" in [].keys()), p = function() {
            return this;
          };
          t.exports = function(t2, e2, n2, h, v, g, y) {
            l(n2, e2, h);
            var b, m, k, x = function(t3) {
              if (!d && t3 in E)
                return E[t3];
              switch (t3) {
                case "keys":
                case "values":
                  return function() {
                    return new n2(this, t3);
                  };
              }
              return function() {
                return new n2(this, t3);
              };
            }, w = e2 + " Iterator", S = "values" == v, T = false, E = t2.prototype, B = E[f] || E["@@iterator"] || v && E[v], C = B || x(v), _2 = v ? S ? x("entries") : C : void 0, I = "Array" == e2 && E.entries || B;
            if (I && (k = u(I.call(new t2()))) !== Object.prototype && k.next && (c(k, w, true), o || "function" == typeof k[f] || a(k, f, p)), S && B && "values" !== B.name && (T = true, C = function() {
              return B.call(this);
            }), o && !y || !d && !T && E[f] || a(E, f, C), s[e2] = C, s[w] = p, v)
              if (b = { values: S ? C : x("values"), keys: g ? C : x("keys"), entries: _2 }, y)
                for (m in b)
                  m in E || i(E, m, b[m]);
              else
                r(r.P + r.F * (d || T), e2, b);
            return b;
          };
        }, function(t, e, n) {
          var o = n(99), r = n(38);
          t.exports = function(t2, e2, n2) {
            if (o(e2))
              throw TypeError("String#" + n2 + " doesn't accept regex!");
            return String(r(t2));
          };
        }, function(t, e, n) {
          var o = n(13), r = n(37), i = n(15)("match");
          t.exports = function(t2) {
            var e2;
            return o(t2) && (void 0 !== (e2 = t2[i]) ? !!e2 : "RegExp" == r(t2));
          };
        }, function(t, e, n) {
          var o = n(15)("match");
          t.exports = function(t2) {
            var e2 = /./;
            try {
              "/./"[t2](e2);
            } catch (n2) {
              try {
                return e2[o] = false, !"/./"[t2](e2);
              } catch (t3) {
              }
            }
            return true;
          };
        }, function(t, e, n) {
          var o = n(55), r = n(15)("iterator"), i = Array.prototype;
          t.exports = function(t2) {
            return void 0 !== t2 && (o.Array === t2 || i[r] === t2);
          };
        }, function(t, e, n) {
          "use strict";
          var o = n(19), r = n(43);
          t.exports = function(t2, e2, n2) {
            e2 in t2 ? o.f(t2, e2, r(0, n2)) : t2[e2] = n2;
          };
        }, function(t, e, n) {
          var o = n(65), r = n(15)("iterator"), i = n(55);
          t.exports = n(17).getIteratorMethod = function(t2) {
            if (null != t2)
              return t2[r] || t2["@@iterator"] || i[o(t2)];
          };
        }, function(t, e, n) {
          "use strict";
          var o = n(22), r = n(47), i = n(16);
          t.exports = function(t2) {
            for (var e2 = o(this), n2 = i(e2.length), a = arguments.length, s = r(a > 1 ? arguments[1] : void 0, n2), l = a > 2 ? arguments[2] : void 0, c = void 0 === l ? n2 : r(l, n2); c > s; )
              e2[s++] = t2;
            return e2;
          };
        }, function(t, e, n) {
          "use strict";
          var o = n(51), r = n(135), i = n(55), a = n(28);
          t.exports = n(97)(Array, "Array", function(t2, e2) {
            this._t = a(t2), this._i = 0, this._k = e2;
          }, function() {
            var t2 = this._t, e2 = this._k, n2 = this._i++;
            return !t2 || n2 >= t2.length ? (this._t = void 0, r(1)) : r(0, "keys" == e2 ? n2 : "values" == e2 ? t2[n2] : [n2, t2[n2]]);
          }, "values"), i.Arguments = i.Array, o("keys"), o("values"), o("entries");
        }, function(t, e, n) {
          "use strict";
          var o, r, i = n(74), a = RegExp.prototype.exec, s = String.prototype.replace, l = a, c = (o = /a/, r = /b*/g, a.call(o, "a"), a.call(r, "a"), 0 !== o.lastIndex || 0 !== r.lastIndex), u = void 0 !== /()??/.exec("")[1];
          (c || u) && (l = function(t2) {
            var e2, n2, o2, r2, l2 = this;
            return u && (n2 = new RegExp("^" + l2.source + "$(?!\\s)", i.call(l2))), c && (e2 = l2.lastIndex), o2 = a.call(l2, t2), c && o2 && (l2.lastIndex = l2.global ? o2.index + o2[0].length : e2), u && o2 && o2.length > 1 && s.call(o2[0], n2, function() {
              for (r2 = 1; r2 < arguments.length - 2; r2++)
                void 0 === arguments[r2] && (o2[r2] = void 0);
            }), o2;
          }), t.exports = l;
        }, function(t, e, n) {
          "use strict";
          var o = n(96)(true);
          t.exports = function(t2, e2, n2) {
            return e2 + (n2 ? o(t2, e2).length : 1);
          };
        }, function(t, e, n) {
          var o, r, i, a = n(31), s = n(124), l = n(89), c = n(85), u = n(10), f = u.process, d = u.setImmediate, p = u.clearImmediate, h = u.MessageChannel, v = u.Dispatch, g = 0, y = {}, b = function() {
            var t2 = +this;
            if (y.hasOwnProperty(t2)) {
              var e2 = y[t2];
              delete y[t2], e2();
            }
          }, m = function(t2) {
            b.call(t2.data);
          };
          d && p || (d = function(t2) {
            for (var e2 = [], n2 = 1; arguments.length > n2; )
              e2.push(arguments[n2++]);
            return y[++g] = function() {
              s("function" == typeof t2 ? t2 : Function(t2), e2);
            }, o(g), g;
          }, p = function(t2) {
            delete y[t2];
          }, "process" == n(37)(f) ? o = function(t2) {
            f.nextTick(a(b, t2, 1));
          } : v && v.now ? o = function(t2) {
            v.now(a(b, t2, 1));
          } : h ? (i = (r = new h()).port2, r.port1.onmessage = m, o = a(i.postMessage, i, 1)) : u.addEventListener && "function" == typeof postMessage && !u.importScripts ? (o = function(t2) {
            u.postMessage(t2 + "", "*");
          }, u.addEventListener("message", m, false)) : o = "onreadystatechange" in c("script") ? function(t2) {
            l.appendChild(c("script")).onreadystatechange = function() {
              l.removeChild(this), b.call(t2);
            };
          } : function(t2) {
            setTimeout(a(b, t2, 1), 0);
          }), t.exports = { set: d, clear: p };
        }, function(t, e, n) {
          "use strict";
          var o = n(10), r = n(18), i = n(45), a = n(80), s = n(27), l = n(58), c = n(11), u = n(57), f = n(33), d = n(16), p = n(143), h = n(49).f, v = n(19).f, g = n(104), y = n(53), b = o.ArrayBuffer, m = o.DataView, k = o.Math, x = o.RangeError, w = o.Infinity, S = b, T = k.abs, E = k.pow, B = k.floor, C = k.log, _2 = k.LN2, I = r ? "_b" : "buffer", O = r ? "_l" : "byteLength", M = r ? "_o" : "byteOffset";
          function R(t2, e2, n2) {
            var o2, r2, i2, a2 = new Array(n2), s2 = 8 * n2 - e2 - 1, l2 = (1 << s2) - 1, c2 = l2 >> 1, u2 = 23 === e2 ? E(2, -24) - E(2, -77) : 0, f2 = 0, d2 = t2 < 0 || 0 === t2 && 1 / t2 < 0 ? 1 : 0;
            for ((t2 = T(t2)) != t2 || t2 === w ? (r2 = t2 != t2 ? 1 : 0, o2 = l2) : (o2 = B(C(t2) / _2), t2 * (i2 = E(2, -o2)) < 1 && (o2--, i2 *= 2), (t2 += o2 + c2 >= 1 ? u2 / i2 : u2 * E(2, 1 - c2)) * i2 >= 2 && (o2++, i2 /= 2), o2 + c2 >= l2 ? (r2 = 0, o2 = l2) : o2 + c2 >= 1 ? (r2 = (t2 * i2 - 1) * E(2, e2), o2 += c2) : (r2 = t2 * E(2, c2 - 1) * E(2, e2), o2 = 0)); e2 >= 8; a2[f2++] = 255 & r2, r2 /= 256, e2 -= 8)
              ;
            for (o2 = o2 << e2 | r2, s2 += e2; s2 > 0; a2[f2++] = 255 & o2, o2 /= 256, s2 -= 8)
              ;
            return a2[--f2] |= 128 * d2, a2;
          }
          function A(t2, e2, n2) {
            var o2, r2 = 8 * n2 - e2 - 1, i2 = (1 << r2) - 1, a2 = i2 >> 1, s2 = r2 - 7, l2 = n2 - 1, c2 = t2[l2--], u2 = 127 & c2;
            for (c2 >>= 7; s2 > 0; u2 = 256 * u2 + t2[l2], l2--, s2 -= 8)
              ;
            for (o2 = u2 & (1 << -s2) - 1, u2 >>= -s2, s2 += e2; s2 > 0; o2 = 256 * o2 + t2[l2], l2--, s2 -= 8)
              ;
            if (0 === u2)
              u2 = 1 - a2;
            else {
              if (u2 === i2)
                return o2 ? NaN : c2 ? -w : w;
              o2 += E(2, e2), u2 -= a2;
            }
            return (c2 ? -1 : 1) * o2 * E(2, u2 - e2);
          }
          function N(t2) {
            return t2[3] << 24 | t2[2] << 16 | t2[1] << 8 | t2[0];
          }
          function L(t2) {
            return [255 & t2];
          }
          function P(t2) {
            return [255 & t2, t2 >> 8 & 255];
          }
          function D(t2) {
            return [255 & t2, t2 >> 8 & 255, t2 >> 16 & 255, t2 >> 24 & 255];
          }
          function j(t2) {
            return R(t2, 52, 8);
          }
          function F(t2) {
            return R(t2, 23, 4);
          }
          function H(t2, e2, n2) {
            v(t2.prototype, e2, { get: function() {
              return this[n2];
            } });
          }
          function U(t2, e2, n2, o2) {
            var r2 = p(+n2);
            if (r2 + e2 > t2[O])
              throw x("Wrong index!");
            var i2 = t2[I]._b, a2 = r2 + t2[M], s2 = i2.slice(a2, a2 + e2);
            return o2 ? s2 : s2.reverse();
          }
          function z(t2, e2, n2, o2, r2, i2) {
            var a2 = p(+n2);
            if (a2 + e2 > t2[O])
              throw x("Wrong index!");
            for (var s2 = t2[I]._b, l2 = a2 + t2[M], c2 = o2(+r2), u2 = 0; u2 < e2; u2++)
              s2[l2 + u2] = c2[i2 ? u2 : e2 - u2 - 1];
          }
          if (a.ABV) {
            if (!c(function() {
              b(1);
            }) || !c(function() {
              new b(-1);
            }) || c(function() {
              return new b(), new b(1.5), new b(NaN), "ArrayBuffer" != b.name;
            })) {
              for (var W, Y = (b = function(t2) {
                return u(this, b), new S(p(t2));
              }).prototype = S.prototype, V = h(S), X = 0; V.length > X; )
                (W = V[X++]) in b || s(b, W, S[W]);
              i || (Y.constructor = b);
            }
            var K = new m(new b(2)), G = m.prototype.setInt8;
            K.setInt8(0, 2147483648), K.setInt8(1, 2147483649), !K.getInt8(0) && K.getInt8(1) || l(m.prototype, { setInt8: function(t2, e2) {
              G.call(this, t2, e2 << 24 >> 24);
            }, setUint8: function(t2, e2) {
              G.call(this, t2, e2 << 24 >> 24);
            } }, true);
          } else
            b = function(t2) {
              u(this, b, "ArrayBuffer");
              var e2 = p(t2);
              this._b = g.call(new Array(e2), 0), this[O] = e2;
            }, m = function(t2, e2, n2) {
              u(this, m, "DataView"), u(t2, b, "DataView");
              var o2 = t2[O], r2 = f(e2);
              if (r2 < 0 || r2 > o2)
                throw x("Wrong offset!");
              if (r2 + (n2 = void 0 === n2 ? o2 - r2 : d(n2)) > o2)
                throw x("Wrong length!");
              this[I] = t2, this[M] = r2, this[O] = n2;
            }, r && (H(b, "byteLength", "_l"), H(m, "buffer", "_b"), H(m, "byteLength", "_l"), H(m, "byteOffset", "_o")), l(m.prototype, { getInt8: function(t2) {
              return U(this, 1, t2)[0] << 24 >> 24;
            }, getUint8: function(t2) {
              return U(this, 1, t2)[0];
            }, getInt16: function(t2) {
              var e2 = U(this, 2, t2, arguments[1]);
              return (e2[1] << 8 | e2[0]) << 16 >> 16;
            }, getUint16: function(t2) {
              var e2 = U(this, 2, t2, arguments[1]);
              return e2[1] << 8 | e2[0];
            }, getInt32: function(t2) {
              return N(U(this, 4, t2, arguments[1]));
            }, getUint32: function(t2) {
              return N(U(this, 4, t2, arguments[1])) >>> 0;
            }, getFloat32: function(t2) {
              return A(U(this, 4, t2, arguments[1]), 23, 4);
            }, getFloat64: function(t2) {
              return A(U(this, 8, t2, arguments[1]), 52, 8);
            }, setInt8: function(t2, e2) {
              z(this, 1, t2, L, e2);
            }, setUint8: function(t2, e2) {
              z(this, 1, t2, L, e2);
            }, setInt16: function(t2, e2) {
              z(this, 2, t2, P, e2, arguments[2]);
            }, setUint16: function(t2, e2) {
              z(this, 2, t2, P, e2, arguments[2]);
            }, setInt32: function(t2, e2) {
              z(this, 4, t2, D, e2, arguments[2]);
            }, setUint32: function(t2, e2) {
              z(this, 4, t2, D, e2, arguments[2]);
            }, setFloat32: function(t2, e2) {
              z(this, 4, t2, F, e2, arguments[2]);
            }, setFloat64: function(t2, e2) {
              z(this, 8, t2, j, e2, arguments[2]);
            } });
          y(b, "ArrayBuffer"), y(m, "DataView"), s(m.prototype, a.VIEW, true), e.ArrayBuffer = b, e.DataView = m;
        }, function(t, e) {
          function n(e2, o) {
            return t.exports = n = Object.setPrototypeOf || function(t2, e3) {
              return t2.__proto__ = e3, t2;
            }, n(e2, o);
          }
          t.exports = n;
        }, function(t, e, n) {
          var o, r, i;
          "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self && self, r = [e, n(2), n(3), n(7)], void 0 === (i = "function" == typeof (o = function(o2, r2, i2, a) {
            "use strict";
            var s = n(8), l = n(1);
            Object.defineProperty(o2, "__esModule", { value: true }), o2.default = void 0, r2 = l(r2), i2 = l(i2), a = s(a);
            var c = function() {
              function t2() {
                (0, r2.default)(this, t2), this.allListeners = [];
              }
              return (0, i2.default)(t2, [{ key: "on", value: function(t3, e2, n2) {
                var o3 = arguments.length > 3 && void 0 !== arguments[3] && arguments[3], r3 = a.generateId("l"), i3 = { id: r3, element: t3, eventType: e2, handler: n2, options: o3 }, s2 = this.findOne(t3, e2, n2);
                if (!s2)
                  return this.allListeners.push(i3), t3.addEventListener(e2, n2, o3), r3;
              } }, { key: "off", value: function(t3, e2, n2, o3) {
                var r3 = this, i3 = this.findAll(t3, e2, n2);
                i3.forEach(function(t4, e3) {
                  var n3 = r3.allListeners.indexOf(i3[e3]);
                  n3 > -1 && (r3.allListeners.splice(n3, 1), t4.element.removeEventListener(t4.eventType, t4.handler, t4.options));
                });
              } }, { key: "offById", value: function(t3) {
                var e2 = this.findById(t3);
                e2 && e2.element.removeEventListener(e2.eventType, e2.handler, e2.options);
              } }, { key: "findOne", value: function(t3, e2, n2) {
                var o3 = this.findAll(t3, e2, n2);
                return o3.length > 0 ? o3[0] : null;
              } }, { key: "findAll", value: function(t3, e2, n2) {
                var o3 = t3 ? this.findByEventTarget(t3) : [];
                return t3 && e2 && n2 ? o3.filter(function(t4) {
                  return t4.eventType === e2 && t4.handler === n2;
                }) : t3 && e2 ? o3.filter(function(t4) {
                  return t4.eventType === e2;
                }) : o3;
              } }, { key: "removeAll", value: function() {
                this.allListeners.map(function(t3) {
                  t3.element.removeEventListener(t3.eventType, t3.handler, t3.options);
                }), this.allListeners = [];
              } }, { key: "destroy", value: function() {
                this.removeAll();
              } }, { key: "findByEventTarget", value: function(t3) {
                return this.allListeners.filter(function(e2) {
                  if (e2.element === t3)
                    return e2;
                });
              } }, { key: "findByType", value: function(t3) {
                return this.allListeners.filter(function(e2) {
                  if (e2.eventType === t3)
                    return e2;
                });
              } }, { key: "findByHandler", value: function(t3) {
                return this.allListeners.filter(function(e2) {
                  if (e2.handler === t3)
                    return e2;
                });
              } }, { key: "findById", value: function(t3) {
                return this.allListeners.find(function(e2) {
                  return e2.id === t3;
                });
              } }]), t2;
            }();
            o2.default = c, c.displayName = "Listeners", t.exports = e.default;
          }) ? o.apply(e, r) : o) || (t.exports = i);
        }, function(t, e, n) {
          var o, r, i;
          "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self && self, r = [e], void 0 === (i = "function" == typeof (o = function(n2) {
            "use strict";
            Object.defineProperty(n2, "__esModule", { value: true }), n2.default = void 0;
            var o2 = function(t2) {
              var e2 = { get id() {
                return t2.id;
              }, get name() {
                return t2.name;
              }, get config() {
                return t2.config;
              }, get holder() {
                return t2.holder;
              }, get isEmpty() {
                return t2.isEmpty;
              }, get selected() {
                return t2.selected;
              }, set stretched(e3) {
                t2.stretched = e3;
              }, get stretched() {
                return t2.stretched;
              }, call: function(e3, n3) {
                return t2.call(e3, n3);
              }, save: function() {
                return t2.save();
              }, validate: function(e3) {
                return t2.validate(e3);
              }, dispatchChange: function() {
                t2.dispatchChange();
              } };
              Object.setPrototypeOf(this, e2);
            };
            n2.default = o2, t.exports = e.default;
          }) ? o.apply(e, r) : o) || (t.exports = i);
        }, function(t, e, n) {
          var o = n(376);
          function r(e2, n2, i) {
            return "undefined" != typeof Reflect && Reflect.get ? t.exports = r = Reflect.get : t.exports = r = function(t2, e3, n3) {
              var r2 = o(t2, e3);
              if (r2) {
                var i2 = Object.getOwnPropertyDescriptor(r2, e3);
                return i2.get ? i2.get.call(n3) : i2.value;
              }
            }, r(e2, n2, i || e2);
          }
          t.exports = r;
        }, function(t, e, n) {
          var o, r, i;
          "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self && self, r = [e, n(2), n(3), n(380)], void 0 === (i = "function" == typeof (o = function(o2, r2, i2, a) {
            "use strict";
            var s = n(1);
            Object.defineProperty(o2, "__esModule", { value: true }), o2.default = void 0, r2 = s(r2), i2 = s(i2), a = s(a);
            var l = function() {
              function t2() {
                (0, r2.default)(this, t2), this.lib = new a.default();
              }
              return (0, i2.default)(t2, [{ key: "destroy", value: function() {
                this.lib.destroy();
              } }, { key: "show", value: function(t3, e2, n2) {
                this.lib.show(t3, e2, n2);
              } }, { key: "hide", value: function() {
                var t3 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
                this.lib.hide(t3);
              } }, { key: "onHover", value: function(t3, e2, n2) {
                this.lib.onHover(t3, e2, n2);
              } }]), t2;
            }();
            o2.default = l, l.displayName = "Tooltip", t.exports = e.default;
          }) ? o.apply(e, r) : o) || (t.exports = i);
        }, function(t, e, n) {
          var o, r, i;
          "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self && self, r = [e, n(42), n(2), n(3), n(384)], void 0 === (i = "function" == typeof (o = function(o2, r2, i2, a, s) {
            "use strict";
            var l = n(1);
            Object.defineProperty(o2, "__esModule", { value: true }), o2.default = void 0, r2 = l(r2), i2 = l(i2), a = l(a), s = l(s);
            var c = function() {
              function t2() {
                (0, i2.default)(this, t2), this.registeredShortcuts = /* @__PURE__ */ new Map();
              }
              return (0, a.default)(t2, [{ key: "add", value: function(t3) {
                if (this.findShortcut(t3.on, t3.name))
                  throw Error("Shortcut ".concat(t3.name, " is already registered for ").concat(t3.on, ". Please remove it before add a new handler."));
                var e2 = new s.default({ name: t3.name, on: t3.on, callback: t3.handler }), n2 = this.registeredShortcuts.get(t3.on) || [];
                this.registeredShortcuts.set(t3.on, [].concat((0, r2.default)(n2), [e2]));
              } }, { key: "remove", value: function(t3, e2) {
                var n2 = this.findShortcut(t3, e2);
                if (n2) {
                  n2.remove();
                  var o3 = this.registeredShortcuts.get(t3);
                  this.registeredShortcuts.set(t3, o3.filter(function(t4) {
                    return t4 !== n2;
                  }));
                }
              } }, { key: "findShortcut", value: function(t3, e2) {
                return (this.registeredShortcuts.get(t3) || []).find(function(t4) {
                  return t4.name === e2;
                });
              } }]), t2;
            }();
            c.displayName = "Shortcuts";
            var u = new c();
            o2.default = u, t.exports = e.default;
          }) ? o.apply(e, r) : o) || (t.exports = i);
        }, function(t, e, n) {
          t.exports = !n(18) && !n(11)(function() {
            return 7 != Object.defineProperty(n(85)("div"), "a", { get: function() {
              return 7;
            } }).a;
          });
        }, function(t, e, n) {
          var o = n(10), r = n(17), i = n(45), a = n(86), s = n(19).f;
          t.exports = function(t2) {
            var e2 = r.Symbol || (r.Symbol = i ? {} : o.Symbol || {});
            "_" == t2.charAt(0) || t2 in e2 || s(e2, t2, { value: a.f(t2) });
          };
        }, function(t, e, n) {
          var o = n(26), r = n(28), i = n(70)(false), a = n(87)("IE_PROTO");
          t.exports = function(t2, e2) {
            var n2, s = r(t2), l = 0, c = [];
            for (n2 in s)
              n2 != a && o(s, n2) && c.push(n2);
            for (; e2.length > l; )
              o(s, n2 = e2[l++]) && (~i(c, n2) || c.push(n2));
            return c;
          };
        }, function(t, e, n) {
          var o = n(19), r = n(12), i = n(46);
          t.exports = n(18) ? Object.defineProperties : function(t2, e2) {
            r(t2);
            for (var n2, a = i(e2), s = a.length, l = 0; s > l; )
              o.f(t2, n2 = a[l++], e2[n2]);
            return t2;
          };
        }, function(t, e, n) {
          var o = n(28), r = n(49).f, i = {}.toString, a = "object" == typeof window && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
          t.exports.f = function(t2) {
            return a && "[object Window]" == i.call(t2) ? function(t3) {
              try {
                return r(t3);
              } catch (t4) {
                return a.slice();
              }
            }(t2) : r(o(t2));
          };
        }, function(t, e, n) {
          "use strict";
          var o = n(18), r = n(46), i = n(71), a = n(64), s = n(22), l = n(63), c = Object.assign;
          t.exports = !c || n(11)(function() {
            var t2 = {}, e2 = {}, n2 = Symbol(), o2 = "abcdefghijklmnopqrst";
            return t2[n2] = 7, o2.split("").forEach(function(t3) {
              e2[t3] = t3;
            }), 7 != c({}, t2)[n2] || Object.keys(c({}, e2)).join("") != o2;
          }) ? function(t2, e2) {
            for (var n2 = s(t2), c2 = arguments.length, u = 1, f = i.f, d = a.f; c2 > u; )
              for (var p, h = l(arguments[u++]), v = f ? r(h).concat(f(h)) : r(h), g = v.length, y = 0; g > y; )
                p = v[y++], o && !d.call(h, p) || (n2[p] = h[p]);
            return n2;
          } : c;
        }, function(t, e) {
          t.exports = Object.is || function(t2, e2) {
            return t2 === e2 ? 0 !== t2 || 1 / t2 == 1 / e2 : t2 != t2 && e2 != e2;
          };
        }, function(t, e, n) {
          "use strict";
          var o = n(32), r = n(13), i = n(124), a = [].slice, s = {}, l = function(t2, e2, n2) {
            if (!(e2 in s)) {
              for (var o2 = [], r2 = 0; r2 < e2; r2++)
                o2[r2] = "a[" + r2 + "]";
              s[e2] = Function("F,a", "return new F(" + o2.join(",") + ")");
            }
            return s[e2](t2, n2);
          };
          t.exports = Function.bind || function(t2) {
            var e2 = o(this), n2 = a.call(arguments, 1), s2 = function() {
              var o2 = n2.concat(a.call(arguments));
              return this instanceof s2 ? l(e2, o2.length, o2) : i(e2, o2, t2);
            };
            return r(e2.prototype) && (s2.prototype = e2.prototype), s2;
          };
        }, function(t, e) {
          t.exports = function(t2, e2, n) {
            var o = void 0 === n;
            switch (e2.length) {
              case 0:
                return o ? t2() : t2.call(n);
              case 1:
                return o ? t2(e2[0]) : t2.call(n, e2[0]);
              case 2:
                return o ? t2(e2[0], e2[1]) : t2.call(n, e2[0], e2[1]);
              case 3:
                return o ? t2(e2[0], e2[1], e2[2]) : t2.call(n, e2[0], e2[1], e2[2]);
              case 4:
                return o ? t2(e2[0], e2[1], e2[2], e2[3]) : t2.call(n, e2[0], e2[1], e2[2], e2[3]);
            }
            return t2.apply(n, e2);
          };
        }, function(t, e, n) {
          var o = n(10).parseInt, r = n(54).trim, i = n(91), a = /^[-+]?0[xX]/;
          t.exports = 8 !== o(i + "08") || 22 !== o(i + "0x16") ? function(t2, e2) {
            var n2 = r(String(t2), 3);
            return o(n2, e2 >>> 0 || (a.test(n2) ? 16 : 10));
          } : o;
        }, function(t, e, n) {
          var o = n(10).parseFloat, r = n(54).trim;
          t.exports = 1 / o(n(91) + "-0") != -1 / 0 ? function(t2) {
            var e2 = r(String(t2), 3), n2 = o(e2);
            return 0 === n2 && "-" == e2.charAt(0) ? -0 : n2;
          } : o;
        }, function(t, e, n) {
          var o = n(37);
          t.exports = function(t2, e2) {
            if ("number" != typeof t2 && "Number" != o(t2))
              throw TypeError(e2);
            return +t2;
          };
        }, function(t, e, n) {
          var o = n(13), r = Math.floor;
          t.exports = function(t2) {
            return !o(t2) && isFinite(t2) && r(t2) === t2;
          };
        }, function(t, e) {
          t.exports = Math.log1p || function(t2) {
            return (t2 = +t2) > -1e-8 && t2 < 1e-8 ? t2 - t2 * t2 / 2 : Math.log(1 + t2);
          };
        }, function(t, e, n) {
          "use strict";
          var o = n(48), r = n(43), i = n(53), a = {};
          n(27)(a, n(15)("iterator"), function() {
            return this;
          }), t.exports = function(t2, e2, n2) {
            t2.prototype = o(a, { next: r(1, n2) }), i(t2, e2 + " Iterator");
          };
        }, function(t, e, n) {
          var o = n(12);
          t.exports = function(t2, e2, n2, r) {
            try {
              return r ? e2(o(n2)[0], n2[1]) : e2(n2);
            } catch (e3) {
              var i = t2.return;
              throw void 0 !== i && o(i.call(t2)), e3;
            }
          };
        }, function(t, e, n) {
          var o = n(282);
          t.exports = function(t2, e2) {
            return new (o(t2))(e2);
          };
        }, function(t, e, n) {
          var o = n(32), r = n(22), i = n(63), a = n(16);
          t.exports = function(t2, e2, n2, s, l) {
            o(e2);
            var c = r(t2), u = i(c), f = a(c.length), d = l ? f - 1 : 0, p = l ? -1 : 1;
            if (n2 < 2)
              for (; ; ) {
                if (d in u) {
                  s = u[d], d += p;
                  break;
                }
                if (d += p, l ? d < 0 : f <= d)
                  throw TypeError("Reduce of empty array with no initial value");
              }
            for (; l ? d >= 0 : f > d; d += p)
              d in u && (s = e2(s, u[d], d, c));
            return s;
          };
        }, function(t, e, n) {
          "use strict";
          var o = n(22), r = n(47), i = n(16);
          t.exports = [].copyWithin || function(t2, e2) {
            var n2 = o(this), a = i(n2.length), s = r(t2, a), l = r(e2, a), c = arguments.length > 2 ? arguments[2] : void 0, u = Math.min((void 0 === c ? a : r(c, a)) - l, a - s), f = 1;
            for (l < s && s < l + u && (f = -1, l += u - 1, s += u - 1); u-- > 0; )
              l in n2 ? n2[s] = n2[l] : delete n2[s], s += f, l += f;
            return n2;
          };
        }, function(t, e) {
          t.exports = function(t2, e2) {
            return { value: e2, done: !!t2 };
          };
        }, function(t, e, n) {
          "use strict";
          var o = n(106);
          n(0)({ target: "RegExp", proto: true, forced: o !== /./.exec }, { exec: o });
        }, function(t, e, n) {
          n(18) && "g" != /./g.flags && n(19).f(RegExp.prototype, "flags", { configurable: true, get: n(74) });
        }, function(t, e, n) {
          "use strict";
          var o, r, i, a, s = n(45), l = n(10), c = n(31), u = n(65), f = n(0), d = n(13), p = n(32), h = n(57), v = n(77), g = n(66), y = n(108).set, b = n(302)(), m = n(139), k = n(303), x = n(78), w = n(140), S = l.TypeError, T = l.process, E = T && T.versions, B = E && E.v8 || "", C = l.Promise, _2 = "process" == u(T), I = function() {
          }, O = r = m.f, M = !!function() {
            try {
              var t2 = C.resolve(1), e2 = (t2.constructor = {})[n(15)("species")] = function(t3) {
                t3(I, I);
              };
              return (_2 || "function" == typeof PromiseRejectionEvent) && t2.then(I) instanceof e2 && 0 !== B.indexOf("6.6") && -1 === x.indexOf("Chrome/66");
            } catch (t3) {
            }
          }(), R = function(t2) {
            var e2;
            return !(!d(t2) || "function" != typeof (e2 = t2.then)) && e2;
          }, A = function(t2, e2) {
            if (!t2._n) {
              t2._n = true;
              var n2 = t2._c;
              b(function() {
                for (var o2 = t2._v, r2 = 1 == t2._s, i2 = 0, a2 = function(e3) {
                  var n3, i3, a3, s2 = r2 ? e3.ok : e3.fail, l2 = e3.resolve, c2 = e3.reject, u2 = e3.domain;
                  try {
                    s2 ? (r2 || (2 == t2._h && P(t2), t2._h = 1), true === s2 ? n3 = o2 : (u2 && u2.enter(), n3 = s2(o2), u2 && (u2.exit(), a3 = true)), n3 === e3.promise ? c2(S("Promise-chain cycle")) : (i3 = R(n3)) ? i3.call(n3, l2, c2) : l2(n3)) : c2(o2);
                  } catch (t3) {
                    u2 && !a3 && u2.exit(), c2(t3);
                  }
                }; n2.length > i2; )
                  a2(n2[i2++]);
                t2._c = [], t2._n = false, e2 && !t2._h && N(t2);
              });
            }
          }, N = function(t2) {
            y.call(l, function() {
              var e2, n2, o2, r2 = t2._v, i2 = L(t2);
              if (i2 && (e2 = k(function() {
                _2 ? T.emit("unhandledRejection", r2, t2) : (n2 = l.onunhandledrejection) ? n2({ promise: t2, reason: r2 }) : (o2 = l.console) && o2.error && o2.error("Unhandled promise rejection", r2);
              }), t2._h = _2 || L(t2) ? 2 : 1), t2._a = void 0, i2 && e2.e)
                throw e2.v;
            });
          }, L = function(t2) {
            return 1 !== t2._h && 0 === (t2._a || t2._c).length;
          }, P = function(t2) {
            y.call(l, function() {
              var e2;
              _2 ? T.emit("rejectionHandled", t2) : (e2 = l.onrejectionhandled) && e2({ promise: t2, reason: t2._v });
            });
          }, D = function(t2) {
            var e2 = this;
            e2._d || (e2._d = true, (e2 = e2._w || e2)._v = t2, e2._s = 2, e2._a || (e2._a = e2._c.slice()), A(e2, true));
          }, j = function(t2) {
            var e2, n2 = this;
            if (!n2._d) {
              n2._d = true, n2 = n2._w || n2;
              try {
                if (n2 === t2)
                  throw S("Promise can't be resolved itself");
                (e2 = R(t2)) ? b(function() {
                  var o2 = { _w: n2, _d: false };
                  try {
                    e2.call(t2, c(j, o2, 1), c(D, o2, 1));
                  } catch (t3) {
                    D.call(o2, t3);
                  }
                }) : (n2._v = t2, n2._s = 1, A(n2, false));
              } catch (t3) {
                D.call({ _w: n2, _d: false }, t3);
              }
            }
          };
          M || (C = function(t2) {
            h(this, C, "Promise", "_h"), p(t2), o.call(this);
            try {
              t2(c(j, this, 1), c(D, this, 1));
            } catch (t3) {
              D.call(this, t3);
            }
          }, (o = function(t2) {
            this._c = [], this._a = void 0, this._s = 0, this._d = false, this._v = void 0, this._h = 0, this._n = false;
          }).prototype = n(58)(C.prototype, { then: function(t2, e2) {
            var n2 = O(g(this, C));
            return n2.ok = "function" != typeof t2 || t2, n2.fail = "function" == typeof e2 && e2, n2.domain = _2 ? T.domain : void 0, this._c.push(n2), this._a && this._a.push(n2), this._s && A(this, false), n2.promise;
          }, catch: function(t2) {
            return this.then(void 0, t2);
          } }), i = function() {
            var t2 = new o();
            this.promise = t2, this.resolve = c(j, t2, 1), this.reject = c(D, t2, 1);
          }, m.f = O = function(t2) {
            return t2 === C || t2 === a ? new i(t2) : r(t2);
          }), f(f.G + f.W + f.F * !M, { Promise: C }), n(53)(C, "Promise"), n(56)("Promise"), a = n(17).Promise, f(f.S + f.F * !M, "Promise", { reject: function(t2) {
            var e2 = O(this);
            return (0, e2.reject)(t2), e2.promise;
          } }), f(f.S + f.F * (s || !M), "Promise", { resolve: function(t2) {
            return w(s && this === a ? C : this, t2);
          } }), f(f.S + f.F * !(M && n(73)(function(t2) {
            C.all(t2).catch(I);
          })), "Promise", { all: function(t2) {
            var e2 = this, n2 = O(e2), o2 = n2.resolve, r2 = n2.reject, i2 = k(function() {
              var n3 = [], i3 = 0, a2 = 1;
              v(t2, false, function(t3) {
                var s2 = i3++, l2 = false;
                n3.push(void 0), a2++, e2.resolve(t3).then(function(t4) {
                  l2 || (l2 = true, n3[s2] = t4, --a2 || o2(n3));
                }, r2);
              }), --a2 || o2(n3);
            });
            return i2.e && r2(i2.v), n2.promise;
          }, race: function(t2) {
            var e2 = this, n2 = O(e2), o2 = n2.reject, r2 = k(function() {
              v(t2, false, function(t3) {
                e2.resolve(t3).then(n2.resolve, o2);
              });
            });
            return r2.e && o2(r2.v), n2.promise;
          } });
        }, function(t, e, n) {
          "use strict";
          var o = n(32);
          function r(t2) {
            var e2, n2;
            this.promise = new t2(function(t3, o2) {
              if (void 0 !== e2 || void 0 !== n2)
                throw TypeError("Bad Promise constructor");
              e2 = t3, n2 = o2;
            }), this.resolve = o(e2), this.reject = o(n2);
          }
          t.exports.f = function(t2) {
            return new r(t2);
          };
        }, function(t, e, n) {
          var o = n(12), r = n(13), i = n(139);
          t.exports = function(t2, e2) {
            if (o(t2), r(e2) && e2.constructor === t2)
              return e2;
            var n2 = i.f(t2);
            return (0, n2.resolve)(e2), n2.promise;
          };
        }, function(t, e, n) {
          "use strict";
          var o = n(19).f, r = n(48), i = n(58), a = n(31), s = n(57), l = n(77), c = n(97), u = n(135), f = n(56), d = n(18), p = n(41).fastKey, h = n(52), v = d ? "_s" : "size", g = function(t2, e2) {
            var n2, o2 = p(e2);
            if ("F" !== o2)
              return t2._i[o2];
            for (n2 = t2._f; n2; n2 = n2.n)
              if (n2.k == e2)
                return n2;
          };
          t.exports = { getConstructor: function(t2, e2, n2, c2) {
            var u2 = t2(function(t3, o2) {
              s(t3, u2, e2, "_i"), t3._t = e2, t3._i = r(null), t3._f = void 0, t3._l = void 0, t3[v] = 0, null != o2 && l(o2, n2, t3[c2], t3);
            });
            return i(u2.prototype, { clear: function() {
              for (var t3 = h(this, e2), n3 = t3._i, o2 = t3._f; o2; o2 = o2.n)
                o2.r = true, o2.p && (o2.p = o2.p.n = void 0), delete n3[o2.i];
              t3._f = t3._l = void 0, t3[v] = 0;
            }, delete: function(t3) {
              var n3 = h(this, e2), o2 = g(n3, t3);
              if (o2) {
                var r2 = o2.n, i2 = o2.p;
                delete n3._i[o2.i], o2.r = true, i2 && (i2.n = r2), r2 && (r2.p = i2), n3._f == o2 && (n3._f = r2), n3._l == o2 && (n3._l = i2), n3[v]--;
              }
              return !!o2;
            }, forEach: function(t3) {
              h(this, e2);
              for (var n3, o2 = a(t3, arguments.length > 1 ? arguments[1] : void 0, 3); n3 = n3 ? n3.n : this._f; )
                for (o2(n3.v, n3.k, this); n3 && n3.r; )
                  n3 = n3.p;
            }, has: function(t3) {
              return !!g(h(this, e2), t3);
            } }), d && o(u2.prototype, "size", { get: function() {
              return h(this, e2)[v];
            } }), u2;
          }, def: function(t2, e2, n2) {
            var o2, r2, i2 = g(t2, e2);
            return i2 ? i2.v = n2 : (t2._l = i2 = { i: r2 = p(e2, true), k: e2, v: n2, p: o2 = t2._l, n: void 0, r: false }, t2._f || (t2._f = i2), o2 && (o2.n = i2), t2[v]++, "F" !== r2 && (t2._i[r2] = i2)), t2;
          }, getEntry: g, setStrong: function(t2, e2, n2) {
            c(t2, e2, function(t3, n3) {
              this._t = h(t3, e2), this._k = n3, this._l = void 0;
            }, function() {
              for (var t3 = this._k, e3 = this._l; e3 && e3.r; )
                e3 = e3.p;
              return this._t && (this._l = e3 = e3 ? e3.n : this._t._f) ? u(0, "keys" == t3 ? e3.k : "values" == t3 ? e3.v : [e3.k, e3.v]) : (this._t = void 0, u(1));
            }, n2 ? "entries" : "values", !n2, true), f(e2);
          } };
        }, function(t, e, n) {
          "use strict";
          var o = n(58), r = n(41).getWeak, i = n(12), a = n(13), s = n(57), l = n(77), c = n(36), u = n(26), f = n(52), d = c(5), p = c(6), h = 0, v = function(t2) {
            return t2._l || (t2._l = new g());
          }, g = function() {
            this.a = [];
          }, y = function(t2, e2) {
            return d(t2.a, function(t3) {
              return t3[0] === e2;
            });
          };
          g.prototype = { get: function(t2) {
            var e2 = y(this, t2);
            if (e2)
              return e2[1];
          }, has: function(t2) {
            return !!y(this, t2);
          }, set: function(t2, e2) {
            var n2 = y(this, t2);
            n2 ? n2[1] = e2 : this.a.push([t2, e2]);
          }, delete: function(t2) {
            var e2 = p(this.a, function(e3) {
              return e3[0] === t2;
            });
            return ~e2 && this.a.splice(e2, 1), !!~e2;
          } }, t.exports = { getConstructor: function(t2, e2, n2, i2) {
            var c2 = t2(function(t3, o2) {
              s(t3, c2, e2, "_i"), t3._t = e2, t3._i = h++, t3._l = void 0, null != o2 && l(o2, n2, t3[i2], t3);
            });
            return o(c2.prototype, { delete: function(t3) {
              if (!a(t3))
                return false;
              var n3 = r(t3);
              return true === n3 ? v(f(this, e2)).delete(t3) : n3 && u(n3, this._i) && delete n3[this._i];
            }, has: function(t3) {
              if (!a(t3))
                return false;
              var n3 = r(t3);
              return true === n3 ? v(f(this, e2)).has(t3) : n3 && u(n3, this._i);
            } }), c2;
          }, def: function(t2, e2, n2) {
            var o2 = r(i(e2), true);
            return true === o2 ? v(t2).set(e2, n2) : o2[t2._i] = n2, t2;
          }, ufstore: v };
        }, function(t, e, n) {
          var o = n(33), r = n(16);
          t.exports = function(t2) {
            if (void 0 === t2)
              return 0;
            var e2 = o(t2), n2 = r(e2);
            if (e2 !== n2)
              throw RangeError("Wrong length!");
            return n2;
          };
        }, function(t, e, n) {
          var o = n(49), r = n(71), i = n(12), a = n(10).Reflect;
          t.exports = a && a.ownKeys || function(t2) {
            var e2 = o.f(i(t2)), n2 = r.f;
            return n2 ? e2.concat(n2(t2)) : e2;
          };
        }, function(t, e, n) {
          var o = n(16), r = n(93), i = n(38);
          t.exports = function(t2, e2, n2, a) {
            var s = String(i(t2)), l = s.length, c = void 0 === n2 ? " " : String(n2), u = o(e2);
            if (u <= l || "" == c)
              return s;
            var f = u - l, d = r.call(c, Math.ceil(f / c.length));
            return d.length > f && (d = d.slice(0, f)), a ? d + s : s + d;
          };
        }, function(t, e, n) {
          var o = n(18), r = n(46), i = n(28), a = n(64).f;
          t.exports = function(t2) {
            return function(e2) {
              for (var n2, s = i(e2), l = r(s), c = l.length, u = 0, f = []; c > u; )
                n2 = l[u++], o && !a.call(s, n2) || f.push(t2 ? [n2, s[n2]] : s[n2]);
              return f;
            };
          };
        }, function(t, e, n) {
          var o = function(t2) {
            "use strict";
            var e2 = Object.prototype, n2 = e2.hasOwnProperty, o2 = "function" == typeof Symbol ? Symbol : {}, r = o2.iterator || "@@iterator", i = o2.asyncIterator || "@@asyncIterator", a = o2.toStringTag || "@@toStringTag";
            function s(t3, e3, n3, o3) {
              var r2 = e3 && e3.prototype instanceof u ? e3 : u, i2 = Object.create(r2.prototype), a2 = new w(o3 || []);
              return i2._invoke = /* @__PURE__ */ function(t4, e4, n4) {
                var o4 = "suspendedStart";
                return function(r3, i3) {
                  if ("executing" === o4)
                    throw new Error("Generator is already running");
                  if ("completed" === o4) {
                    if ("throw" === r3)
                      throw i3;
                    return T();
                  }
                  for (n4.method = r3, n4.arg = i3; ; ) {
                    var a3 = n4.delegate;
                    if (a3) {
                      var s2 = m(a3, n4);
                      if (s2) {
                        if (s2 === c)
                          continue;
                        return s2;
                      }
                    }
                    if ("next" === n4.method)
                      n4.sent = n4._sent = n4.arg;
                    else if ("throw" === n4.method) {
                      if ("suspendedStart" === o4)
                        throw o4 = "completed", n4.arg;
                      n4.dispatchException(n4.arg);
                    } else
                      "return" === n4.method && n4.abrupt("return", n4.arg);
                    o4 = "executing";
                    var u2 = l(t4, e4, n4);
                    if ("normal" === u2.type) {
                      if (o4 = n4.done ? "completed" : "suspendedYield", u2.arg === c)
                        continue;
                      return { value: u2.arg, done: n4.done };
                    }
                    "throw" === u2.type && (o4 = "completed", n4.method = "throw", n4.arg = u2.arg);
                  }
                };
              }(t3, n3, a2), i2;
            }
            function l(t3, e3, n3) {
              try {
                return { type: "normal", arg: t3.call(e3, n3) };
              } catch (t4) {
                return { type: "throw", arg: t4 };
              }
            }
            t2.wrap = s;
            var c = {};
            function u() {
            }
            function f() {
            }
            function d() {
            }
            var p = {};
            p[r] = function() {
              return this;
            };
            var h = Object.getPrototypeOf, v = h && h(h(S([])));
            v && v !== e2 && n2.call(v, r) && (p = v);
            var g = d.prototype = u.prototype = Object.create(p);
            function y(t3) {
              ["next", "throw", "return"].forEach(function(e3) {
                t3[e3] = function(t4) {
                  return this._invoke(e3, t4);
                };
              });
            }
            function b(t3, e3) {
              var o3;
              this._invoke = function(r2, i2) {
                function a2() {
                  return new e3(function(o4, a3) {
                    !function o5(r3, i3, a4, s2) {
                      var c2 = l(t3[r3], t3, i3);
                      if ("throw" !== c2.type) {
                        var u2 = c2.arg, f2 = u2.value;
                        return f2 && "object" == typeof f2 && n2.call(f2, "__await") ? e3.resolve(f2.__await).then(function(t4) {
                          o5("next", t4, a4, s2);
                        }, function(t4) {
                          o5("throw", t4, a4, s2);
                        }) : e3.resolve(f2).then(function(t4) {
                          u2.value = t4, a4(u2);
                        }, function(t4) {
                          return o5("throw", t4, a4, s2);
                        });
                      }
                      s2(c2.arg);
                    }(r2, i2, o4, a3);
                  });
                }
                return o3 = o3 ? o3.then(a2, a2) : a2();
              };
            }
            function m(t3, e3) {
              var n3 = t3.iterator[e3.method];
              if (void 0 === n3) {
                if (e3.delegate = null, "throw" === e3.method) {
                  if (t3.iterator.return && (e3.method = "return", e3.arg = void 0, m(t3, e3), "throw" === e3.method))
                    return c;
                  e3.method = "throw", e3.arg = new TypeError("The iterator does not provide a 'throw' method");
                }
                return c;
              }
              var o3 = l(n3, t3.iterator, e3.arg);
              if ("throw" === o3.type)
                return e3.method = "throw", e3.arg = o3.arg, e3.delegate = null, c;
              var r2 = o3.arg;
              return r2 ? r2.done ? (e3[t3.resultName] = r2.value, e3.next = t3.nextLoc, "return" !== e3.method && (e3.method = "next", e3.arg = void 0), e3.delegate = null, c) : r2 : (e3.method = "throw", e3.arg = new TypeError("iterator result is not an object"), e3.delegate = null, c);
            }
            function k(t3) {
              var e3 = { tryLoc: t3[0] };
              1 in t3 && (e3.catchLoc = t3[1]), 2 in t3 && (e3.finallyLoc = t3[2], e3.afterLoc = t3[3]), this.tryEntries.push(e3);
            }
            function x(t3) {
              var e3 = t3.completion || {};
              e3.type = "normal", delete e3.arg, t3.completion = e3;
            }
            function w(t3) {
              this.tryEntries = [{ tryLoc: "root" }], t3.forEach(k, this), this.reset(true);
            }
            function S(t3) {
              if (t3) {
                var e3 = t3[r];
                if (e3)
                  return e3.call(t3);
                if ("function" == typeof t3.next)
                  return t3;
                if (!isNaN(t3.length)) {
                  var o3 = -1, i2 = function e4() {
                    for (; ++o3 < t3.length; )
                      if (n2.call(t3, o3))
                        return e4.value = t3[o3], e4.done = false, e4;
                    return e4.value = void 0, e4.done = true, e4;
                  };
                  return i2.next = i2;
                }
              }
              return { next: T };
            }
            function T() {
              return { value: void 0, done: true };
            }
            return f.prototype = g.constructor = d, d.constructor = f, d[a] = f.displayName = "GeneratorFunction", t2.isGeneratorFunction = function(t3) {
              var e3 = "function" == typeof t3 && t3.constructor;
              return !!e3 && (e3 === f || "GeneratorFunction" === (e3.displayName || e3.name));
            }, t2.mark = function(t3) {
              return Object.setPrototypeOf ? Object.setPrototypeOf(t3, d) : (t3.__proto__ = d, a in t3 || (t3[a] = "GeneratorFunction")), t3.prototype = Object.create(g), t3;
            }, t2.awrap = function(t3) {
              return { __await: t3 };
            }, y(b.prototype), b.prototype[i] = function() {
              return this;
            }, t2.AsyncIterator = b, t2.async = function(e3, n3, o3, r2, i2) {
              void 0 === i2 && (i2 = Promise);
              var a2 = new b(s(e3, n3, o3, r2), i2);
              return t2.isGeneratorFunction(n3) ? a2 : a2.next().then(function(t3) {
                return t3.done ? t3.value : a2.next();
              });
            }, y(g), g[a] = "Generator", g[r] = function() {
              return this;
            }, g.toString = function() {
              return "[object Generator]";
            }, t2.keys = function(t3) {
              var e3 = [];
              for (var n3 in t3)
                e3.push(n3);
              return e3.reverse(), function n4() {
                for (; e3.length; ) {
                  var o3 = e3.pop();
                  if (o3 in t3)
                    return n4.value = o3, n4.done = false, n4;
                }
                return n4.done = true, n4;
              };
            }, t2.values = S, w.prototype = { constructor: w, reset: function(t3) {
              if (this.prev = 0, this.next = 0, this.sent = this._sent = void 0, this.done = false, this.delegate = null, this.method = "next", this.arg = void 0, this.tryEntries.forEach(x), !t3)
                for (var e3 in this)
                  "t" === e3.charAt(0) && n2.call(this, e3) && !isNaN(+e3.slice(1)) && (this[e3] = void 0);
            }, stop: function() {
              this.done = true;
              var t3 = this.tryEntries[0].completion;
              if ("throw" === t3.type)
                throw t3.arg;
              return this.rval;
            }, dispatchException: function(t3) {
              if (this.done)
                throw t3;
              var e3 = this;
              function o3(n3, o4) {
                return a2.type = "throw", a2.arg = t3, e3.next = n3, o4 && (e3.method = "next", e3.arg = void 0), !!o4;
              }
              for (var r2 = this.tryEntries.length - 1; r2 >= 0; --r2) {
                var i2 = this.tryEntries[r2], a2 = i2.completion;
                if ("root" === i2.tryLoc)
                  return o3("end");
                if (i2.tryLoc <= this.prev) {
                  var s2 = n2.call(i2, "catchLoc"), l2 = n2.call(i2, "finallyLoc");
                  if (s2 && l2) {
                    if (this.prev < i2.catchLoc)
                      return o3(i2.catchLoc, true);
                    if (this.prev < i2.finallyLoc)
                      return o3(i2.finallyLoc);
                  } else if (s2) {
                    if (this.prev < i2.catchLoc)
                      return o3(i2.catchLoc, true);
                  } else {
                    if (!l2)
                      throw new Error("try statement without catch or finally");
                    if (this.prev < i2.finallyLoc)
                      return o3(i2.finallyLoc);
                  }
                }
              }
            }, abrupt: function(t3, e3) {
              for (var o3 = this.tryEntries.length - 1; o3 >= 0; --o3) {
                var r2 = this.tryEntries[o3];
                if (r2.tryLoc <= this.prev && n2.call(r2, "finallyLoc") && this.prev < r2.finallyLoc) {
                  var i2 = r2;
                  break;
                }
              }
              i2 && ("break" === t3 || "continue" === t3) && i2.tryLoc <= e3 && e3 <= i2.finallyLoc && (i2 = null);
              var a2 = i2 ? i2.completion : {};
              return a2.type = t3, a2.arg = e3, i2 ? (this.method = "next", this.next = i2.finallyLoc, c) : this.complete(a2);
            }, complete: function(t3, e3) {
              if ("throw" === t3.type)
                throw t3.arg;
              return "break" === t3.type || "continue" === t3.type ? this.next = t3.arg : "return" === t3.type ? (this.rval = this.arg = t3.arg, this.method = "return", this.next = "end") : "normal" === t3.type && e3 && (this.next = e3), c;
            }, finish: function(t3) {
              for (var e3 = this.tryEntries.length - 1; e3 >= 0; --e3) {
                var n3 = this.tryEntries[e3];
                if (n3.finallyLoc === t3)
                  return this.complete(n3.completion, n3.afterLoc), x(n3), c;
              }
            }, catch: function(t3) {
              for (var e3 = this.tryEntries.length - 1; e3 >= 0; --e3) {
                var n3 = this.tryEntries[e3];
                if (n3.tryLoc === t3) {
                  var o3 = n3.completion;
                  if ("throw" === o3.type) {
                    var r2 = o3.arg;
                    x(n3);
                  }
                  return r2;
                }
              }
              throw new Error("illegal catch attempt");
            }, delegateYield: function(t3, e3, n3) {
              return this.delegate = { iterator: S(t3), resultName: e3, nextLoc: n3 }, "next" === this.method && (this.arg = void 0), c;
            } }, t2;
          }(t.exports);
          try {
            regeneratorRuntime = o;
          } catch (t2) {
            Function("r", "regeneratorRuntime = r")(o);
          }
        }, function(t, e, n) {
          var o = n(149);
          t.exports = function(t2, e2) {
            if (t2) {
              if ("string" == typeof t2)
                return o(t2, e2);
              var n2 = Object.prototype.toString.call(t2).slice(8, -1);
              return "Object" === n2 && t2.constructor && (n2 = t2.constructor.name), "Map" === n2 || "Set" === n2 ? Array.from(n2) : "Arguments" === n2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2) ? o(t2, e2) : void 0;
            }
          };
        }, function(t, e) {
          t.exports = function(t2, e2) {
            (null == e2 || e2 > t2.length) && (e2 = t2.length);
            for (var n = 0, o = new Array(e2); n < e2; n++)
              o[n] = t2[n];
            return o;
          };
        }, function(t) {
          t.exports = JSON.parse('{"ui":{"blockTunes":{"toggler":{"Click to tune":"","or drag to move":""}},"inlineToolbar":{"converter":{"Convert to":""}},"toolbar":{"toolbox":{"Add":"","Filter":"","Nothing found":""}}},"toolNames":{"Text":"","Link":"","Bold":"","Italic":""},"tools":{"link":{"Add a link":""},"stub":{"The block can not be displayed correctly.":""}},"blockTunes":{"delete":{"Delete":""},"moveUp":{"Move up":""},"moveDown":{"Move down":""}}}');
        }, function(t, e, n) {
          var o, r, i;
          "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self && self, r = [e, n(2), n(5), n(6), n(4), n(153)], void 0 === (i = "function" == typeof (o = function(t2, e2, o2, r2, i2, a) {
            "use strict";
            var s = n(1);
            function l() {
              if ("undefined" == typeof Reflect || !Reflect.construct)
                return false;
              if (Reflect.construct.sham)
                return false;
              if ("function" == typeof Proxy)
                return true;
              try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
                })), true;
              } catch (t3) {
                return false;
              }
            }
            Object.defineProperty(t2, "__esModule", { value: true }), t2.CriticalError = void 0, e2 = s(e2), o2 = s(o2), r2 = s(r2), i2 = s(i2);
            var c = function(t3) {
              (0, o2.default)(s2, t3);
              var n2, a2 = (n2 = s2, function() {
                var t4, e3 = (0, i2.default)(n2);
                if (l()) {
                  var o3 = (0, i2.default)(this).constructor;
                  t4 = Reflect.construct(e3, arguments, o3);
                } else
                  t4 = e3.apply(this, arguments);
                return (0, r2.default)(this, t4);
              });
              function s2() {
                return (0, e2.default)(this, s2), a2.apply(this, arguments);
              }
              return s2;
            }((0, (a = s(a)).default)(Error));
            t2.CriticalError = c, c.displayName = "CriticalError";
          }) ? o.apply(e, r) : o) || (t.exports = i);
        }, function(t, e) {
          t.exports = function(t2) {
            if (void 0 === t2)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return t2;
          };
        }, function(t, e, n) {
          var o = n(4), r = n(110), i = n(372), a = n(373);
          function s(e2) {
            var n2 = "function" == typeof Map ? /* @__PURE__ */ new Map() : void 0;
            return t.exports = s = function(t2) {
              if (null === t2 || !i(t2))
                return t2;
              if ("function" != typeof t2)
                throw new TypeError("Super expression must either be null or a function");
              if (void 0 !== n2) {
                if (n2.has(t2))
                  return n2.get(t2);
                n2.set(t2, e3);
              }
              function e3() {
                return a(t2, arguments, o(this).constructor);
              }
              return e3.prototype = Object.create(t2.prototype, { constructor: { value: e3, enumerable: false, writable: true, configurable: true } }), r(e3, t2);
            }, s(e2);
          }
          t.exports = s;
        }, function(t, e, n) {
          var o, r, i;
          "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self && self, r = [e, n(20), n(21), n(2), n(3), n(5), n(6), n(4), n(7), n(112), n(9), n(61)], void 0 === (i = "function" == typeof (o = function(o2, r2, i2, a, s, l, c, u, f, d, p, h) {
            "use strict";
            var v = n(8), g = n(1);
            function y() {
              if ("undefined" == typeof Reflect || !Reflect.construct)
                return false;
              if (Reflect.construct.sham)
                return false;
              if ("function" == typeof Proxy)
                return true;
              try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
                })), true;
              } catch (t2) {
                return false;
              }
            }
            Object.defineProperty(o2, "__esModule", { value: true }), o2.default = void 0, r2 = g(r2), i2 = g(i2), a = g(a), s = g(s), l = g(l), c = g(c), u = g(u), f = v(f), d = g(d), p = g(p), h = g(h);
            var b = function(t2) {
              (0, l.default)(o3, t2);
              var e2, n2 = (e2 = o3, function() {
                var t3, n3 = (0, u.default)(e2);
                if (y()) {
                  var o4 = (0, u.default)(this).constructor;
                  t3 = Reflect.construct(n3, arguments, o4);
                } else
                  t3 = n3.apply(this, arguments);
                return (0, c.default)(this, t3);
              });
              function o3() {
                var t3;
                return (0, a.default)(this, o3), (t3 = n2.apply(this, arguments)).insert = function() {
                  var e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : t3.config.defaultBlock, n3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, o4 = (arguments.length > 2 && void 0 !== arguments[2] && arguments[2], arguments.length > 3 ? arguments[3] : void 0), r3 = arguments.length > 4 ? arguments[4] : void 0, i3 = arguments.length > 5 ? arguments[5] : void 0, a2 = t3.Editor.BlockManager.insert({ tool: e3, data: n3, index: o4, needToFocus: r3, replace: i3 });
                  return new d.default(a2);
                }, t3.composeBlockData = function() {
                  var e3 = (0, i2.default)(r2.default.mark(function e4(n3) {
                    var o4, i3;
                    return r2.default.wrap(function(e5) {
                      for (; ; )
                        switch (e5.prev = e5.next) {
                          case 0:
                            return o4 = t3.Editor.Tools.blockTools.get(n3), i3 = new h.default({ tool: o4, api: t3.Editor.API, readOnly: true, data: {}, tunesData: {} }), e5.abrupt("return", i3.data);
                          case 3:
                          case "end":
                            return e5.stop();
                        }
                    }, e4);
                  }));
                  return function(t4) {
                    return e3.apply(this, arguments);
                  };
                }(), t3.update = function(e3, n3) {
                  var o4 = t3.Editor.BlockManager, r3 = o4.getBlockById(e3);
                  if (r3) {
                    var i3 = o4.getBlockIndex(r3);
                    o4.insert({ id: r3.id, tool: r3.name, data: n3, index: i3, replace: true, tunes: r3.tunes });
                  } else
                    f.log("blocks.update(): Block with passed id was not found", "warn");
                }, t3;
              }
              return (0, s.default)(o3, [{ key: "getBlocksCount", value: function() {
                return this.Editor.BlockManager.blocks.length;
              } }, { key: "getCurrentBlockIndex", value: function() {
                return this.Editor.BlockManager.currentBlockIndex;
              } }, { key: "getBlockIndex", value: function(t3) {
                var e3 = this.Editor.BlockManager.getBlockById(t3);
                if (e3)
                  return this.Editor.BlockManager.getBlockIndex(e3);
                f.logLabeled("There is no block with id `" + t3 + "`", "warn");
              } }, { key: "getBlockByIndex", value: function(t3) {
                var e3 = this.Editor.BlockManager.getBlockByIndex(t3);
                if (void 0 !== e3)
                  return new d.default(e3);
                f.logLabeled("There is no block at index `" + t3 + "`", "warn");
              } }, { key: "getById", value: function(t3) {
                var e3 = this.Editor.BlockManager.getBlockById(t3);
                return void 0 === e3 ? (f.logLabeled("There is no block with id `" + t3 + "`", "warn"), null) : new d.default(e3);
              } }, { key: "swap", value: function(t3, e3) {
                f.log("`blocks.swap()` method is deprecated and will be removed in the next major release. Use `block.move()` method instead", "info"), this.Editor.BlockManager.swap(t3, e3);
              } }, { key: "move", value: function(t3, e3) {
                this.Editor.BlockManager.move(t3, e3);
              } }, { key: "delete", value: function(t3) {
                try {
                  this.Editor.BlockManager.removeBlock(t3);
                } catch (t4) {
                  return void f.logLabeled(t4, "warn");
                }
                0 === this.Editor.BlockManager.blocks.length && this.Editor.BlockManager.insert(), this.Editor.BlockManager.currentBlock && this.Editor.Caret.setToBlock(this.Editor.BlockManager.currentBlock, this.Editor.Caret.positions.END), this.Editor.Toolbar.close();
              } }, { key: "clear", value: function() {
                this.Editor.BlockManager.clear(true), this.Editor.InlineToolbar.close();
              } }, { key: "render", value: function(t3) {
                return this.Editor.BlockManager.clear(), this.Editor.Renderer.render(t3.blocks);
              } }, { key: "renderFromHTML", value: function(t3) {
                return this.Editor.BlockManager.clear(), this.Editor.Paste.processText(t3, true);
              } }, { key: "stretchBlock", value: function(t3) {
                var e3 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
                f.deprecationAssert(true, "blocks.stretchBlock()", "BlockAPI");
                var n3 = this.Editor.BlockManager.getBlockByIndex(t3);
                n3 && (n3.stretched = e3);
              } }, { key: "insertNewBlock", value: function() {
                f.log("Method blocks.insertNewBlock() is deprecated and it will be removed in the next major release. Use blocks.insert() instead.", "warn"), this.insert();
              } }, { key: "methods", get: function() {
                var t3 = this;
                return { clear: function() {
                  return t3.clear();
                }, render: function(e3) {
                  return t3.render(e3);
                }, renderFromHTML: function(e3) {
                  return t3.renderFromHTML(e3);
                }, delete: function(e3) {
                  return t3.delete(e3);
                }, swap: function(e3, n3) {
                  return t3.swap(e3, n3);
                }, move: function(e3, n3) {
                  return t3.move(e3, n3);
                }, getBlockByIndex: function(e3) {
                  return t3.getBlockByIndex(e3);
                }, getById: function(e3) {
                  return t3.getById(e3);
                }, getCurrentBlockIndex: function() {
                  return t3.getCurrentBlockIndex();
                }, getBlockIndex: function(e3) {
                  return t3.getBlockIndex(e3);
                }, getBlocksCount: function() {
                  return t3.getBlocksCount();
                }, stretchBlock: function(e3) {
                  var n3 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
                  return t3.stretchBlock(e3, n3);
                }, insertNewBlock: function() {
                  return t3.insertNewBlock();
                }, insert: this.insert, update: this.update, composeBlockData: this.composeBlockData };
              } }]), o3;
            }(p.default);
            o2.default = b, b.displayName = "BlocksAPI", t.exports = e.default;
          }) ? o.apply(e, r) : o) || (t.exports = i);
        }, function(t, e, n) {
          var o, r, i;
          "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self && self, r = [e, n(2), n(3), n(5), n(6), n(4), n(9)], void 0 === (i = "function" == typeof (o = function(o2, r2, i2, a, s, l, c) {
            "use strict";
            var u = n(1);
            function f() {
              if ("undefined" == typeof Reflect || !Reflect.construct)
                return false;
              if (Reflect.construct.sham)
                return false;
              if ("function" == typeof Proxy)
                return true;
              try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
                })), true;
              } catch (t2) {
                return false;
              }
            }
            Object.defineProperty(o2, "__esModule", { value: true }), o2.default = void 0, r2 = u(r2), i2 = u(i2), a = u(a), s = u(s), l = u(l);
            var d = function(t2) {
              (0, a.default)(o3, t2);
              var e2, n2 = (e2 = o3, function() {
                var t3, n3 = (0, l.default)(e2);
                if (f()) {
                  var o4 = (0, l.default)(this).constructor;
                  t3 = Reflect.construct(n3, arguments, o4);
                } else
                  t3 = n3.apply(this, arguments);
                return (0, s.default)(this, t3);
              });
              function o3() {
                var t3;
                return (0, r2.default)(this, o3), (t3 = n2.apply(this, arguments)).setToFirstBlock = function() {
                  var e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : t3.Editor.Caret.positions.DEFAULT, n3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                  return !!t3.Editor.BlockManager.firstBlock && (t3.Editor.Caret.setToBlock(t3.Editor.BlockManager.firstBlock, e3, n3), true);
                }, t3.setToLastBlock = function() {
                  var e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : t3.Editor.Caret.positions.DEFAULT, n3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                  return !!t3.Editor.BlockManager.lastBlock && (t3.Editor.Caret.setToBlock(t3.Editor.BlockManager.lastBlock, e3, n3), true);
                }, t3.setToPreviousBlock = function() {
                  var e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : t3.Editor.Caret.positions.DEFAULT, n3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                  return !!t3.Editor.BlockManager.previousBlock && (t3.Editor.Caret.setToBlock(t3.Editor.BlockManager.previousBlock, e3, n3), true);
                }, t3.setToNextBlock = function() {
                  var e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : t3.Editor.Caret.positions.DEFAULT, n3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                  return !!t3.Editor.BlockManager.nextBlock && (t3.Editor.Caret.setToBlock(t3.Editor.BlockManager.nextBlock, e3, n3), true);
                }, t3.setToBlock = function(e3) {
                  var n3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : t3.Editor.Caret.positions.DEFAULT, o4 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
                  return !!t3.Editor.BlockManager.blocks[e3] && (t3.Editor.Caret.setToBlock(t3.Editor.BlockManager.blocks[e3], n3, o4), true);
                }, t3.focus = function() {
                  var e3 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
                  return e3 ? t3.setToLastBlock(t3.Editor.Caret.positions.END) : t3.setToFirstBlock(t3.Editor.Caret.positions.START);
                }, t3;
              }
              return (0, i2.default)(o3, [{ key: "methods", get: function() {
                return { setToFirstBlock: this.setToFirstBlock, setToLastBlock: this.setToLastBlock, setToPreviousBlock: this.setToPreviousBlock, setToNextBlock: this.setToNextBlock, setToBlock: this.setToBlock, focus: this.focus };
              } }]), o3;
            }((c = u(c)).default);
            o2.default = d, d.displayName = "CaretAPI", t.exports = e.default;
          }) ? o.apply(e, r) : o) || (t.exports = i);
        }, function(t, e, n) {
          var o, r, i;
          "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self && self, r = [e, n(2), n(3), n(5), n(6), n(4), n(9)], void 0 === (i = "function" == typeof (o = function(o2, r2, i2, a, s, l, c) {
            "use strict";
            var u = n(1);
            function f() {
              if ("undefined" == typeof Reflect || !Reflect.construct)
                return false;
              if (Reflect.construct.sham)
                return false;
              if ("function" == typeof Proxy)
                return true;
              try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
                })), true;
              } catch (t2) {
                return false;
              }
            }
            Object.defineProperty(o2, "__esModule", { value: true }), o2.default = void 0, r2 = u(r2), i2 = u(i2), a = u(a), s = u(s), l = u(l);
            var d = function(t2) {
              (0, a.default)(o3, t2);
              var e2, n2 = (e2 = o3, function() {
                var t3, n3 = (0, l.default)(e2);
                if (f()) {
                  var o4 = (0, l.default)(this).constructor;
                  t3 = Reflect.construct(n3, arguments, o4);
                } else
                  t3 = n3.apply(this, arguments);
                return (0, s.default)(this, t3);
              });
              function o3() {
                return (0, r2.default)(this, o3), n2.apply(this, arguments);
              }
              return (0, i2.default)(o3, [{ key: "on", value: function(t3, e3) {
                this.eventsDispatcher.on(t3, e3);
              } }, { key: "emit", value: function(t3, e3) {
                this.eventsDispatcher.emit(t3, e3);
              } }, { key: "off", value: function(t3, e3) {
                this.eventsDispatcher.off(t3, e3);
              } }, { key: "methods", get: function() {
                var t3 = this;
                return { emit: function(e3, n3) {
                  return t3.emit(e3, n3);
                }, off: function(e3, n3) {
                  return t3.off(e3, n3);
                }, on: function(e3, n3) {
                  return t3.on(e3, n3);
                } };
              } }]), o3;
            }((c = u(c)).default);
            o2.default = d, d.displayName = "EventsAPI", t.exports = e.default;
          }) ? o.apply(e, r) : o) || (t.exports = i);
        }, function(t, e, n) {
          var o, r, i;
          "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self && self, r = [e, n(2), n(3), n(5), n(6), n(4), n(60), n(7), n(9)], void 0 === (i = "function" == typeof (o = function(o2, r2, i2, a, s, l, c, u, f) {
            "use strict";
            var d = n(1);
            function p() {
              if ("undefined" == typeof Reflect || !Reflect.construct)
                return false;
              if (Reflect.construct.sham)
                return false;
              if ("function" == typeof Proxy)
                return true;
              try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
                })), true;
              } catch (t2) {
                return false;
              }
            }
            Object.defineProperty(o2, "__esModule", { value: true }), o2.default = void 0, r2 = d(r2), i2 = d(i2), a = d(a), s = d(s), l = d(l), c = d(c);
            var h = function(t2) {
              (0, a.default)(o3, t2);
              var e2, n2 = (e2 = o3, function() {
                var t3, n3 = (0, l.default)(e2);
                if (p()) {
                  var o4 = (0, l.default)(this).constructor;
                  t3 = Reflect.construct(n3, arguments, o4);
                } else
                  t3 = n3.apply(this, arguments);
                return (0, s.default)(this, t3);
              });
              function o3() {
                return (0, r2.default)(this, o3), n2.apply(this, arguments);
              }
              return (0, i2.default)(o3, [{ key: "getMethodsForTool", value: function(t3) {
                return Object.assign(this.methods, { t: function(e3) {
                  return c.default.t(o3.getNamespace(t3), e3);
                } });
              } }, { key: "methods", get: function() {
                return { t: function() {
                  (0, u.logLabeled)("I18n.t() method can be accessed only from Tools", "warn");
                } };
              } }], [{ key: "getNamespace", value: function(t3) {
                return t3.isTune() ? "blockTunes.".concat(t3.name) : "tools.".concat(t3.name);
              } }]), o3;
            }((f = d(f)).default);
            o2.default = h, h.displayName = "I18nAPI", t.exports = e.default;
          }) ? o.apply(e, r) : o) || (t.exports = i);
        }, function(t, e, n) {
          var o, r, i;
          "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self && self, r = [e, n(2), n(3), n(5), n(6), n(4), n(9)], void 0 === (i = "function" == typeof (o = function(o2, r2, i2, a, s, l, c) {
            "use strict";
            var u = n(1);
            function f() {
              if ("undefined" == typeof Reflect || !Reflect.construct)
                return false;
              if (Reflect.construct.sham)
                return false;
              if ("function" == typeof Proxy)
                return true;
              try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
                })), true;
              } catch (t2) {
                return false;
              }
            }
            Object.defineProperty(o2, "__esModule", { value: true }), o2.default = void 0, r2 = u(r2), i2 = u(i2), a = u(a), s = u(s), l = u(l);
            var d = function(t2) {
              (0, a.default)(o3, t2);
              var e2, n2 = (e2 = o3, function() {
                var t3, n3 = (0, l.default)(e2);
                if (f()) {
                  var o4 = (0, l.default)(this).constructor;
                  t3 = Reflect.construct(n3, arguments, o4);
                } else
                  t3 = n3.apply(this, arguments);
                return (0, s.default)(this, t3);
              });
              function o3() {
                return (0, r2.default)(this, o3), n2.apply(this, arguments);
              }
              return (0, i2.default)(o3, [{ key: "open", value: function() {
                this.Editor.InlineToolbar.tryToShow();
              } }, { key: "close", value: function() {
                this.Editor.InlineToolbar.close();
              } }, { key: "methods", get: function() {
                var t3 = this;
                return { close: function() {
                  return t3.close();
                }, open: function() {
                  return t3.open();
                } };
              } }]), o3;
            }((c = u(c)).default);
            o2.default = d, d.displayName = "InlineToolbarAPI", t.exports = e.default;
          }) ? o.apply(e, r) : o) || (t.exports = i);
        }, function(t, e, n) {
          var o, r, i;
          "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self && self, r = [e, n(2), n(3), n(5), n(6), n(4), n(9)], void 0 === (i = "function" == typeof (o = function(o2, r2, i2, a, s, l, c) {
            "use strict";
            var u = n(1);
            function f() {
              if ("undefined" == typeof Reflect || !Reflect.construct)
                return false;
              if (Reflect.construct.sham)
                return false;
              if ("function" == typeof Proxy)
                return true;
              try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
                })), true;
              } catch (t2) {
                return false;
              }
            }
            Object.defineProperty(o2, "__esModule", { value: true }), o2.default = void 0, r2 = u(r2), i2 = u(i2), a = u(a), s = u(s), l = u(l);
            var d = function(t2) {
              (0, a.default)(o3, t2);
              var e2, n2 = (e2 = o3, function() {
                var t3, n3 = (0, l.default)(e2);
                if (f()) {
                  var o4 = (0, l.default)(this).constructor;
                  t3 = Reflect.construct(n3, arguments, o4);
                } else
                  t3 = n3.apply(this, arguments);
                return (0, s.default)(this, t3);
              });
              function o3() {
                return (0, r2.default)(this, o3), n2.apply(this, arguments);
              }
              return (0, i2.default)(o3, [{ key: "on", value: function(t3, e3, n3, o4) {
                return this.listeners.on(t3, e3, n3, o4);
              } }, { key: "off", value: function(t3, e3, n3, o4) {
                this.listeners.off(t3, e3, n3, o4);
              } }, { key: "offById", value: function(t3) {
                this.listeners.offById(t3);
              } }, { key: "methods", get: function() {
                var t3 = this;
                return { on: function(e3, n3, o4, r3) {
                  return t3.on(e3, n3, o4, r3);
                }, off: function(e3, n3, o4, r3) {
                  return t3.off(e3, n3, o4, r3);
                }, offById: function(e3) {
                  return t3.offById(e3);
                } };
              } }]), o3;
            }((c = u(c)).default);
            o2.default = d, d.displayName = "ListenersAPI", t.exports = e.default;
          }) ? o.apply(e, r) : o) || (t.exports = i);
        }, function(t, e, n) {
          var o, r, i;
          "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self && self, r = [e, n(2), n(3), n(5), n(6), n(4), n(377), n(9)], void 0 === (i = "function" == typeof (o = function(o2, r2, i2, a, s, l, c, u) {
            "use strict";
            var f = n(1);
            function d() {
              if ("undefined" == typeof Reflect || !Reflect.construct)
                return false;
              if (Reflect.construct.sham)
                return false;
              if ("function" == typeof Proxy)
                return true;
              try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
                })), true;
              } catch (t2) {
                return false;
              }
            }
            Object.defineProperty(o2, "__esModule", { value: true }), o2.default = void 0, r2 = f(r2), i2 = f(i2), a = f(a), s = f(s), l = f(l), c = f(c);
            var p = function(t2) {
              (0, a.default)(o3, t2);
              var e2, n2 = (e2 = o3, function() {
                var t3, n3 = (0, l.default)(e2);
                if (d()) {
                  var o4 = (0, l.default)(this).constructor;
                  t3 = Reflect.construct(n3, arguments, o4);
                } else
                  t3 = n3.apply(this, arguments);
                return (0, s.default)(this, t3);
              });
              function o3(t3) {
                var e3, i3 = t3.config, a2 = t3.eventsDispatcher;
                return (0, r2.default)(this, o3), (e3 = n2.call(this, { config: i3, eventsDispatcher: a2 })).notifier = new c.default(), e3;
              }
              return (0, i2.default)(o3, [{ key: "show", value: function(t3) {
                return this.notifier.show(t3);
              } }, { key: "methods", get: function() {
                var t3 = this;
                return { show: function(e3) {
                  return t3.show(e3);
                } };
              } }]), o3;
            }((u = f(u)).default);
            o2.default = p, p.displayName = "NotifierAPI", t.exports = e.default;
          }) ? o.apply(e, r) : o) || (t.exports = i);
        }, function(t, e, n) {
          var o, r, i;
          "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self && self, r = [e, n(2), n(3), n(5), n(6), n(4), n(9)], void 0 === (i = "function" == typeof (o = function(o2, r2, i2, a, s, l, c) {
            "use strict";
            var u = n(1);
            function f() {
              if ("undefined" == typeof Reflect || !Reflect.construct)
                return false;
              if (Reflect.construct.sham)
                return false;
              if ("function" == typeof Proxy)
                return true;
              try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
                })), true;
              } catch (t2) {
                return false;
              }
            }
            Object.defineProperty(o2, "__esModule", { value: true }), o2.default = void 0, r2 = u(r2), i2 = u(i2), a = u(a), s = u(s), l = u(l);
            var d = function(t2) {
              (0, a.default)(o3, t2);
              var e2, n2 = (e2 = o3, function() {
                var t3, n3 = (0, l.default)(e2);
                if (f()) {
                  var o4 = (0, l.default)(this).constructor;
                  t3 = Reflect.construct(n3, arguments, o4);
                } else
                  t3 = n3.apply(this, arguments);
                return (0, s.default)(this, t3);
              });
              function o3() {
                return (0, r2.default)(this, o3), n2.apply(this, arguments);
              }
              return (0, i2.default)(o3, [{ key: "toggle", value: function(t3) {
                return this.Editor.ReadOnly.toggle(t3);
              } }, { key: "methods", get: function() {
                var t3 = this;
                return { toggle: function(e3) {
                  return t3.toggle(e3);
                }, get isEnabled() {
                  return t3.isEnabled;
                } };
              } }, { key: "isEnabled", get: function() {
                return this.Editor.ReadOnly.isEnabled;
              } }]), o3;
            }((c = u(c)).default);
            o2.default = d, d.displayName = "ReadOnlyAPI", t.exports = e.default;
          }) ? o.apply(e, r) : o) || (t.exports = i);
        }, function(t, e, n) {
          var o, r, i;
          "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self && self, r = [e, n(2), n(3), n(5), n(6), n(4), n(9), n(67)], void 0 === (i = "function" == typeof (o = function(o2, r2, i2, a, s, l, c, u) {
            "use strict";
            var f = n(1);
            function d() {
              if ("undefined" == typeof Reflect || !Reflect.construct)
                return false;
              if (Reflect.construct.sham)
                return false;
              if ("function" == typeof Proxy)
                return true;
              try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
                })), true;
              } catch (t2) {
                return false;
              }
            }
            Object.defineProperty(o2, "__esModule", { value: true }), o2.default = void 0, r2 = f(r2), i2 = f(i2), a = f(a), s = f(s), l = f(l);
            var p = function(t2) {
              (0, a.default)(o3, t2);
              var e2, n2 = (e2 = o3, function() {
                var t3, n3 = (0, l.default)(e2);
                if (d()) {
                  var o4 = (0, l.default)(this).constructor;
                  t3 = Reflect.construct(n3, arguments, o4);
                } else
                  t3 = n3.apply(this, arguments);
                return (0, s.default)(this, t3);
              });
              function o3() {
                return (0, r2.default)(this, o3), n2.apply(this, arguments);
              }
              return (0, i2.default)(o3, [{ key: "clean", value: function(t3, e3) {
                return (0, u.clean)(t3, e3);
              } }, { key: "methods", get: function() {
                var t3 = this;
                return { clean: function(e3, n3) {
                  return t3.clean(e3, n3);
                } };
              } }]), o3;
            }((c = f(c)).default);
            o2.default = p, p.displayName = "SanitizerAPI", t.exports = e.default;
          }) ? o.apply(e, r) : o) || (t.exports = i);
        }, function(t, e, n) {
          var o, r, i;
          "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self && self, r = [e, n(2), n(3), n(5), n(6), n(4), n(7), n(9)], void 0 === (i = "function" == typeof (o = function(o2, r2, i2, a, s, l, c, u) {
            "use strict";
            var f = n(8), d = n(1);
            function p() {
              if ("undefined" == typeof Reflect || !Reflect.construct)
                return false;
              if (Reflect.construct.sham)
                return false;
              if ("function" == typeof Proxy)
                return true;
              try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
                })), true;
              } catch (t2) {
                return false;
              }
            }
            Object.defineProperty(o2, "__esModule", { value: true }), o2.default = void 0, r2 = d(r2), i2 = d(i2), a = d(a), s = d(s), l = d(l), c = f(c);
            var h = function(t2) {
              (0, a.default)(o3, t2);
              var e2, n2 = (e2 = o3, function() {
                var t3, n3 = (0, l.default)(e2);
                if (p()) {
                  var o4 = (0, l.default)(this).constructor;
                  t3 = Reflect.construct(n3, arguments, o4);
                } else
                  t3 = n3.apply(this, arguments);
                return (0, s.default)(this, t3);
              });
              function o3() {
                return (0, r2.default)(this, o3), n2.apply(this, arguments);
              }
              return (0, i2.default)(o3, [{ key: "save", value: function() {
                var t3 = "Editor's content can not be saved in read-only mode";
                return this.Editor.ReadOnly.isEnabled ? (c.logLabeled(t3, "warn"), Promise.reject(new Error(t3))) : this.Editor.Saver.save();
              } }, { key: "methods", get: function() {
                var t3 = this;
                return { save: function() {
                  return t3.save();
                } };
              } }]), o3;
            }((u = d(u)).default);
            o2.default = h, h.displayName = "SaverAPI", t.exports = e.default;
          }) ? o.apply(e, r) : o) || (t.exports = i);
        }, function(t, e, n) {
          var o, r, i;
          "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self && self, r = [e, n(2), n(3), n(5), n(6), n(4), n(25), n(9)], void 0 === (i = "function" == typeof (o = function(o2, r2, i2, a, s, l, c, u) {
            "use strict";
            var f = n(1);
            function d() {
              if ("undefined" == typeof Reflect || !Reflect.construct)
                return false;
              if (Reflect.construct.sham)
                return false;
              if ("function" == typeof Proxy)
                return true;
              try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
                })), true;
              } catch (t2) {
                return false;
              }
            }
            Object.defineProperty(o2, "__esModule", { value: true }), o2.default = void 0, r2 = f(r2), i2 = f(i2), a = f(a), s = f(s), l = f(l), c = f(c);
            var p = function(t2) {
              (0, a.default)(o3, t2);
              var e2, n2 = (e2 = o3, function() {
                var t3, n3 = (0, l.default)(e2);
                if (d()) {
                  var o4 = (0, l.default)(this).constructor;
                  t3 = Reflect.construct(n3, arguments, o4);
                } else
                  t3 = n3.apply(this, arguments);
                return (0, s.default)(this, t3);
              });
              function o3() {
                return (0, r2.default)(this, o3), n2.apply(this, arguments);
              }
              return (0, i2.default)(o3, [{ key: "findParentTag", value: function(t3, e3) {
                return new c.default().findParentTag(t3, e3);
              } }, { key: "expandToTag", value: function(t3) {
                new c.default().expandToTag(t3);
              } }, { key: "methods", get: function() {
                var t3 = this;
                return { findParentTag: function(e3, n3) {
                  return t3.findParentTag(e3, n3);
                }, expandToTag: function(e3) {
                  return t3.expandToTag(e3);
                } };
              } }]), o3;
            }((u = f(u)).default);
            o2.default = p, p.displayName = "SelectionAPI", t.exports = e.default;
          }) ? o.apply(e, r) : o) || (t.exports = i);
        }, function(t, e, n) {
          var o, r, i;
          "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self && self, r = [e, n(2), n(3), n(5), n(6), n(4), n(9)], void 0 === (i = "function" == typeof (o = function(o2, r2, i2, a, s, l, c) {
            "use strict";
            var u = n(1);
            function f() {
              if ("undefined" == typeof Reflect || !Reflect.construct)
                return false;
              if (Reflect.construct.sham)
                return false;
              if ("function" == typeof Proxy)
                return true;
              try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
                })), true;
              } catch (t2) {
                return false;
              }
            }
            Object.defineProperty(o2, "__esModule", { value: true }), o2.default = void 0, r2 = u(r2), i2 = u(i2), a = u(a), s = u(s), l = u(l);
            var d = function(t2) {
              (0, a.default)(o3, t2);
              var e2, n2 = (e2 = o3, function() {
                var t3, n3 = (0, l.default)(e2);
                if (f()) {
                  var o4 = (0, l.default)(this).constructor;
                  t3 = Reflect.construct(n3, arguments, o4);
                } else
                  t3 = n3.apply(this, arguments);
                return (0, s.default)(this, t3);
              });
              function o3() {
                return (0, r2.default)(this, o3), n2.apply(this, arguments);
              }
              return (0, i2.default)(o3, [{ key: "classes", get: function() {
                return { block: "cdx-block", inlineToolButton: "ce-inline-tool", inlineToolButtonActive: "ce-inline-tool--active", input: "cdx-input", loader: "cdx-loader", button: "cdx-button", settingsButton: "cdx-settings-button", settingsButtonActive: "cdx-settings-button--active" };
              } }]), o3;
            }((c = u(c)).default);
            o2.default = d, d.displayName = "StylesAPI", t.exports = e.default;
          }) ? o.apply(e, r) : o) || (t.exports = i);
        }, function(t, e, n) {
          var o, r, i;
          "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self && self, r = [e, n(2), n(3), n(5), n(6), n(4), n(9), n(7)], void 0 === (i = "function" == typeof (o = function(o2, r2, i2, a, s, l, c, u) {
            "use strict";
            var f = n(8), d = n(1);
            function p() {
              if ("undefined" == typeof Reflect || !Reflect.construct)
                return false;
              if (Reflect.construct.sham)
                return false;
              if ("function" == typeof Proxy)
                return true;
              try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
                })), true;
              } catch (t2) {
                return false;
              }
            }
            Object.defineProperty(o2, "__esModule", { value: true }), o2.default = void 0, r2 = d(r2), i2 = d(i2), a = d(a), s = d(s), l = d(l), c = d(c), u = f(u);
            var h = function(t2) {
              (0, a.default)(o3, t2);
              var e2, n2 = (e2 = o3, function() {
                var t3, n3 = (0, l.default)(e2);
                if (p()) {
                  var o4 = (0, l.default)(this).constructor;
                  t3 = Reflect.construct(n3, arguments, o4);
                } else
                  t3 = n3.apply(this, arguments);
                return (0, s.default)(this, t3);
              });
              function o3() {
                return (0, r2.default)(this, o3), n2.apply(this, arguments);
              }
              return (0, i2.default)(o3, [{ key: "open", value: function() {
                this.Editor.Toolbar.moveAndOpen();
              } }, { key: "close", value: function() {
                this.Editor.Toolbar.close();
              } }, { key: "toggleBlockSettings", value: function(t3) {
                -1 !== this.Editor.BlockManager.currentBlockIndex ? (null != t3 ? t3 : !this.Editor.BlockSettings.opened) ? (this.Editor.Toolbar.moveAndOpen(), this.Editor.BlockSettings.open()) : this.Editor.BlockSettings.close() : u.logLabeled("Could't toggle the Toolbar because there is no block selected ", "warn");
              } }, { key: "methods", get: function() {
                var t3 = this;
                return { close: function() {
                  return t3.close();
                }, open: function() {
                  return t3.open();
                }, toggleBlockSettings: function(e3) {
                  return t3.toggleBlockSettings(e3);
                } };
              } }]), o3;
            }(c.default);
            o2.default = h, h.displayName = "ToolbarAPI", t.exports = e.default;
          }) ? o.apply(e, r) : o) || (t.exports = i);
        }, function(t, e, n) {
          var o, r, i;
          "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self && self, r = [e, n(2), n(3), n(5), n(6), n(4), n(9), n(114)], void 0 === (i = "function" == typeof (o = function(o2, r2, i2, a, s, l, c, u) {
            "use strict";
            var f = n(1);
            function d() {
              if ("undefined" == typeof Reflect || !Reflect.construct)
                return false;
              if (Reflect.construct.sham)
                return false;
              if ("function" == typeof Proxy)
                return true;
              try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
                })), true;
              } catch (t2) {
                return false;
              }
            }
            Object.defineProperty(o2, "__esModule", { value: true }), o2.default = void 0, r2 = f(r2), i2 = f(i2), a = f(a), s = f(s), l = f(l), c = f(c), u = f(u);
            var p = function(t2) {
              (0, a.default)(o3, t2);
              var e2, n2 = (e2 = o3, function() {
                var t3, n3 = (0, l.default)(e2);
                if (d()) {
                  var o4 = (0, l.default)(this).constructor;
                  t3 = Reflect.construct(n3, arguments, o4);
                } else
                  t3 = n3.apply(this, arguments);
                return (0, s.default)(this, t3);
              });
              function o3(t3) {
                var e3, i3 = t3.config, a2 = t3.eventsDispatcher;
                return (0, r2.default)(this, o3), (e3 = n2.call(this, { config: i3, eventsDispatcher: a2 })).tooltip = new u.default(), e3;
              }
              return (0, i2.default)(o3, [{ key: "destroy", value: function() {
                this.tooltip.destroy();
              } }, { key: "show", value: function(t3, e3, n3) {
                this.tooltip.show(t3, e3, n3);
              } }, { key: "hide", value: function() {
                this.tooltip.hide();
              } }, { key: "onHover", value: function(t3, e3, n3) {
                this.tooltip.onHover(t3, e3, n3);
              } }, { key: "methods", get: function() {
                var t3 = this;
                return { show: function(e3, n3, o4) {
                  return t3.show(e3, n3, o4);
                }, hide: function() {
                  return t3.hide();
                }, onHover: function(e3, n3, o4) {
                  return t3.onHover(e3, n3, o4);
                } };
              } }]), o3;
            }(c.default);
            o2.default = p, p.displayName = "TooltipAPI", t.exports = e.default;
          }) ? o.apply(e, r) : o) || (t.exports = i);
        }, function(t, e, n) {
          var o, r, i;
          "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self && self, r = [e, n(2), n(3), n(5), n(6), n(4), n(9)], void 0 === (i = "function" == typeof (o = function(o2, r2, i2, a, s, l, c) {
            "use strict";
            var u = n(1);
            function f() {
              if ("undefined" == typeof Reflect || !Reflect.construct)
                return false;
              if (Reflect.construct.sham)
                return false;
              if ("function" == typeof Proxy)
                return true;
              try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
                })), true;
              } catch (t2) {
                return false;
              }
            }
            Object.defineProperty(o2, "__esModule", { value: true }), o2.default = void 0, r2 = u(r2), i2 = u(i2), a = u(a), s = u(s), l = u(l);
            var d = function(t2) {
              (0, a.default)(o3, t2);
              var e2, n2 = (e2 = o3, function() {
                var t3, n3 = (0, l.default)(e2);
                if (f()) {
                  var o4 = (0, l.default)(this).constructor;
                  t3 = Reflect.construct(n3, arguments, o4);
                } else
                  t3 = n3.apply(this, arguments);
                return (0, s.default)(this, t3);
              });
              function o3() {
                return (0, r2.default)(this, o3), n2.apply(this, arguments);
              }
              return (0, i2.default)(o3, [{ key: "methods", get: function() {
                return { nodes: this.editorNodes };
              } }, { key: "editorNodes", get: function() {
                return { wrapper: this.Editor.UI.nodes.wrapper, redactor: this.Editor.UI.nodes.redactor };
              } }]), o3;
            }((c = u(c)).default);
            o2.default = d, d.displayName = "UiAPI", t.exports = e.default;
          }) ? o.apply(e, r) : o) || (t.exports = i);
        }, function(t, e, n) {
          var o, r, i;
          "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self && self, r = [e, n(2), n(3), n(5), n(6), n(4), n(9), n(7), n(25), n(62)], void 0 === (i = "function" == typeof (o = function(o2, r2, i2, a, s, l, c, u, f, d) {
            "use strict";
            var p = n(8), h = n(1);
            function v() {
              if ("undefined" == typeof Reflect || !Reflect.construct)
                return false;
              if (Reflect.construct.sham)
                return false;
              if ("function" == typeof Proxy)
                return true;
              try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
                })), true;
              } catch (t2) {
                return false;
              }
            }
            Object.defineProperty(o2, "__esModule", { value: true }), o2.default = void 0, r2 = h(r2), i2 = h(i2), a = h(a), s = h(s), l = h(l), c = h(c), u = p(u), f = h(f), d = h(d);
            var g = function(t2) {
              (0, a.default)(o3, t2);
              var e2, n2 = (e2 = o3, function() {
                var t3, n3 = (0, l.default)(e2);
                if (v()) {
                  var o4 = (0, l.default)(this).constructor;
                  t3 = Reflect.construct(n3, arguments, o4);
                } else
                  t3 = n3.apply(this, arguments);
                return (0, s.default)(this, t3);
              });
              function o3() {
                return (0, r2.default)(this, o3), n2.apply(this, arguments);
              }
              return (0, i2.default)(o3, [{ key: "keydown", value: function(t3) {
                switch (this.beforeKeydownProcessing(t3), t3.keyCode) {
                  case u.keyCodes.BACKSPACE:
                    this.backspace(t3);
                    break;
                  case u.keyCodes.ENTER:
                    this.enter(t3);
                    break;
                  case u.keyCodes.DOWN:
                  case u.keyCodes.RIGHT:
                    this.arrowRightAndDown(t3);
                    break;
                  case u.keyCodes.UP:
                  case u.keyCodes.LEFT:
                    this.arrowLeftAndUp(t3);
                    break;
                  case u.keyCodes.TAB:
                    this.tabPressed(t3);
                }
              } }, { key: "beforeKeydownProcessing", value: function(t3) {
                this.needToolbarClosing(t3) && u.isPrintableKey(t3.keyCode) && (this.Editor.Toolbar.close(), this.Editor.ConversionToolbar.close(), t3.ctrlKey || t3.metaKey || t3.altKey || t3.shiftKey || (this.Editor.BlockManager.clearFocused(), this.Editor.BlockSelection.clearSelection(t3)));
              } }, { key: "keyup", value: function(t3) {
                t3.shiftKey || this.Editor.UI.checkEmptiness();
              } }, { key: "tabPressed", value: function(t3) {
                this.Editor.BlockSelection.clearSelection(t3);
                var e3 = this.Editor, n3 = e3.BlockManager, o4 = e3.InlineToolbar, r3 = e3.ConversionToolbar, i3 = n3.currentBlock;
                if (i3) {
                  var a2 = i3.isEmpty, s2 = i3.tool.isDefault && a2, l2 = !a2 && r3.opened, c2 = !a2 && !f.default.isCollapsed && o4.opened;
                  s2 ? this.activateToolbox() : l2 || c2 || this.activateBlockSettings();
                }
              } }, { key: "dragOver", value: function(t3) {
                this.Editor.BlockManager.getBlockByChildNode(t3.target).dropTarget = true;
              } }, { key: "dragLeave", value: function(t3) {
                this.Editor.BlockManager.getBlockByChildNode(t3.target).dropTarget = false;
              } }, { key: "handleCommandC", value: function(t3) {
                var e3 = this.Editor.BlockSelection;
                e3.anyBlockSelected && e3.copySelectedBlocks(t3);
              } }, { key: "handleCommandX", value: function(t3) {
                var e3 = this.Editor, n3 = e3.BlockSelection, o4 = e3.BlockManager, r3 = e3.Caret;
                n3.anyBlockSelected && n3.copySelectedBlocks(t3).then(function() {
                  var e4 = o4.removeSelectedBlocks(), i3 = o4.insertDefaultBlockAtIndex(e4, true);
                  r3.setToBlock(i3, r3.positions.START), n3.clearSelection(t3);
                });
              } }, { key: "enter", value: function(t3) {
                var e3 = this.Editor, n3 = e3.BlockManager, o4 = e3.UI;
                if (!n3.currentBlock.tool.isLineBreaksEnabled && !(o4.someToolbarOpened && o4.someFlipperButtonFocused || t3.shiftKey)) {
                  var r3 = this.Editor.BlockManager.currentBlock;
                  this.Editor.Caret.isAtStart && !this.Editor.BlockManager.currentBlock.hasMedia ? this.Editor.BlockManager.insertDefaultBlockAtIndex(this.Editor.BlockManager.currentBlockIndex) : r3 = this.Editor.BlockManager.split(), this.Editor.Caret.setToBlock(r3), this.Editor.Toolbar.moveAndOpen(r3), t3.preventDefault();
                }
              } }, { key: "backspace", value: function(t3) {
                var e3 = this.Editor, n3 = e3.BlockManager, o4 = e3.BlockSelection, r3 = e3.Caret, i3 = n3.currentBlock, a2 = i3.tool;
                if (i3.selected || i3.isEmpty && i3.currentInput === i3.firstInput) {
                  t3.preventDefault();
                  var s2 = n3.currentBlockIndex;
                  return n3.previousBlock && 0 === n3.previousBlock.inputs.length ? n3.removeBlock(s2 - 1) : n3.removeBlock(), r3.setToBlock(n3.currentBlock, s2 ? r3.positions.END : r3.positions.START), this.Editor.Toolbar.close(), void o4.clearSelection(t3);
                }
                if (!a2.isLineBreaksEnabled || r3.isAtStart) {
                  var l2 = 0 === n3.currentBlockIndex;
                  r3.isAtStart && f.default.isCollapsed && i3.currentInput === i3.firstInput && !l2 && (t3.preventDefault(), this.mergeBlocks());
                }
              } }, { key: "mergeBlocks", value: function() {
                var t3 = this.Editor, e3 = t3.BlockManager, n3 = t3.Caret, o4 = t3.Toolbar, r3 = e3.previousBlock, i3 = e3.currentBlock;
                if (i3.name !== r3.name || !r3.mergeable)
                  return 0 === r3.inputs.length || r3.isEmpty ? (e3.removeBlock(e3.currentBlockIndex - 1), n3.setToBlock(e3.currentBlock), void o4.close()) : void (n3.navigatePrevious() && o4.close());
                n3.createShadow(r3.pluginsContent), e3.mergeBlocks(r3, i3).then(function() {
                  n3.restoreCaret(r3.pluginsContent), r3.pluginsContent.normalize(), o4.close();
                });
              } }, { key: "arrowRightAndDown", value: function(t3) {
                var e3 = this, n3 = d.default.usedKeys.includes(t3.keyCode) && (!t3.shiftKey || t3.keyCode === u.keyCodes.TAB);
                if (!this.Editor.UI.someToolbarOpened || !n3) {
                  this.Editor.BlockManager.clearFocused(), this.Editor.Toolbar.close();
                  var o4 = this.Editor.Caret.isAtEnd || this.Editor.BlockSelection.anyBlockSelected;
                  t3.shiftKey && t3.keyCode === u.keyCodes.DOWN && o4 ? this.Editor.CrossBlockSelection.toggleBlockSelectedState() : ((t3.keyCode === u.keyCodes.DOWN || t3.keyCode === u.keyCodes.RIGHT && !this.isRtl ? this.Editor.Caret.navigateNext() : this.Editor.Caret.navigatePrevious()) ? t3.preventDefault() : u.delay(function() {
                    e3.Editor.BlockManager.currentBlock && e3.Editor.BlockManager.currentBlock.updateCurrentInput();
                  }, 20)(), this.Editor.BlockSelection.clearSelection(t3));
                }
              } }, { key: "arrowLeftAndUp", value: function(t3) {
                var e3 = this;
                if (this.Editor.UI.someToolbarOpened) {
                  if (d.default.usedKeys.includes(t3.keyCode) && (!t3.shiftKey || t3.keyCode === u.keyCodes.TAB))
                    return;
                  this.Editor.UI.closeAllToolbars();
                }
                this.Editor.BlockManager.clearFocused(), this.Editor.Toolbar.close();
                var n3 = this.Editor.Caret.isAtStart || this.Editor.BlockSelection.anyBlockSelected;
                t3.shiftKey && t3.keyCode === u.keyCodes.UP && n3 ? this.Editor.CrossBlockSelection.toggleBlockSelectedState(false) : ((t3.keyCode === u.keyCodes.UP || t3.keyCode === u.keyCodes.LEFT && !this.isRtl ? this.Editor.Caret.navigatePrevious() : this.Editor.Caret.navigateNext()) ? t3.preventDefault() : u.delay(function() {
                  e3.Editor.BlockManager.currentBlock && e3.Editor.BlockManager.currentBlock.updateCurrentInput();
                }, 20)(), this.Editor.BlockSelection.clearSelection(t3));
              } }, { key: "needToolbarClosing", value: function(t3) {
                var e3 = t3.keyCode === u.keyCodes.ENTER && this.Editor.Toolbar.toolbox.opened, n3 = t3.keyCode === u.keyCodes.ENTER && this.Editor.BlockSettings.opened, o4 = t3.keyCode === u.keyCodes.ENTER && this.Editor.InlineToolbar.opened, r3 = t3.keyCode === u.keyCodes.ENTER && this.Editor.ConversionToolbar.opened, i3 = t3.keyCode === u.keyCodes.TAB;
                return !(t3.shiftKey || i3 || e3 || n3 || o4 || r3);
              } }, { key: "activateToolbox", value: function() {
                this.Editor.Toolbar.opened || this.Editor.Toolbar.moveAndOpen(), this.Editor.Toolbar.toolbox.open();
              } }, { key: "activateBlockSettings", value: function() {
                this.Editor.Toolbar.opened || (this.Editor.BlockManager.currentBlock.focused = true, this.Editor.Toolbar.moveAndOpen()), this.Editor.BlockSettings.opened || this.Editor.BlockSettings.open();
              } }]), o3;
            }(c.default);
            o2.default = g, g.displayName = "BlockEvents", t.exports = e.default;
          }) ? o.apply(e, r) : o) || (t.exports = i);
        }, function(t, e, n) {
          var o, r, i;
          "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self && self, r = [e, n(20), n(21), n(2), n(3), n(5), n(6), n(4), n(61), n(9), n(14), n(7), n(382), n(112), n(383)], void 0 === (i = "function" == typeof (o = function(o2, r2, i2, a, s, l, c, u, f, d, p, h, v, g, y) {
            "use strict";
            var b = n(8), m = n(1);
            function k() {
              if ("undefined" == typeof Reflect || !Reflect.construct)
                return false;
              if (Reflect.construct.sham)
                return false;
              if ("function" == typeof Proxy)
                return true;
              try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
                })), true;
              } catch (t2) {
                return false;
              }
            }
            Object.defineProperty(o2, "__esModule", { value: true }), o2.default = void 0, r2 = m(r2), i2 = m(i2), a = m(a), s = m(s), l = m(l), c = m(c), u = m(u), f = b(f), d = m(d), p = m(p), h = b(h), v = m(v), g = m(g);
            var x = function(t2) {
              (0, l.default)(b2, t2);
              var e2, n2, o3, d2 = (e2 = b2, function() {
                var t3, n3 = (0, u.default)(e2);
                if (k()) {
                  var o4 = (0, u.default)(this).constructor;
                  t3 = Reflect.construct(n3, arguments, o4);
                } else
                  t3 = n3.apply(this, arguments);
                return (0, c.default)(this, t3);
              });
              function b2() {
                var t3;
                return (0, a.default)(this, b2), (t3 = d2.apply(this, arguments))._currentBlockIndex = -1, t3._blocks = null, t3;
              }
              return (0, s.default)(b2, [{ key: "prepare", value: function() {
                var t3 = this, e3 = new v.default(this.Editor.UI.nodes.redactor);
                this._blocks = new Proxy(e3, { set: v.default.set, get: v.default.get }), this.listeners.on(document, "copy", function(e4) {
                  return t3.Editor.BlockEvents.handleCommandC(e4);
                });
              } }, { key: "toggleReadOnly", value: function(t3) {
                t3 ? this.disableModuleBindings() : this.enableModuleBindings();
              } }, { key: "composeBlock", value: function(t3) {
                var e3 = t3.tool, n3 = t3.data, o4 = void 0 === n3 ? {} : n3, r3 = t3.id, i3 = void 0 === r3 ? void 0 : r3, a2 = t3.tunes, s2 = void 0 === a2 ? {} : a2, l2 = this.Editor.ReadOnly.isEnabled, c2 = this.Editor.Tools.blockTools.get(e3), u2 = new f.default({ id: i3, data: o4, tool: c2, api: this.Editor.API, readOnly: l2, tunesData: s2 });
                return l2 || this.bindBlockEvents(u2), u2;
              } }, { key: "insert", value: function() {
                var t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, e3 = t3.id, n3 = void 0 === e3 ? void 0 : e3, o4 = t3.tool, r3 = void 0 === o4 ? this.config.defaultBlock : o4, i3 = t3.data, a2 = void 0 === i3 ? {} : i3, s2 = t3.index, l2 = t3.needToFocus, c2 = void 0 === l2 || l2, u2 = t3.replace, f2 = void 0 !== u2 && u2, d3 = t3.tunes, p2 = void 0 === d3 ? {} : d3, h2 = s2;
                void 0 === h2 && (h2 = this.currentBlockIndex + (f2 ? 0 : 1));
                var v2 = this.composeBlock({ id: n3, tool: r3, data: a2, tunes: p2 });
                return f2 && this.blockDidMutated(y.BlockMutationType.Removed, this.getBlockByIndex(h2), { index: h2 }), this._blocks.insert(h2, v2, f2), this.blockDidMutated(y.BlockMutationType.Added, v2, { index: h2 }), c2 ? this.currentBlockIndex = h2 : h2 <= this.currentBlockIndex && this.currentBlockIndex++, v2;
              } }, { key: "replace", value: function(t3) {
                var e3 = t3.tool, n3 = void 0 === e3 ? this.config.defaultBlock : e3, o4 = t3.data, r3 = void 0 === o4 ? {} : o4;
                return this.insert({ tool: n3, data: r3, index: this.currentBlockIndex, replace: true });
              } }, { key: "paste", value: function(t3, e3) {
                var n3 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], o4 = this.insert({ tool: t3, replace: n3 });
                try {
                  o4.call(f.BlockToolAPI.ON_PASTE, e3);
                } catch (e4) {
                  h.log("".concat(t3, ": onPaste callback call is failed"), "error", e4);
                }
                return o4;
              } }, { key: "insertDefaultBlockAtIndex", value: function(t3) {
                var e3 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], n3 = this.composeBlock({ tool: this.config.defaultBlock });
                return this._blocks[t3] = n3, this.blockDidMutated(y.BlockMutationType.Added, n3, { index: t3 }), e3 ? this.currentBlockIndex = t3 : t3 <= this.currentBlockIndex && this.currentBlockIndex++, n3;
              } }, { key: "insertAtEnd", value: function() {
                return this.currentBlockIndex = this.blocks.length - 1, this.insert();
              } }, { key: "mergeBlocks", value: (o3 = (0, i2.default)(r2.default.mark(function t3(e3, n3) {
                var o4, i3;
                return r2.default.wrap(function(t4) {
                  for (; ; )
                    switch (t4.prev = t4.next) {
                      case 0:
                        if (o4 = this._blocks.indexOf(n3), !n3.isEmpty) {
                          t4.next = 3;
                          break;
                        }
                        return t4.abrupt("return");
                      case 3:
                        return t4.next = 5, n3.data;
                      case 5:
                        if (i3 = t4.sent, h.isEmpty(i3)) {
                          t4.next = 9;
                          break;
                        }
                        return t4.next = 9, e3.mergeWith(i3);
                      case 9:
                        this.removeBlock(o4), this.currentBlockIndex = this._blocks.indexOf(e3);
                      case 11:
                      case "end":
                        return t4.stop();
                    }
                }, t3, this);
              })), function(t3, e3) {
                return o3.apply(this, arguments);
              }) }, { key: "removeBlock", value: function() {
                var t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.currentBlockIndex;
                if (!this.validateIndex(t3))
                  throw new Error("Can't find a Block to remove");
                var e3 = this._blocks[t3];
                e3.destroy(), this._blocks.remove(t3), this.blockDidMutated(y.BlockMutationType.Removed, e3, { index: t3 }), this.currentBlockIndex >= t3 && this.currentBlockIndex--, this.blocks.length ? 0 === t3 && (this.currentBlockIndex = 0) : (this.currentBlockIndex = -1, this.insert());
              } }, { key: "removeSelectedBlocks", value: function() {
                for (var t3, e3 = this.blocks.length - 1; e3 >= 0; e3--)
                  this.blocks[e3].selected && (this.removeBlock(e3), t3 = e3);
                return t3;
              } }, { key: "removeAllBlocks", value: function() {
                for (var t3 = this.blocks.length - 1; t3 >= 0; t3--)
                  this._blocks.remove(t3);
                this.currentBlockIndex = -1, this.insert(), this.currentBlock.firstInput.focus();
              } }, { key: "split", value: function() {
                var t3 = this.Editor.Caret.extractFragmentFromCaretPosition(), e3 = p.default.make("div");
                e3.appendChild(t3);
                var n3 = { text: p.default.isEmpty(e3) ? "" : e3.innerHTML };
                return this.insert({ data: n3 });
              } }, { key: "getBlockByIndex", value: function(t3) {
                return -1 === t3 && (t3 = this._blocks.length - 1), this._blocks[t3];
              } }, { key: "getBlockIndex", value: function(t3) {
                return this._blocks.indexOf(t3);
              } }, { key: "getBlockById", value: function(t3) {
                return this._blocks.array.find(function(e3) {
                  return e3.id === t3;
                });
              } }, { key: "getBlock", value: function(t3) {
                p.default.isElement(t3) || (t3 = t3.parentNode);
                var e3 = this._blocks.nodes, n3 = t3.closest(".".concat(f.default.CSS.wrapper)), o4 = e3.indexOf(n3);
                if (o4 >= 0)
                  return this._blocks[o4];
              } }, { key: "highlightCurrentNode", value: function() {
                this.clearFocused(), this.currentBlock.focused = true;
              } }, { key: "clearFocused", value: function() {
                this.blocks.forEach(function(t3) {
                  t3.focused = false;
                });
              } }, { key: "setCurrentBlockByChildNode", value: function(t3) {
                p.default.isElement(t3) || (t3 = t3.parentNode);
                var e3 = t3.closest(".".concat(f.default.CSS.wrapper));
                if (e3) {
                  var n3 = e3.closest(".".concat(this.Editor.UI.CSS.editorWrapper));
                  if (null == n3 ? void 0 : n3.isEqualNode(this.Editor.UI.nodes.wrapper))
                    return this.currentBlockIndex = this._blocks.nodes.indexOf(e3), this.currentBlock.updateCurrentInput(), this.currentBlock;
                }
              } }, { key: "getBlockByChildNode", value: function(t3) {
                p.default.isElement(t3) || (t3 = t3.parentNode);
                var e3 = t3.closest(".".concat(f.default.CSS.wrapper));
                return this.blocks.find(function(t4) {
                  return t4.holder === e3;
                });
              } }, { key: "swap", value: function(t3, e3) {
                this._blocks.swap(t3, e3), this.currentBlockIndex = e3;
              } }, { key: "move", value: function(t3) {
                var e3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.currentBlockIndex;
                isNaN(t3) || isNaN(e3) ? h.log("Warning during 'move' call: incorrect indices provided.", "warn") : this.validateIndex(t3) && this.validateIndex(e3) ? (this._blocks.move(t3, e3), this.currentBlockIndex = t3, this.blockDidMutated(y.BlockMutationType.Moved, this.currentBlock, { fromIndex: e3, toIndex: t3 })) : h.log("Warning during 'move' call: indices cannot be lower than 0 or greater than the amount of blocks.", "warn");
              } }, { key: "dropPointer", value: function() {
                this.currentBlockIndex = -1, this.clearFocused();
              } }, { key: "clear", value: function() {
                var t3 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
                this._blocks.removeAll(), this.dropPointer(), t3 && this.insert(), this.Editor.UI.checkEmptiness();
              } }, { key: "destroy", value: (n2 = (0, i2.default)(r2.default.mark(function t3() {
                return r2.default.wrap(function(t4) {
                  for (; ; )
                    switch (t4.prev = t4.next) {
                      case 0:
                        return t4.next = 2, Promise.all(this.blocks.map(function(t5) {
                          return t5.destroy();
                        }));
                      case 2:
                      case "end":
                        return t4.stop();
                    }
                }, t3, this);
              })), function() {
                return n2.apply(this, arguments);
              }) }, { key: "bindBlockEvents", value: function(t3) {
                var e3 = this, n3 = this.Editor.BlockEvents;
                this.readOnlyMutableListeners.on(t3.holder, "keydown", function(t4) {
                  n3.keydown(t4);
                }), this.readOnlyMutableListeners.on(t3.holder, "keyup", function(t4) {
                  n3.keyup(t4);
                }), this.readOnlyMutableListeners.on(t3.holder, "dragover", function(t4) {
                  n3.dragOver(t4);
                }), this.readOnlyMutableListeners.on(t3.holder, "dragleave", function(t4) {
                  n3.dragLeave(t4);
                }), t3.on("didMutated", function(t4) {
                  return e3.blockDidMutated(y.BlockMutationType.Changed, t4, { index: e3.getBlockIndex(t4) });
                });
              } }, { key: "disableModuleBindings", value: function() {
                this.readOnlyMutableListeners.clearAll();
              } }, { key: "enableModuleBindings", value: function() {
                var t3 = this;
                this.readOnlyMutableListeners.on(document, "cut", function(e3) {
                  return t3.Editor.BlockEvents.handleCommandX(e3);
                }), this.blocks.forEach(function(e3) {
                  t3.bindBlockEvents(e3);
                });
              } }, { key: "validateIndex", value: function(t3) {
                return !(t3 < 0 || t3 >= this._blocks.length);
              } }, { key: "blockDidMutated", value: function(t3, e3) {
                var n3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, o4 = new CustomEvent(t3, { detail: Object.assign({ target: new g.default(e3) }, n3) });
                return this.Editor.ModificationsObserver.onChange(o4), e3;
              } }, { key: "currentBlockIndex", get: function() {
                return this._currentBlockIndex;
              }, set: function(t3) {
                this._blocks[this._currentBlockIndex] && this._blocks[this._currentBlockIndex].willUnselect(), this._blocks[t3] && this._blocks[t3].willSelect(), this._currentBlockIndex = t3;
              } }, { key: "firstBlock", get: function() {
                return this._blocks[0];
              } }, { key: "lastBlock", get: function() {
                return this._blocks[this._blocks.length - 1];
              } }, { key: "currentBlock", get: function() {
                return this._blocks[this.currentBlockIndex];
              }, set: function(t3) {
                this.currentBlockIndex = this.getBlockIndex(t3);
              } }, { key: "nextBlock", get: function() {
                return this.currentBlockIndex === this._blocks.length - 1 ? null : this._blocks[this.currentBlockIndex + 1];
              } }, { key: "nextContentfulBlock", get: function() {
                return this.blocks.slice(this.currentBlockIndex + 1).find(function(t3) {
                  return !!t3.inputs.length;
                });
              } }, { key: "previousContentfulBlock", get: function() {
                return this.blocks.slice(0, this.currentBlockIndex).reverse().find(function(t3) {
                  return !!t3.inputs.length;
                });
              } }, { key: "previousBlock", get: function() {
                return 0 === this.currentBlockIndex ? null : this._blocks[this.currentBlockIndex - 1];
              } }, { key: "blocks", get: function() {
                return this._blocks.array;
              } }, { key: "isEditorEmpty", get: function() {
                return this.blocks.every(function(t3) {
                  return t3.isEmpty;
                });
              } }]), b2;
            }(d.default);
            o2.default = x, x.displayName = "BlockManager", t.exports = e.default;
          }) ? o.apply(e, r) : o) || (t.exports = i);
        }, function(t, e, n) {
          var o, r, i;
          "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self && self, r = [e, n(2), n(3), n(5), n(6), n(4), n(9), n(7), n(14), n(115), n(25), n(67)], void 0 === (i = "function" == typeof (o = function(o2, r2, i2, a, s, l, c, u, f, d, p, h) {
            "use strict";
            var v = n(8), g = n(1);
            function y() {
              if ("undefined" == typeof Reflect || !Reflect.construct)
                return false;
              if (Reflect.construct.sham)
                return false;
              if ("function" == typeof Proxy)
                return true;
              try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
                })), true;
              } catch (t2) {
                return false;
              }
            }
            Object.defineProperty(o2, "__esModule", { value: true }), o2.default = void 0, r2 = g(r2), i2 = g(i2), a = g(a), s = g(s), l = g(l), c = g(c), u = v(u), f = g(f), d = g(d), p = g(p);
            var b = function(t2) {
              (0, a.default)(o3, t2);
              var e2, n2 = (e2 = o3, function() {
                var t3, n3 = (0, l.default)(e2);
                if (y()) {
                  var o4 = (0, l.default)(this).constructor;
                  t3 = Reflect.construct(n3, arguments, o4);
                } else
                  t3 = n3.apply(this, arguments);
                return (0, s.default)(this, t3);
              });
              function o3() {
                var t3;
                return (0, r2.default)(this, o3), (t3 = n2.apply(this, arguments)).anyBlockSelectedCache = null, t3.needToSelectAll = false, t3.nativeInputSelected = false, t3.readyToBlockSelection = false, t3;
              }
              return (0, i2.default)(o3, [{ key: "prepare", value: function() {
                var t3 = this;
                this.selection = new p.default(), d.default.add({ name: "CMD+A", handler: function(e3) {
                  var n3 = t3.Editor, o4 = n3.BlockManager;
                  if (n3.ReadOnly.isEnabled)
                    return e3.preventDefault(), void t3.selectAllBlocks();
                  o4.currentBlock && t3.handleCommandA(e3);
                }, on: this.Editor.UI.nodes.redactor });
              } }, { key: "toggleReadOnly", value: function(t3) {
                p.default.get().removeAllRanges(), this.allBlocksSelected = false;
              } }, { key: "unSelectBlockByIndex", value: function(t3) {
                var e3 = this.Editor.BlockManager;
                (isNaN(t3) ? e3.currentBlock : e3.getBlockByIndex(t3)).selected = false, this.clearCache();
              } }, { key: "clearSelection", value: function(t3) {
                var e3 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], n3 = this.Editor, o4 = n3.BlockManager, r3 = n3.Caret, i3 = n3.RectangleSelection;
                this.needToSelectAll = false, this.nativeInputSelected = false, this.readyToBlockSelection = false;
                var a2 = t3 && t3 instanceof KeyboardEvent, s2 = a2 && u.isPrintableKey(t3.keyCode);
                if (this.anyBlockSelected && a2 && s2 && !p.default.isSelectionExists) {
                  var l2 = o4.removeSelectedBlocks();
                  o4.insertDefaultBlockAtIndex(l2, true), r3.setToBlock(o4.currentBlock), u.delay(function() {
                    var e4 = t3.key;
                    r3.insertContentAtCaretPosition(e4.length > 1 ? "" : e4);
                  }, 20)();
                }
                this.Editor.CrossBlockSelection.clear(t3), this.anyBlockSelected && !i3.isRectActivated() ? (e3 && this.selection.restore(), this.allBlocksSelected = false) : this.Editor.RectangleSelection.clearSelection();
              } }, { key: "copySelectedBlocks", value: function(t3) {
                var e3 = this;
                t3.preventDefault();
                var n3 = f.default.make("div");
                this.selectedBlocks.forEach(function(t4) {
                  var o5 = (0, h.clean)(t4.holder.innerHTML, e3.sanitizerConfig), r4 = f.default.make("p");
                  r4.innerHTML = o5, n3.appendChild(r4);
                });
                var o4 = Array.from(n3.childNodes).map(function(t4) {
                  return t4.textContent;
                }).join("\n\n"), r3 = n3.innerHTML;
                return t3.clipboardData.setData("text/plain", o4), t3.clipboardData.setData("text/html", r3), Promise.all(this.selectedBlocks.map(function(t4) {
                  return t4.save();
                })).then(function(n4) {
                  try {
                    t3.clipboardData.setData(e3.Editor.Paste.MIME_TYPE, JSON.stringify(n4));
                  } catch (t4) {
                  }
                });
              } }, { key: "selectBlockByIndex", value: function(t3) {
                var e3, n3 = this.Editor.BlockManager;
                n3.clearFocused(), e3 = isNaN(t3) ? n3.currentBlock : n3.getBlockByIndex(t3), this.selection.save(), p.default.get().removeAllRanges(), e3.selected = true, this.clearCache(), this.Editor.InlineToolbar.close();
              } }, { key: "clearCache", value: function() {
                this.anyBlockSelectedCache = null;
              } }, { key: "destroy", value: function() {
                d.default.remove(this.Editor.UI.nodes.redactor, "CMD+A");
              } }, { key: "handleCommandA", value: function(t3) {
                if (this.Editor.RectangleSelection.clearSelection(), !f.default.isNativeInput(t3.target) || this.readyToBlockSelection) {
                  var e3 = this.Editor.BlockManager.getBlock(t3.target).inputs;
                  e3.length > 1 && !this.readyToBlockSelection ? this.readyToBlockSelection = true : 1 !== e3.length || this.needToSelectAll ? this.needToSelectAll ? (t3.preventDefault(), this.selectAllBlocks(), this.needToSelectAll = false, this.readyToBlockSelection = false, this.Editor.ConversionToolbar.close()) : this.readyToBlockSelection && (t3.preventDefault(), this.selectBlockByIndex(), this.needToSelectAll = true) : this.needToSelectAll = true;
                } else
                  this.readyToBlockSelection = true;
              } }, { key: "selectAllBlocks", value: function() {
                this.selection.save(), p.default.get().removeAllRanges(), this.allBlocksSelected = true, this.Editor.InlineToolbar.close();
              } }, { key: "sanitizerConfig", get: function() {
                return { p: {}, h1: {}, h2: {}, h3: {}, h4: {}, h5: {}, h6: {}, ol: {}, ul: {}, li: {}, br: true, img: { src: true, width: true, height: true }, a: { href: true }, b: {}, i: {}, u: {} };
              } }, { key: "allBlocksSelected", get: function() {
                return this.Editor.BlockManager.blocks.every(function(t3) {
                  return true === t3.selected;
                });
              }, set: function(t3) {
                this.Editor.BlockManager.blocks.forEach(function(e3) {
                  e3.selected = t3;
                }), this.clearCache();
              } }, { key: "anyBlockSelected", get: function() {
                var t3 = this.Editor.BlockManager;
                return null === this.anyBlockSelectedCache && (this.anyBlockSelectedCache = t3.blocks.some(function(t4) {
                  return true === t4.selected;
                })), this.anyBlockSelectedCache;
              } }, { key: "selectedBlocks", get: function() {
                return this.Editor.BlockManager.blocks.filter(function(t3) {
                  return t3.selected;
                });
              } }]), o3;
            }(c.default);
            o2.default = b, b.displayName = "BlockSelection", t.exports = e.default;
          }) ? o.apply(e, r) : o) || (t.exports = i);
        }, function(t, e, n) {
          var o, r, i;
          "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self && self, r = [e, n(2), n(3), n(5), n(6), n(4), n(25), n(9), n(14), n(7)], void 0 === (i = "function" == typeof (o = function(o2, r2, i2, a, s, l, c, u, f, d) {
            "use strict";
            var p = n(8), h = n(1);
            function v() {
              if ("undefined" == typeof Reflect || !Reflect.construct)
                return false;
              if (Reflect.construct.sham)
                return false;
              if ("function" == typeof Proxy)
                return true;
              try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
                })), true;
              } catch (t2) {
                return false;
              }
            }
            Object.defineProperty(o2, "__esModule", { value: true }), o2.default = void 0, r2 = h(r2), i2 = h(i2), a = h(a), s = h(s), l = h(l), c = h(c), u = h(u), f = h(f), d = p(d);
            var g = function(t2) {
              (0, a.default)(o3, t2);
              var e2, n2 = (e2 = o3, function() {
                var t3, n3 = (0, l.default)(e2);
                if (v()) {
                  var o4 = (0, l.default)(this).constructor;
                  t3 = Reflect.construct(n3, arguments, o4);
                } else
                  t3 = n3.apply(this, arguments);
                return (0, s.default)(this, t3);
              });
              function o3() {
                return (0, r2.default)(this, o3), n2.apply(this, arguments);
              }
              return (0, i2.default)(o3, [{ key: "setToBlock", value: function(t3) {
                var e3, n3 = this, o4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.positions.DEFAULT, r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, i3 = this.Editor.BlockManager;
                switch (o4) {
                  case this.positions.START:
                    e3 = t3.firstInput;
                    break;
                  case this.positions.END:
                    e3 = t3.lastInput;
                    break;
                  default:
                    e3 = t3.currentInput;
                }
                if (e3) {
                  var a2 = f.default.getDeepestNode(e3, o4 === this.positions.END), s2 = f.default.getContentLength(a2);
                  switch (true) {
                    case o4 === this.positions.START:
                      r3 = 0;
                      break;
                    case o4 === this.positions.END:
                    case r3 > s2:
                      r3 = s2;
                  }
                  d.delay(function() {
                    n3.set(a2, r3);
                  }, 20)(), i3.setCurrentBlockByChildNode(t3.holder), i3.currentBlock.currentInput = e3;
                }
              } }, { key: "setToInput", value: function(t3) {
                var e3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.positions.DEFAULT, n3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, o4 = this.Editor.BlockManager.currentBlock, r3 = f.default.getDeepestNode(t3);
                switch (e3) {
                  case this.positions.START:
                    this.set(r3, 0);
                    break;
                  case this.positions.END:
                    this.set(r3, f.default.getContentLength(r3));
                    break;
                  default:
                    n3 && this.set(r3, n3);
                }
                o4.currentInput = t3;
              } }, { key: "set", value: function(t3) {
                var e3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, n3 = c.default.setCursor(t3, e3), o4 = n3.top, r3 = n3.bottom, i3 = window, a2 = i3.innerHeight;
                o4 < 0 && window.scrollBy(0, o4), r3 > a2 && window.scrollBy(0, r3 - a2);
              } }, { key: "setToTheLastBlock", value: function() {
                var t3 = this.Editor.BlockManager.lastBlock;
                if (t3)
                  if (t3.tool.isDefault && t3.isEmpty)
                    this.setToBlock(t3);
                  else {
                    var e3 = this.Editor.BlockManager.insertAtEnd();
                    this.setToBlock(e3);
                  }
              } }, { key: "extractFragmentFromCaretPosition", value: function() {
                var t3 = c.default.get();
                if (t3.rangeCount) {
                  var e3 = t3.getRangeAt(0), n3 = this.Editor.BlockManager.currentBlock.currentInput;
                  if (e3.deleteContents(), n3) {
                    if (f.default.isNativeInput(n3)) {
                      var o4 = n3, r3 = document.createDocumentFragment(), i3 = o4.value.substring(0, o4.selectionStart), a2 = o4.value.substring(o4.selectionStart);
                      return r3.textContent = a2, o4.value = i3, r3;
                    }
                    var s2 = e3.cloneRange();
                    return s2.selectNodeContents(n3), s2.setStart(e3.endContainer, e3.endOffset), s2.extractContents();
                  }
                }
              } }, { key: "navigateNext", value: function() {
                var t3 = this.Editor.BlockManager, e3 = t3.currentBlock, n3 = t3.nextContentfulBlock, o4 = e3.nextInput, r3 = this.isAtEnd, i3 = n3;
                if (!i3 && !o4) {
                  if (e3.tool.isDefault || !r3)
                    return false;
                  i3 = t3.insertAtEnd();
                }
                return !!r3 && (o4 ? this.setToInput(o4, this.positions.START) : this.setToBlock(i3, this.positions.START), true);
              } }, { key: "navigatePrevious", value: function() {
                var t3 = this.Editor.BlockManager, e3 = t3.currentBlock, n3 = t3.previousContentfulBlock;
                if (!e3)
                  return false;
                var o4 = e3.previousInput;
                return !(!n3 && !o4 || !this.isAtStart || (o4 ? this.setToInput(o4, this.positions.END) : this.setToBlock(n3, this.positions.END), 0));
              } }, { key: "createShadow", value: function(t3) {
                var e3 = document.createElement("span");
                e3.classList.add(o3.CSS.shadowCaret), t3.insertAdjacentElement("beforeend", e3);
              } }, { key: "restoreCaret", value: function(t3) {
                var e3 = t3.querySelector(".".concat(o3.CSS.shadowCaret));
                e3 && (new c.default().expandToTag(e3), setTimeout(function() {
                  var t4 = document.createRange();
                  t4.selectNode(e3), t4.extractContents();
                }, 50));
              } }, { key: "insertContentAtCaretPosition", value: function(t3) {
                var e3 = document.createDocumentFragment(), n3 = document.createElement("div"), o4 = c.default.get(), r3 = c.default.range;
                n3.innerHTML = t3, Array.from(n3.childNodes).forEach(function(t4) {
                  return e3.appendChild(t4);
                }), 0 === e3.childNodes.length && e3.appendChild(new Text());
                var i3 = e3.lastChild;
                r3.deleteContents(), r3.insertNode(e3);
                var a2 = document.createRange();
                a2.setStart(i3, i3.textContent.length), o4.removeAllRanges(), o4.addRange(a2);
              } }, { key: "getHigherLevelSiblings", value: function(t3, e3) {
                for (var n3 = t3, o4 = []; n3.parentNode && "true" !== n3.parentNode.contentEditable; )
                  n3 = n3.parentNode;
                for (var r3 = "left" === e3 ? "previousSibling" : "nextSibling"; n3[r3]; )
                  n3 = n3[r3], o4.push(n3);
                return o4;
              } }, { key: "positions", get: function() {
                return { START: "start", END: "end", DEFAULT: "default" };
              } }, { key: "isAtStart", get: function() {
                var t3 = c.default.get(), e3 = f.default.getDeepestNode(this.Editor.BlockManager.currentBlock.currentInput), n3 = t3.focusNode;
                if (f.default.isNativeInput(e3))
                  return 0 === e3.selectionEnd;
                if (!t3.anchorNode)
                  return false;
                var o4 = n3.textContent.search(/\S/);
                -1 === o4 && (o4 = 0);
                var r3 = t3.focusOffset;
                return n3.nodeType !== Node.TEXT_NODE && n3.childNodes.length && (n3.childNodes[r3] ? (n3 = n3.childNodes[r3], r3 = 0) : r3 = (n3 = n3.childNodes[r3 - 1]).textContent.length), !(!f.default.isLineBreakTag(e3) && !f.default.isEmpty(e3) || !this.getHigherLevelSiblings(n3, "left").every(function(t4) {
                  var e4 = f.default.isLineBreakTag(t4), n4 = 1 === t4.children.length && f.default.isLineBreakTag(t4.children[0]), o5 = e4 || n4;
                  return f.default.isEmpty(t4) && !o5;
                }) || r3 !== o4) || (null === e3 || n3 === e3 && r3 <= o4);
              } }, { key: "isAtEnd", get: function() {
                var t3 = c.default.get(), e3 = t3.focusNode, n3 = f.default.getDeepestNode(this.Editor.BlockManager.currentBlock.currentInput, true);
                if (f.default.isNativeInput(n3))
                  return n3.selectionEnd === n3.value.length;
                if (!t3.focusNode)
                  return false;
                var o4 = t3.focusOffset;
                if (e3.nodeType !== Node.TEXT_NODE && e3.childNodes.length && (e3.childNodes[o4 - 1] ? o4 = (e3 = e3.childNodes[o4 - 1]).textContent.length : (e3 = e3.childNodes[0], o4 = 0)), f.default.isLineBreakTag(n3) || f.default.isEmpty(n3)) {
                  var r3 = this.getHigherLevelSiblings(e3, "right");
                  if (r3.every(function(t4, e4) {
                    return e4 === r3.length - 1 && f.default.isLineBreakTag(t4) || f.default.isEmpty(t4) && !f.default.isLineBreakTag(t4);
                  }) && o4 === e3.textContent.length)
                    return true;
                }
                var i3 = n3.textContent.replace(/\s+$/, "");
                return e3 === n3 && o4 >= i3.length;
              } }], [{ key: "CSS", get: function() {
                return { shadowCaret: "cdx-shadow-caret" };
              } }]), o3;
            }(u.default);
            o2.default = g, g.displayName = "Caret", t.exports = e.default;
          }) ? o.apply(e, r) : o) || (t.exports = i);
        }, function(t, e, n) {
          var o, r, i;
          "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self && self, r = [e, n(20), n(21), n(2), n(3), n(5), n(6), n(4), n(9), n(25), n(7)], void 0 === (i = "function" == typeof (o = function(o2, r2, i2, a, s, l, c, u, f, d, p) {
            "use strict";
            var h = n(8), v = n(1);
            function g() {
              if ("undefined" == typeof Reflect || !Reflect.construct)
                return false;
              if (Reflect.construct.sham)
                return false;
              if ("function" == typeof Proxy)
                return true;
              try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
                })), true;
              } catch (t2) {
                return false;
              }
            }
            Object.defineProperty(o2, "__esModule", { value: true }), o2.default = void 0, r2 = v(r2), i2 = v(i2), a = v(a), s = v(s), l = v(l), c = v(c), u = v(u), f = v(f), d = v(d), p = h(p);
            var y = function(t2) {
              (0, l.default)(f2, t2);
              var e2, n2, o3 = (e2 = f2, function() {
                var t3, n3 = (0, u.default)(e2);
                if (g()) {
                  var o4 = (0, u.default)(this).constructor;
                  t3 = Reflect.construct(n3, arguments, o4);
                } else
                  t3 = n3.apply(this, arguments);
                return (0, c.default)(this, t3);
              });
              function f2() {
                var t3;
                return (0, a.default)(this, f2), (t3 = o3.apply(this, arguments)).onMouseUp = function() {
                  t3.listeners.off(document, "mouseover", t3.onMouseOver), t3.listeners.off(document, "mouseup", t3.onMouseUp);
                }, t3.onMouseOver = function(e3) {
                  var n3 = t3.Editor, o4 = n3.BlockManager, r3 = n3.BlockSelection, i3 = o4.getBlockByChildNode(e3.relatedTarget) || t3.lastSelectedBlock, a2 = o4.getBlockByChildNode(e3.target);
                  if (i3 && a2 && a2 !== i3) {
                    if (i3 === t3.firstSelectedBlock)
                      return d.default.get().removeAllRanges(), i3.selected = true, a2.selected = true, void r3.clearCache();
                    if (a2 === t3.firstSelectedBlock)
                      return i3.selected = false, a2.selected = false, void r3.clearCache();
                    t3.Editor.InlineToolbar.close(), t3.toggleBlocksSelectedState(i3, a2), t3.lastSelectedBlock = a2;
                  }
                }, t3;
              }
              return (0, s.default)(f2, [{ key: "prepare", value: (n2 = (0, i2.default)(r2.default.mark(function t3() {
                var e3 = this;
                return r2.default.wrap(function(t4) {
                  for (; ; )
                    switch (t4.prev = t4.next) {
                      case 0:
                        this.listeners.on(document, "mousedown", function(t5) {
                          e3.enableCrossBlockSelection(t5);
                        });
                      case 1:
                      case "end":
                        return t4.stop();
                    }
                }, t3, this);
              })), function() {
                return n2.apply(this, arguments);
              }) }, { key: "watchSelection", value: function(t3) {
                if (t3.button === p.mouseButtons.LEFT) {
                  var e3 = this.Editor.BlockManager;
                  this.firstSelectedBlock = e3.getBlock(t3.target), this.lastSelectedBlock = this.firstSelectedBlock, this.listeners.on(document, "mouseover", this.onMouseOver), this.listeners.on(document, "mouseup", this.onMouseUp);
                }
              } }, { key: "toggleBlockSelectedState", value: function() {
                var t3 = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0], e3 = this.Editor, n3 = e3.BlockManager, o4 = e3.BlockSelection;
                this.lastSelectedBlock || (this.lastSelectedBlock = this.firstSelectedBlock = n3.currentBlock), this.firstSelectedBlock === this.lastSelectedBlock && (this.firstSelectedBlock.selected = true, o4.clearCache(), d.default.get().removeAllRanges());
                var r3 = n3.blocks.indexOf(this.lastSelectedBlock) + (t3 ? 1 : -1), i3 = n3.blocks[r3];
                i3 && (this.lastSelectedBlock.selected !== i3.selected ? (i3.selected = true, o4.clearCache()) : (this.lastSelectedBlock.selected = false, o4.clearCache()), this.lastSelectedBlock = i3, this.Editor.InlineToolbar.close(), i3.holder.scrollIntoView({ block: "nearest" }));
              } }, { key: "clear", value: function(t3) {
                var e3 = this.Editor, n3 = e3.BlockManager, o4 = e3.BlockSelection, r3 = e3.Caret, i3 = n3.blocks.indexOf(this.firstSelectedBlock), a2 = n3.blocks.indexOf(this.lastSelectedBlock);
                if (o4.anyBlockSelected && i3 > -1 && a2 > -1)
                  if (t3 && t3 instanceof KeyboardEvent)
                    switch (t3.keyCode) {
                      case p.keyCodes.DOWN:
                      case p.keyCodes.RIGHT:
                        r3.setToBlock(n3.blocks[Math.max(i3, a2)], r3.positions.END);
                        break;
                      case p.keyCodes.UP:
                      case p.keyCodes.LEFT:
                        r3.setToBlock(n3.blocks[Math.min(i3, a2)], r3.positions.START);
                        break;
                      default:
                        r3.setToBlock(n3.blocks[Math.max(i3, a2)], r3.positions.END);
                    }
                  else
                    r3.setToBlock(n3.blocks[Math.max(i3, a2)], r3.positions.END);
                this.firstSelectedBlock = this.lastSelectedBlock = null;
              } }, { key: "enableCrossBlockSelection", value: function(t3) {
                var e3 = this.Editor.UI;
                d.default.isCollapsed || this.Editor.BlockSelection.clearSelection(t3), e3.nodes.redactor.contains(t3.target) ? this.watchSelection(t3) : this.Editor.BlockSelection.clearSelection(t3);
              } }, { key: "toggleBlocksSelectedState", value: function(t3, e3) {
                for (var n3 = this.Editor, o4 = n3.BlockManager, r3 = n3.BlockSelection, i3 = o4.blocks.indexOf(t3), a2 = o4.blocks.indexOf(e3), s2 = t3.selected !== e3.selected, l2 = Math.min(i3, a2); l2 <= Math.max(i3, a2); l2++) {
                  var c2 = o4.blocks[l2];
                  c2 !== this.firstSelectedBlock && c2 !== (s2 ? t3 : e3) && (o4.blocks[l2].selected = !o4.blocks[l2].selected, r3.clearCache());
                }
              } }, { key: "isCrossBlockSelectionStarted", get: function() {
                return !!this.firstSelectedBlock && !!this.lastSelectedBlock;
              } }]), f2;
            }(f.default);
            o2.default = y, y.displayName = "CrossBlockSelection", t.exports = e.default;
          }) ? o.apply(e, r) : o) || (t.exports = i);
        }, function(t, e, n) {
          var o, r, i;
          "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self && self, r = [e, n(20), n(21), n(2), n(3), n(5), n(6), n(4), n(25), n(9)], void 0 === (i = "function" == typeof (o = function(o2, r2, i2, a, s, l, c, u, f, d) {
            "use strict";
            var p = n(1);
            function h() {
              if ("undefined" == typeof Reflect || !Reflect.construct)
                return false;
              if (Reflect.construct.sham)
                return false;
              if ("function" == typeof Proxy)
                return true;
              try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
                })), true;
              } catch (t2) {
                return false;
              }
            }
            Object.defineProperty(o2, "__esModule", { value: true }), o2.default = void 0, r2 = p(r2), i2 = p(i2), a = p(a), s = p(s), l = p(l), c = p(c), u = p(u), f = p(f);
            var v = function(t2) {
              (0, l.default)(d2, t2);
              var e2, n2, o3 = (e2 = d2, function() {
                var t3, n3 = (0, u.default)(e2);
                if (h()) {
                  var o4 = (0, u.default)(this).constructor;
                  t3 = Reflect.construct(n3, arguments, o4);
                } else
                  t3 = n3.apply(this, arguments);
                return (0, c.default)(this, t3);
              });
              function d2() {
                var t3;
                return (0, a.default)(this, d2), (t3 = o3.apply(this, arguments)).isStartedAtEditor = false, t3;
              }
              return (0, s.default)(d2, [{ key: "toggleReadOnly", value: function(t3) {
                t3 ? this.disableModuleBindings() : this.enableModuleBindings();
              } }, { key: "enableModuleBindings", value: function() {
                var t3 = this, e3 = this.Editor.UI;
                this.readOnlyMutableListeners.on(e3.nodes.holder, "drop", function() {
                  var e4 = (0, i2.default)(r2.default.mark(function e5(n3) {
                    return r2.default.wrap(function(e6) {
                      for (; ; )
                        switch (e6.prev = e6.next) {
                          case 0:
                            return e6.next = 2, t3.processDrop(n3);
                          case 2:
                          case "end":
                            return e6.stop();
                        }
                    }, e5);
                  }));
                  return function(t4) {
                    return e4.apply(this, arguments);
                  };
                }(), true), this.readOnlyMutableListeners.on(e3.nodes.holder, "dragstart", function() {
                  t3.processDragStart();
                }), this.readOnlyMutableListeners.on(e3.nodes.holder, "dragover", function(e4) {
                  t3.processDragOver(e4);
                }, true);
              } }, { key: "disableModuleBindings", value: function() {
                this.readOnlyMutableListeners.clearAll();
              } }, { key: "processDrop", value: (n2 = (0, i2.default)(r2.default.mark(function t3(e3) {
                var n3, o4, i3, a2, s2, l2;
                return r2.default.wrap(function(t4) {
                  for (; ; )
                    switch (t4.prev = t4.next) {
                      case 0:
                        return n3 = this.Editor, o4 = n3.BlockManager, i3 = n3.Caret, a2 = n3.Paste, e3.preventDefault(), o4.blocks.forEach(function(t5) {
                          t5.dropTarget = false;
                        }), f.default.isAtEditor && !f.default.isCollapsed && this.isStartedAtEditor && document.execCommand("delete"), this.isStartedAtEditor = false, (s2 = o4.setCurrentBlockByChildNode(e3.target)) ? this.Editor.Caret.setToBlock(s2, i3.positions.END) : (l2 = o4.setCurrentBlockByChildNode(o4.lastBlock.holder), this.Editor.Caret.setToBlock(l2, i3.positions.END)), t4.next = 9, a2.processDataTransfer(e3.dataTransfer, true);
                      case 9:
                      case "end":
                        return t4.stop();
                    }
                }, t3, this);
              })), function(t3) {
                return n2.apply(this, arguments);
              }) }, { key: "processDragStart", value: function() {
                f.default.isAtEditor && !f.default.isCollapsed && (this.isStartedAtEditor = true), this.Editor.InlineToolbar.close();
              } }, { key: "processDragOver", value: function(t3) {
                t3.preventDefault();
              } }]), d2;
            }((d = p(d)).default);
            o2.default = v, v.displayName = "DragNDrop", t.exports = e.default;
          }) ? o.apply(e, r) : o) || (t.exports = i);
        }, function(t, e, n) {
          var o, r, i;
          "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self && self, r = [e, n(2), n(3), n(5), n(6), n(4), n(9), n(7)], void 0 === (i = "function" == typeof (o = function(o2, r2, i2, a, s, l, c, u) {
            "use strict";
            var f = n(8), d = n(1);
            function p() {
              if ("undefined" == typeof Reflect || !Reflect.construct)
                return false;
              if (Reflect.construct.sham)
                return false;
              if ("function" == typeof Proxy)
                return true;
              try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
                })), true;
              } catch (t2) {
                return false;
              }
            }
            Object.defineProperty(o2, "__esModule", { value: true }), o2.default = void 0, r2 = d(r2), i2 = d(i2), a = d(a), s = d(s), l = d(l), c = d(c), u = f(u);
            var h = function(t2) {
              (0, a.default)(o3, t2);
              var e2, n2 = (e2 = o3, function() {
                var t3, n3 = (0, l.default)(e2);
                if (p()) {
                  var o4 = (0, l.default)(this).constructor;
                  t3 = Reflect.construct(n3, arguments, o4);
                } else
                  t3 = n3.apply(this, arguments);
                return (0, s.default)(this, t3);
              });
              function o3() {
                var t3;
                return (0, r2.default)(this, o3), (t3 = n2.apply(this, arguments)).disabled = false, t3;
              }
              return (0, i2.default)(o3, [{ key: "enable", value: function() {
                this.disabled = false;
              } }, { key: "disable", value: function() {
                this.disabled = true;
              } }, { key: "onChange", value: function(t3) {
                !this.disabled && u.isFunction(this.config.onChange) && this.config.onChange(this.Editor.API.methods, t3);
              } }]), o3;
            }(c.default);
            o2.default = h, h.displayName = "ModificationsObserver", t.exports = e.default;
          }) ? o.apply(e, r) : o) || (t.exports = i);
        }, function(t, e, n) {
          var o, r, i;
          "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self && self, r = [e, n(42), n(30), n(20), n(21), n(2), n(3), n(5), n(6), n(4), n(9), n(14), n(7), n(67)], void 0 === (i = "function" == typeof (o = function(o2, r2, i2, a, s, l, c, u, f, d, p, h, v, g) {
            "use strict";
            var y = n(8), b = n(1);
            function m() {
              if ("undefined" == typeof Reflect || !Reflect.construct)
                return false;
              if (Reflect.construct.sham)
                return false;
              if ("function" == typeof Proxy)
                return true;
              try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
                })), true;
              } catch (t2) {
                return false;
              }
            }
            Object.defineProperty(o2, "__esModule", { value: true }), o2.default = void 0, r2 = b(r2), i2 = b(i2), a = b(a), s = b(s), l = b(l), c = b(c), u = b(u), f = b(f), d = b(d), p = b(p), h = b(h), v = y(v);
            var k = function(t2) {
              (0, u.default)(T, t2);
              var e2, n2, o3, p2, y2, b2, k2, x, w, S = (e2 = T, function() {
                var t3, n3 = (0, d.default)(e2);
                if (m()) {
                  var o4 = (0, d.default)(this).constructor;
                  t3 = Reflect.construct(n3, arguments, o4);
                } else
                  t3 = n3.apply(this, arguments);
                return (0, f.default)(this, t3);
              });
              function T() {
                var t3;
                return (0, l.default)(this, T), (t3 = S.apply(this, arguments)).MIME_TYPE = "application/x-editor-js", t3.toolsTags = {}, t3.tagsByTool = {}, t3.toolsPatterns = [], t3.toolsFiles = {}, t3.exceptionList = [], t3.processTool = function(e3) {
                  try {
                    var n3 = e3.create({}, {}, false);
                    if (false === e3.pasteConfig)
                      return void t3.exceptionList.push(e3.name);
                    if (!v.isFunction(n3.onPaste))
                      return;
                    t3.getTagsConfig(e3), t3.getFilesConfig(e3), t3.getPatternsConfig(e3);
                  } catch (t4) {
                    v.log("Paste handling for \xAB".concat(e3.name, "\xBB Tool hasn't been set up because of the error"), "warn", t4);
                  }
                }, t3.handlePasteEvent = function() {
                  var e3 = (0, s.default)(a.default.mark(function e4(n3) {
                    var o4, r3, i3;
                    return a.default.wrap(function(e5) {
                      for (; ; )
                        switch (e5.prev = e5.next) {
                          case 0:
                            if (o4 = t3.Editor, r3 = o4.BlockManager, i3 = o4.Toolbar, r3.currentBlock && (!t3.isNativeBehaviour(n3.target) || n3.clipboardData.types.includes("Files"))) {
                              e5.next = 3;
                              break;
                            }
                            return e5.abrupt("return");
                          case 3:
                            if (!r3.currentBlock || !t3.exceptionList.includes(r3.currentBlock.name)) {
                              e5.next = 5;
                              break;
                            }
                            return e5.abrupt("return");
                          case 5:
                            n3.preventDefault(), t3.processDataTransfer(n3.clipboardData), r3.clearFocused(), i3.close();
                          case 9:
                          case "end":
                            return e5.stop();
                        }
                    }, e4);
                  }));
                  return function(t4) {
                    return e3.apply(this, arguments);
                  };
                }(), t3;
              }
              return (0, c.default)(T, [{ key: "prepare", value: (w = (0, s.default)(a.default.mark(function t3() {
                return a.default.wrap(function(t4) {
                  for (; ; )
                    switch (t4.prev = t4.next) {
                      case 0:
                        this.processTools();
                      case 1:
                      case "end":
                        return t4.stop();
                    }
                }, t3, this);
              })), function() {
                return w.apply(this, arguments);
              }) }, { key: "toggleReadOnly", value: function(t3) {
                t3 ? this.unsetCallback() : this.setCallback();
              } }, { key: "processDataTransfer", value: (x = (0, s.default)(a.default.mark(function t3(e3) {
                var n3, o4, r3, i3, s2, l2, c2, u2, f2, d2 = arguments;
                return a.default.wrap(function(t4) {
                  for (; ; )
                    switch (t4.prev = t4.next) {
                      case 0:
                        if (n3 = d2.length > 1 && void 0 !== d2[1] && d2[1], o4 = this.Editor.Tools, !((r3 = e3.types).includes ? r3.includes("Files") : r3.contains("Files"))) {
                          t4.next = 8;
                          break;
                        }
                        return t4.next = 7, this.processFiles(e3.files);
                      case 7:
                        return t4.abrupt("return");
                      case 8:
                        if (i3 = e3.getData(this.MIME_TYPE), s2 = e3.getData("text/plain"), l2 = e3.getData("text/html"), !i3) {
                          t4.next = 19;
                          break;
                        }
                        return t4.prev = 12, this.insertEditorJSData(JSON.parse(i3)), t4.abrupt("return");
                      case 17:
                        t4.prev = 17, t4.t0 = t4.catch(12);
                      case 19:
                        if (n3 && s2.trim() && l2.trim() && (l2 = "<p>" + (l2.trim() ? l2 : s2) + "</p>"), c2 = Object.keys(this.toolsTags).reduce(function(t5, e4) {
                          return t5[e4.toLowerCase()] = true, t5;
                        }, {}), u2 = Object.assign({}, c2, o4.getAllInlineToolsSanitizeConfig(), { br: {} }), (f2 = (0, g.clean)(l2, u2)).trim() && f2.trim() !== s2 && h.default.isHTMLString(f2)) {
                          t4.next = 28;
                          break;
                        }
                        return t4.next = 26, this.processText(s2);
                      case 26:
                        t4.next = 30;
                        break;
                      case 28:
                        return t4.next = 30, this.processText(f2, true);
                      case 30:
                      case "end":
                        return t4.stop();
                    }
                }, t3, this, [[12, 17]]);
              })), function(t3) {
                return x.apply(this, arguments);
              }) }, { key: "processText", value: (k2 = (0, s.default)(a.default.mark(function t3(e3) {
                var n3, o4, r3, i3, l2, c2, u2, f2 = this, d2 = arguments;
                return a.default.wrap(function(t4) {
                  for (; ; )
                    switch (t4.prev = t4.next) {
                      case 0:
                        if (n3 = d2.length > 1 && void 0 !== d2[1] && d2[1], o4 = this.Editor, r3 = o4.Caret, i3 = o4.BlockManager, (l2 = n3 ? this.processHTML(e3) : this.processPlain(e3)).length) {
                          t4.next = 5;
                          break;
                        }
                        return t4.abrupt("return");
                      case 5:
                        if (1 !== l2.length) {
                          t4.next = 8;
                          break;
                        }
                        return l2[0].isBlock ? this.processSingleBlock(l2.pop()) : this.processInlinePaste(l2.pop()), t4.abrupt("return");
                      case 8:
                        c2 = i3.currentBlock && i3.currentBlock.tool.isDefault, u2 = c2 && i3.currentBlock.isEmpty, l2.map(function() {
                          var t5 = (0, s.default)(a.default.mark(function t6(e4, n4) {
                            return a.default.wrap(function(t7) {
                              for (; ; )
                                switch (t7.prev = t7.next) {
                                  case 0:
                                    return t7.abrupt("return", f2.insertBlock(e4, 0 === n4 && u2));
                                  case 1:
                                  case "end":
                                    return t7.stop();
                                }
                            }, t6);
                          }));
                          return function(e4, n4) {
                            return t5.apply(this, arguments);
                          };
                        }()), i3.currentBlock && r3.setToBlock(i3.currentBlock, r3.positions.END);
                      case 12:
                      case "end":
                        return t4.stop();
                    }
                }, t3, this);
              })), function(t3) {
                return k2.apply(this, arguments);
              }) }, { key: "setCallback", value: function() {
                this.listeners.on(this.Editor.UI.nodes.holder, "paste", this.handlePasteEvent);
              } }, { key: "unsetCallback", value: function() {
                this.listeners.off(this.Editor.UI.nodes.holder, "paste", this.handlePasteEvent);
              } }, { key: "processTools", value: function() {
                var t3 = this.Editor.Tools.blockTools;
                Array.from(t3.values()).forEach(this.processTool);
              } }, { key: "getTagsConfig", value: function(t3) {
                var e3 = this, n3 = t3.pasteConfig.tags || [];
                n3.forEach(function(n4) {
                  Object.prototype.hasOwnProperty.call(e3.toolsTags, n4) ? v.log("Paste handler for \xAB".concat(t3.name, "\xBB Tool on \xAB").concat(n4, "\xBB tag is skipped ") + "because it is already used by \xAB".concat(e3.toolsTags[n4].tool.name, "\xBB Tool."), "warn") : e3.toolsTags[n4.toUpperCase()] = { tool: t3 };
                }), this.tagsByTool[t3.name] = n3.map(function(t4) {
                  return t4.toUpperCase();
                });
              } }, { key: "getFilesConfig", value: function(t3) {
                var e3 = t3.pasteConfig.files, n3 = void 0 === e3 ? {} : e3, o4 = n3.extensions, r3 = n3.mimeTypes;
                (o4 || r3) && (o4 && !Array.isArray(o4) && (v.log("\xABextensions\xBB property of the onDrop config for \xAB".concat(t3.name, "\xBB Tool should be an array")), o4 = []), r3 && !Array.isArray(r3) && (v.log("\xABmimeTypes\xBB property of the onDrop config for \xAB".concat(t3.name, "\xBB Tool should be an array")), r3 = []), r3 && (r3 = r3.filter(function(e4) {
                  return !!v.isValidMimeType(e4) || (v.log("MIME type value \xAB".concat(e4, "\xBB for the \xAB").concat(t3.name, "\xBB Tool is not a valid MIME type"), "warn"), false);
                })), this.toolsFiles[t3.name] = { extensions: o4 || [], mimeTypes: r3 || [] });
              } }, { key: "getPatternsConfig", value: function(t3) {
                var e3 = this;
                t3.pasteConfig.patterns && !v.isEmpty(t3.pasteConfig.patterns) && Object.entries(t3.pasteConfig.patterns).forEach(function(n3) {
                  var o4 = (0, i2.default)(n3, 2), r3 = o4[0], a2 = o4[1];
                  a2 instanceof RegExp || v.log("Pattern ".concat(a2, " for \xAB").concat(t3.name, "\xBB Tool is skipped because it should be a Regexp instance."), "warn"), e3.toolsPatterns.push({ key: r3, pattern: a2, tool: t3 });
                });
              } }, { key: "isNativeBehaviour", value: function(t3) {
                return h.default.isNativeInput(t3);
              } }, { key: "processFiles", value: (b2 = (0, s.default)(a.default.mark(function t3(e3) {
                var n3, o4, r3, i3, s2 = this;
                return a.default.wrap(function(t4) {
                  for (; ; )
                    switch (t4.prev = t4.next) {
                      case 0:
                        return n3 = this.Editor.BlockManager, t4.next = 3, Promise.all(Array.from(e3).map(function(t5) {
                          return s2.processFile(t5);
                        }));
                      case 3:
                        o4 = (o4 = t4.sent).filter(function(t5) {
                          return !!t5;
                        }), r3 = n3.currentBlock.tool.isDefault, i3 = r3 && n3.currentBlock.isEmpty, o4.forEach(function(t5, e4) {
                          n3.paste(t5.type, t5.event, 0 === e4 && i3);
                        });
                      case 8:
                      case "end":
                        return t4.stop();
                    }
                }, t3, this);
              })), function(t3) {
                return b2.apply(this, arguments);
              }) }, { key: "processFile", value: (y2 = (0, s.default)(a.default.mark(function t3(e3) {
                var n3, o4, r3, s2, l2;
                return a.default.wrap(function(t4) {
                  for (; ; )
                    switch (t4.prev = t4.next) {
                      case 0:
                        if (n3 = v.getFileExtension(e3), o4 = Object.entries(this.toolsFiles).find(function(t5) {
                          var o5 = (0, i2.default)(t5, 2), r4 = (o5[0], o5[1]), a2 = r4.mimeTypes, s3 = r4.extensions, l3 = e3.type.split("/"), c2 = (0, i2.default)(l3, 2), u2 = c2[0], f2 = c2[1], d2 = s3.find(function(t6) {
                            return t6.toLowerCase() === n3.toLowerCase();
                          }), p3 = a2.find(function(t6) {
                            var e4 = t6.split("/"), n4 = (0, i2.default)(e4, 2), o6 = n4[0], r5 = n4[1];
                            return o6 === u2 && (r5 === f2 || "*" === r5);
                          });
                          return !!d2 || !!p3;
                        })) {
                          t4.next = 4;
                          break;
                        }
                        return t4.abrupt("return");
                      case 4:
                        return r3 = (0, i2.default)(o4, 1), s2 = r3[0], l2 = this.composePasteEvent("file", { file: e3 }), t4.abrupt("return", { event: l2, type: s2 });
                      case 7:
                      case "end":
                        return t4.stop();
                    }
                }, t3, this);
              })), function(t3) {
                return y2.apply(this, arguments);
              }) }, { key: "processHTML", value: function(t3) {
                var e3 = this, n3 = this.Editor.Tools, o4 = h.default.make("DIV");
                return o4.innerHTML = t3, this.getNodes(o4).map(function(t4) {
                  var o5, r3 = n3.defaultTool, i3 = false;
                  switch (t4.nodeType) {
                    case Node.DOCUMENT_FRAGMENT_NODE:
                      (o5 = h.default.make("div")).appendChild(t4);
                      break;
                    case Node.ELEMENT_NODE:
                      o5 = t4, i3 = true, e3.toolsTags[o5.tagName] && (r3 = e3.toolsTags[o5.tagName].tool);
                  }
                  var a2 = r3.pasteConfig.tags.reduce(function(t5, e4) {
                    return t5[e4.toLowerCase()] = {}, t5;
                  }, {}), s2 = Object.assign({}, a2, r3.baseSanitizeConfig);
                  o5.innerHTML = (0, g.clean)(o5.innerHTML, s2);
                  var l2 = e3.composePasteEvent("tag", { data: o5 });
                  return { content: o5, isBlock: i3, tool: r3.name, event: l2 };
                }).filter(function(t4) {
                  return !h.default.isNodeEmpty(t4.content) || h.default.isSingleTag(t4.content);
                });
              } }, { key: "processPlain", value: function(t3) {
                var e3 = this, n3 = this.config.defaultBlock;
                if (!t3)
                  return [];
                var o4 = n3;
                return t3.split(/\r?\n/).filter(function(t4) {
                  return t4.trim();
                }).map(function(t4) {
                  var n4 = h.default.make("div");
                  n4.textContent = t4;
                  var r3 = e3.composePasteEvent("tag", { data: n4 });
                  return { content: n4, tool: o4, isBlock: false, event: r3 };
                });
              } }, { key: "processSingleBlock", value: (p2 = (0, s.default)(a.default.mark(function t3(e3) {
                var n3, o4, r3, i3;
                return a.default.wrap(function(t4) {
                  for (; ; )
                    switch (t4.prev = t4.next) {
                      case 0:
                        if (n3 = this.Editor, o4 = n3.Caret, r3 = n3.BlockManager, (i3 = r3.currentBlock) && e3.tool === i3.name && h.default.containsOnlyInlineElements(e3.content.innerHTML)) {
                          t4.next = 5;
                          break;
                        }
                        return this.insertBlock(e3, (null == i3 ? void 0 : i3.tool.isDefault) && i3.isEmpty), t4.abrupt("return");
                      case 5:
                        o4.insertContentAtCaretPosition(e3.content.innerHTML);
                      case 6:
                      case "end":
                        return t4.stop();
                    }
                }, t3, this);
              })), function(t3) {
                return p2.apply(this, arguments);
              }) }, { key: "processInlinePaste", value: (o3 = (0, s.default)(a.default.mark(function t3(e3) {
                var n3, o4, r3, i3, s2, l2, c2, u2;
                return a.default.wrap(function(t4) {
                  for (; ; )
                    switch (t4.prev = t4.next) {
                      case 0:
                        if (n3 = this.Editor, o4 = n3.BlockManager, r3 = n3.Caret, i3 = e3.content, !(o4.currentBlock && o4.currentBlock.tool.isDefault && i3.textContent.length < T.PATTERN_PROCESSING_MAX_LENGTH)) {
                          t4.next = 12;
                          break;
                        }
                        return t4.next = 6, this.processPattern(i3.textContent);
                      case 6:
                        if (!(s2 = t4.sent)) {
                          t4.next = 12;
                          break;
                        }
                        return l2 = o4.currentBlock && o4.currentBlock.tool.isDefault && o4.currentBlock.isEmpty, c2 = o4.paste(s2.tool, s2.event, l2), r3.setToBlock(c2, r3.positions.END), t4.abrupt("return");
                      case 12:
                        o4.currentBlock && o4.currentBlock.currentInput ? (u2 = o4.currentBlock.tool.baseSanitizeConfig, document.execCommand("insertHTML", false, (0, g.clean)(i3.innerHTML, u2))) : this.insertBlock(e3);
                      case 13:
                      case "end":
                        return t4.stop();
                    }
                }, t3, this);
              })), function(t3) {
                return o3.apply(this, arguments);
              }) }, { key: "processPattern", value: (n2 = (0, s.default)(a.default.mark(function t3(e3) {
                var n3, o4;
                return a.default.wrap(function(t4) {
                  for (; ; )
                    switch (t4.prev = t4.next) {
                      case 0:
                        if (n3 = this.toolsPatterns.find(function(t5) {
                          var n4 = t5.pattern.exec(e3);
                          return !!n4 && e3 === n4.shift();
                        })) {
                          t4.next = 3;
                          break;
                        }
                        return t4.abrupt("return");
                      case 3:
                        return o4 = this.composePasteEvent("pattern", { key: n3.key, data: e3 }), t4.abrupt("return", { event: o4, tool: n3.tool.name });
                      case 5:
                      case "end":
                        return t4.stop();
                    }
                }, t3, this);
              })), function(t3) {
                return n2.apply(this, arguments);
              }) }, { key: "insertBlock", value: function(t3) {
                var e3, n3 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], o4 = this.Editor, r3 = o4.BlockManager, i3 = o4.Caret, a2 = r3.currentBlock;
                if (n3 && a2 && a2.isEmpty)
                  return e3 = r3.paste(t3.tool, t3.event, true), void i3.setToBlock(e3, i3.positions.END);
                e3 = r3.paste(t3.tool, t3.event), i3.setToBlock(e3, i3.positions.END);
              } }, { key: "insertEditorJSData", value: function(t3) {
                var e3 = this.Editor, n3 = e3.BlockManager, o4 = e3.Caret, r3 = e3.Tools;
                (0, g.sanitizeBlocks)(t3, function(t4) {
                  return r3.blockTools.get(t4).sanitizeConfig;
                }).forEach(function(t4, e4) {
                  var r4 = t4.tool, i3 = t4.data, a2 = false;
                  0 === e4 && (a2 = n3.currentBlock && n3.currentBlock.tool.isDefault && n3.currentBlock.isEmpty);
                  var s2 = n3.insert({ tool: r4, data: i3, replace: a2 });
                  o4.setToBlock(s2, o4.positions.END);
                });
              } }, { key: "processElementNode", value: function(t3, e3, n3) {
                var o4 = Object.keys(this.toolsTags), i3 = t3, a2 = (this.toolsTags[i3.tagName] || {}).tool, s2 = this.tagsByTool[null == a2 ? void 0 : a2.name] || [], l2 = o4.includes(i3.tagName), c2 = h.default.blockElements.includes(i3.tagName.toLowerCase()), u2 = Array.from(i3.children).some(function(t4) {
                  var e4 = t4.tagName;
                  return o4.includes(e4) && !s2.includes(e4);
                }), f2 = Array.from(i3.children).some(function(t4) {
                  var e4 = t4.tagName;
                  return h.default.blockElements.includes(e4.toLowerCase());
                });
                return c2 || l2 || u2 ? l2 && !u2 || c2 && !f2 && !u2 ? [].concat((0, r2.default)(e3), [n3, i3]) : void 0 : (n3.appendChild(i3), [].concat((0, r2.default)(e3), [n3]));
              } }, { key: "getNodes", value: function(t3) {
                var e3, n3 = this;
                return Array.from(t3.childNodes).reduce(function t4(o4, i3) {
                  if (h.default.isEmpty(i3) && !h.default.isSingleTag(i3))
                    return o4;
                  var a2 = o4[o4.length - 1], s2 = new DocumentFragment();
                  switch (a2 && h.default.isFragment(a2) && (s2 = o4.pop()), i3.nodeType) {
                    case Node.ELEMENT_NODE:
                      if (e3 = n3.processElementNode(i3, o4, s2))
                        return e3;
                      break;
                    case Node.TEXT_NODE:
                      return s2.appendChild(i3), [].concat((0, r2.default)(o4), [s2]);
                    default:
                      return [].concat((0, r2.default)(o4), [s2]);
                  }
                  return [].concat((0, r2.default)(o4), (0, r2.default)(Array.from(i3.childNodes).reduce(t4, [])));
                }, []);
              } }, { key: "composePasteEvent", value: function(t3, e3) {
                return new CustomEvent(t3, { detail: e3 });
              } }]), T;
            }(p.default);
            o2.default = k, k.displayName = "Paste", k.PATTERN_PROCESSING_MAX_LENGTH = 450, t.exports = e.default;
          }) ? o.apply(e, r) : o) || (t.exports = i);
        }, function(t, e, n) {
          var o, r, i;
          "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self && self, r = [e, n(20), n(30), n(21), n(2), n(3), n(5), n(6), n(4), n(9), n(151)], void 0 === (i = "function" == typeof (o = function(o2, r2, i2, a, s, l, c, u, f, d, p) {
            "use strict";
            var h = n(1);
            function v() {
              if ("undefined" == typeof Reflect || !Reflect.construct)
                return false;
              if (Reflect.construct.sham)
                return false;
              if ("function" == typeof Proxy)
                return true;
              try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
                })), true;
              } catch (t2) {
                return false;
              }
            }
            Object.defineProperty(o2, "__esModule", { value: true }), o2.default = void 0, r2 = h(r2), i2 = h(i2), a = h(a), s = h(s), l = h(l), c = h(c), u = h(u), f = h(f);
            var g = function(t2) {
              (0, c.default)(h2, t2);
              var e2, n2, o3, d2 = (e2 = h2, function() {
                var t3, n3 = (0, f.default)(e2);
                if (v()) {
                  var o4 = (0, f.default)(this).constructor;
                  t3 = Reflect.construct(n3, arguments, o4);
                } else
                  t3 = n3.apply(this, arguments);
                return (0, u.default)(this, t3);
              });
              function h2() {
                var t3;
                return (0, s.default)(this, h2), (t3 = d2.apply(this, arguments)).toolsDontSupportReadOnly = [], t3.readOnlyEnabled = false, t3;
              }
              return (0, l.default)(h2, [{ key: "prepare", value: (o3 = (0, a.default)(r2.default.mark(function t3() {
                var e3, n3, o4;
                return r2.default.wrap(function(t4) {
                  for (; ; )
                    switch (t4.prev = t4.next) {
                      case 0:
                        e3 = this.Editor.Tools, n3 = e3.blockTools, o4 = [], Array.from(n3.entries()).forEach(function(t5) {
                          var e4 = (0, i2.default)(t5, 2), n4 = e4[0];
                          e4[1].isReadOnlySupported || o4.push(n4);
                        }), this.toolsDontSupportReadOnly = o4, this.config.readOnly && o4.length > 0 && this.throwCriticalError(), this.toggle(this.config.readOnly);
                      case 7:
                      case "end":
                        return t4.stop();
                    }
                }, t3, this);
              })), function() {
                return o3.apply(this, arguments);
              }) }, { key: "toggle", value: (n2 = (0, a.default)(r2.default.mark(function t3() {
                var e3, n3, o4, i3, a2 = arguments;
                return r2.default.wrap(function(t4) {
                  for (; ; )
                    switch (t4.prev = t4.next) {
                      case 0:
                        (e3 = a2.length > 0 && void 0 !== a2[0] ? a2[0] : !this.readOnlyEnabled) && this.toolsDontSupportReadOnly.length > 0 && this.throwCriticalError(), n3 = this.readOnlyEnabled, this.readOnlyEnabled = e3, t4.t0 = r2.default.keys(this.Editor);
                      case 5:
                        if ((t4.t1 = t4.t0()).done) {
                          t4.next = 12;
                          break;
                        }
                        if (o4 = t4.t1.value, this.Editor[o4].toggleReadOnly) {
                          t4.next = 9;
                          break;
                        }
                        return t4.abrupt("continue", 5);
                      case 9:
                        this.Editor[o4].toggleReadOnly(e3), t4.next = 5;
                        break;
                      case 12:
                        if (n3 !== e3) {
                          t4.next = 14;
                          break;
                        }
                        return t4.abrupt("return", this.readOnlyEnabled);
                      case 14:
                        return t4.next = 16, this.Editor.Saver.save();
                      case 16:
                        return i3 = t4.sent, t4.next = 19, this.Editor.BlockManager.clear();
                      case 19:
                        return t4.next = 21, this.Editor.Renderer.render(i3.blocks);
                      case 21:
                        return t4.abrupt("return", this.readOnlyEnabled);
                      case 22:
                      case "end":
                        return t4.stop();
                    }
                }, t3, this);
              })), function() {
                return n2.apply(this, arguments);
              }) }, { key: "throwCriticalError", value: function() {
                throw new p.CriticalError("To enable read-only mode all connected tools should support it. Tools ".concat(this.toolsDontSupportReadOnly.join(", "), " don't support read-only mode."));
              } }, { key: "isEnabled", get: function() {
                return this.readOnlyEnabled;
              } }]), h2;
            }((d = h(d)).default);
            o2.default = g, g.displayName = "ReadOnly", t.exports = e.default;
          }) ? o.apply(e, r) : o) || (t.exports = i);
        }, function(t, e, n) {
          var o, r, i;
          "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self && self, r = [e, n(2), n(3), n(5), n(6), n(4), n(9), n(14), n(25), n(61), n(7)], void 0 === (i = "function" == typeof (o = function(o2, r2, i2, a, s, l, c, u, f, d, p) {
            "use strict";
            var h = n(8), v = n(1);
            function g(t2) {
              if ("undefined" == typeof Symbol || null == t2[Symbol.iterator]) {
                if (Array.isArray(t2) || (t2 = function(t3, e3) {
                  if (t3) {
                    if ("string" == typeof t3)
                      return y(t3, e3);
                    var n3 = Object.prototype.toString.call(t3).slice(8, -1);
                    return "Object" === n3 && t3.constructor && (n3 = t3.constructor.name), "Map" === n3 || "Set" === n3 ? Array.from(n3) : "Arguments" === n3 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n3) ? y(t3, e3) : void 0;
                  }
                }(t2))) {
                  var e2 = 0, n2 = function() {
                  };
                  return { s: n2, n: function() {
                    return e2 >= t2.length ? { done: true } : { done: false, value: t2[e2++] };
                  }, e: function(t3) {
                    throw t3;
                  }, f: n2 };
                }
                throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
              }
              var o3, r3, i3 = true, a2 = false;
              return { s: function() {
                o3 = t2[Symbol.iterator]();
              }, n: function() {
                var t3 = o3.next();
                return i3 = t3.done, t3;
              }, e: function(t3) {
                a2 = true, r3 = t3;
              }, f: function() {
                try {
                  i3 || null == o3.return || o3.return();
                } finally {
                  if (a2)
                    throw r3;
                }
              } };
            }
            function y(t2, e2) {
              (null == e2 || e2 > t2.length) && (e2 = t2.length);
              for (var n2 = 0, o3 = new Array(e2); n2 < e2; n2++)
                o3[n2] = t2[n2];
              return o3;
            }
            function b() {
              if ("undefined" == typeof Reflect || !Reflect.construct)
                return false;
              if (Reflect.construct.sham)
                return false;
              if ("function" == typeof Proxy)
                return true;
              try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
                })), true;
              } catch (t2) {
                return false;
              }
            }
            Object.defineProperty(o2, "__esModule", { value: true }), o2.default = void 0, r2 = v(r2), i2 = v(i2), a = v(a), s = v(s), l = v(l), c = v(c), u = v(u), f = v(f), d = v(d), p = h(p);
            var m = function(t2) {
              (0, a.default)(o3, t2);
              var e2, n2 = (e2 = o3, function() {
                var t3, n3 = (0, l.default)(e2);
                if (b()) {
                  var o4 = (0, l.default)(this).constructor;
                  t3 = Reflect.construct(n3, arguments, o4);
                } else
                  t3 = n3.apply(this, arguments);
                return (0, s.default)(this, t3);
              });
              function o3() {
                var t3;
                return (0, r2.default)(this, o3), (t3 = n2.apply(this, arguments)).isRectSelectionActivated = false, t3.SCROLL_SPEED = 3, t3.HEIGHT_OF_SCROLL_ZONE = 40, t3.BOTTOM_SCROLL_ZONE = 1, t3.TOP_SCROLL_ZONE = 2, t3.MAIN_MOUSE_BUTTON = 0, t3.mousedown = false, t3.isScrolling = false, t3.inScrollZone = null, t3.startX = 0, t3.startY = 0, t3.mouseX = 0, t3.mouseY = 0, t3.stackOfSelected = [], t3.listenerIds = [], t3;
              }
              return (0, i2.default)(o3, [{ key: "prepare", value: function() {
                this.enableModuleBindings();
              } }, { key: "startSelection", value: function(t3, e3) {
                var n3 = document.elementFromPoint(t3 - window.pageXOffset, e3 - window.pageYOffset);
                n3.closest(".".concat(this.Editor.Toolbar.CSS.toolbar)) || (this.Editor.BlockSelection.allBlocksSelected = false, this.clearSelection(), this.stackOfSelected = []);
                var o4 = [".".concat(d.default.CSS.content), ".".concat(this.Editor.Toolbar.CSS.toolbar), ".".concat(this.Editor.InlineToolbar.CSS.inlineToolbar)], r3 = n3.closest("." + this.Editor.UI.CSS.editorWrapper), i3 = o4.some(function(t4) {
                  return !!n3.closest(t4);
                });
                r3 && !i3 && (this.mousedown = true, this.startX = t3, this.startY = e3);
              } }, { key: "endSelection", value: function() {
                this.mousedown = false, this.startX = 0, this.startY = 0, this.overlayRectangle.style.display = "none";
              } }, { key: "isRectActivated", value: function() {
                return this.isRectSelectionActivated;
              } }, { key: "clearSelection", value: function() {
                this.isRectSelectionActivated = false;
              } }, { key: "enableModuleBindings", value: function() {
                var t3 = this, e3 = this.genHTML().container;
                this.listeners.on(e3, "mousedown", function(e4) {
                  t3.processMouseDown(e4);
                }, false), this.listeners.on(document.body, "mousemove", p.throttle(function(e4) {
                  t3.processMouseMove(e4);
                }, 10), { passive: true }), this.listeners.on(document.body, "mouseleave", function() {
                  t3.processMouseLeave();
                }), this.listeners.on(window, "scroll", p.throttle(function(e4) {
                  t3.processScroll(e4);
                }, 10), { passive: true }), this.listeners.on(document.body, "mouseup", function() {
                  t3.processMouseUp();
                }, false);
              } }, { key: "processMouseDown", value: function(t3) {
                t3.button === this.MAIN_MOUSE_BUTTON && (null !== t3.target.closest(u.default.allInputsSelector) || this.startSelection(t3.pageX, t3.pageY));
              } }, { key: "processMouseMove", value: function(t3) {
                this.changingRectangle(t3), this.scrollByZones(t3.clientY);
              } }, { key: "processMouseLeave", value: function() {
                this.clearSelection(), this.endSelection();
              } }, { key: "processScroll", value: function(t3) {
                this.changingRectangle(t3);
              } }, { key: "processMouseUp", value: function() {
                this.clearSelection(), this.endSelection();
              } }, { key: "scrollByZones", value: function(t3) {
                this.inScrollZone = null, t3 <= this.HEIGHT_OF_SCROLL_ZONE && (this.inScrollZone = this.TOP_SCROLL_ZONE), document.documentElement.clientHeight - t3 <= this.HEIGHT_OF_SCROLL_ZONE && (this.inScrollZone = this.BOTTOM_SCROLL_ZONE), this.inScrollZone ? this.isScrolling || (this.scrollVertical(this.inScrollZone === this.TOP_SCROLL_ZONE ? -this.SCROLL_SPEED : this.SCROLL_SPEED), this.isScrolling = true) : this.isScrolling = false;
              } }, { key: "genHTML", value: function() {
                var t3 = this.Editor.UI, e3 = t3.nodes.holder.querySelector("." + t3.CSS.editorWrapper), n3 = u.default.make("div", o3.CSS.overlay, {}), r3 = u.default.make("div", o3.CSS.overlayContainer, {}), i3 = u.default.make("div", o3.CSS.rect, {});
                return r3.appendChild(i3), n3.appendChild(r3), e3.appendChild(n3), this.overlayRectangle = i3, { container: e3, overlay: n3 };
              } }, { key: "scrollVertical", value: function(t3) {
                var e3 = this;
                if (this.inScrollZone && this.mousedown) {
                  var n3 = window.pageYOffset;
                  window.scrollBy(0, t3), this.mouseY += window.pageYOffset - n3, setTimeout(function() {
                    e3.scrollVertical(t3);
                  }, 0);
                }
              } }, { key: "changingRectangle", value: function(t3) {
                if (this.mousedown) {
                  void 0 !== t3.pageY && (this.mouseX = t3.pageX, this.mouseY = t3.pageY);
                  var e3 = this.genInfoForMouseSelection(), n3 = e3.rightPos, o4 = e3.leftPos, r3 = e3.index, i3 = this.startX > n3 && this.mouseX > n3, a2 = this.startX < o4 && this.mouseX < o4;
                  this.rectCrossesBlocks = !(i3 || a2), this.isRectSelectionActivated || (this.rectCrossesBlocks = false, this.isRectSelectionActivated = true, this.shrinkRectangleToPoint(), this.overlayRectangle.style.display = "block"), this.updateRectangleSize(), this.Editor.Toolbar.close(), void 0 !== r3 && (this.trySelectNextBlock(r3), this.inverseSelection(), f.default.get().removeAllRanges());
                }
              } }, { key: "shrinkRectangleToPoint", value: function() {
                this.overlayRectangle.style.left = "".concat(this.startX - window.pageXOffset, "px"), this.overlayRectangle.style.top = "".concat(this.startY - window.pageYOffset, "px"), this.overlayRectangle.style.bottom = "calc(100% - ".concat(this.startY - window.pageYOffset, "px"), this.overlayRectangle.style.right = "calc(100% - ".concat(this.startX - window.pageXOffset, "px");
              } }, { key: "inverseSelection", value: function() {
                var t3 = this.Editor.BlockManager.getBlockByIndex(this.stackOfSelected[0]).selected;
                if (this.rectCrossesBlocks && !t3) {
                  var e3, n3 = g(this.stackOfSelected);
                  try {
                    for (n3.s(); !(e3 = n3.n()).done; ) {
                      var o4 = e3.value;
                      this.Editor.BlockSelection.selectBlockByIndex(o4);
                    }
                  } catch (t4) {
                    n3.e(t4);
                  } finally {
                    n3.f();
                  }
                }
                if (!this.rectCrossesBlocks && t3) {
                  var r3, i3 = g(this.stackOfSelected);
                  try {
                    for (i3.s(); !(r3 = i3.n()).done; ) {
                      var a2 = r3.value;
                      this.Editor.BlockSelection.unSelectBlockByIndex(a2);
                    }
                  } catch (t4) {
                    i3.e(t4);
                  } finally {
                    i3.f();
                  }
                }
              } }, { key: "updateRectangleSize", value: function() {
                this.mouseY >= this.startY ? (this.overlayRectangle.style.top = "".concat(this.startY - window.pageYOffset, "px"), this.overlayRectangle.style.bottom = "calc(100% - ".concat(this.mouseY - window.pageYOffset, "px")) : (this.overlayRectangle.style.bottom = "calc(100% - ".concat(this.startY - window.pageYOffset, "px"), this.overlayRectangle.style.top = "".concat(this.mouseY - window.pageYOffset, "px")), this.mouseX >= this.startX ? (this.overlayRectangle.style.left = "".concat(this.startX - window.pageXOffset, "px"), this.overlayRectangle.style.right = "calc(100% - ".concat(this.mouseX - window.pageXOffset, "px")) : (this.overlayRectangle.style.right = "calc(100% - ".concat(this.startX - window.pageXOffset, "px"), this.overlayRectangle.style.left = "".concat(this.mouseX - window.pageXOffset, "px"));
              } }, { key: "genInfoForMouseSelection", value: function() {
                var t3, e3 = document.body.offsetWidth / 2, n3 = this.mouseY - window.pageYOffset, o4 = document.elementFromPoint(e3, n3), r3 = this.Editor.BlockManager.getBlockByChildNode(o4);
                void 0 !== r3 && (t3 = this.Editor.BlockManager.blocks.findIndex(function(t4) {
                  return t4.holder === r3.holder;
                }));
                var i3 = this.Editor.BlockManager.lastBlock.holder.querySelector("." + d.default.CSS.content), a2 = Number.parseInt(window.getComputedStyle(i3).width, 10) / 2;
                return { index: t3, leftPos: e3 - a2, rightPos: e3 + a2 };
              } }, { key: "addBlockInSelection", value: function(t3) {
                this.rectCrossesBlocks && this.Editor.BlockSelection.selectBlockByIndex(t3), this.stackOfSelected.push(t3);
              } }, { key: "trySelectNextBlock", value: function(t3) {
                var e3 = this, n3 = this.stackOfSelected[this.stackOfSelected.length - 1] === t3, o4 = this.stackOfSelected.length;
                if (!n3) {
                  var r3 = this.stackOfSelected[o4 - 1] - this.stackOfSelected[o4 - 2] > 0, i3 = 0;
                  o4 > 1 && (i3 = r3 ? 1 : -1);
                  var a2 = t3 > this.stackOfSelected[o4 - 1] && 1 === i3, s2 = t3 < this.stackOfSelected[o4 - 1] && -1 === i3, l2 = !(a2 || s2 || 0 === i3);
                  if (l2 || !(t3 > this.stackOfSelected[o4 - 1] || void 0 === this.stackOfSelected[o4 - 1])) {
                    if (!l2 && t3 < this.stackOfSelected[o4 - 1])
                      for (var c2 = this.stackOfSelected[o4 - 1] - 1; c2 >= t3; c2--)
                        this.addBlockInSelection(c2);
                    else if (l2) {
                      var u2, f2 = o4 - 1;
                      for (u2 = t3 > this.stackOfSelected[o4 - 1] ? function() {
                        return t3 > e3.stackOfSelected[f2];
                      } : function() {
                        return t3 < e3.stackOfSelected[f2];
                      }; u2(); )
                        this.rectCrossesBlocks && this.Editor.BlockSelection.unSelectBlockByIndex(this.stackOfSelected[f2]), this.stackOfSelected.pop(), f2--;
                    }
                  } else
                    for (var d2 = this.stackOfSelected[o4 - 1] + 1 || t3; d2 <= t3; d2++)
                      this.addBlockInSelection(d2);
                }
              } }], [{ key: "CSS", get: function() {
                return { overlay: "codex-editor-overlay", overlayContainer: "codex-editor-overlay__container", rect: "codex-editor-overlay__rectangle", topScrollZone: "codex-editor-overlay__scroll-zone--top", bottomScrollZone: "codex-editor-overlay__scroll-zone--bottom" };
              } }]), o3;
            }(c.default);
            o2.default = m, m.displayName = "RectangleSelection", t.exports = e.default;
          }) ? o.apply(e, r) : o) || (t.exports = i);
        }, function(t, e, n) {
          var o, r, i;
          "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self && self, r = [e, n(20), n(21), n(2), n(3), n(5), n(6), n(4), n(9), n(7)], void 0 === (i = "function" == typeof (o = function(o2, r2, i2, a, s, l, c, u, f, d) {
            "use strict";
            var p = n(8), h = n(1);
            function v() {
              if ("undefined" == typeof Reflect || !Reflect.construct)
                return false;
              if (Reflect.construct.sham)
                return false;
              if ("function" == typeof Proxy)
                return true;
              try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
                })), true;
              } catch (t2) {
                return false;
              }
            }
            Object.defineProperty(o2, "__esModule", { value: true }), o2.default = void 0, r2 = h(r2), i2 = h(i2), a = h(a), s = h(s), l = h(l), c = h(c), u = h(u), f = h(f), d = p(d);
            var g = function(t2) {
              (0, l.default)(p2, t2);
              var e2, n2, o3, f2 = (e2 = p2, function() {
                var t3, n3 = (0, u.default)(e2);
                if (v()) {
                  var o4 = (0, u.default)(this).constructor;
                  t3 = Reflect.construct(n3, arguments, o4);
                } else
                  t3 = n3.apply(this, arguments);
                return (0, c.default)(this, t3);
              });
              function p2() {
                return (0, a.default)(this, p2), f2.apply(this, arguments);
              }
              return (0, s.default)(p2, [{ key: "render", value: (o3 = (0, i2.default)(r2.default.mark(function t3(e3) {
                var n3, o4, i3 = this;
                return r2.default.wrap(function(t4) {
                  for (; ; )
                    switch (t4.prev = t4.next) {
                      case 0:
                        return n3 = e3.map(function(t5) {
                          return { function: function() {
                            return i3.insertBlock(t5);
                          } };
                        }), this.Editor.ModificationsObserver.disable(), t4.next = 4, d.sequence(n3);
                      case 4:
                        return o4 = t4.sent, this.Editor.ModificationsObserver.enable(), this.Editor.UI.checkEmptiness(), t4.abrupt("return", o4);
                      case 8:
                      case "end":
                        return t4.stop();
                    }
                }, t3, this);
              })), function(t3) {
                return o3.apply(this, arguments);
              }) }, { key: "insertBlock", value: (n2 = (0, i2.default)(r2.default.mark(function t3(e3) {
                var n3, o4, i3, a2, s2, l2, c2, u2, f3, p3, h2;
                return r2.default.wrap(function(t4) {
                  for (; ; )
                    switch (t4.prev = t4.next) {
                      case 0:
                        if (o4 = this.Editor, i3 = o4.Tools, a2 = o4.BlockManager, s2 = e3.type, l2 = e3.data, c2 = e3.tunes, u2 = e3.id, !i3.available.has(s2)) {
                          t4.next = 13;
                          break;
                        }
                        t4.prev = 3, a2.insert({ id: u2, tool: s2, data: l2, tunes: c2 }), t4.next = 11;
                        break;
                      case 7:
                        throw t4.prev = 7, t4.t0 = t4.catch(3), d.log("Block \xAB".concat(s2, "\xBB skipped because of plugins error"), "warn", l2), Error(t4.t0);
                      case 11:
                        t4.next = 18;
                        break;
                      case 13:
                        f3 = { savedData: { id: u2, type: s2, data: l2 }, title: s2 }, i3.unavailable.has(s2) && (p3 = i3.unavailable.get(s2).toolbox, h2 = null === (n3 = p3[0]) || void 0 === n3 ? void 0 : n3.title, f3.title = h2 || f3.title), a2.insert({ id: u2, tool: i3.stubTool, data: f3 }).stretched = true, d.log("Tool \xAB".concat(s2, "\xBB is not found. Check 'tools' property at your initial Editor.js config."), "warn");
                      case 18:
                      case "end":
                        return t4.stop();
                    }
                }, t3, this, [[3, 7]]);
              })), function(t3) {
                return n2.apply(this, arguments);
              }) }]), p2;
            }(f.default);
            o2.default = g, g.displayName = "Renderer", t.exports = e.default;
          }) ? o.apply(e, r) : o) || (t.exports = i);
        }, function(t, e, n) {
          var o, r, i;
          "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self && self, r = [e, n(20), n(21), n(2), n(3), n(5), n(6), n(4), n(9), n(7), n(67)], void 0 === (i = "function" == typeof (o = function(o2, r2, i2, a, s, l, c, u, f, d, p) {
            "use strict";
            var h = n(8), v = n(1);
            function g() {
              if ("undefined" == typeof Reflect || !Reflect.construct)
                return false;
              if (Reflect.construct.sham)
                return false;
              if ("function" == typeof Proxy)
                return true;
              try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
                })), true;
              } catch (t2) {
                return false;
              }
            }
            Object.defineProperty(o2, "__esModule", { value: true }), o2.default = void 0, r2 = v(r2), i2 = v(i2), a = v(a), s = v(s), l = v(l), c = v(c), u = v(u), f = v(f), d = h(d);
            var y = function(t2) {
              (0, l.default)(h2, t2);
              var e2, n2, o3, f2 = (e2 = h2, function() {
                var t3, n3 = (0, u.default)(e2);
                if (g()) {
                  var o4 = (0, u.default)(this).constructor;
                  t3 = Reflect.construct(n3, arguments, o4);
                } else
                  t3 = n3.apply(this, arguments);
                return (0, c.default)(this, t3);
              });
              function h2() {
                return (0, a.default)(this, h2), f2.apply(this, arguments);
              }
              return (0, s.default)(h2, [{ key: "save", value: (o3 = (0, i2.default)(r2.default.mark(function t3() {
                var e3, n3, o4, i3, a2, s2, l2, c2 = this;
                return r2.default.wrap(function(t4) {
                  for (; ; )
                    switch (t4.prev = t4.next) {
                      case 0:
                        return e3 = this.Editor, n3 = e3.BlockManager, o4 = e3.Tools, i3 = n3.blocks, a2 = [], t4.prev = 2, i3.forEach(function(t5) {
                          a2.push(c2.getSavedData(t5));
                        }), t4.next = 6, Promise.all(a2);
                      case 6:
                        return s2 = t4.sent, t4.next = 9, (0, p.sanitizeBlocks)(s2, function(t5) {
                          return o4.blockTools.get(t5).sanitizeConfig;
                        });
                      case 9:
                        return l2 = t4.sent, t4.abrupt("return", this.makeOutput(l2));
                      case 13:
                        t4.prev = 13, t4.t0 = t4.catch(2), d.logLabeled("Saving failed due to the Error %o", "error", t4.t0);
                      case 16:
                      case "end":
                        return t4.stop();
                    }
                }, t3, this, [[2, 13]]);
              })), function() {
                return o3.apply(this, arguments);
              }) }, { key: "getSavedData", value: (n2 = (0, i2.default)(r2.default.mark(function t3(e3) {
                var n3, o4;
                return r2.default.wrap(function(t4) {
                  for (; ; )
                    switch (t4.prev = t4.next) {
                      case 0:
                        return t4.next = 2, e3.save();
                      case 2:
                        if (n3 = t4.sent, t4.t0 = n3, !t4.t0) {
                          t4.next = 8;
                          break;
                        }
                        return t4.next = 7, e3.validate(n3.data);
                      case 7:
                        t4.t0 = t4.sent;
                      case 8:
                        return o4 = t4.t0, t4.abrupt("return", Object.assign(Object.assign({}, n3), { isValid: o4 }));
                      case 10:
                      case "end":
                        return t4.stop();
                    }
                }, t3);
              })), function(t3) {
                return n2.apply(this, arguments);
              }) }, { key: "makeOutput", value: function(t3) {
                var e3 = this, n3 = 0, o4 = [];
                return d.log("[Editor.js saving]:", "groupCollapsed"), t3.forEach(function(t4) {
                  var r3 = t4.id, i3 = t4.tool, a2 = t4.data, s2 = t4.tunes, l2 = t4.time, c2 = t4.isValid;
                  if (n3 += l2, d.log("".concat(i3.charAt(0).toUpperCase() + i3.slice(1)), "group"), !c2)
                    return d.log("Block \xAB".concat(i3, "\xBB skipped because saved data is invalid")), void d.log(void 0, "groupEnd");
                  if (d.log(a2), d.log(void 0, "groupEnd"), i3 !== e3.Editor.Tools.stubTool) {
                    var u2 = Object.assign({ id: r3, type: i3, data: a2 }, !d.isEmpty(s2) && { tunes: s2 });
                    o4.push(u2);
                  } else
                    o4.push(a2);
                }), d.log("Total", "log", n3), d.log(void 0, "groupEnd"), { time: +/* @__PURE__ */ new Date(), blocks: o4, version: "2.25.0" };
              } }]), h2;
            }(f.default);
            o2.default = y, y.displayName = "Saver", t.exports = e.default;
          }) ? o.apply(e, r) : o) || (t.exports = i);
        }, function(t, e, n) {
          var o, r, i;
          "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self && self, r = [e, n(30), n(2), n(3), n(5), n(6), n(4), n(9), n(14), n(62), n(7), n(25)], void 0 === (i = "function" == typeof (o = function(o2, r2, i2, a, s, l, c, u, f, d, p, h) {
            "use strict";
            var v = n(8), g = n(1);
            function y() {
              if ("undefined" == typeof Reflect || !Reflect.construct)
                return false;
              if (Reflect.construct.sham)
                return false;
              if ("function" == typeof Proxy)
                return true;
              try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
                })), true;
              } catch (t2) {
                return false;
              }
            }
            Object.defineProperty(o2, "__esModule", { value: true }), o2.default = void 0, r2 = g(r2), i2 = g(i2), a = g(a), s = g(s), l = g(l), c = g(c), u = g(u), f = g(f), d = g(d), p = v(p), h = g(h);
            var b = function(t2) {
              (0, s.default)(o3, t2);
              var e2, n2 = (e2 = o3, function() {
                var t3, n3 = (0, c.default)(e2);
                if (y()) {
                  var o4 = (0, c.default)(this).constructor;
                  t3 = Reflect.construct(n3, arguments, o4);
                } else
                  t3 = n3.apply(this, arguments);
                return (0, l.default)(this, t3);
              });
              function o3() {
                var t3;
                return (0, i2.default)(this, o3), (t3 = n2.apply(this, arguments)).buttons = [], t3.flipper = null, t3.selection = new h.default(), t3;
              }
              return (0, a.default)(o3, [{ key: "make", value: function() {
                this.nodes.wrapper = f.default.make("div", this.CSS.wrapper), this.nodes.toolSettings = f.default.make("div", this.CSS.toolSettings), this.nodes.defaultSettings = f.default.make("div", this.CSS.defaultSettings), f.default.append(this.nodes.wrapper, [this.nodes.toolSettings, this.nodes.defaultSettings]), this.enableFlipper();
              } }, { key: "destroy", value: function() {
                this.flipper && (this.flipper.deactivate(), this.flipper = null), this.removeAllNodes();
              } }, { key: "open", value: function() {
                var t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.Editor.BlockManager.currentBlock;
                this.nodes.wrapper.classList.add(this.CSS.wrapperOpened), this.selection.save(), t3.selected = true, this.Editor.BlockSelection.clearCache(), this.addToolSettings(t3), this.addTunes(t3), this.eventsDispatcher.emit(this.events.opened), this.flipper.activate(this.blockTunesButtons);
              } }, { key: "close", value: function() {
                this.nodes.wrapper.classList.remove(this.CSS.wrapperOpened), h.default.isAtEditor || this.selection.restore(), this.selection.clearSaved(), !this.Editor.CrossBlockSelection.isCrossBlockSelectionStarted && this.Editor.BlockManager.currentBlock && (this.Editor.BlockManager.currentBlock.selected = false), this.nodes.toolSettings.innerHTML = "", this.nodes.defaultSettings.innerHTML = "", this.eventsDispatcher.emit(this.events.closed), this.buttons = [], this.flipper.deactivate();
              } }, { key: "addToolSettings", value: function(t3) {
                var e3 = t3.renderSettings();
                e3 && f.default.append(this.nodes.toolSettings, e3);
              } }, { key: "addTunes", value: function(t3) {
                var e3 = t3.renderTunes(), n3 = (0, r2.default)(e3, 2), o4 = n3[0], i3 = n3[1];
                f.default.append(this.nodes.toolSettings, o4), f.default.append(this.nodes.defaultSettings, i3);
              } }, { key: "enableFlipper", value: function() {
                var t3 = this;
                this.flipper = new d.default({ focusedItemClass: this.CSS.focusedButton, activateCallback: function(e3) {
                  e3 && f.default.canSetCaret(e3) ? t3.close() : p.delay(function() {
                    t3.Editor.Caret.setToBlock(t3.Editor.BlockManager.currentBlock);
                  }, 50)();
                } });
              } }, { key: "events", get: function() {
                return { opened: "block-settings-opened", closed: "block-settings-closed" };
              } }, { key: "CSS", get: function() {
                return { wrapper: "ce-settings", wrapperOpened: "ce-settings--opened", toolSettings: "ce-settings__plugin-zone", defaultSettings: "ce-settings__default-zone", button: "ce-settings__button", focusedButton: "ce-settings__button--focused", focusedButtonAnimated: "ce-settings__button--focused-animated" };
              } }, { key: "opened", get: function() {
                return this.nodes.wrapper.classList.contains(this.CSS.wrapperOpened);
              } }, { key: "blockTunesButtons", get: function() {
                var t3 = this, e3 = this.Editor.StylesAPI;
                if (0 !== this.buttons.length)
                  return this.buttons;
                var n3 = this.nodes.toolSettings.querySelectorAll(".".concat(e3.classes.settingsButton, ", ").concat(f.default.allInputsSelector)), o4 = this.nodes.defaultSettings.querySelectorAll(".".concat(this.CSS.button));
                return n3.forEach(function(e4) {
                  t3.buttons.push(e4);
                }), o4.forEach(function(e4) {
                  t3.buttons.push(e4);
                }), this.buttons;
              } }]), o3;
            }(u.default);
            o2.default = b, b.displayName = "BlockSettings", t.exports = e.default;
          }) ? o.apply(e, r) : o) || (t.exports = i);
        }, function(t, e, n) {
          var o, r, i;
          "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self && self, r = [e, n(30), n(20), n(21), n(42), n(2), n(3), n(5), n(6), n(4), n(9), n(14), n(7), n(62), n(60), n(84), n(67)], void 0 === (i = "function" == typeof (o = function(o2, r2, i2, a, s, l, c, u, f, d, p, h, v, g, y, b, m) {
            "use strict";
            var k = n(8), x = n(1);
            function w() {
              if ("undefined" == typeof Reflect || !Reflect.construct)
                return false;
              if (Reflect.construct.sham)
                return false;
              if ("function" == typeof Proxy)
                return true;
              try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
                })), true;
              } catch (t2) {
                return false;
              }
            }
            Object.defineProperty(o2, "__esModule", { value: true }), o2.default = void 0, r2 = x(r2), i2 = x(i2), a = x(a), s = x(s), l = x(l), c = x(c), u = x(u), f = x(f), d = x(d), p = x(p), h = x(h), v = k(v), g = x(g), y = x(y);
            var S = function(t2) {
              (0, u.default)(k2, t2);
              var e2, n2, o3, p2 = (e2 = k2, function() {
                var t3, n3 = (0, d.default)(e2);
                if (w()) {
                  var o4 = (0, d.default)(this).constructor;
                  t3 = Reflect.construct(n3, arguments, o4);
                } else
                  t3 = n3.apply(this, arguments);
                return (0, f.default)(this, t3);
              });
              function k2() {
                var t3;
                return (0, l.default)(this, k2), (t3 = p2.apply(this, arguments)).opened = false, t3.tools = [], t3.flipper = null, t3.togglingCallback = null, t3;
              }
              return (0, c.default)(k2, [{ key: "make", value: function() {
                this.nodes.wrapper = h.default.make("div", [k2.CSS.conversionToolbarWrapper].concat((0, s.default)(this.isRtl ? [this.Editor.UI.CSS.editorRtlFix] : []))), this.nodes.tools = h.default.make("div", k2.CSS.conversionToolbarTools);
                var t3 = h.default.make("div", k2.CSS.conversionToolbarLabel, { textContent: y.default.ui(b.I18nInternalNS.ui.inlineToolbar.converter, "Convert to") });
                return this.addTools(), this.enableFlipper(), h.default.append(this.nodes.wrapper, t3), h.default.append(this.nodes.wrapper, this.nodes.tools), this.nodes.wrapper;
              } }, { key: "destroy", value: function() {
                this.flipper && (this.flipper.deactivate(), this.flipper = null), this.removeAllNodes();
              } }, { key: "toggle", value: function(t3) {
                this.opened ? this.close() : this.open(), v.isFunction(t3) && (this.togglingCallback = t3);
              } }, { key: "open", value: function() {
                var t3 = this;
                this.filterTools(), this.opened = true, this.nodes.wrapper.classList.add(k2.CSS.conversionToolbarShowed), window.requestAnimationFrame(function() {
                  t3.flipper.activate(t3.tools.map(function(t4) {
                    return t4.button;
                  }).filter(function(t4) {
                    return !t4.classList.contains(k2.CSS.conversionToolHidden);
                  })), t3.flipper.focusFirst(), v.isFunction(t3.togglingCallback) && t3.togglingCallback(true);
                });
              } }, { key: "close", value: function() {
                this.opened = false, this.flipper.deactivate(), this.nodes.wrapper.classList.remove(k2.CSS.conversionToolbarShowed), v.isFunction(this.togglingCallback) && this.togglingCallback(false);
              } }, { key: "hasTools", value: function() {
                return 1 !== this.tools.length || this.tools[0].name !== this.config.defaultBlock;
              } }, { key: "replaceWithBlock", value: (o3 = (0, a.default)(i2.default.mark(function t3(e3, n3) {
                var o4, r3, a2, s2, l2, c2, u2, f2, d2, p3 = this;
                return i2.default.wrap(function(t4) {
                  for (; ; )
                    switch (t4.prev = t4.next) {
                      case 0:
                        return o4 = this.Editor.BlockManager.currentBlock.tool, t4.next = 3, this.Editor.BlockManager.currentBlock.save();
                      case 3:
                        if (r3 = t4.sent, a2 = r3.data, s2 = this.Editor.Tools.blockTools.get(e3), l2 = "", c2 = o4.conversionConfig.export, !v.isFunction(c2)) {
                          t4.next = 12;
                          break;
                        }
                        l2 = c2(a2), t4.next = 18;
                        break;
                      case 12:
                        if (!v.isString(c2)) {
                          t4.next = 16;
                          break;
                        }
                        l2 = a2[c2], t4.next = 18;
                        break;
                      case 16:
                        return v.log("Conversion \xABexport\xBB property must be a string or function. String means key of saved data object to export. Function should export processed string to export."), t4.abrupt("return");
                      case 18:
                        if (u2 = (0, m.clean)(l2, s2.sanitizeConfig), f2 = {}, d2 = s2.conversionConfig.import, !v.isFunction(d2)) {
                          t4.next = 25;
                          break;
                        }
                        f2 = d2(u2), t4.next = 31;
                        break;
                      case 25:
                        if (!v.isString(d2)) {
                          t4.next = 29;
                          break;
                        }
                        f2[d2] = u2, t4.next = 31;
                        break;
                      case 29:
                        return v.log("Conversion \xABimport\xBB property must be a string or function. String means key of tool data to import. Function accepts a imported string and return composed tool data."), t4.abrupt("return");
                      case 31:
                        n3 && (f2 = Object.assign(f2, n3)), this.Editor.BlockManager.replace({ tool: e3, data: f2 }), this.Editor.BlockSelection.clearSelection(), this.close(), this.Editor.InlineToolbar.close(), v.delay(function() {
                          p3.Editor.Caret.setToBlock(p3.Editor.BlockManager.currentBlock);
                        }, 10)();
                      case 37:
                      case "end":
                        return t4.stop();
                    }
                }, t3, this);
              })), function(t3, e3) {
                return o3.apply(this, arguments);
              }) }, { key: "addTools", value: function() {
                var t3 = this, e3 = this.Editor.Tools.blockTools;
                Array.from(e3.entries()).forEach(function(e4) {
                  var n3 = (0, r2.default)(e4, 2), o4 = n3[0], i3 = n3[1], a2 = i3.conversionConfig;
                  a2 && a2.import && i3.toolbox.forEach(function(e5) {
                    return t3.addToolIfValid(o4, e5);
                  });
                });
              } }, { key: "addToolIfValid", value: function(t3, e3) {
                !v.isEmpty(e3) && e3.icon && this.addTool(t3, e3);
              } }, { key: "addTool", value: function(t3, e3) {
                var n3 = this, o4 = h.default.make("div", [k2.CSS.conversionTool]), r3 = h.default.make("div", [k2.CSS.conversionToolIcon]);
                o4.dataset.tool = t3, r3.innerHTML = e3.icon, h.default.append(o4, r3), h.default.append(o4, h.default.text(y.default.t(b.I18nInternalNS.toolNames, e3.title || v.capitalize(t3)))), h.default.append(this.nodes.tools, o4), this.tools.push({ name: t3, button: o4, toolboxItem: e3 }), this.listeners.on(o4, "click", (0, a.default)(i2.default.mark(function o5() {
                  return i2.default.wrap(function(o6) {
                    for (; ; )
                      switch (o6.prev = o6.next) {
                        case 0:
                          return o6.next = 2, n3.replaceWithBlock(t3, e3.data);
                        case 2:
                        case "end":
                          return o6.stop();
                      }
                  }, o5);
                })));
              } }, { key: "filterTools", value: (n2 = (0, a.default)(i2.default.mark(function t3() {
                var e3, n3, o4;
                return i2.default.wrap(function(t4) {
                  for (; ; )
                    switch (t4.prev = t4.next) {
                      case 0:
                        return o4 = function(t5, e4) {
                          return t5.icon === e4.icon && t5.title === e4.title;
                        }, e3 = this.Editor.BlockManager.currentBlock, t4.next = 4, e3.getActiveToolboxEntry();
                      case 4:
                        n3 = t4.sent, this.tools.forEach(function(t5) {
                          var r3 = false;
                          if (n3) {
                            var i3 = o4(n3, t5.toolboxItem);
                            r3 = t5.button.dataset.tool === e3.name && i3;
                          }
                          t5.button.hidden = r3, t5.button.classList.toggle(k2.CSS.conversionToolHidden, r3);
                        });
                      case 6:
                      case "end":
                        return t4.stop();
                    }
                }, t3, this);
              })), function() {
                return n2.apply(this, arguments);
              }) }, { key: "enableFlipper", value: function() {
                this.flipper = new g.default({ focusedItemClass: k2.CSS.conversionToolFocused });
              } }], [{ key: "CSS", get: function() {
                return { conversionToolbarWrapper: "ce-conversion-toolbar", conversionToolbarShowed: "ce-conversion-toolbar--showed", conversionToolbarTools: "ce-conversion-toolbar__tools", conversionToolbarLabel: "ce-conversion-toolbar__label", conversionTool: "ce-conversion-tool", conversionToolHidden: "ce-conversion-tool--hidden", conversionToolIcon: "ce-conversion-tool__icon", conversionToolFocused: "ce-conversion-tool--focused", conversionToolActive: "ce-conversion-tool--active" };
              } }]), k2;
            }(p.default);
            o2.default = S, S.displayName = "ConversionToolbar", t.exports = e.default;
          }) ? o.apply(e, r) : o) || (t.exports = i);
        }, function(t, e, n) {
          var o, r, i;
          "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self && self, r = [e, n(20), n(21), n(42), n(30), n(2), n(3), n(5), n(6), n(4), n(9), n(14), n(25), n(7), n(62), n(60), n(84), n(115), n(114), n(68)], void 0 === (i = "function" == typeof (o = function(o2, r2, i2, a, s, l, c, u, f, d, p, h, v, g, y, b, m, k, x, w) {
            "use strict";
            var S = n(8), T = n(1);
            function E() {
              if ("undefined" == typeof Reflect || !Reflect.construct)
                return false;
              if (Reflect.construct.sham)
                return false;
              if ("function" == typeof Proxy)
                return true;
              try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
                })), true;
              } catch (t2) {
                return false;
              }
            }
            Object.defineProperty(o2, "__esModule", { value: true }), o2.default = void 0, r2 = T(r2), i2 = T(i2), a = T(a), s = T(s), l = T(l), c = T(c), u = T(u), f = T(f), d = T(d), p = T(p), h = T(h), v = T(v), g = S(g), y = T(y), b = T(b), k = T(k), x = T(x);
            var B = function(t2) {
              (0, u.default)(p2, t2);
              var e2, n2, o3 = (e2 = p2, function() {
                var t3, n3 = (0, d.default)(e2);
                if (E()) {
                  var o4 = (0, d.default)(this).constructor;
                  t3 = Reflect.construct(n3, arguments, o4);
                } else
                  t3 = n3.apply(this, arguments);
                return (0, f.default)(this, t3);
              });
              function p2(t3) {
                var e3, n3 = t3.config, r3 = t3.eventsDispatcher;
                return (0, l.default)(this, p2), (e3 = o3.call(this, { config: n3, eventsDispatcher: r3 })).CSS = { inlineToolbar: "ce-inline-toolbar", inlineToolbarShowed: "ce-inline-toolbar--showed", inlineToolbarLeftOriented: "ce-inline-toolbar--left-oriented", inlineToolbarRightOriented: "ce-inline-toolbar--right-oriented", inlineToolbarShortcut: "ce-inline-toolbar__shortcut", buttonsWrapper: "ce-inline-toolbar__buttons", actionsWrapper: "ce-inline-toolbar__actions", inlineToolButton: "ce-inline-tool", inputField: "cdx-input", focusedButton: "ce-inline-tool--focused", conversionToggler: "ce-inline-toolbar__dropdown", conversionTogglerHidden: "ce-inline-toolbar__dropdown--hidden", conversionTogglerContent: "ce-inline-toolbar__dropdown-content", togglerAndButtonsWrapper: "ce-inline-toolbar__toggler-and-button-wrapper" }, e3.opened = false, e3.toolbarVerticalMargin = 5, e3.buttonsList = null, e3.width = 0, e3.flipper = null, e3.tooltip = new x.default(), e3;
              }
              return (0, c.default)(p2, [{ key: "toggleReadOnly", value: function(t3) {
                t3 ? (this.destroy(), this.Editor.ConversionToolbar.destroy()) : this.make();
              } }, { key: "tryToShow", value: function() {
                var t3 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0], e3 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
                this.allowedToShow() ? (this.move(), this.open(e3), this.Editor.Toolbar.close()) : t3 && this.close();
              } }, { key: "move", value: function() {
                var t3 = v.default.rect, e3 = this.Editor.UI.nodes.wrapper.getBoundingClientRect(), n3 = { x: t3.x - e3.left, y: t3.y + t3.height - e3.top + this.toolbarVerticalMargin };
                t3.width && (n3.x += Math.floor(t3.width / 2));
                var o4 = n3.x - this.width / 2, r3 = n3.x + this.width / 2;
                this.nodes.wrapper.classList.toggle(this.CSS.inlineToolbarLeftOriented, o4 < this.Editor.UI.contentRect.left), this.nodes.wrapper.classList.toggle(this.CSS.inlineToolbarRightOriented, r3 > this.Editor.UI.contentRect.right), this.nodes.wrapper.style.left = Math.floor(n3.x) + "px", this.nodes.wrapper.style.top = Math.floor(n3.y) + "px";
              } }, { key: "close", value: function() {
                var t3 = this;
                this.opened && (this.Editor.ReadOnly.isEnabled || (this.nodes.wrapper.classList.remove(this.CSS.inlineToolbarShowed), Array.from(this.toolsInstances.entries()).forEach(function(e3) {
                  var n3 = (0, s.default)(e3, 2), o4 = n3[0], r3 = n3[1], i3 = t3.getToolShortcut(o4);
                  i3 && k.default.remove(t3.Editor.UI.nodes.redactor, i3), g.isFunction(r3.clear) && r3.clear();
                }), this.opened = false, this.flipper.deactivate(), this.Editor.ConversionToolbar.close()));
              } }, { key: "open", value: function() {
                var t3 = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
                if (!this.opened) {
                  this.addToolsFiltered(), this.nodes.wrapper.classList.add(this.CSS.inlineToolbarShowed), this.buttonsList = this.nodes.buttons.querySelectorAll(".".concat(this.CSS.inlineToolButton)), this.opened = true, t3 && this.Editor.ConversionToolbar.hasTools() ? this.setConversionTogglerContent() : this.nodes.conversionToggler.hidden = true;
                  var e3 = Array.from(this.buttonsList);
                  e3.unshift(this.nodes.conversionToggler), e3 = e3.filter(function(t4) {
                    return !t4.hidden;
                  }), this.flipper.activate(e3);
                }
              } }, { key: "containsNode", value: function(t3) {
                return this.nodes.wrapper.contains(t3);
              } }, { key: "destroy", value: function() {
                this.flipper && (this.flipper.deactivate(), this.flipper = null), this.removeAllNodes(), this.tooltip.destroy();
              } }, { key: "make", value: function() {
                var t3 = this;
                this.nodes.wrapper = h.default.make("div", [this.CSS.inlineToolbar].concat((0, a.default)(this.isRtl ? [this.Editor.UI.CSS.editorRtlFix] : []))), this.nodes.togglerAndButtonsWrapper = h.default.make("div", this.CSS.togglerAndButtonsWrapper), this.nodes.buttons = h.default.make("div", this.CSS.buttonsWrapper), this.nodes.actions = h.default.make("div", this.CSS.actionsWrapper), this.listeners.on(this.nodes.wrapper, "mousedown", function(e3) {
                  e3.target.closest(".".concat(t3.CSS.actionsWrapper)) || e3.preventDefault();
                }), h.default.append(this.nodes.wrapper, [this.nodes.togglerAndButtonsWrapper, this.nodes.actions]), h.default.append(this.Editor.UI.nodes.wrapper, this.nodes.wrapper), this.addConversionToggler(), h.default.append(this.nodes.togglerAndButtonsWrapper, this.nodes.buttons), this.prepareConversionToolbar(), this.recalculateWidth(), this.enableFlipper();
              } }, { key: "allowedToShow", value: function() {
                var t3 = v.default.get(), e3 = v.default.text;
                if (!t3 || !t3.anchorNode)
                  return false;
                if (t3.isCollapsed || e3.length < 1)
                  return false;
                var n3 = h.default.isElement(t3.anchorNode) ? t3.anchorNode : t3.anchorNode.parentElement;
                if (t3 && ["IMG", "INPUT"].includes(n3.tagName))
                  return false;
                if (null === n3.closest('[contenteditable="true"]'))
                  return false;
                var o4 = this.Editor.BlockManager.getBlock(t3.anchorNode);
                return !!o4 && 0 !== o4.tool.inlineTools.size;
              } }, { key: "recalculateWidth", value: function() {
                this.width = this.nodes.wrapper.offsetWidth;
              } }, { key: "addConversionToggler", value: function() {
                var t3 = this;
                this.nodes.conversionToggler = h.default.make("div", this.CSS.conversionToggler), this.nodes.conversionTogglerContent = h.default.make("div", this.CSS.conversionTogglerContent);
                var e3 = h.default.svg("toggler-down", 13, 13);
                this.nodes.conversionToggler.appendChild(this.nodes.conversionTogglerContent), this.nodes.conversionToggler.appendChild(e3), this.nodes.togglerAndButtonsWrapper.appendChild(this.nodes.conversionToggler), this.listeners.on(this.nodes.conversionToggler, "click", function() {
                  t3.Editor.ConversionToolbar.toggle(function(e4) {
                    !e4 && t3.opened ? t3.flipper.activate() : t3.opened && t3.flipper.deactivate();
                  });
                }), this.tooltip.onHover(this.nodes.conversionToggler, b.default.ui(m.I18nInternalNS.ui.inlineToolbar.converter, "Convert to"), { placement: "top", hidingDelay: 100 });
              } }, { key: "setConversionTogglerContent", value: (n2 = (0, i2.default)(r2.default.mark(function t3() {
                var e3, n3, o4, i3, a2, s2;
                return r2.default.wrap(function(t4) {
                  for (; ; )
                    switch (t4.prev = t4.next) {
                      case 0:
                        return e3 = this.Editor.BlockManager, n3 = e3.currentBlock, o4 = n3.name, i3 = n3.tool.conversionConfig, a2 = i3 && i3.export, this.nodes.conversionToggler.hidden = !a2, this.nodes.conversionToggler.classList.toggle(this.CSS.conversionTogglerHidden, !a2), t4.next = 9, n3.getActiveToolboxEntry();
                      case 9:
                        if (t4.t0 = t4.sent, t4.t0) {
                          t4.next = 12;
                          break;
                        }
                        t4.t0 = {};
                      case 12:
                        s2 = t4.t0, this.nodes.conversionTogglerContent.innerHTML = s2.icon || s2.title || g.capitalize(o4);
                      case 14:
                      case "end":
                        return t4.stop();
                    }
                }, t3, this);
              })), function() {
                return n2.apply(this, arguments);
              }) }, { key: "prepareConversionToolbar", value: function() {
                var t3 = this.Editor.ConversionToolbar.make();
                h.default.append(this.nodes.wrapper, t3);
              } }, { key: "addToolsFiltered", value: function() {
                var t3 = this, e3 = v.default.get(), n3 = this.Editor.BlockManager.getBlock(e3.anchorNode);
                this.nodes.buttons.innerHTML = "", this.nodes.actions.innerHTML = "", this.toolsInstances = /* @__PURE__ */ new Map(), Array.from(n3.tool.inlineTools.values()).forEach(function(e4) {
                  t3.addTool(e4);
                }), this.recalculateWidth();
              } }, { key: "addTool", value: function(t3) {
                var e3 = this, n3 = t3.create(), o4 = n3.render();
                if (o4) {
                  if (o4.dataset.tool = t3.name, this.nodes.buttons.appendChild(o4), this.toolsInstances.set(t3.name, n3), g.isFunction(n3.renderActions)) {
                    var r3 = n3.renderActions();
                    this.nodes.actions.appendChild(r3);
                  }
                  this.listeners.on(o4, "click", function(t4) {
                    e3.toolClicked(n3), t4.preventDefault();
                  });
                  var i3 = this.getToolShortcut(t3.name);
                  if (i3)
                    try {
                      this.enableShortcuts(n3, i3);
                    } catch (t4) {
                    }
                  var a2 = h.default.make("div"), s2 = b.default.t(m.I18nInternalNS.toolNames, t3.title || g.capitalize(t3.name));
                  a2.appendChild(h.default.text(s2)), i3 && a2.appendChild(h.default.make("div", this.CSS.inlineToolbarShortcut, { textContent: g.beautifyShortcut(i3) })), this.tooltip.onHover(o4, a2, { placement: "top", hidingDelay: 100 }), n3.checkState(v.default.get());
                } else
                  g.log("Render method must return an instance of Node", "warn", t3.name);
              } }, { key: "getToolShortcut", value: function(t3) {
                var e3 = this.Editor.Tools, n3 = e3.inlineTools.get(t3), o4 = e3.internal.inlineTools;
                return Array.from(o4.keys()).includes(t3) ? this.inlineTools[t3][w.CommonInternalSettings.Shortcut] : n3.shortcut;
              } }, { key: "enableShortcuts", value: function(t3, e3) {
                var n3 = this;
                k.default.add({ name: e3, handler: function(e4) {
                  var o4 = n3.Editor.BlockManager.currentBlock;
                  o4 && o4.tool.enabledInlineTools && (e4.preventDefault(), n3.toolClicked(t3));
                }, on: this.Editor.UI.nodes.redactor });
              } }, { key: "toolClicked", value: function(t3) {
                var e3 = v.default.range;
                t3.surround(e3), this.checkToolsState();
              } }, { key: "checkToolsState", value: function() {
                this.toolsInstances.forEach(function(t3) {
                  t3.checkState(v.default.get());
                });
              } }, { key: "enableFlipper", value: function() {
                this.flipper = new y.default({ focusedItemClass: this.CSS.focusedButton, allowedKeys: [g.keyCodes.ENTER, g.keyCodes.TAB] });
              } }, { key: "inlineTools", get: function() {
                var t3 = {};
                return Array.from(this.Editor.Tools.inlineTools.entries()).forEach(function(e3) {
                  var n3 = (0, s.default)(e3, 2), o4 = n3[0], r3 = n3[1];
                  t3[o4] = r3.create();
                }), t3;
              } }]), p2;
            }(p.default);
            o2.default = B, B.displayName = "InlineToolbar", t.exports = e.default;
          }) ? o.apply(e, r) : o) || (t.exports = i);
        }, function(t, e, n) {
          var o, r, i;
          "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self && self, r = [e, n(42), n(30), n(20), n(21), n(2), n(3), n(5), n(6), n(4), n(59), n(389), n(9), n(7), n(390), n(391), n(392), n(393), n(394), n(398), n(399), n(400), n(185)], void 0 === (i = "function" == typeof (o = function(o2, r2, i2, a, s, l, c, u, f, d, p, h, v, g, y, b, m, k, x, w, S, T, E) {
            "use strict";
            var B = n(8), C = n(1);
            function _2() {
              if ("undefined" == typeof Reflect || !Reflect.construct)
                return false;
              if (Reflect.construct.sham)
                return false;
              if ("function" == typeof Proxy)
                return true;
              try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
                })), true;
              } catch (t2) {
                return false;
              }
            }
            Object.defineProperty(o2, "__esModule", { value: true }), o2.default = void 0, r2 = C(r2), i2 = C(i2), a = C(a), s = C(s), l = C(l), c = C(c), u = C(u), f = C(f), d = C(d), p = C(p), h = C(h), v = C(v), g = B(g), y = C(y), b = C(b), m = C(m), k = C(k), x = C(x), w = C(w), S = C(S), T = C(T), E = C(E);
            var I = function(t2, e2, n2, o3) {
              var r3, i3 = arguments.length, a2 = i3 < 3 ? e2 : null === o3 ? o3 = Object.getOwnPropertyDescriptor(e2, n2) : o3;
              if ("object" === ("undefined" == typeof Reflect ? "undefined" : (0, p.default)(Reflect)) && "function" == typeof Reflect.decorate)
                a2 = Reflect.decorate(t2, e2, n2, o3);
              else
                for (var s2 = t2.length - 1; s2 >= 0; s2--)
                  (r3 = t2[s2]) && (a2 = (i3 < 3 ? r3(a2) : i3 > 3 ? r3(e2, n2, a2) : r3(e2, n2)) || a2);
              return i3 > 3 && a2 && Object.defineProperty(e2, n2, a2), a2;
            }, O = function(t2) {
              (0, u.default)(p2, t2);
              var e2, n2, o3 = (e2 = p2, function() {
                var t3, n3 = (0, d.default)(e2);
                if (_2()) {
                  var o4 = (0, d.default)(this).constructor;
                  t3 = Reflect.construct(n3, arguments, o4);
                } else
                  t3 = n3.apply(this, arguments);
                return (0, f.default)(this, t3);
              });
              function p2() {
                var t3;
                return (0, l.default)(this, p2), (t3 = o3.apply(this, arguments)).stubTool = "stub", t3.toolsAvailable = new E.default(), t3.toolsUnavailable = new E.default(), t3;
              }
              return (0, c.default)(p2, [{ key: "prepare", value: (n2 = (0, s.default)(a.default.mark(function t3() {
                var e3, n3, o4 = this;
                return a.default.wrap(function(t4) {
                  for (; ; )
                    switch (t4.prev = t4.next) {
                      case 0:
                        if (this.validateTools(), this.config.tools = g.deepMerge({}, this.internalTools, this.config.tools), Object.prototype.hasOwnProperty.call(this.config, "tools") && 0 !== Object.keys(this.config.tools).length) {
                          t4.next = 4;
                          break;
                        }
                        throw Error("Can't start without tools");
                      case 4:
                        if (e3 = this.prepareConfig(), this.factory = new x.default(e3, this.config, this.Editor.API), 0 !== (n3 = this.getListOfPrepareFunctions(e3)).length) {
                          t4.next = 9;
                          break;
                        }
                        return t4.abrupt("return", Promise.resolve());
                      case 9:
                        return t4.next = 11, g.sequence(n3, function(t5) {
                          o4.toolPrepareMethodSuccess(t5);
                        }, function(t5) {
                          o4.toolPrepareMethodFallback(t5);
                        });
                      case 11:
                        this.prepareBlockTools();
                      case 12:
                      case "end":
                        return t4.stop();
                    }
                }, t3, this);
              })), function() {
                return n2.apply(this, arguments);
              }) }, { key: "getAllInlineToolsSanitizeConfig", value: function() {
                var t3 = {};
                return Array.from(this.inlineTools.values()).forEach(function(e3) {
                  Object.assign(t3, e3.sanitizeConfig);
                }), t3;
              } }, { key: "destroy", value: function() {
                Object.values(this.available).forEach(function() {
                  var t3 = (0, s.default)(a.default.mark(function t4(e3) {
                    return a.default.wrap(function(t5) {
                      for (; ; )
                        switch (t5.prev = t5.next) {
                          case 0:
                            if (!g.isFunction(e3.reset)) {
                              t5.next = 3;
                              break;
                            }
                            return t5.next = 3, e3.reset();
                          case 3:
                          case "end":
                            return t5.stop();
                        }
                    }, t4);
                  }));
                  return function(e3) {
                    return t3.apply(this, arguments);
                  };
                }());
              } }, { key: "toolPrepareMethodSuccess", value: function(t3) {
                var e3 = this.factory.get(t3.toolName);
                if (e3.isInline()) {
                  var n3 = ["render", "surround", "checkState"].filter(function(t4) {
                    return !e3.create()[t4];
                  });
                  if (n3.length)
                    return g.log("Incorrect Inline Tool: ".concat(e3.name, ". Some of required methods is not implemented %o"), "warn", n3), void this.toolsUnavailable.set(e3.name, e3);
                }
                this.toolsAvailable.set(e3.name, e3);
              } }, { key: "toolPrepareMethodFallback", value: function(t3) {
                this.toolsUnavailable.set(t3.toolName, this.factory.get(t3.toolName));
              } }, { key: "getListOfPrepareFunctions", value: function(t3) {
                var e3 = [];
                return Object.entries(t3).forEach(function(t4) {
                  var n3 = (0, i2.default)(t4, 2), o4 = n3[0], r3 = n3[1];
                  e3.push({ function: g.isFunction(r3.class.prepare) ? r3.class.prepare : function() {
                  }, data: { toolName: o4, config: r3.config } });
                }), e3;
              } }, { key: "prepareBlockTools", value: function() {
                var t3 = this;
                Array.from(this.blockTools.values()).forEach(function(e3) {
                  t3.assignInlineToolsToBlockTool(e3), t3.assignBlockTunesToBlockTool(e3);
                });
              } }, { key: "assignInlineToolsToBlockTool", value: function(t3) {
                var e3 = this;
                false !== this.config.inlineToolbar && (true !== t3.enabledInlineTools ? Array.isArray(t3.enabledInlineTools) && (t3.inlineTools = new E.default(t3.enabledInlineTools.map(function(t4) {
                  return [t4, e3.inlineTools.get(t4)];
                }))) : t3.inlineTools = new E.default(Array.isArray(this.config.inlineToolbar) ? this.config.inlineToolbar.map(function(t4) {
                  return [t4, e3.inlineTools.get(t4)];
                }) : Array.from(this.inlineTools.entries())));
              } }, { key: "assignBlockTunesToBlockTool", value: function(t3) {
                var e3 = this;
                if (false !== t3.enabledBlockTunes)
                  if (Array.isArray(t3.enabledBlockTunes)) {
                    var n3 = new E.default(t3.enabledBlockTunes.map(function(t4) {
                      return [t4, e3.blockTunes.get(t4)];
                    }));
                    t3.tunes = new E.default([].concat((0, r2.default)(n3), (0, r2.default)(this.blockTunes.internalTools)));
                  } else if (Array.isArray(this.config.tunes)) {
                    var o4 = new E.default(this.config.tunes.map(function(t4) {
                      return [t4, e3.blockTunes.get(t4)];
                    }));
                    t3.tunes = new E.default([].concat((0, r2.default)(o4), (0, r2.default)(this.blockTunes.internalTools)));
                  } else
                    t3.tunes = this.blockTunes.internalTools;
              } }, { key: "validateTools", value: function() {
                for (var t3 in this.config.tools)
                  if (Object.prototype.hasOwnProperty.call(this.config.tools, t3)) {
                    if (t3 in this.internalTools)
                      return;
                    var e3 = this.config.tools[t3];
                    if (!g.isFunction(e3) && !g.isFunction(e3.class))
                      throw Error("Tool \xAB".concat(t3, "\xBB must be a constructor function or an object with function in the \xABclass\xBB property"));
                  }
              } }, { key: "prepareConfig", value: function() {
                var t3 = {};
                for (var e3 in this.config.tools)
                  g.isObject(this.config.tools[e3]) ? t3[e3] = this.config.tools[e3] : t3[e3] = { class: this.config.tools[e3] };
                return t3;
              } }, { key: "available", get: function() {
                return this.toolsAvailable;
              } }, { key: "unavailable", get: function() {
                return this.toolsUnavailable;
              } }, { key: "inlineTools", get: function() {
                return this.available.inlineTools;
              } }, { key: "blockTools", get: function() {
                return this.available.blockTools;
              } }, { key: "blockTunes", get: function() {
                return this.available.blockTunes;
              } }, { key: "defaultTool", get: function() {
                return this.blockTools.get(this.config.defaultBlock);
              } }, { key: "internal", get: function() {
                return this.available.internalTools;
              } }, { key: "internalTools", get: function() {
                return { bold: { class: y.default, isInternal: true }, italic: { class: b.default, isInternal: true }, link: { class: m.default, isInternal: true }, paragraph: { class: h.default, inlineToolbar: true, isInternal: true }, stub: { class: k.default, isInternal: true }, moveUp: { class: T.default, isInternal: true }, delete: { class: S.default, isInternal: true }, moveDown: { class: w.default, isInternal: true } };
              } }]), p2;
            }(v.default);
            o2.default = O, O.displayName = "Tools", I([g.cacheable], O.prototype, "getAllInlineToolsSanitizeConfig", null), t.exports = e.default;
          }) ? o.apply(e, r) : o) || (t.exports = i);
        }, function(t, e, n) {
          var o, r, i;
          "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self && self, r = [e, n(30), n(2), n(3), n(5), n(6), n(4), n(153)], void 0 === (i = "function" == typeof (o = function(o2, r2, i2, a, s, l, c, u) {
            "use strict";
            var f = n(1);
            function d() {
              if ("undefined" == typeof Reflect || !Reflect.construct)
                return false;
              if (Reflect.construct.sham)
                return false;
              if ("function" == typeof Proxy)
                return true;
              try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
                })), true;
              } catch (t2) {
                return false;
              }
            }
            Object.defineProperty(o2, "__esModule", { value: true }), o2.default = void 0, r2 = f(r2), i2 = f(i2), a = f(a), s = f(s), l = f(l), c = f(c);
            var p = function(t2) {
              (0, s.default)(o3, t2);
              var e2, n2 = (e2 = o3, function() {
                var t3, n3 = (0, c.default)(e2);
                if (d()) {
                  var o4 = (0, c.default)(this).constructor;
                  t3 = Reflect.construct(n3, arguments, o4);
                } else
                  t3 = n3.apply(this, arguments);
                return (0, l.default)(this, t3);
              });
              function o3() {
                return (0, i2.default)(this, o3), n2.apply(this, arguments);
              }
              return (0, a.default)(o3, [{ key: "blockTools", get: function() {
                return new o3(Array.from(this.entries()).filter(function(t3) {
                  return (0, r2.default)(t3, 2)[1].isBlock();
                }));
              } }, { key: "inlineTools", get: function() {
                return new o3(Array.from(this.entries()).filter(function(t3) {
                  return (0, r2.default)(t3, 2)[1].isInline();
                }));
              } }, { key: "blockTunes", get: function() {
                return new o3(Array.from(this.entries()).filter(function(t3) {
                  return (0, r2.default)(t3, 2)[1].isTune();
                }));
              } }, { key: "internalTools", get: function() {
                return new o3(Array.from(this.entries()).filter(function(t3) {
                  return (0, r2.default)(t3, 2)[1].isInternal;
                }));
              } }, { key: "externalTools", get: function() {
                return new o3(Array.from(this.entries()).filter(function(t3) {
                  return !(0, r2.default)(t3, 2)[1].isInternal;
                }));
              } }]), o3;
            }((0, (u = f(u)).default)(Map));
            o2.default = p, p.displayName = "ToolsCollection", t.exports = e.default;
          }) ? o.apply(e, r) : o) || (t.exports = i);
        }, function(t, e, n) {
          var o, r, i;
          "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self && self, r = [e, n(30), n(42), n(20), n(21), n(2), n(3), n(5), n(6), n(4), n(401), n(9), n(14), n(7), n(25), n(61), n(62)], void 0 === (i = "function" == typeof (o = function(o2, r2, i2, a, s, l, c, u, f, d, p, h, v, g, y, b, m) {
            "use strict";
            var k = n(8), x = n(1);
            function w() {
              if ("undefined" == typeof Reflect || !Reflect.construct)
                return false;
              if (Reflect.construct.sham)
                return false;
              if ("function" == typeof Proxy)
                return true;
              try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
                })), true;
              } catch (t2) {
                return false;
              }
            }
            Object.defineProperty(o2, "__esModule", { value: true }), o2.default = void 0, r2 = x(r2), i2 = x(i2), a = x(a), s = x(s), l = x(l), c = x(c), u = x(u), f = x(f), d = x(d), p = x(p), h = x(h), v = x(v), g = k(g), y = x(y), b = x(b), m = x(m);
            var S = function(t2) {
              (0, u.default)(k2, t2);
              var e2, o3, h2 = (e2 = k2, function() {
                var t3, n2 = (0, d.default)(e2);
                if (w()) {
                  var o4 = (0, d.default)(this).constructor;
                  t3 = Reflect.construct(n2, arguments, o4);
                } else
                  t3 = n2.apply(this, arguments);
                return (0, f.default)(this, t3);
              });
              function k2() {
                var t3;
                return (0, l.default)(this, k2), (t3 = h2.apply(this, arguments)).isMobile = false, t3.contentRectCache = void 0, t3.resizeDebouncer = g.debounce(function() {
                  t3.windowResize();
                }, 200), t3;
              }
              return (0, c.default)(k2, [{ key: "addLoader", value: function() {
                this.nodes.loader = v.default.make("div", this.CSS.editorLoader), this.nodes.wrapper.prepend(this.nodes.loader), this.nodes.redactor.classList.add(this.CSS.editorZoneHidden);
              } }, { key: "removeLoader", value: function() {
                this.nodes.loader.remove(), this.nodes.redactor.classList.remove(this.CSS.editorZoneHidden);
              } }, { key: "prepare", value: (o3 = (0, s.default)(a.default.mark(function t3() {
                return a.default.wrap(function(t4) {
                  for (; ; )
                    switch (t4.prev = t4.next) {
                      case 0:
                        this.checkIsMobile(), this.make(), this.addLoader(), this.appendSVGSprite(), this.loadStyles();
                      case 5:
                      case "end":
                        return t4.stop();
                    }
                }, t3, this);
              })), function() {
                return o3.apply(this, arguments);
              }) }, { key: "toggleReadOnly", value: function(t3) {
                t3 ? this.disableModuleBindings() : this.enableModuleBindings();
              } }, { key: "checkEmptiness", value: function() {
                var t3 = this.Editor.BlockManager;
                this.nodes.wrapper.classList.toggle(this.CSS.editorEmpty, t3.isEditorEmpty);
              } }, { key: "destroy", value: function() {
                this.nodes.holder.innerHTML = "";
              } }, { key: "closeAllToolbars", value: function() {
                var t3 = this.Editor, e3 = t3.Toolbar, n2 = t3.BlockSettings, o4 = t3.InlineToolbar, r3 = t3.ConversionToolbar;
                n2.close(), o4.close(), r3.close(), e3.toolbox.close();
              } }, { key: "checkIsMobile", value: function() {
                this.isMobile = window.innerWidth < 650;
              } }, { key: "make", value: function() {
                this.nodes.holder = v.default.getHolder(this.config.holder), this.nodes.wrapper = v.default.make("div", [this.CSS.editorWrapper].concat((0, i2.default)(this.isRtl ? [this.CSS.editorRtlFix] : []))), this.nodes.redactor = v.default.make("div", this.CSS.editorZone), this.nodes.holder.offsetWidth < this.contentRect.width && this.nodes.wrapper.classList.add(this.CSS.editorWrapperNarrow), this.nodes.redactor.style.paddingBottom = this.config.minHeight + "px", this.nodes.wrapper.appendChild(this.nodes.redactor), this.nodes.holder.appendChild(this.nodes.wrapper);
              } }, { key: "loadStyles", value: function() {
                var t3 = n(402);
                if (!v.default.get("editor-js-styles")) {
                  var e3 = v.default.make("style", null, { id: "editor-js-styles", textContent: t3.toString() });
                  v.default.prepend(document.head, e3);
                }
              } }, { key: "enableModuleBindings", value: function() {
                var t3 = this;
                this.readOnlyMutableListeners.on(this.nodes.redactor, "click", function(e3) {
                  t3.redactorClicked(e3);
                }, false), this.readOnlyMutableListeners.on(this.nodes.redactor, "mousedown", function(e3) {
                  t3.documentTouched(e3);
                }, true), this.readOnlyMutableListeners.on(this.nodes.redactor, "touchstart", function(e3) {
                  t3.documentTouched(e3);
                }, true), this.readOnlyMutableListeners.on(document, "keydown", function(e3) {
                  t3.documentKeydown(e3);
                }, true), this.readOnlyMutableListeners.on(document, "mousedown", function(e3) {
                  t3.documentClicked(e3);
                }, true), this.readOnlyMutableListeners.on(document, "selectionchange", function(e3) {
                  t3.selectionChanged(e3);
                }, true), this.readOnlyMutableListeners.on(window, "resize", function() {
                  t3.resizeDebouncer();
                }, { passive: true }), this.watchBlockHoveredEvents();
              } }, { key: "watchBlockHoveredEvents", value: function() {
                var t3, e3 = this;
                this.readOnlyMutableListeners.on(this.nodes.redactor, "mousemove", g.throttle(function(n2) {
                  var o4 = n2.target.closest(".ce-block");
                  e3.Editor.BlockSelection.anyBlockSelected || o4 && t3 !== o4 && (t3 = o4, e3.eventsDispatcher.emit(e3.events.blockHovered, { block: e3.Editor.BlockManager.getBlockByChildNode(o4) }));
                }, 20), { passive: true });
              } }, { key: "disableModuleBindings", value: function() {
                this.readOnlyMutableListeners.clearAll();
              } }, { key: "windowResize", value: function() {
                this.contentRectCache = null, this.checkIsMobile();
              } }, { key: "documentKeydown", value: function(t3) {
                switch (t3.keyCode) {
                  case g.keyCodes.ENTER:
                    this.enterPressed(t3);
                    break;
                  case g.keyCodes.BACKSPACE:
                    this.backspacePressed(t3);
                    break;
                  case g.keyCodes.ESC:
                    this.escapePressed(t3);
                    break;
                  default:
                    this.defaultBehaviour(t3);
                }
              } }, { key: "defaultBehaviour", value: function(t3) {
                var e3 = this.Editor.BlockManager.currentBlock, n2 = t3.target.closest(".".concat(this.CSS.editorWrapper)), o4 = t3.altKey || t3.ctrlKey || t3.metaKey || t3.shiftKey;
                void 0 === e3 || null !== n2 ? n2 || e3 && o4 || (this.Editor.BlockManager.dropPointer(), this.Editor.Toolbar.close()) : this.Editor.BlockEvents.keydown(t3);
              } }, { key: "backspacePressed", value: function(t3) {
                var e3 = this.Editor, n2 = e3.BlockManager, o4 = e3.BlockSelection, r3 = e3.Caret;
                if (o4.anyBlockSelected && !y.default.isSelectionExists) {
                  var i3 = n2.removeSelectedBlocks();
                  r3.setToBlock(n2.insertDefaultBlockAtIndex(i3, true), r3.positions.START), o4.clearSelection(t3), t3.preventDefault(), t3.stopPropagation(), t3.stopImmediatePropagation();
                }
              } }, { key: "escapePressed", value: function(t3) {
                this.Editor.BlockSelection.clearSelection(t3), this.Editor.Toolbar.toolbox.opened ? (this.Editor.Toolbar.toolbox.close(), this.Editor.Caret.setToBlock(this.Editor.BlockManager.currentBlock)) : this.Editor.BlockSettings.opened ? this.Editor.BlockSettings.close() : this.Editor.ConversionToolbar.opened ? this.Editor.ConversionToolbar.close() : this.Editor.InlineToolbar.opened ? this.Editor.InlineToolbar.close() : this.Editor.Toolbar.close();
              } }, { key: "enterPressed", value: function(t3) {
                var e3 = this.Editor, n2 = e3.BlockManager, o4 = e3.BlockSelection, r3 = n2.currentBlockIndex >= 0;
                if (o4.anyBlockSelected && !y.default.isSelectionExists)
                  return o4.clearSelection(t3), t3.preventDefault(), t3.stopImmediatePropagation(), void t3.stopPropagation();
                if (!this.someToolbarOpened && r3 && "BODY" === t3.target.tagName) {
                  var i3 = this.Editor.BlockManager.insert();
                  this.Editor.Caret.setToBlock(i3), this.Editor.BlockManager.highlightCurrentNode(), this.Editor.Toolbar.moveAndOpen(i3);
                }
                this.Editor.BlockSelection.clearSelection(t3);
              } }, { key: "documentClicked", value: function(t3) {
                if (t3.isTrusted) {
                  var e3 = t3.target;
                  this.nodes.holder.contains(e3) || y.default.isAtEditor || (this.Editor.BlockManager.dropPointer(), this.Editor.Toolbar.close());
                  var n2 = this.Editor.BlockSettings.nodes.wrapper.contains(e3), o4 = this.Editor.Toolbar.nodes.settingsToggler.contains(e3), r3 = n2 || o4;
                  if (this.Editor.BlockSettings.opened && !r3) {
                    this.Editor.BlockSettings.close();
                    var i3 = this.Editor.BlockManager.getBlockByChildNode(e3);
                    this.Editor.Toolbar.moveAndOpen(i3);
                  }
                  this.Editor.BlockSelection.clearSelection(t3);
                }
              } }, { key: "documentTouched", value: function(t3) {
                var e3 = t3.target;
                if (e3 === this.nodes.redactor) {
                  var n2 = t3 instanceof MouseEvent ? t3.clientX : t3.touches[0].clientX, o4 = t3 instanceof MouseEvent ? t3.clientY : t3.touches[0].clientY;
                  e3 = document.elementFromPoint(n2, o4);
                }
                try {
                  this.Editor.BlockManager.setCurrentBlockByChildNode(e3), this.Editor.BlockManager.highlightCurrentNode();
                } catch (t4) {
                  this.Editor.RectangleSelection.isRectActivated() || this.Editor.Caret.setToTheLastBlock();
                }
                this.Editor.Toolbar.moveAndOpen();
              } }, { key: "redactorClicked", value: function(t3) {
                var e3 = this.Editor.BlockSelection;
                if (y.default.isCollapsed) {
                  var n2 = function() {
                    t3.stopImmediatePropagation(), t3.stopPropagation();
                  }, o4 = t3.target, r3 = t3.metaKey || t3.ctrlKey;
                  if (v.default.isAnchor(o4) && r3) {
                    n2();
                    var i3 = o4.getAttribute("href"), a2 = g.getValidUrl(i3);
                    g.openTab(a2);
                  } else {
                    var s2 = this.Editor.BlockManager.getBlockByIndex(-1), l2 = v.default.offset(s2.holder).bottom, c2 = t3.pageY;
                    if (t3.target instanceof Element && t3.target.isEqualNode(this.nodes.redactor) && !e3.anyBlockSelected && l2 < c2) {
                      n2();
                      var u2 = this.Editor, f2 = u2.BlockManager, d2 = u2.Caret, p2 = u2.Toolbar;
                      f2.lastBlock.tool.isDefault && f2.lastBlock.isEmpty || f2.insertAtEnd(), d2.setToTheLastBlock(), p2.moveAndOpen(f2.lastBlock);
                    }
                  }
                }
              } }, { key: "selectionChanged", value: function(t3) {
                var e3 = this.Editor, n2 = e3.CrossBlockSelection, o4 = e3.BlockSelection, r3 = y.default.anchorElement;
                if (n2.isCrossBlockSelectionStarted && o4.anyBlockSelected && y.default.get().removeAllRanges(), r3) {
                  var i3 = null === r3.closest(".".concat(b.default.CSS.content));
                  if (i3 && (this.Editor.InlineToolbar.containsNode(r3) || this.Editor.InlineToolbar.close(), "true" !== r3.dataset.inlineToolbar))
                    return;
                  this.Editor.BlockManager.currentBlock || this.Editor.BlockManager.setCurrentBlockByChildNode(r3);
                  var a2 = true !== i3;
                  this.Editor.InlineToolbar.tryToShow(true, a2);
                } else
                  y.default.range || this.Editor.InlineToolbar.close();
              } }, { key: "appendSVGSprite", value: function() {
                var t3 = v.default.make("div");
                t3.hidden = true, t3.style.display = "none", t3.innerHTML = p.default, v.default.append(this.nodes.wrapper, t3);
              } }, { key: "events", get: function() {
                return { blockHovered: "block-hovered" };
              } }, { key: "CSS", get: function() {
                return { editorWrapper: "codex-editor", editorWrapperNarrow: "codex-editor--narrow", editorZone: "codex-editor__redactor", editorZoneHidden: "codex-editor__redactor--hidden", editorLoader: "codex-editor__loader", editorEmpty: "codex-editor--empty", editorRtlFix: "codex-editor--rtl" };
              } }, { key: "contentRect", get: function() {
                if (this.contentRectCache)
                  return this.contentRectCache;
                var t3 = this.nodes.wrapper.querySelector(".".concat(b.default.CSS.content));
                return t3 ? (this.contentRectCache = t3.getBoundingClientRect(), this.contentRectCache) : { width: 650, left: 0, right: 0 };
              } }, { key: "someToolbarOpened", get: function() {
                var t3 = this.Editor, e3 = t3.Toolbar, n2 = t3.BlockSettings, o4 = t3.InlineToolbar, r3 = t3.ConversionToolbar;
                return n2.opened || o4.opened || r3.opened || e3.toolbox.opened;
              } }, { key: "someFlipperButtonFocused", get: function() {
                return !!this.Editor.Toolbar.toolbox.hasFocus() || Object.entries(this.Editor).filter(function(t3) {
                  var e3 = (0, r2.default)(t3, 2);
                  return e3[0], e3[1].flipper instanceof m.default;
                }).some(function(t3) {
                  var e3 = (0, r2.default)(t3, 2);
                  return e3[0], e3[1].flipper.hasFocus();
                });
              } }]), k2;
            }(h.default);
            o2.default = S, S.displayName = "UI", t.exports = e.default;
          }) ? o.apply(e, r) : o) || (t.exports = i);
        }, function(t, e, n) {
          n(188), t.exports = n(360);
        }, function(t, e, n) {
          n(189);
        }, function(t, e, n) {
          "use strict";
          n(190), n(333), n(335), n(338), n(340), n(342), n(344), n(346), n(348), n(350), n(352), n(354), n(356), n(147);
        }, function(t, e, n) {
          n(191), n(194), n(195), n(196), n(197), n(198), n(199), n(200), n(201), n(202), n(203), n(204), n(205), n(206), n(207), n(208), n(209), n(210), n(211), n(212), n(213), n(214), n(215), n(216), n(217), n(218), n(219), n(220), n(221), n(222), n(223), n(224), n(225), n(226), n(227), n(228), n(229), n(230), n(231), n(232), n(233), n(234), n(235), n(237), n(238), n(239), n(240), n(241), n(242), n(243), n(244), n(245), n(246), n(247), n(248), n(249), n(250), n(251), n(252), n(253), n(254), n(255), n(256), n(257), n(258), n(259), n(260), n(261), n(262), n(263), n(264), n(265), n(266), n(267), n(268), n(269), n(270), n(272), n(273), n(275), n(276), n(277), n(278), n(279), n(280), n(281), n(283), n(284), n(285), n(286), n(287), n(288), n(289), n(290), n(291), n(292), n(293), n(294), n(295), n(105), n(296), n(136), n(297), n(137), n(298), n(299), n(300), n(301), n(138), n(304), n(305), n(306), n(307), n(308), n(309), n(310), n(311), n(312), n(313), n(314), n(315), n(316), n(317), n(318), n(319), n(320), n(321), n(322), n(323), n(324), n(325), n(326), n(327), n(328), n(329), n(330), n(331), n(332), t.exports = n(17);
        }, function(t, e, n) {
          "use strict";
          var o = n(10), r = n(26), i = n(18), a = n(0), s = n(23), l = n(41).KEY, c = n(11), u = n(69), f = n(53), d = n(44), p = n(15), h = n(86), v = n(117), g = n(193), y = n(72), b = n(12), m = n(13), k = n(22), x = n(28), w = n(40), S = n(43), T = n(48), E = n(120), B = n(34), C = n(71), _2 = n(19), I = n(46), O = B.f, M = _2.f, R = E.f, A = o.Symbol, N = o.JSON, L = N && N.stringify, P = p("_hidden"), D = p("toPrimitive"), j = {}.propertyIsEnumerable, F = u("symbol-registry"), H = u("symbols"), U = u("op-symbols"), z = Object.prototype, W = "function" == typeof A && !!C.f, Y = o.QObject, V = !Y || !Y.prototype || !Y.prototype.findChild, X = i && c(function() {
            return 7 != T(M({}, "a", { get: function() {
              return M(this, "a", { value: 7 }).a;
            } })).a;
          }) ? function(t2, e2, n2) {
            var o2 = O(z, e2);
            o2 && delete z[e2], M(t2, e2, n2), o2 && t2 !== z && M(z, e2, o2);
          } : M, K = function(t2) {
            var e2 = H[t2] = T(A.prototype);
            return e2._k = t2, e2;
          }, G = W && "symbol" == typeof A.iterator ? function(t2) {
            return "symbol" == typeof t2;
          } : function(t2) {
            return t2 instanceof A;
          }, Z = function(t2, e2, n2) {
            return t2 === z && Z(U, e2, n2), b(t2), e2 = w(e2, true), b(n2), r(H, e2) ? (n2.enumerable ? (r(t2, P) && t2[P][e2] && (t2[P][e2] = false), n2 = T(n2, { enumerable: S(0, false) })) : (r(t2, P) || M(t2, P, S(1, {})), t2[P][e2] = true), X(t2, e2, n2)) : M(t2, e2, n2);
          }, q = function(t2, e2) {
            b(t2);
            for (var n2, o2 = g(e2 = x(e2)), r2 = 0, i2 = o2.length; i2 > r2; )
              Z(t2, n2 = o2[r2++], e2[n2]);
            return t2;
          }, J = function(t2) {
            var e2 = j.call(this, t2 = w(t2, true));
            return !(this === z && r(H, t2) && !r(U, t2)) && (!(e2 || !r(this, t2) || !r(H, t2) || r(this, P) && this[P][t2]) || e2);
          }, $ = function(t2, e2) {
            if (t2 = x(t2), e2 = w(e2, true), t2 !== z || !r(H, e2) || r(U, e2)) {
              var n2 = O(t2, e2);
              return !n2 || !r(H, e2) || r(t2, P) && t2[P][e2] || (n2.enumerable = true), n2;
            }
          }, Q = function(t2) {
            for (var e2, n2 = R(x(t2)), o2 = [], i2 = 0; n2.length > i2; )
              r(H, e2 = n2[i2++]) || e2 == P || e2 == l || o2.push(e2);
            return o2;
          }, tt = function(t2) {
            for (var e2, n2 = t2 === z, o2 = R(n2 ? U : x(t2)), i2 = [], a2 = 0; o2.length > a2; )
              !r(H, e2 = o2[a2++]) || n2 && !r(z, e2) || i2.push(H[e2]);
            return i2;
          };
          W || (s((A = function() {
            if (this instanceof A)
              throw TypeError("Symbol is not a constructor!");
            var t2 = d(arguments.length > 0 ? arguments[0] : void 0), e2 = function(n2) {
              this === z && e2.call(U, n2), r(this, P) && r(this[P], t2) && (this[P][t2] = false), X(this, t2, S(1, n2));
            };
            return i && V && X(z, t2, { configurable: true, set: e2 }), K(t2);
          }).prototype, "toString", function() {
            return this._k;
          }), B.f = $, _2.f = Z, n(49).f = E.f = Q, n(64).f = J, C.f = tt, i && !n(45) && s(z, "propertyIsEnumerable", J, true), h.f = function(t2) {
            return K(p(t2));
          }), a(a.G + a.W + a.F * !W, { Symbol: A });
          for (var et = "hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","), nt = 0; et.length > nt; )
            p(et[nt++]);
          for (var ot = I(p.store), rt = 0; ot.length > rt; )
            v(ot[rt++]);
          a(a.S + a.F * !W, "Symbol", { for: function(t2) {
            return r(F, t2 += "") ? F[t2] : F[t2] = A(t2);
          }, keyFor: function(t2) {
            if (!G(t2))
              throw TypeError(t2 + " is not a symbol!");
            for (var e2 in F)
              if (F[e2] === t2)
                return e2;
          }, useSetter: function() {
            V = true;
          }, useSimple: function() {
            V = false;
          } }), a(a.S + a.F * !W, "Object", { create: function(t2, e2) {
            return void 0 === e2 ? T(t2) : q(T(t2), e2);
          }, defineProperty: Z, defineProperties: q, getOwnPropertyDescriptor: $, getOwnPropertyNames: Q, getOwnPropertySymbols: tt });
          var it = c(function() {
            C.f(1);
          });
          a(a.S + a.F * it, "Object", { getOwnPropertySymbols: function(t2) {
            return C.f(k(t2));
          } }), N && a(a.S + a.F * (!W || c(function() {
            var t2 = A();
            return "[null]" != L([t2]) || "{}" != L({ a: t2 }) || "{}" != L(Object(t2));
          })), "JSON", { stringify: function(t2) {
            for (var e2, n2, o2 = [t2], r2 = 1; arguments.length > r2; )
              o2.push(arguments[r2++]);
            if (n2 = e2 = o2[1], (m(e2) || void 0 !== t2) && !G(t2))
              return y(e2) || (e2 = function(t3, e3) {
                if ("function" == typeof n2 && (e3 = n2.call(this, t3, e3)), !G(e3))
                  return e3;
              }), o2[1] = e2, L.apply(N, o2);
          } }), A.prototype[D] || n(27)(A.prototype, D, A.prototype.valueOf), f(A, "Symbol"), f(Math, "Math", true), f(o.JSON, "JSON", true);
        }, function(t, e, n) {
          t.exports = n(69)("native-function-to-string", Function.toString);
        }, function(t, e, n) {
          var o = n(46), r = n(71), i = n(64);
          t.exports = function(t2) {
            var e2 = o(t2), n2 = r.f;
            if (n2)
              for (var a, s = n2(t2), l = i.f, c = 0; s.length > c; )
                l.call(t2, a = s[c++]) && e2.push(a);
            return e2;
          };
        }, function(t, e, n) {
          var o = n(0);
          o(o.S, "Object", { create: n(48) });
        }, function(t, e, n) {
          var o = n(0);
          o(o.S + o.F * !n(18), "Object", { defineProperty: n(19).f });
        }, function(t, e, n) {
          var o = n(0);
          o(o.S + o.F * !n(18), "Object", { defineProperties: n(119) });
        }, function(t, e, n) {
          var o = n(28), r = n(34).f;
          n(35)("getOwnPropertyDescriptor", function() {
            return function(t2, e2) {
              return r(o(t2), e2);
            };
          });
        }, function(t, e, n) {
          var o = n(22), r = n(50);
          n(35)("getPrototypeOf", function() {
            return function(t2) {
              return r(o(t2));
            };
          });
        }, function(t, e, n) {
          var o = n(22), r = n(46);
          n(35)("keys", function() {
            return function(t2) {
              return r(o(t2));
            };
          });
        }, function(t, e, n) {
          n(35)("getOwnPropertyNames", function() {
            return n(120).f;
          });
        }, function(t, e, n) {
          var o = n(13), r = n(41).onFreeze;
          n(35)("freeze", function(t2) {
            return function(e2) {
              return t2 && o(e2) ? t2(r(e2)) : e2;
            };
          });
        }, function(t, e, n) {
          var o = n(13), r = n(41).onFreeze;
          n(35)("seal", function(t2) {
            return function(e2) {
              return t2 && o(e2) ? t2(r(e2)) : e2;
            };
          });
        }, function(t, e, n) {
          var o = n(13), r = n(41).onFreeze;
          n(35)("preventExtensions", function(t2) {
            return function(e2) {
              return t2 && o(e2) ? t2(r(e2)) : e2;
            };
          });
        }, function(t, e, n) {
          var o = n(13);
          n(35)("isFrozen", function(t2) {
            return function(e2) {
              return !o(e2) || !!t2 && t2(e2);
            };
          });
        }, function(t, e, n) {
          var o = n(13);
          n(35)("isSealed", function(t2) {
            return function(e2) {
              return !o(e2) || !!t2 && t2(e2);
            };
          });
        }, function(t, e, n) {
          var o = n(13);
          n(35)("isExtensible", function(t2) {
            return function(e2) {
              return !!o(e2) && (!t2 || t2(e2));
            };
          });
        }, function(t, e, n) {
          var o = n(0);
          o(o.S + o.F, "Object", { assign: n(121) });
        }, function(t, e, n) {
          var o = n(0);
          o(o.S, "Object", { is: n(122) });
        }, function(t, e, n) {
          var o = n(0);
          o(o.S, "Object", { setPrototypeOf: n(90).set });
        }, function(t, e, n) {
          "use strict";
          var o = n(65), r = {};
          r[n(15)("toStringTag")] = "z", r + "" != "[object z]" && n(23)(Object.prototype, "toString", function() {
            return "[object " + o(this) + "]";
          }, true);
        }, function(t, e, n) {
          var o = n(0);
          o(o.P, "Function", { bind: n(123) });
        }, function(t, e, n) {
          var o = n(19).f, r = Function.prototype, i = /^\s*function ([^ (]*)/;
          "name" in r || n(18) && o(r, "name", { configurable: true, get: function() {
            try {
              return ("" + this).match(i)[1];
            } catch (t2) {
              return "";
            }
          } });
        }, function(t, e, n) {
          "use strict";
          var o = n(13), r = n(50), i = n(15)("hasInstance"), a = Function.prototype;
          i in a || n(19).f(a, i, { value: function(t2) {
            if ("function" != typeof this || !o(t2))
              return false;
            if (!o(this.prototype))
              return t2 instanceof this;
            for (; t2 = r(t2); )
              if (this.prototype === t2)
                return true;
            return false;
          } });
        }, function(t, e, n) {
          var o = n(0), r = n(125);
          o(o.G + o.F * (parseInt != r), { parseInt: r });
        }, function(t, e, n) {
          var o = n(0), r = n(126);
          o(o.G + o.F * (parseFloat != r), { parseFloat: r });
        }, function(t, e, n) {
          "use strict";
          var o = n(10), r = n(26), i = n(37), a = n(92), s = n(40), l = n(11), c = n(49).f, u = n(34).f, f = n(19).f, d = n(54).trim, p = o.Number, h = p, v = p.prototype, g = "Number" == i(n(48)(v)), y = "trim" in String.prototype, b = function(t2) {
            var e2 = s(t2, false);
            if ("string" == typeof e2 && e2.length > 2) {
              var n2, o2, r2, i2 = (e2 = y ? e2.trim() : d(e2, 3)).charCodeAt(0);
              if (43 === i2 || 45 === i2) {
                if (88 === (n2 = e2.charCodeAt(2)) || 120 === n2)
                  return NaN;
              } else if (48 === i2) {
                switch (e2.charCodeAt(1)) {
                  case 66:
                  case 98:
                    o2 = 2, r2 = 49;
                    break;
                  case 79:
                  case 111:
                    o2 = 8, r2 = 55;
                    break;
                  default:
                    return +e2;
                }
                for (var a2, l2 = e2.slice(2), c2 = 0, u2 = l2.length; c2 < u2; c2++)
                  if ((a2 = l2.charCodeAt(c2)) < 48 || a2 > r2)
                    return NaN;
                return parseInt(l2, o2);
              }
            }
            return +e2;
          };
          if (!p(" 0o1") || !p("0b1") || p("+0x1")) {
            p = function(t2) {
              var e2 = arguments.length < 1 ? 0 : t2, n2 = this;
              return n2 instanceof p && (g ? l(function() {
                v.valueOf.call(n2);
              }) : "Number" != i(n2)) ? a(new h(b(e2)), n2, p) : b(e2);
            };
            for (var m, k = n(18) ? c(h) : "MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger".split(","), x = 0; k.length > x; x++)
              r(h, m = k[x]) && !r(p, m) && f(p, m, u(h, m));
            p.prototype = v, v.constructor = p, n(23)(o, "Number", p);
          }
        }, function(t, e, n) {
          "use strict";
          var o = n(0), r = n(33), i = n(127), a = n(93), s = 1 .toFixed, l = Math.floor, c = [0, 0, 0, 0, 0, 0], u = "Number.toFixed: incorrect invocation!", f = function(t2, e2) {
            for (var n2 = -1, o2 = e2; ++n2 < 6; )
              o2 += t2 * c[n2], c[n2] = o2 % 1e7, o2 = l(o2 / 1e7);
          }, d = function(t2) {
            for (var e2 = 6, n2 = 0; --e2 >= 0; )
              n2 += c[e2], c[e2] = l(n2 / t2), n2 = n2 % t2 * 1e7;
          }, p = function() {
            for (var t2 = 6, e2 = ""; --t2 >= 0; )
              if ("" !== e2 || 0 === t2 || 0 !== c[t2]) {
                var n2 = String(c[t2]);
                e2 = "" === e2 ? n2 : e2 + a.call("0", 7 - n2.length) + n2;
              }
            return e2;
          }, h = function(t2, e2, n2) {
            return 0 === e2 ? n2 : e2 % 2 == 1 ? h(t2, e2 - 1, n2 * t2) : h(t2 * t2, e2 / 2, n2);
          };
          o(o.P + o.F * (!!s && ("0.000" !== 8e-5.toFixed(3) || "1" !== 0.9.toFixed(0) || "1.25" !== 1.255.toFixed(2) || "1000000000000000128" !== 1000000000000000100 .toFixed(0)) || !n(11)(function() {
            s.call({});
          })), "Number", { toFixed: function(t2) {
            var e2, n2, o2, s2, l2 = i(this, u), c2 = r(t2), v = "", g = "0";
            if (c2 < 0 || c2 > 20)
              throw RangeError(u);
            if (l2 != l2)
              return "NaN";
            if (l2 <= -1e21 || l2 >= 1e21)
              return String(l2);
            if (l2 < 0 && (v = "-", l2 = -l2), l2 > 1e-21)
              if (n2 = (e2 = function(t3) {
                for (var e3 = 0, n3 = t3; n3 >= 4096; )
                  e3 += 12, n3 /= 4096;
                for (; n3 >= 2; )
                  e3 += 1, n3 /= 2;
                return e3;
              }(l2 * h(2, 69, 1)) - 69) < 0 ? l2 * h(2, -e2, 1) : l2 / h(2, e2, 1), n2 *= 4503599627370496, (e2 = 52 - e2) > 0) {
                for (f(0, n2), o2 = c2; o2 >= 7; )
                  f(1e7, 0), o2 -= 7;
                for (f(h(10, o2, 1), 0), o2 = e2 - 1; o2 >= 23; )
                  d(1 << 23), o2 -= 23;
                d(1 << o2), f(1, 1), d(2), g = p();
              } else
                f(0, n2), f(1 << -e2, 0), g = p() + a.call("0", c2);
            return g = c2 > 0 ? v + ((s2 = g.length) <= c2 ? "0." + a.call("0", c2 - s2) + g : g.slice(0, s2 - c2) + "." + g.slice(s2 - c2)) : v + g;
          } });
        }, function(t, e, n) {
          "use strict";
          var o = n(0), r = n(11), i = n(127), a = 1 .toPrecision;
          o(o.P + o.F * (r(function() {
            return "1" !== a.call(1, void 0);
          }) || !r(function() {
            a.call({});
          })), "Number", { toPrecision: function(t2) {
            var e2 = i(this, "Number#toPrecision: incorrect invocation!");
            return void 0 === t2 ? a.call(e2) : a.call(e2, t2);
          } });
        }, function(t, e, n) {
          var o = n(0);
          o(o.S, "Number", { EPSILON: Math.pow(2, -52) });
        }, function(t, e, n) {
          var o = n(0), r = n(10).isFinite;
          o(o.S, "Number", { isFinite: function(t2) {
            return "number" == typeof t2 && r(t2);
          } });
        }, function(t, e, n) {
          var o = n(0);
          o(o.S, "Number", { isInteger: n(128) });
        }, function(t, e, n) {
          var o = n(0);
          o(o.S, "Number", { isNaN: function(t2) {
            return t2 != t2;
          } });
        }, function(t, e, n) {
          var o = n(0), r = n(128), i = Math.abs;
          o(o.S, "Number", { isSafeInteger: function(t2) {
            return r(t2) && i(t2) <= 9007199254740991;
          } });
        }, function(t, e, n) {
          var o = n(0);
          o(o.S, "Number", { MAX_SAFE_INTEGER: 9007199254740991 });
        }, function(t, e, n) {
          var o = n(0);
          o(o.S, "Number", { MIN_SAFE_INTEGER: -9007199254740991 });
        }, function(t, e, n) {
          var o = n(0), r = n(126);
          o(o.S + o.F * (Number.parseFloat != r), "Number", { parseFloat: r });
        }, function(t, e, n) {
          var o = n(0), r = n(125);
          o(o.S + o.F * (Number.parseInt != r), "Number", { parseInt: r });
        }, function(t, e, n) {
          var o = n(0), r = n(129), i = Math.sqrt, a = Math.acosh;
          o(o.S + o.F * !(a && 710 == Math.floor(a(Number.MAX_VALUE)) && a(1 / 0) == 1 / 0), "Math", { acosh: function(t2) {
            return (t2 = +t2) < 1 ? NaN : t2 > 9490626562425156e-8 ? Math.log(t2) + Math.LN2 : r(t2 - 1 + i(t2 - 1) * i(t2 + 1));
          } });
        }, function(t, e, n) {
          var o = n(0), r = Math.asinh;
          o(o.S + o.F * !(r && 1 / r(0) > 0), "Math", { asinh: function t2(e2) {
            return isFinite(e2 = +e2) && 0 != e2 ? e2 < 0 ? -t2(-e2) : Math.log(e2 + Math.sqrt(e2 * e2 + 1)) : e2;
          } });
        }, function(t, e, n) {
          var o = n(0), r = Math.atanh;
          o(o.S + o.F * !(r && 1 / r(-0) < 0), "Math", { atanh: function(t2) {
            return 0 == (t2 = +t2) ? t2 : Math.log((1 + t2) / (1 - t2)) / 2;
          } });
        }, function(t, e, n) {
          var o = n(0), r = n(94);
          o(o.S, "Math", { cbrt: function(t2) {
            return r(t2 = +t2) * Math.pow(Math.abs(t2), 1 / 3);
          } });
        }, function(t, e, n) {
          var o = n(0);
          o(o.S, "Math", { clz32: function(t2) {
            return (t2 >>>= 0) ? 31 - Math.floor(Math.log(t2 + 0.5) * Math.LOG2E) : 32;
          } });
        }, function(t, e, n) {
          var o = n(0), r = Math.exp;
          o(o.S, "Math", { cosh: function(t2) {
            return (r(t2 = +t2) + r(-t2)) / 2;
          } });
        }, function(t, e, n) {
          var o = n(0), r = n(95);
          o(o.S + o.F * (r != Math.expm1), "Math", { expm1: r });
        }, function(t, e, n) {
          var o = n(0);
          o(o.S, "Math", { fround: n(236) });
        }, function(t, e, n) {
          var o = n(94), r = Math.pow, i = r(2, -52), a = r(2, -23), s = r(2, 127) * (2 - a), l = r(2, -126);
          t.exports = Math.fround || function(t2) {
            var e2, n2, r2 = Math.abs(t2), c = o(t2);
            return r2 < l ? c * (r2 / l / a + 1 / i - 1 / i) * l * a : (n2 = (e2 = (1 + a / i) * r2) - (e2 - r2)) > s || n2 != n2 ? c * (1 / 0) : c * n2;
          };
        }, function(t, e, n) {
          var o = n(0), r = Math.abs;
          o(o.S, "Math", { hypot: function(t2, e2) {
            for (var n2, o2, i = 0, a = 0, s = arguments.length, l = 0; a < s; )
              l < (n2 = r(arguments[a++])) ? (i = i * (o2 = l / n2) * o2 + 1, l = n2) : i += n2 > 0 ? (o2 = n2 / l) * o2 : n2;
            return l === 1 / 0 ? 1 / 0 : l * Math.sqrt(i);
          } });
        }, function(t, e, n) {
          var o = n(0), r = Math.imul;
          o(o.S + o.F * n(11)(function() {
            return -5 != r(4294967295, 5) || 2 != r.length;
          }), "Math", { imul: function(t2, e2) {
            var n2 = +t2, o2 = +e2, r2 = 65535 & n2, i = 65535 & o2;
            return 0 | r2 * i + ((65535 & n2 >>> 16) * i + r2 * (65535 & o2 >>> 16) << 16 >>> 0);
          } });
        }, function(t, e, n) {
          var o = n(0);
          o(o.S, "Math", { log10: function(t2) {
            return Math.log(t2) * Math.LOG10E;
          } });
        }, function(t, e, n) {
          var o = n(0);
          o(o.S, "Math", { log1p: n(129) });
        }, function(t, e, n) {
          var o = n(0);
          o(o.S, "Math", { log2: function(t2) {
            return Math.log(t2) / Math.LN2;
          } });
        }, function(t, e, n) {
          var o = n(0);
          o(o.S, "Math", { sign: n(94) });
        }, function(t, e, n) {
          var o = n(0), r = n(95), i = Math.exp;
          o(o.S + o.F * n(11)(function() {
            return -2e-17 != !Math.sinh(-2e-17);
          }), "Math", { sinh: function(t2) {
            return Math.abs(t2 = +t2) < 1 ? (r(t2) - r(-t2)) / 2 : (i(t2 - 1) - i(-t2 - 1)) * (Math.E / 2);
          } });
        }, function(t, e, n) {
          var o = n(0), r = n(95), i = Math.exp;
          o(o.S, "Math", { tanh: function(t2) {
            var e2 = r(t2 = +t2), n2 = r(-t2);
            return e2 == 1 / 0 ? 1 : n2 == 1 / 0 ? -1 : (e2 - n2) / (i(t2) + i(-t2));
          } });
        }, function(t, e, n) {
          var o = n(0);
          o(o.S, "Math", { trunc: function(t2) {
            return (t2 > 0 ? Math.floor : Math.ceil)(t2);
          } });
        }, function(t, e, n) {
          var o = n(0), r = n(47), i = String.fromCharCode, a = String.fromCodePoint;
          o(o.S + o.F * (!!a && 1 != a.length), "String", { fromCodePoint: function(t2) {
            for (var e2, n2 = [], o2 = arguments.length, a2 = 0; o2 > a2; ) {
              if (e2 = +arguments[a2++], r(e2, 1114111) !== e2)
                throw RangeError(e2 + " is not a valid code point");
              n2.push(e2 < 65536 ? i(e2) : i(55296 + ((e2 -= 65536) >> 10), e2 % 1024 + 56320));
            }
            return n2.join("");
          } });
        }, function(t, e, n) {
          var o = n(0), r = n(28), i = n(16);
          o(o.S, "String", { raw: function(t2) {
            for (var e2 = r(t2.raw), n2 = i(e2.length), o2 = arguments.length, a = [], s = 0; n2 > s; )
              a.push(String(e2[s++])), s < o2 && a.push(String(arguments[s]));
            return a.join("");
          } });
        }, function(t, e, n) {
          "use strict";
          n(54)("trim", function(t2) {
            return function() {
              return t2(this, 3);
            };
          });
        }, function(t, e, n) {
          "use strict";
          var o = n(96)(true);
          n(97)(String, "String", function(t2) {
            this._t = String(t2), this._i = 0;
          }, function() {
            var t2, e2 = this._t, n2 = this._i;
            return n2 >= e2.length ? { value: void 0, done: true } : (t2 = o(e2, n2), this._i += t2.length, { value: t2, done: false });
          });
        }, function(t, e, n) {
          "use strict";
          var o = n(0), r = n(96)(false);
          o(o.P, "String", { codePointAt: function(t2) {
            return r(this, t2);
          } });
        }, function(t, e, n) {
          "use strict";
          var o = n(0), r = n(16), i = n(98), a = "".endsWith;
          o(o.P + o.F * n(100)("endsWith"), "String", { endsWith: function(t2) {
            var e2 = i(this, t2, "endsWith"), n2 = arguments.length > 1 ? arguments[1] : void 0, o2 = r(e2.length), s = void 0 === n2 ? o2 : Math.min(r(n2), o2), l = String(t2);
            return a ? a.call(e2, l, s) : e2.slice(s - l.length, s) === l;
          } });
        }, function(t, e, n) {
          "use strict";
          var o = n(0), r = n(98);
          o(o.P + o.F * n(100)("includes"), "String", { includes: function(t2) {
            return !!~r(this, t2, "includes").indexOf(t2, arguments.length > 1 ? arguments[1] : void 0);
          } });
        }, function(t, e, n) {
          var o = n(0);
          o(o.P, "String", { repeat: n(93) });
        }, function(t, e, n) {
          "use strict";
          var o = n(0), r = n(16), i = n(98), a = "".startsWith;
          o(o.P + o.F * n(100)("startsWith"), "String", { startsWith: function(t2) {
            var e2 = i(this, t2, "startsWith"), n2 = r(Math.min(arguments.length > 1 ? arguments[1] : void 0, e2.length)), o2 = String(t2);
            return a ? a.call(e2, o2, n2) : e2.slice(n2, n2 + o2.length) === o2;
          } });
        }, function(t, e, n) {
          "use strict";
          n(24)("anchor", function(t2) {
            return function(e2) {
              return t2(this, "a", "name", e2);
            };
          });
        }, function(t, e, n) {
          "use strict";
          n(24)("big", function(t2) {
            return function() {
              return t2(this, "big", "", "");
            };
          });
        }, function(t, e, n) {
          "use strict";
          n(24)("blink", function(t2) {
            return function() {
              return t2(this, "blink", "", "");
            };
          });
        }, function(t, e, n) {
          "use strict";
          n(24)("bold", function(t2) {
            return function() {
              return t2(this, "b", "", "");
            };
          });
        }, function(t, e, n) {
          "use strict";
          n(24)("fixed", function(t2) {
            return function() {
              return t2(this, "tt", "", "");
            };
          });
        }, function(t, e, n) {
          "use strict";
          n(24)("fontcolor", function(t2) {
            return function(e2) {
              return t2(this, "font", "color", e2);
            };
          });
        }, function(t, e, n) {
          "use strict";
          n(24)("fontsize", function(t2) {
            return function(e2) {
              return t2(this, "font", "size", e2);
            };
          });
        }, function(t, e, n) {
          "use strict";
          n(24)("italics", function(t2) {
            return function() {
              return t2(this, "i", "", "");
            };
          });
        }, function(t, e, n) {
          "use strict";
          n(24)("link", function(t2) {
            return function(e2) {
              return t2(this, "a", "href", e2);
            };
          });
        }, function(t, e, n) {
          "use strict";
          n(24)("small", function(t2) {
            return function() {
              return t2(this, "small", "", "");
            };
          });
        }, function(t, e, n) {
          "use strict";
          n(24)("strike", function(t2) {
            return function() {
              return t2(this, "strike", "", "");
            };
          });
        }, function(t, e, n) {
          "use strict";
          n(24)("sub", function(t2) {
            return function() {
              return t2(this, "sub", "", "");
            };
          });
        }, function(t, e, n) {
          "use strict";
          n(24)("sup", function(t2) {
            return function() {
              return t2(this, "sup", "", "");
            };
          });
        }, function(t, e, n) {
          var o = n(0);
          o(o.S, "Date", { now: function() {
            return (/* @__PURE__ */ new Date()).getTime();
          } });
        }, function(t, e, n) {
          "use strict";
          var o = n(0), r = n(22), i = n(40);
          o(o.P + o.F * n(11)(function() {
            return null !== (/* @__PURE__ */ new Date(NaN)).toJSON() || 1 !== Date.prototype.toJSON.call({ toISOString: function() {
              return 1;
            } });
          }), "Date", { toJSON: function(t2) {
            var e2 = r(this), n2 = i(e2);
            return "number" != typeof n2 || isFinite(n2) ? e2.toISOString() : null;
          } });
        }, function(t, e, n) {
          var o = n(0), r = n(271);
          o(o.P + o.F * (Date.prototype.toISOString !== r), "Date", { toISOString: r });
        }, function(t, e, n) {
          "use strict";
          var o = n(11), r = Date.prototype.getTime, i = Date.prototype.toISOString, a = function(t2) {
            return t2 > 9 ? t2 : "0" + t2;
          };
          t.exports = o(function() {
            return "0385-07-25T07:06:39.999Z" != i.call(/* @__PURE__ */ new Date(-50000000000001));
          }) || !o(function() {
            i.call(/* @__PURE__ */ new Date(NaN));
          }) ? function() {
            if (!isFinite(r.call(this)))
              throw RangeError("Invalid time value");
            var t2 = this, e2 = t2.getUTCFullYear(), n2 = t2.getUTCMilliseconds(), o2 = e2 < 0 ? "-" : e2 > 9999 ? "+" : "";
            return o2 + ("00000" + Math.abs(e2)).slice(o2 ? -6 : -4) + "-" + a(t2.getUTCMonth() + 1) + "-" + a(t2.getUTCDate()) + "T" + a(t2.getUTCHours()) + ":" + a(t2.getUTCMinutes()) + ":" + a(t2.getUTCSeconds()) + "." + (n2 > 99 ? n2 : "0" + a(n2)) + "Z";
          } : i;
        }, function(t, e, n) {
          var o = Date.prototype, r = o.toString, i = o.getTime;
          /* @__PURE__ */ new Date(NaN) + "" != "Invalid Date" && n(23)(o, "toString", function() {
            var t2 = i.call(this);
            return t2 == t2 ? r.call(this) : "Invalid Date";
          });
        }, function(t, e, n) {
          var o = n(15)("toPrimitive"), r = Date.prototype;
          o in r || n(27)(r, o, n(274));
        }, function(t, e, n) {
          "use strict";
          var o = n(12), r = n(40);
          t.exports = function(t2) {
            if ("string" !== t2 && "number" !== t2 && "default" !== t2)
              throw TypeError("Incorrect hint");
            return r(o(this), "number" != t2);
          };
        }, function(t, e, n) {
          var o = n(0);
          o(o.S, "Array", { isArray: n(72) });
        }, function(t, e, n) {
          "use strict";
          var o = n(31), r = n(0), i = n(22), a = n(131), s = n(101), l = n(16), c = n(102), u = n(103);
          r(r.S + r.F * !n(73)(function(t2) {
            Array.from(t2);
          }), "Array", { from: function(t2) {
            var e2, n2, r2, f, d = i(t2), p = "function" == typeof this ? this : Array, h = arguments.length, v = h > 1 ? arguments[1] : void 0, g = void 0 !== v, y = 0, b = u(d);
            if (g && (v = o(v, h > 2 ? arguments[2] : void 0, 2)), null == b || p == Array && s(b))
              for (n2 = new p(e2 = l(d.length)); e2 > y; y++)
                c(n2, y, g ? v(d[y], y) : d[y]);
            else
              for (f = b.call(d), n2 = new p(); !(r2 = f.next()).done; y++)
                c(n2, y, g ? a(f, v, [r2.value, y], true) : r2.value);
            return n2.length = y, n2;
          } });
        }, function(t, e, n) {
          "use strict";
          var o = n(0), r = n(102);
          o(o.S + o.F * n(11)(function() {
            function t2() {
            }
            return !(Array.of.call(t2) instanceof t2);
          }), "Array", { of: function() {
            for (var t2 = 0, e2 = arguments.length, n2 = new ("function" == typeof this ? this : Array)(e2); e2 > t2; )
              r(n2, t2, arguments[t2++]);
            return n2.length = e2, n2;
          } });
        }, function(t, e, n) {
          "use strict";
          var o = n(0), r = n(28), i = [].join;
          o(o.P + o.F * (n(63) != Object || !n(29)(i)), "Array", { join: function(t2) {
            return i.call(r(this), void 0 === t2 ? "," : t2);
          } });
        }, function(t, e, n) {
          "use strict";
          var o = n(0), r = n(89), i = n(37), a = n(47), s = n(16), l = [].slice;
          o(o.P + o.F * n(11)(function() {
            r && l.call(r);
          }), "Array", { slice: function(t2, e2) {
            var n2 = s(this.length), o2 = i(this);
            if (e2 = void 0 === e2 ? n2 : e2, "Array" == o2)
              return l.call(this, t2, e2);
            for (var r2 = a(t2, n2), c = a(e2, n2), u = s(c - r2), f = new Array(u), d = 0; d < u; d++)
              f[d] = "String" == o2 ? this.charAt(r2 + d) : this[r2 + d];
            return f;
          } });
        }, function(t, e, n) {
          "use strict";
          var o = n(0), r = n(32), i = n(22), a = n(11), s = [].sort, l = [1, 2, 3];
          o(o.P + o.F * (a(function() {
            l.sort(void 0);
          }) || !a(function() {
            l.sort(null);
          }) || !n(29)(s)), "Array", { sort: function(t2) {
            return void 0 === t2 ? s.call(i(this)) : s.call(i(this), r(t2));
          } });
        }, function(t, e, n) {
          "use strict";
          var o = n(0), r = n(36)(0), i = n(29)([].forEach, true);
          o(o.P + o.F * !i, "Array", { forEach: function(t2) {
            return r(this, t2, arguments[1]);
          } });
        }, function(t, e, n) {
          var o = n(13), r = n(72), i = n(15)("species");
          t.exports = function(t2) {
            var e2;
            return r(t2) && ("function" != typeof (e2 = t2.constructor) || e2 !== Array && !r(e2.prototype) || (e2 = void 0), o(e2) && null === (e2 = e2[i]) && (e2 = void 0)), void 0 === e2 ? Array : e2;
          };
        }, function(t, e, n) {
          "use strict";
          var o = n(0), r = n(36)(1);
          o(o.P + o.F * !n(29)([].map, true), "Array", { map: function(t2) {
            return r(this, t2, arguments[1]);
          } });
        }, function(t, e, n) {
          "use strict";
          var o = n(0), r = n(36)(2);
          o(o.P + o.F * !n(29)([].filter, true), "Array", { filter: function(t2) {
            return r(this, t2, arguments[1]);
          } });
        }, function(t, e, n) {
          "use strict";
          var o = n(0), r = n(36)(3);
          o(o.P + o.F * !n(29)([].some, true), "Array", { some: function(t2) {
            return r(this, t2, arguments[1]);
          } });
        }, function(t, e, n) {
          "use strict";
          var o = n(0), r = n(36)(4);
          o(o.P + o.F * !n(29)([].every, true), "Array", { every: function(t2) {
            return r(this, t2, arguments[1]);
          } });
        }, function(t, e, n) {
          "use strict";
          var o = n(0), r = n(133);
          o(o.P + o.F * !n(29)([].reduce, true), "Array", { reduce: function(t2) {
            return r(this, t2, arguments.length, arguments[1], false);
          } });
        }, function(t, e, n) {
          "use strict";
          var o = n(0), r = n(133);
          o(o.P + o.F * !n(29)([].reduceRight, true), "Array", { reduceRight: function(t2) {
            return r(this, t2, arguments.length, arguments[1], true);
          } });
        }, function(t, e, n) {
          "use strict";
          var o = n(0), r = n(70)(false), i = [].indexOf, a = !!i && 1 / [1].indexOf(1, -0) < 0;
          o(o.P + o.F * (a || !n(29)(i)), "Array", { indexOf: function(t2) {
            return a ? i.apply(this, arguments) || 0 : r(this, t2, arguments[1]);
          } });
        }, function(t, e, n) {
          "use strict";
          var o = n(0), r = n(28), i = n(33), a = n(16), s = [].lastIndexOf, l = !!s && 1 / [1].lastIndexOf(1, -0) < 0;
          o(o.P + o.F * (l || !n(29)(s)), "Array", { lastIndexOf: function(t2) {
            if (l)
              return s.apply(this, arguments) || 0;
            var e2 = r(this), n2 = a(e2.length), o2 = n2 - 1;
            for (arguments.length > 1 && (o2 = Math.min(o2, i(arguments[1]))), o2 < 0 && (o2 = n2 + o2); o2 >= 0; o2--)
              if (o2 in e2 && e2[o2] === t2)
                return o2 || 0;
            return -1;
          } });
        }, function(t, e, n) {
          var o = n(0);
          o(o.P, "Array", { copyWithin: n(134) }), n(51)("copyWithin");
        }, function(t, e, n) {
          var o = n(0);
          o(o.P, "Array", { fill: n(104) }), n(51)("fill");
        }, function(t, e, n) {
          "use strict";
          var o = n(0), r = n(36)(5), i = true;
          "find" in [] && Array(1).find(function() {
            i = false;
          }), o(o.P + o.F * i, "Array", { find: function(t2) {
            return r(this, t2, arguments.length > 1 ? arguments[1] : void 0);
          } }), n(51)("find");
        }, function(t, e, n) {
          "use strict";
          var o = n(0), r = n(36)(6), i = "findIndex", a = true;
          i in [] && Array(1)[i](function() {
            a = false;
          }), o(o.P + o.F * a, "Array", { findIndex: function(t2) {
            return r(this, t2, arguments.length > 1 ? arguments[1] : void 0);
          } }), n(51)(i);
        }, function(t, e, n) {
          n(56)("Array");
        }, function(t, e, n) {
          var o = n(10), r = n(92), i = n(19).f, a = n(49).f, s = n(99), l = n(74), c = o.RegExp, u = c, f = c.prototype, d = /a/g, p = /a/g, h = new c(d) !== d;
          if (n(18) && (!h || n(11)(function() {
            return p[n(15)("match")] = false, c(d) != d || c(p) == p || "/a/i" != c(d, "i");
          }))) {
            c = function(t2, e2) {
              var n2 = this instanceof c, o2 = s(t2), i2 = void 0 === e2;
              return !n2 && o2 && t2.constructor === c && i2 ? t2 : r(h ? new u(o2 && !i2 ? t2.source : t2, e2) : u((o2 = t2 instanceof c) ? t2.source : t2, o2 && i2 ? l.call(t2) : e2), n2 ? this : f, c);
            };
            for (var v = function(t2) {
              t2 in c || i(c, t2, { configurable: true, get: function() {
                return u[t2];
              }, set: function(e2) {
                u[t2] = e2;
              } });
            }, g = a(u), y = 0; g.length > y; )
              v(g[y++]);
            f.constructor = c, c.prototype = f, n(23)(o, "RegExp", c);
          }
          n(56)("RegExp");
        }, function(t, e, n) {
          "use strict";
          n(137);
          var o = n(12), r = n(74), i = n(18), a = /./.toString, s = function(t2) {
            n(23)(RegExp.prototype, "toString", t2, true);
          };
          n(11)(function() {
            return "/a/b" != a.call({ source: "a", flags: "b" });
          }) ? s(function() {
            var t2 = o(this);
            return "/".concat(t2.source, "/", "flags" in t2 ? t2.flags : !i && t2 instanceof RegExp ? r.call(t2) : void 0);
          }) : "toString" != a.name && s(function() {
            return a.call(this);
          });
        }, function(t, e, n) {
          "use strict";
          var o = n(12), r = n(16), i = n(107), a = n(75);
          n(76)("match", 1, function(t2, e2, n2, s) {
            return [function(n3) {
              var o2 = t2(this), r2 = null == n3 ? void 0 : n3[e2];
              return void 0 !== r2 ? r2.call(n3, o2) : new RegExp(n3)[e2](String(o2));
            }, function(t3) {
              var e3 = s(n2, t3, this);
              if (e3.done)
                return e3.value;
              var l = o(t3), c = String(this);
              if (!l.global)
                return a(l, c);
              var u = l.unicode;
              l.lastIndex = 0;
              for (var f, d = [], p = 0; null !== (f = a(l, c)); ) {
                var h = String(f[0]);
                d[p] = h, "" === h && (l.lastIndex = i(c, r(l.lastIndex), u)), p++;
              }
              return 0 === p ? null : d;
            }];
          });
        }, function(t, e, n) {
          "use strict";
          var o = n(12), r = n(22), i = n(16), a = n(33), s = n(107), l = n(75), c = Math.max, u = Math.min, f = Math.floor, d = /\$([$&`']|\d\d?|<[^>]*>)/g, p = /\$([$&`']|\d\d?)/g;
          n(76)("replace", 2, function(t2, e2, n2, h) {
            return [function(o2, r2) {
              var i2 = t2(this), a2 = null == o2 ? void 0 : o2[e2];
              return void 0 !== a2 ? a2.call(o2, i2, r2) : n2.call(String(i2), o2, r2);
            }, function(t3, e3) {
              var r2 = h(n2, t3, this, e3);
              if (r2.done)
                return r2.value;
              var f2 = o(t3), d2 = String(this), p2 = "function" == typeof e3;
              p2 || (e3 = String(e3));
              var g = f2.global;
              if (g) {
                var y = f2.unicode;
                f2.lastIndex = 0;
              }
              for (var b = []; ; ) {
                var m = l(f2, d2);
                if (null === m)
                  break;
                if (b.push(m), !g)
                  break;
                "" === String(m[0]) && (f2.lastIndex = s(d2, i(f2.lastIndex), y));
              }
              for (var k, x = "", w = 0, S = 0; S < b.length; S++) {
                m = b[S];
                for (var T = String(m[0]), E = c(u(a(m.index), d2.length), 0), B = [], C = 1; C < m.length; C++)
                  B.push(void 0 === (k = m[C]) ? k : String(k));
                var _2 = m.groups;
                if (p2) {
                  var I = [T].concat(B, E, d2);
                  void 0 !== _2 && I.push(_2);
                  var O = String(e3.apply(void 0, I));
                } else
                  O = v(T, d2, E, B, _2, e3);
                E >= w && (x += d2.slice(w, E) + O, w = E + T.length);
              }
              return x + d2.slice(w);
            }];
            function v(t3, e3, o2, i2, a2, s2) {
              var l2 = o2 + t3.length, c2 = i2.length, u2 = p;
              return void 0 !== a2 && (a2 = r(a2), u2 = d), n2.call(s2, u2, function(n3, r2) {
                var s3;
                switch (r2.charAt(0)) {
                  case "$":
                    return "$";
                  case "&":
                    return t3;
                  case "`":
                    return e3.slice(0, o2);
                  case "'":
                    return e3.slice(l2);
                  case "<":
                    s3 = a2[r2.slice(1, -1)];
                    break;
                  default:
                    var u3 = +r2;
                    if (0 === u3)
                      return n3;
                    if (u3 > c2) {
                      var d2 = f(u3 / 10);
                      return 0 === d2 ? n3 : d2 <= c2 ? void 0 === i2[d2 - 1] ? r2.charAt(1) : i2[d2 - 1] + r2.charAt(1) : n3;
                    }
                    s3 = i2[u3 - 1];
                }
                return void 0 === s3 ? "" : s3;
              });
            }
          });
        }, function(t, e, n) {
          "use strict";
          var o = n(12), r = n(122), i = n(75);
          n(76)("search", 1, function(t2, e2, n2, a) {
            return [function(n3) {
              var o2 = t2(this), r2 = null == n3 ? void 0 : n3[e2];
              return void 0 !== r2 ? r2.call(n3, o2) : new RegExp(n3)[e2](String(o2));
            }, function(t3) {
              var e3 = a(n2, t3, this);
              if (e3.done)
                return e3.value;
              var s = o(t3), l = String(this), c = s.lastIndex;
              r(c, 0) || (s.lastIndex = 0);
              var u = i(s, l);
              return r(s.lastIndex, c) || (s.lastIndex = c), null === u ? -1 : u.index;
            }];
          });
        }, function(t, e, n) {
          "use strict";
          var o = n(99), r = n(12), i = n(66), a = n(107), s = n(16), l = n(75), c = n(106), u = n(11), f = Math.min, d = [].push, p = "length", h = !u(function() {
            RegExp(4294967295, "y");
          });
          n(76)("split", 2, function(t2, e2, n2, u2) {
            var v;
            return v = "c" == "abbc".split(/(b)*/)[1] || 4 != "test".split(/(?:)/, -1)[p] || 2 != "ab".split(/(?:ab)*/)[p] || 4 != ".".split(/(.?)(.?)/)[p] || ".".split(/()()/)[p] > 1 || "".split(/.?/)[p] ? function(t3, e3) {
              var r2 = String(this);
              if (void 0 === t3 && 0 === e3)
                return [];
              if (!o(t3))
                return n2.call(r2, t3, e3);
              for (var i2, a2, s2, l2 = [], u3 = (t3.ignoreCase ? "i" : "") + (t3.multiline ? "m" : "") + (t3.unicode ? "u" : "") + (t3.sticky ? "y" : ""), f2 = 0, h2 = void 0 === e3 ? 4294967295 : e3 >>> 0, v2 = new RegExp(t3.source, u3 + "g"); (i2 = c.call(v2, r2)) && !((a2 = v2.lastIndex) > f2 && (l2.push(r2.slice(f2, i2.index)), i2[p] > 1 && i2.index < r2[p] && d.apply(l2, i2.slice(1)), s2 = i2[0][p], f2 = a2, l2[p] >= h2)); )
                v2.lastIndex === i2.index && v2.lastIndex++;
              return f2 === r2[p] ? !s2 && v2.test("") || l2.push("") : l2.push(r2.slice(f2)), l2[p] > h2 ? l2.slice(0, h2) : l2;
            } : "0".split(void 0, 0)[p] ? function(t3, e3) {
              return void 0 === t3 && 0 === e3 ? [] : n2.call(this, t3, e3);
            } : n2, [function(n3, o2) {
              var r2 = t2(this), i2 = null == n3 ? void 0 : n3[e2];
              return void 0 !== i2 ? i2.call(n3, r2, o2) : v.call(String(r2), n3, o2);
            }, function(t3, e3) {
              var o2 = u2(v, t3, this, e3, v !== n2);
              if (o2.done)
                return o2.value;
              var c2 = r(t3), d2 = String(this), p2 = i(c2, RegExp), g = c2.unicode, y = (c2.ignoreCase ? "i" : "") + (c2.multiline ? "m" : "") + (c2.unicode ? "u" : "") + (h ? "y" : "g"), b = new p2(h ? c2 : "^(?:" + c2.source + ")", y), m = void 0 === e3 ? 4294967295 : e3 >>> 0;
              if (0 === m)
                return [];
              if (0 === d2.length)
                return null === l(b, d2) ? [d2] : [];
              for (var k = 0, x = 0, w = []; x < d2.length; ) {
                b.lastIndex = h ? x : 0;
                var S, T = l(b, h ? d2 : d2.slice(x));
                if (null === T || (S = f(s(b.lastIndex + (h ? 0 : x)), d2.length)) === k)
                  x = a(d2, x, g);
                else {
                  if (w.push(d2.slice(k, x)), w.length === m)
                    return w;
                  for (var E = 1; E <= T.length - 1; E++)
                    if (w.push(T[E]), w.length === m)
                      return w;
                  x = k = S;
                }
              }
              return w.push(d2.slice(k)), w;
            }];
          });
        }, function(t, e, n) {
          var o = n(10), r = n(108).set, i = o.MutationObserver || o.WebKitMutationObserver, a = o.process, s = o.Promise, l = "process" == n(37)(a);
          t.exports = function() {
            var t2, e2, n2, c = function() {
              var o2, r2;
              for (l && (o2 = a.domain) && o2.exit(); t2; ) {
                r2 = t2.fn, t2 = t2.next;
                try {
                  r2();
                } catch (o3) {
                  throw t2 ? n2() : e2 = void 0, o3;
                }
              }
              e2 = void 0, o2 && o2.enter();
            };
            if (l)
              n2 = function() {
                a.nextTick(c);
              };
            else if (!i || o.navigator && o.navigator.standalone)
              if (s && s.resolve) {
                var u = s.resolve(void 0);
                n2 = function() {
                  u.then(c);
                };
              } else
                n2 = function() {
                  r.call(o, c);
                };
            else {
              var f = true, d = document.createTextNode("");
              new i(c).observe(d, { characterData: true }), n2 = function() {
                d.data = f = !f;
              };
            }
            return function(o2) {
              var r2 = { fn: o2, next: void 0 };
              e2 && (e2.next = r2), t2 || (t2 = r2, n2()), e2 = r2;
            };
          };
        }, function(t, e) {
          t.exports = function(t2) {
            try {
              return { e: false, v: t2() };
            } catch (t3) {
              return { e: true, v: t3 };
            }
          };
        }, function(t, e, n) {
          "use strict";
          var o = n(141), r = n(52);
          t.exports = n(79)("Map", function(t2) {
            return function() {
              return t2(this, arguments.length > 0 ? arguments[0] : void 0);
            };
          }, { get: function(t2) {
            var e2 = o.getEntry(r(this, "Map"), t2);
            return e2 && e2.v;
          }, set: function(t2, e2) {
            return o.def(r(this, "Map"), 0 === t2 ? 0 : t2, e2);
          } }, o, true);
        }, function(t, e, n) {
          "use strict";
          var o = n(141), r = n(52);
          t.exports = n(79)("Set", function(t2) {
            return function() {
              return t2(this, arguments.length > 0 ? arguments[0] : void 0);
            };
          }, { add: function(t2) {
            return o.def(r(this, "Set"), t2 = 0 === t2 ? 0 : t2, t2);
          } }, o);
        }, function(t, e, n) {
          "use strict";
          var o, r = n(10), i = n(36)(0), a = n(23), s = n(41), l = n(121), c = n(142), u = n(13), f = n(52), d = n(52), p = !r.ActiveXObject && "ActiveXObject" in r, h = s.getWeak, v = Object.isExtensible, g = c.ufstore, y = function(t2) {
            return function() {
              return t2(this, arguments.length > 0 ? arguments[0] : void 0);
            };
          }, b = { get: function(t2) {
            if (u(t2)) {
              var e2 = h(t2);
              return true === e2 ? g(f(this, "WeakMap")).get(t2) : e2 ? e2[this._i] : void 0;
            }
          }, set: function(t2, e2) {
            return c.def(f(this, "WeakMap"), t2, e2);
          } }, m = t.exports = n(79)("WeakMap", y, b, c, true, true);
          d && p && (l((o = c.getConstructor(y, "WeakMap")).prototype, b), s.NEED = true, i(["delete", "has", "get", "set"], function(t2) {
            var e2 = m.prototype, n2 = e2[t2];
            a(e2, t2, function(e3, r2) {
              if (u(e3) && !v(e3)) {
                this._f || (this._f = new o());
                var i2 = this._f[t2](e3, r2);
                return "set" == t2 ? this : i2;
              }
              return n2.call(this, e3, r2);
            });
          }));
        }, function(t, e, n) {
          "use strict";
          var o = n(142), r = n(52);
          n(79)("WeakSet", function(t2) {
            return function() {
              return t2(this, arguments.length > 0 ? arguments[0] : void 0);
            };
          }, { add: function(t2) {
            return o.def(r(this, "WeakSet"), t2, true);
          } }, o, false, true);
        }, function(t, e, n) {
          "use strict";
          var o = n(0), r = n(80), i = n(109), a = n(12), s = n(47), l = n(16), c = n(13), u = n(10).ArrayBuffer, f = n(66), d = i.ArrayBuffer, p = i.DataView, h = r.ABV && u.isView, v = d.prototype.slice, g = r.VIEW;
          o(o.G + o.W + o.F * (u !== d), { ArrayBuffer: d }), o(o.S + o.F * !r.CONSTR, "ArrayBuffer", { isView: function(t2) {
            return h && h(t2) || c(t2) && g in t2;
          } }), o(o.P + o.U + o.F * n(11)(function() {
            return !new d(2).slice(1, void 0).byteLength;
          }), "ArrayBuffer", { slice: function(t2, e2) {
            if (void 0 !== v && void 0 === e2)
              return v.call(a(this), t2);
            for (var n2 = a(this).byteLength, o2 = s(t2, n2), r2 = s(void 0 === e2 ? n2 : e2, n2), i2 = new (f(this, d))(l(r2 - o2)), c2 = new p(this), u2 = new p(i2), h2 = 0; o2 < r2; )
              u2.setUint8(h2++, c2.getUint8(o2++));
            return i2;
          } }), n(56)("ArrayBuffer");
        }, function(t, e, n) {
          var o = n(0);
          o(o.G + o.W + o.F * !n(80).ABV, { DataView: n(109).DataView });
        }, function(t, e, n) {
          n(39)("Int8", 1, function(t2) {
            return function(e2, n2, o) {
              return t2(this, e2, n2, o);
            };
          });
        }, function(t, e, n) {
          n(39)("Uint8", 1, function(t2) {
            return function(e2, n2, o) {
              return t2(this, e2, n2, o);
            };
          });
        }, function(t, e, n) {
          n(39)("Uint8", 1, function(t2) {
            return function(e2, n2, o) {
              return t2(this, e2, n2, o);
            };
          }, true);
        }, function(t, e, n) {
          n(39)("Int16", 2, function(t2) {
            return function(e2, n2, o) {
              return t2(this, e2, n2, o);
            };
          });
        }, function(t, e, n) {
          n(39)("Uint16", 2, function(t2) {
            return function(e2, n2, o) {
              return t2(this, e2, n2, o);
            };
          });
        }, function(t, e, n) {
          n(39)("Int32", 4, function(t2) {
            return function(e2, n2, o) {
              return t2(this, e2, n2, o);
            };
          });
        }, function(t, e, n) {
          n(39)("Uint32", 4, function(t2) {
            return function(e2, n2, o) {
              return t2(this, e2, n2, o);
            };
          });
        }, function(t, e, n) {
          n(39)("Float32", 4, function(t2) {
            return function(e2, n2, o) {
              return t2(this, e2, n2, o);
            };
          });
        }, function(t, e, n) {
          n(39)("Float64", 8, function(t2) {
            return function(e2, n2, o) {
              return t2(this, e2, n2, o);
            };
          });
        }, function(t, e, n) {
          var o = n(0), r = n(32), i = n(12), a = (n(10).Reflect || {}).apply, s = Function.apply;
          o(o.S + o.F * !n(11)(function() {
            a(function() {
            });
          }), "Reflect", { apply: function(t2, e2, n2) {
            var o2 = r(t2), l = i(n2);
            return a ? a(o2, e2, l) : s.call(o2, e2, l);
          } });
        }, function(t, e, n) {
          var o = n(0), r = n(48), i = n(32), a = n(12), s = n(13), l = n(11), c = n(123), u = (n(10).Reflect || {}).construct, f = l(function() {
            function t2() {
            }
            return !(u(function() {
            }, [], t2) instanceof t2);
          }), d = !l(function() {
            u(function() {
            });
          });
          o(o.S + o.F * (f || d), "Reflect", { construct: function(t2, e2) {
            i(t2), a(e2);
            var n2 = arguments.length < 3 ? t2 : i(arguments[2]);
            if (d && !f)
              return u(t2, e2, n2);
            if (t2 == n2) {
              switch (e2.length) {
                case 0:
                  return new t2();
                case 1:
                  return new t2(e2[0]);
                case 2:
                  return new t2(e2[0], e2[1]);
                case 3:
                  return new t2(e2[0], e2[1], e2[2]);
                case 4:
                  return new t2(e2[0], e2[1], e2[2], e2[3]);
              }
              var o2 = [null];
              return o2.push.apply(o2, e2), new (c.apply(t2, o2))();
            }
            var l2 = n2.prototype, p = r(s(l2) ? l2 : Object.prototype), h = Function.apply.call(t2, p, e2);
            return s(h) ? h : p;
          } });
        }, function(t, e, n) {
          var o = n(19), r = n(0), i = n(12), a = n(40);
          r(r.S + r.F * n(11)(function() {
            Reflect.defineProperty(o.f({}, 1, { value: 1 }), 1, { value: 2 });
          }), "Reflect", { defineProperty: function(t2, e2, n2) {
            i(t2), e2 = a(e2, true), i(n2);
            try {
              return o.f(t2, e2, n2), true;
            } catch (t3) {
              return false;
            }
          } });
        }, function(t, e, n) {
          var o = n(0), r = n(34).f, i = n(12);
          o(o.S, "Reflect", { deleteProperty: function(t2, e2) {
            var n2 = r(i(t2), e2);
            return !(n2 && !n2.configurable) && delete t2[e2];
          } });
        }, function(t, e, n) {
          "use strict";
          var o = n(0), r = n(12), i = function(t2) {
            this._t = r(t2), this._i = 0;
            var e2, n2 = this._k = [];
            for (e2 in t2)
              n2.push(e2);
          };
          n(130)(i, "Object", function() {
            var t2, e2 = this._k;
            do {
              if (this._i >= e2.length)
                return { value: void 0, done: true };
            } while (!((t2 = e2[this._i++]) in this._t));
            return { value: t2, done: false };
          }), o(o.S, "Reflect", { enumerate: function(t2) {
            return new i(t2);
          } });
        }, function(t, e, n) {
          var o = n(34), r = n(50), i = n(26), a = n(0), s = n(13), l = n(12);
          a(a.S, "Reflect", { get: function t2(e2, n2) {
            var a2, c, u = arguments.length < 3 ? e2 : arguments[2];
            return l(e2) === u ? e2[n2] : (a2 = o.f(e2, n2)) ? i(a2, "value") ? a2.value : void 0 !== a2.get ? a2.get.call(u) : void 0 : s(c = r(e2)) ? t2(c, n2, u) : void 0;
          } });
        }, function(t, e, n) {
          var o = n(34), r = n(0), i = n(12);
          r(r.S, "Reflect", { getOwnPropertyDescriptor: function(t2, e2) {
            return o.f(i(t2), e2);
          } });
        }, function(t, e, n) {
          var o = n(0), r = n(50), i = n(12);
          o(o.S, "Reflect", { getPrototypeOf: function(t2) {
            return r(i(t2));
          } });
        }, function(t, e, n) {
          var o = n(0);
          o(o.S, "Reflect", { has: function(t2, e2) {
            return e2 in t2;
          } });
        }, function(t, e, n) {
          var o = n(0), r = n(12), i = Object.isExtensible;
          o(o.S, "Reflect", { isExtensible: function(t2) {
            return r(t2), !i || i(t2);
          } });
        }, function(t, e, n) {
          var o = n(0);
          o(o.S, "Reflect", { ownKeys: n(144) });
        }, function(t, e, n) {
          var o = n(0), r = n(12), i = Object.preventExtensions;
          o(o.S, "Reflect", { preventExtensions: function(t2) {
            r(t2);
            try {
              return i && i(t2), true;
            } catch (t3) {
              return false;
            }
          } });
        }, function(t, e, n) {
          var o = n(19), r = n(34), i = n(50), a = n(26), s = n(0), l = n(43), c = n(12), u = n(13);
          s(s.S, "Reflect", { set: function t2(e2, n2, s2) {
            var f, d, p = arguments.length < 4 ? e2 : arguments[3], h = r.f(c(e2), n2);
            if (!h) {
              if (u(d = i(e2)))
                return t2(d, n2, s2, p);
              h = l(0);
            }
            if (a(h, "value")) {
              if (false === h.writable || !u(p))
                return false;
              if (f = r.f(p, n2)) {
                if (f.get || f.set || false === f.writable)
                  return false;
                f.value = s2, o.f(p, n2, f);
              } else
                o.f(p, n2, l(0, s2));
              return true;
            }
            return void 0 !== h.set && (h.set.call(p, s2), true);
          } });
        }, function(t, e, n) {
          var o = n(0), r = n(90);
          r && o(o.S, "Reflect", { setPrototypeOf: function(t2, e2) {
            r.check(t2, e2);
            try {
              return r.set(t2, e2), true;
            } catch (t3) {
              return false;
            }
          } });
        }, function(t, e, n) {
          n(334), t.exports = n(17).Array.includes;
        }, function(t, e, n) {
          "use strict";
          var o = n(0), r = n(70)(true);
          o(o.P, "Array", { includes: function(t2) {
            return r(this, t2, arguments.length > 1 ? arguments[1] : void 0);
          } }), n(51)("includes");
        }, function(t, e, n) {
          n(336), t.exports = n(17).Array.flatMap;
        }, function(t, e, n) {
          "use strict";
          var o = n(0), r = n(337), i = n(22), a = n(16), s = n(32), l = n(132);
          o(o.P, "Array", { flatMap: function(t2) {
            var e2, n2, o2 = i(this);
            return s(t2), e2 = a(o2.length), n2 = l(o2, 0), r(n2, o2, o2, e2, 0, 1, t2, arguments[1]), n2;
          } }), n(51)("flatMap");
        }, function(t, e, n) {
          "use strict";
          var o = n(72), r = n(13), i = n(16), a = n(31), s = n(15)("isConcatSpreadable");
          t.exports = function t2(e2, n2, l, c, u, f, d, p) {
            for (var h, v, g = u, y = 0, b = !!d && a(d, p, 3); y < c; ) {
              if (y in l) {
                if (h = b ? b(l[y], y, n2) : l[y], v = false, r(h) && (v = void 0 !== (v = h[s]) ? !!v : o(h)), v && f > 0)
                  g = t2(e2, n2, h, i(h.length), g, f - 1) - 1;
                else {
                  if (g >= 9007199254740991)
                    throw TypeError();
                  e2[g] = h;
                }
                g++;
              }
              y++;
            }
            return g;
          };
        }, function(t, e, n) {
          n(339), t.exports = n(17).String.padStart;
        }, function(t, e, n) {
          "use strict";
          var o = n(0), r = n(145), i = n(78), a = /Version\/10\.\d+(\.\d+)?( Mobile\/\w+)? Safari\//.test(i);
          o(o.P + o.F * a, "String", { padStart: function(t2) {
            return r(this, t2, arguments.length > 1 ? arguments[1] : void 0, true);
          } });
        }, function(t, e, n) {
          n(341), t.exports = n(17).String.padEnd;
        }, function(t, e, n) {
          "use strict";
          var o = n(0), r = n(145), i = n(78), a = /Version\/10\.\d+(\.\d+)?( Mobile\/\w+)? Safari\//.test(i);
          o(o.P + o.F * a, "String", { padEnd: function(t2) {
            return r(this, t2, arguments.length > 1 ? arguments[1] : void 0, false);
          } });
        }, function(t, e, n) {
          n(343), t.exports = n(17).String.trimLeft;
        }, function(t, e, n) {
          "use strict";
          n(54)("trimLeft", function(t2) {
            return function() {
              return t2(this, 1);
            };
          }, "trimStart");
        }, function(t, e, n) {
          n(345), t.exports = n(17).String.trimRight;
        }, function(t, e, n) {
          "use strict";
          n(54)("trimRight", function(t2) {
            return function() {
              return t2(this, 2);
            };
          }, "trimEnd");
        }, function(t, e, n) {
          n(347), t.exports = n(86).f("asyncIterator");
        }, function(t, e, n) {
          n(117)("asyncIterator");
        }, function(t, e, n) {
          n(349), t.exports = n(17).Object.getOwnPropertyDescriptors;
        }, function(t, e, n) {
          var o = n(0), r = n(144), i = n(28), a = n(34), s = n(102);
          o(o.S, "Object", { getOwnPropertyDescriptors: function(t2) {
            for (var e2, n2, o2 = i(t2), l = a.f, c = r(o2), u = {}, f = 0; c.length > f; )
              void 0 !== (n2 = l(o2, e2 = c[f++])) && s(u, e2, n2);
            return u;
          } });
        }, function(t, e, n) {
          n(351), t.exports = n(17).Object.values;
        }, function(t, e, n) {
          var o = n(0), r = n(146)(false);
          o(o.S, "Object", { values: function(t2) {
            return r(t2);
          } });
        }, function(t, e, n) {
          n(353), t.exports = n(17).Object.entries;
        }, function(t, e, n) {
          var o = n(0), r = n(146)(true);
          o(o.S, "Object", { entries: function(t2) {
            return r(t2);
          } });
        }, function(t, e, n) {
          "use strict";
          n(138), n(355), t.exports = n(17).Promise.finally;
        }, function(t, e, n) {
          "use strict";
          var o = n(0), r = n(17), i = n(10), a = n(66), s = n(140);
          o(o.P + o.R, "Promise", { finally: function(t2) {
            var e2 = a(this, r.Promise || i.Promise), n2 = "function" == typeof t2;
            return this.then(n2 ? function(n3) {
              return s(e2, t2()).then(function() {
                return n3;
              });
            } : t2, n2 ? function(n3) {
              return s(e2, t2()).then(function() {
                throw n3;
              });
            } : t2);
          } });
        }, function(t, e, n) {
          n(357), n(358), n(359), t.exports = n(17);
        }, function(t, e, n) {
          var o = n(10), r = n(0), i = n(78), a = [].slice, s = /MSIE .\./.test(i), l = function(t2) {
            return function(e2, n2) {
              var o2 = arguments.length > 2, r2 = !!o2 && a.call(arguments, 2);
              return t2(o2 ? function() {
                ("function" == typeof e2 ? e2 : Function(e2)).apply(this, r2);
              } : e2, n2);
            };
          };
          r(r.G + r.B + r.F * s, { setTimeout: l(o.setTimeout), setInterval: l(o.setInterval) });
        }, function(t, e, n) {
          var o = n(0), r = n(108);
          o(o.G + o.B, { setImmediate: r.set, clearImmediate: r.clear });
        }, function(t, e, n) {
          for (var o = n(105), r = n(46), i = n(23), a = n(10), s = n(27), l = n(55), c = n(15), u = c("iterator"), f = c("toStringTag"), d = l.Array, p = { CSSRuleList: true, CSSStyleDeclaration: false, CSSValueList: false, ClientRectList: false, DOMRectList: false, DOMStringList: false, DOMTokenList: true, DataTransferItemList: false, FileList: false, HTMLAllCollection: false, HTMLCollection: false, HTMLFormElement: false, HTMLSelectElement: false, MediaList: true, MimeTypeArray: false, NamedNodeMap: false, NodeList: true, PaintRequestList: false, Plugin: false, PluginArray: false, SVGLengthList: false, SVGNumberList: false, SVGPathSegList: false, SVGPointList: false, SVGStringList: false, SVGTransformList: false, SourceBufferList: false, StyleSheetList: true, TextTrackCueList: false, TextTrackList: false, TouchList: false }, h = r(p), v = 0; v < h.length; v++) {
            var g, y = h[v], b = p[y], m = a[y], k = m && m.prototype;
            if (k && (k[u] || s(k, u, d), k[f] || s(k, f, y), l[y] = d, b))
              for (g in o)
                k[g] || i(k, g, o[g], true);
          }
        }, function(t, e, n) {
          var o, r, i;
          "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self && self, r = [e, n(30), n(2), n(3), n(364), n(366), n(367), n(7)], void 0 === (i = "function" == typeof (o = function(o2, r2, i2, a, s, l, c, u) {
            "use strict";
            var f = n(8), d = n(1);
            Object.defineProperty(o2, "__esModule", { value: true }), o2.default = void 0, r2 = d(r2), i2 = d(i2), a = d(a), c = d(c), u = f(u);
            var p = function() {
              function t2(e2) {
                var n2 = this;
                (0, i2.default)(this, t2);
                var o3 = function() {
                };
                u.isObject(e2) && u.isFunction(e2.onReady) && (o3 = e2.onReady);
                var r3 = new c.default(e2);
                this.isReady = r3.isReady.then(function() {
                  n2.exportAPI(r3), o3();
                });
              }
              return (0, a.default)(t2, [{ key: "exportAPI", value: function(t3) {
                var e2 = this;
                ["configuration"].forEach(function(n2) {
                  e2[n2] = t3[n2];
                }), this.destroy = function() {
                  for (var n2 in Object.values(t3.moduleInstances).forEach(function(t4) {
                    u.isFunction(t4.destroy) && t4.destroy(), t4.listeners.removeAll();
                  }), t3 = null, e2)
                    Object.prototype.hasOwnProperty.call(e2, n2) && delete e2[n2];
                  Object.setPrototypeOf(e2, null);
                }, Object.setPrototypeOf(this, t3.moduleInstances.API.methods), delete this.exportAPI, Object.entries({ blocks: { clear: "clear", render: "render" }, caret: { focus: "focus" }, events: { on: "on", off: "off", emit: "emit" }, saver: { save: "save" } }).forEach(function(n2) {
                  var o3 = (0, r2.default)(n2, 2), i3 = o3[0], a2 = o3[1];
                  Object.entries(a2).forEach(function(n3) {
                    var o4 = (0, r2.default)(n3, 2), a3 = o4[0], s2 = o4[1];
                    e2[s2] = t3.moduleInstances.API.methods[i3][a3];
                  });
                });
              } }], [{ key: "version", get: function() {
                return "2.25.0";
              } }]), t2;
            }();
            o2.default = p, p.displayName = "EditorJS", t.exports = e.default;
          }) ? o.apply(e, r) : o) || (t.exports = i);
        }, function(t, e) {
          t.exports = function(t2) {
            if (Array.isArray(t2))
              return t2;
          };
        }, function(t, e) {
          t.exports = function(t2, e2) {
            if ("undefined" != typeof Symbol && Symbol.iterator in Object(t2)) {
              var n = [], o = true, r = false, i = void 0;
              try {
                for (var a, s = t2[Symbol.iterator](); !(o = (a = s.next()).done) && (n.push(a.value), !e2 || n.length !== e2); o = true)
                  ;
              } catch (t3) {
                r = true, i = t3;
              } finally {
                try {
                  o || null == s.return || s.return();
                } finally {
                  if (r)
                    throw i;
                }
              }
              return n;
            }
          };
        }, function(t, e) {
          t.exports = function() {
            throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          };
        }, function(t, e, n) {
          (e = t.exports = function(...t2) {
            return r(...t2);
          }).__esModule = true;
          const o = n(365), r = o.default;
          Object.assign(e, o);
        }, function(t, e, n) {
          "use strict";
          Object.defineProperty(e, "__esModule", { value: true }), e.default = function() {
          }, e.revert = function() {
          };
        }, function(t, e, n) {
          var o, r, i;
          "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self && self, r = [], void 0 === (i = "function" == typeof (o = function() {
            "use strict";
            Element.prototype.matches || (Element.prototype.matches = Element.prototype.matchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector || Element.prototype.oMatchesSelector || Element.prototype.webkitMatchesSelector || function(t2) {
              for (var e2 = (this.document || this.ownerDocument).querySelectorAll(t2), n2 = e2.length; --n2 >= 0 && e2.item(n2) !== this; )
                ;
              return n2 > -1;
            }), Element.prototype.closest || (Element.prototype.closest = function(t2) {
              var e2 = this;
              if (!document.documentElement.contains(e2))
                return null;
              do {
                if (e2.matches(t2))
                  return e2;
                e2 = e2.parentElement || e2.parentNode;
              } while (null !== e2);
              return null;
            }), Element.prototype.prepend || (Element.prototype.prepend = function(t2) {
              var e2 = document.createDocumentFragment();
              Array.isArray(t2) || (t2 = [t2]), t2.forEach(function(t3) {
                var n2 = t3 instanceof Node;
                e2.appendChild(n2 ? t3 : document.createTextNode(t3));
              }), this.insertBefore(e2, this.firstChild);
            }), Element.prototype.scrollIntoViewIfNeeded || (Element.prototype.scrollIntoViewIfNeeded = function(t2) {
              t2 = 0 === arguments.length || !!t2;
              var e2 = this.parentNode, n2 = window.getComputedStyle(e2, null), o2 = parseInt(n2.getPropertyValue("border-top-width")), r2 = parseInt(n2.getPropertyValue("border-left-width")), i2 = this.offsetTop - e2.offsetTop < e2.scrollTop, a = this.offsetTop - e2.offsetTop + this.clientHeight - o2 > e2.scrollTop + e2.clientHeight, s = this.offsetLeft - e2.offsetLeft < e2.scrollLeft, l = this.offsetLeft - e2.offsetLeft + this.clientWidth - r2 > e2.scrollLeft + e2.clientWidth, c = i2 && !a;
              (i2 || a) && t2 && (e2.scrollTop = this.offsetTop - e2.offsetTop - e2.clientHeight / 2 - o2 + this.clientHeight / 2), (s || l) && t2 && (e2.scrollLeft = this.offsetLeft - e2.offsetLeft - e2.clientWidth / 2 - r2 + this.clientWidth / 2), (i2 || a || s || l) && !t2 && this.scrollIntoView(c);
            });
          }) ? o.apply(e, r) : o) || (t.exports = i);
        }, function(t, e, n) {
          var o, r, i;
          "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self && self, r = [e, n(20), n(21), n(2), n(3), n(14), n(7), n(60), n(151), n(81)], void 0 === (i = "function" == typeof (o = function(o2, r2, i2, a, s, l, c, u, f, d) {
            "use strict";
            var p = n(8), h = n(1);
            Object.defineProperty(o2, "__esModule", { value: true }), o2.default = void 0, r2 = h(r2), i2 = h(i2), a = h(a), s = h(s), l = h(l), c = p(c), u = h(u), d = h(d);
            var v = n(375), g = [];
            v.keys().forEach(function(t2) {
              t2.match(/^\.\/[^_][\w/]*\.([tj])s$/) && g.push(v(t2));
            });
            var y = function() {
              function t2(e3) {
                var n3, o3, s2 = this;
                (0, a.default)(this, t2), this.moduleInstances = {}, this.eventsDispatcher = new d.default(), this.isReady = new Promise(function(t3, e4) {
                  n3 = t3, o3 = e4;
                }), Promise.resolve().then((0, i2.default)(r2.default.mark(function t3() {
                  return r2.default.wrap(function(t4) {
                    for (; ; )
                      switch (t4.prev = t4.next) {
                        case 0:
                          return s2.configuration = e3, t4.next = 3, s2.validate();
                        case 3:
                          return t4.next = 5, s2.init();
                        case 5:
                          return t4.next = 7, s2.start();
                        case 7:
                          c.logLabeled("I'm ready! (\uFF89\u25D5\u30EE\u25D5)\uFF89*:\uFF65\uFF9F\u2727", "log", "", "color: #E24A75"), setTimeout((0, i2.default)(r2.default.mark(function t5() {
                            var e4, o4, i3;
                            return r2.default.wrap(function(t6) {
                              for (; ; )
                                switch (t6.prev = t6.next) {
                                  case 0:
                                    return t6.next = 2, s2.render();
                                  case 2:
                                    s2.configuration.autofocus && (e4 = s2.moduleInstances, o4 = e4.BlockManager, (i3 = e4.Caret).setToBlock(o4.blocks[0], i3.positions.START), o4.highlightCurrentNode()), s2.moduleInstances.UI.removeLoader(), n3();
                                  case 5:
                                  case "end":
                                    return t6.stop();
                                }
                            }, t5);
                          })), 500);
                        case 9:
                        case "end":
                          return t4.stop();
                      }
                  }, t3);
                }))).catch(function(t3) {
                  c.log("Editor.js is not ready because of ".concat(t3), "error"), o3(t3);
                });
              }
              var e2, n2;
              return (0, s.default)(t2, [{ key: "validate", value: (n2 = (0, i2.default)(r2.default.mark(function t3() {
                var e3, n3, o3;
                return r2.default.wrap(function(t4) {
                  for (; ; )
                    switch (t4.prev = t4.next) {
                      case 0:
                        if (e3 = this.config, n3 = e3.holderId, o3 = e3.holder, !n3 || !o3) {
                          t4.next = 3;
                          break;
                        }
                        throw Error("\xABholderId\xBB and \xABholder\xBB param can't assign at the same time.");
                      case 3:
                        if (!c.isString(o3) || l.default.get(o3)) {
                          t4.next = 5;
                          break;
                        }
                        throw Error("element with ID \xAB".concat(o3, "\xBB is missing. Pass correct holder's ID."));
                      case 5:
                        if (!o3 || !c.isObject(o3) || l.default.isElement(o3)) {
                          t4.next = 7;
                          break;
                        }
                        throw Error("\xABholder\xBB value must be an Element node");
                      case 7:
                      case "end":
                        return t4.stop();
                    }
                }, t3, this);
              })), function() {
                return n2.apply(this, arguments);
              }) }, { key: "init", value: function() {
                this.constructModules(), this.configureModules();
              } }, { key: "start", value: (e2 = (0, i2.default)(r2.default.mark(function t3() {
                var e3, n3 = this;
                return r2.default.wrap(function(t4) {
                  for (; ; )
                    switch (t4.prev = t4.next) {
                      case 0:
                        return e3 = ["Tools", "UI", "BlockManager", "Paste", "BlockSelection", "RectangleSelection", "CrossBlockSelection", "ReadOnly"], t4.next = 3, e3.reduce(function(t5, e4) {
                          return t5.then((0, i2.default)(r2.default.mark(function t6() {
                            return r2.default.wrap(function(t7) {
                              for (; ; )
                                switch (t7.prev = t7.next) {
                                  case 0:
                                    return t7.prev = 0, t7.next = 3, n3.moduleInstances[e4].prepare();
                                  case 3:
                                    t7.next = 10;
                                    break;
                                  case 5:
                                    if (t7.prev = 5, t7.t0 = t7.catch(0), !(t7.t0 instanceof f.CriticalError)) {
                                      t7.next = 9;
                                      break;
                                    }
                                    throw new Error(t7.t0.message);
                                  case 9:
                                    c.log("Module ".concat(e4, " was skipped because of %o"), "warn", t7.t0);
                                  case 10:
                                  case "end":
                                    return t7.stop();
                                }
                            }, t6, null, [[0, 5]]);
                          })));
                        }, Promise.resolve());
                      case 3:
                      case "end":
                        return t4.stop();
                    }
                }, t3);
              })), function() {
                return e2.apply(this, arguments);
              }) }, { key: "render", value: function() {
                return this.moduleInstances.Renderer.render(this.config.data.blocks);
              } }, { key: "constructModules", value: function() {
                var t3 = this;
                g.forEach(function(e3) {
                  var n3 = c.isFunction(e3) ? e3 : e3.default;
                  try {
                    t3.moduleInstances[n3.displayName] = new n3({ config: t3.configuration, eventsDispatcher: t3.eventsDispatcher });
                  } catch (t4) {
                    c.log("Module ".concat(n3.displayName, " skipped because"), "error", t4);
                  }
                });
              } }, { key: "configureModules", value: function() {
                for (var t3 in this.moduleInstances)
                  Object.prototype.hasOwnProperty.call(this.moduleInstances, t3) && (this.moduleInstances[t3].state = this.getModulesDiff(t3));
              } }, { key: "getModulesDiff", value: function(t3) {
                var e3 = {};
                for (var n3 in this.moduleInstances)
                  n3 !== t3 && (e3[n3] = this.moduleInstances[n3]);
                return e3;
              } }, { key: "configuration", set: function(t3) {
                var e3, n3;
                c.isObject(t3) ? this.config = Object.assign({}, t3) : this.config = { holder: t3 }, c.deprecationAssert(!!this.config.holderId, "config.holderId", "config.holder"), this.config.holderId && !this.config.holder && (this.config.holder = this.config.holderId, this.config.holderId = null), null == this.config.holder && (this.config.holder = "editorjs"), this.config.logLevel || (this.config.logLevel = c.LogLevels.VERBOSE), c.setLogLevel(this.config.logLevel), c.deprecationAssert(Boolean(this.config.initialBlock), "config.initialBlock", "config.defaultBlock"), this.config.defaultBlock = this.config.defaultBlock || this.config.initialBlock || "paragraph", this.config.minHeight = void 0 !== this.config.minHeight ? this.config.minHeight : 300;
                var o3 = { type: this.config.defaultBlock, data: {} };
                this.config.placeholder = this.config.placeholder || false, this.config.sanitizer = this.config.sanitizer || { p: true, b: true, a: true }, this.config.hideToolbar = !!this.config.hideToolbar && this.config.hideToolbar, this.config.tools = this.config.tools || {}, this.config.i18n = this.config.i18n || {}, this.config.data = this.config.data || { blocks: [] }, this.config.onReady = this.config.onReady || function() {
                }, this.config.onChange = this.config.onChange || function() {
                }, this.config.inlineToolbar = void 0 === this.config.inlineToolbar || this.config.inlineToolbar, !c.isEmpty(this.config.data) && this.config.data.blocks && 0 !== this.config.data.blocks.length || (this.config.data = { blocks: [o3] }), this.config.readOnly = this.config.readOnly || false, (null === (e3 = this.config.i18n) || void 0 === e3 ? void 0 : e3.messages) && u.default.setDictionary(this.config.i18n.messages), this.config.i18n.direction = (null === (n3 = this.config.i18n) || void 0 === n3 ? void 0 : n3.direction) || "ltr";
              }, get: function() {
                return this.config;
              } }]), t2;
            }();
            o2.default = y, y.displayName = "Core", t.exports = e.default;
          }) ? o.apply(e, r) : o) || (t.exports = i);
        }, function(t, e, n) {
          var o = n(149);
          t.exports = function(t2) {
            if (Array.isArray(t2))
              return o(t2);
          };
        }, function(t, e) {
          t.exports = function(t2) {
            if ("undefined" != typeof Symbol && Symbol.iterator in Object(t2))
              return Array.from(t2);
          };
        }, function(t, e) {
          t.exports = function() {
            throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          };
        }, function(t, e) {
          t.exports = function(t2, e2, n) {
            return e2 in t2 ? Object.defineProperty(t2, e2, { value: n, enumerable: true, configurable: true, writable: true }) : t2[e2] = n, t2;
          };
        }, function(t, e) {
          t.exports = function(t2) {
            return -1 !== Function.toString.call(t2).indexOf("[native code]");
          };
        }, function(t, e, n) {
          var o = n(110), r = n(374);
          function i(e2, n2, a) {
            return r() ? t.exports = i = Reflect.construct : t.exports = i = function(t2, e3, n3) {
              var r2 = [null];
              r2.push.apply(r2, e3);
              var i2 = new (Function.bind.apply(t2, r2))();
              return n3 && o(i2, n3.prototype), i2;
            }, i.apply(null, arguments);
          }
          t.exports = i;
        }, function(t, e) {
          t.exports = function() {
            if ("undefined" == typeof Reflect || !Reflect.construct)
              return false;
            if (Reflect.construct.sham)
              return false;
            if ("function" == typeof Proxy)
              return true;
            try {
              return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
              })), true;
            } catch (t2) {
              return false;
            }
          };
        }, function(t, e, n) {
          var o = { "./api": 82, "./api/": 82, "./api/blocks": 154, "./api/blocks.ts": 154, "./api/caret": 155, "./api/caret.ts": 155, "./api/events": 156, "./api/events.ts": 156, "./api/i18n": 157, "./api/i18n.ts": 157, "./api/index": 82, "./api/index.ts": 82, "./api/inlineToolbar": 158, "./api/inlineToolbar.ts": 158, "./api/listeners": 159, "./api/listeners.ts": 159, "./api/notifier": 160, "./api/notifier.ts": 160, "./api/readonly": 161, "./api/readonly.ts": 161, "./api/sanitizer": 162, "./api/sanitizer.ts": 162, "./api/saver": 163, "./api/saver.ts": 163, "./api/selection": 164, "./api/selection.ts": 164, "./api/styles": 165, "./api/styles.ts": 165, "./api/toolbar": 166, "./api/toolbar.ts": 166, "./api/tooltip": 167, "./api/tooltip.ts": 167, "./api/ui": 168, "./api/ui.ts": 168, "./blockEvents": 169, "./blockEvents.ts": 169, "./blockManager": 170, "./blockManager.ts": 170, "./blockSelection": 171, "./blockSelection.ts": 171, "./caret": 172, "./caret.ts": 172, "./crossBlockSelection": 173, "./crossBlockSelection.ts": 173, "./dragNDrop": 174, "./dragNDrop.ts": 174, "./modificationsObserver": 175, "./modificationsObserver.ts": 175, "./paste": 176, "./paste.ts": 176, "./readonly": 177, "./readonly.ts": 177, "./rectangleSelection": 178, "./rectangleSelection.ts": 178, "./renderer": 179, "./renderer.ts": 179, "./saver": 180, "./saver.ts": 180, "./toolbar": 83, "./toolbar/": 83, "./toolbar/blockSettings": 181, "./toolbar/blockSettings.ts": 181, "./toolbar/conversion": 182, "./toolbar/conversion.ts": 182, "./toolbar/index": 83, "./toolbar/index.ts": 83, "./toolbar/inline": 183, "./toolbar/inline.ts": 183, "./tools": 184, "./tools.ts": 184, "./ui": 186, "./ui.ts": 186 };
          function r(t2) {
            var e2 = i(t2);
            return n(e2);
          }
          function i(t2) {
            if (!n.o(o, t2)) {
              var e2 = new Error("Cannot find module '" + t2 + "'");
              throw e2.code = "MODULE_NOT_FOUND", e2;
            }
            return o[t2];
          }
          r.keys = function() {
            return Object.keys(o);
          }, r.resolve = i, t.exports = r, r.id = 375;
        }, function(t, e, n) {
          var o = n(4);
          t.exports = function(t2, e2) {
            for (; !Object.prototype.hasOwnProperty.call(t2, e2) && null !== (t2 = o(t2)); )
              ;
            return t2;
          };
        }, function(t, e, n) {
          var o, r, i;
          "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self && self, r = [e, n(2), n(3), n(378)], void 0 === (i = "function" == typeof (o = function(o2, r2, i2, a) {
            "use strict";
            var s = n(1);
            Object.defineProperty(o2, "__esModule", { value: true }), o2.default = void 0, r2 = s(r2), i2 = s(i2), a = s(a);
            var l = function() {
              function t2() {
                (0, r2.default)(this, t2);
              }
              return (0, i2.default)(t2, [{ key: "show", value: function(t3) {
                a.default.show(t3);
              } }]), t2;
            }();
            o2.default = l, l.displayName = "Notifier", t.exports = e.default;
          }) ? o.apply(e, r) : o) || (t.exports = i);
        }, function(t, e, n) {
          window, t.exports = function(t2) {
            var e2 = {};
            function n2(o) {
              if (e2[o])
                return e2[o].exports;
              var r = e2[o] = { i: o, l: false, exports: {} };
              return t2[o].call(r.exports, r, r.exports, n2), r.l = true, r.exports;
            }
            return n2.m = t2, n2.c = e2, n2.d = function(t3, e3, o) {
              n2.o(t3, e3) || Object.defineProperty(t3, e3, { enumerable: true, get: o });
            }, n2.r = function(t3) {
              "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t3, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t3, "__esModule", { value: true });
            }, n2.t = function(t3, e3) {
              if (1 & e3 && (t3 = n2(t3)), 8 & e3)
                return t3;
              if (4 & e3 && "object" == typeof t3 && t3 && t3.__esModule)
                return t3;
              var o = /* @__PURE__ */ Object.create(null);
              if (n2.r(o), Object.defineProperty(o, "default", { enumerable: true, value: t3 }), 2 & e3 && "string" != typeof t3)
                for (var r in t3)
                  n2.d(o, r, function(e4) {
                    return t3[e4];
                  }.bind(null, r));
              return o;
            }, n2.n = function(t3) {
              var e3 = t3 && t3.__esModule ? function() {
                return t3.default;
              } : function() {
                return t3;
              };
              return n2.d(e3, "a", e3), e3;
            }, n2.o = function(t3, e3) {
              return Object.prototype.hasOwnProperty.call(t3, e3);
            }, n2.p = "/", n2(n2.s = 0);
          }([function(t2, e2, n2) {
            "use strict";
            n2(1), t2.exports = function() {
              var t3 = n2(6), e3 = null;
              return { show: function(n3) {
                if (n3.message) {
                  !function() {
                    if (e3)
                      return true;
                    e3 = t3.getWrapper(), document.body.appendChild(e3);
                  }();
                  var o = null, r = n3.time || 8e3;
                  switch (n3.type) {
                    case "confirm":
                      o = t3.confirm(n3);
                      break;
                    case "prompt":
                      o = t3.prompt(n3);
                      break;
                    default:
                      o = t3.alert(n3), window.setTimeout(function() {
                        o.remove();
                      }, r);
                  }
                  e3.appendChild(o), o.classList.add("cdx-notify--bounce-in");
                }
              } };
            }();
          }, function(t2, e2, n2) {
            var o = n2(2);
            "string" == typeof o && (o = [[t2.i, o, ""]]), n2(4)(o, { hmr: true, transform: void 0, insertInto: void 0 }), o.locals && (t2.exports = o.locals);
          }, function(t2, e2, n2) {
            (t2.exports = n2(3)(false)).push([t2.i, `.cdx-notify--error{background:#fffbfb!important}.cdx-notify--error::before{background:#fb5d5d!important}.cdx-notify__input{max-width:130px;padding:5px 10px;background:#f7f7f7;border:0;border-radius:3px;font-size:13px;color:#656b7c;outline:0}.cdx-notify__input:-ms-input-placeholder{color:#656b7c}.cdx-notify__input::placeholder{color:#656b7c}.cdx-notify__input:focus:-ms-input-placeholder{color:rgba(101,107,124,.3)}.cdx-notify__input:focus::placeholder{color:rgba(101,107,124,.3)}.cdx-notify__button{border:none;border-radius:3px;font-size:13px;padding:5px 10px;cursor:pointer}.cdx-notify__button:last-child{margin-left:10px}.cdx-notify__button--cancel{background:#f2f5f7;box-shadow:0 2px 1px 0 rgba(16,19,29,0);color:#656b7c}.cdx-notify__button--cancel:hover{background:#eee}.cdx-notify__button--confirm{background:#34c992;box-shadow:0 1px 1px 0 rgba(18,49,35,.05);color:#fff}.cdx-notify__button--confirm:hover{background:#33b082}.cdx-notify__btns-wrapper{display:-ms-flexbox;display:flex;-ms-flex-flow:row nowrap;flex-flow:row nowrap;margin-top:5px}.cdx-notify__cross{position:absolute;top:5px;right:5px;width:10px;height:10px;padding:5px;opacity:.54;cursor:pointer}.cdx-notify__cross::after,.cdx-notify__cross::before{content:'';position:absolute;left:9px;top:5px;height:12px;width:2px;background:#575d67}.cdx-notify__cross::before{transform:rotate(-45deg)}.cdx-notify__cross::after{transform:rotate(45deg)}.cdx-notify__cross:hover{opacity:1}.cdx-notifies{position:fixed;z-index:2;bottom:20px;left:20px;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",sans-serif}.cdx-notify{position:relative;width:220px;margin-top:15px;padding:13px 16px;background:#fff;box-shadow:0 11px 17px 0 rgba(23,32,61,.13);border-radius:5px;font-size:14px;line-height:1.4em;word-wrap:break-word}.cdx-notify::before{content:'';position:absolute;display:block;top:0;left:0;width:3px;height:calc(100% - 6px);margin:3px;border-radius:5px;background:0 0}@keyframes bounceIn{0%{opacity:0;transform:scale(.3)}50%{opacity:1;transform:scale(1.05)}70%{transform:scale(.9)}100%{transform:scale(1)}}.cdx-notify--bounce-in{animation-name:bounceIn;animation-duration:.6s;animation-iteration-count:1}.cdx-notify--success{background:#fafffe!important}.cdx-notify--success::before{background:#41ffb1!important}`, ""]);
          }, function(t2, e2) {
            t2.exports = function(t3) {
              var e3 = [];
              return e3.toString = function() {
                return this.map(function(e4) {
                  var n2 = function(t4, e5) {
                    var n3, o = t4[1] || "", r = t4[3];
                    if (!r)
                      return o;
                    if (e5 && "function" == typeof btoa) {
                      var i = (n3 = r, "/*# sourceMappingURL=data:application/json;charset=utf-8;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(n3)))) + " */"), a = r.sources.map(function(t5) {
                        return "/*# sourceURL=" + r.sourceRoot + t5 + " */";
                      });
                      return [o].concat(a).concat([i]).join("\n");
                    }
                    return [o].join("\n");
                  }(e4, t3);
                  return e4[2] ? "@media " + e4[2] + "{" + n2 + "}" : n2;
                }).join("");
              }, e3.i = function(t4, n2) {
                "string" == typeof t4 && (t4 = [[null, t4, ""]]);
                for (var o = {}, r = 0; r < this.length; r++) {
                  var i = this[r][0];
                  "number" == typeof i && (o[i] = true);
                }
                for (r = 0; r < t4.length; r++) {
                  var a = t4[r];
                  "number" == typeof a[0] && o[a[0]] || (n2 && !a[2] ? a[2] = n2 : n2 && (a[2] = "(" + a[2] + ") and (" + n2 + ")"), e3.push(a));
                }
              }, e3;
            };
          }, function(t2, e2, n2) {
            var o, r, i = {}, a = (o = function() {
              return window && document && document.all && !window.atob;
            }, function() {
              return void 0 === r && (r = o.apply(this, arguments)), r;
            }), s = /* @__PURE__ */ function(t3) {
              var e3 = {};
              return function(t4) {
                if ("function" == typeof t4)
                  return t4();
                if (void 0 === e3[t4]) {
                  var n3 = function(t5) {
                    return document.querySelector(t5);
                  }.call(this, t4);
                  if (window.HTMLIFrameElement && n3 instanceof window.HTMLIFrameElement)
                    try {
                      n3 = n3.contentDocument.head;
                    } catch (t5) {
                      n3 = null;
                    }
                  e3[t4] = n3;
                }
                return e3[t4];
              };
            }(), l = null, c = 0, u = [], f = n2(5);
            function d(t3, e3) {
              for (var n3 = 0; n3 < t3.length; n3++) {
                var o2 = t3[n3], r2 = i[o2.id];
                if (r2) {
                  r2.refs++;
                  for (var a2 = 0; a2 < r2.parts.length; a2++)
                    r2.parts[a2](o2.parts[a2]);
                  for (; a2 < o2.parts.length; a2++)
                    r2.parts.push(b(o2.parts[a2], e3));
                } else {
                  var s2 = [];
                  for (a2 = 0; a2 < o2.parts.length; a2++)
                    s2.push(b(o2.parts[a2], e3));
                  i[o2.id] = { id: o2.id, refs: 1, parts: s2 };
                }
              }
            }
            function p(t3, e3) {
              for (var n3 = [], o2 = {}, r2 = 0; r2 < t3.length; r2++) {
                var i2 = t3[r2], a2 = e3.base ? i2[0] + e3.base : i2[0], s2 = { css: i2[1], media: i2[2], sourceMap: i2[3] };
                o2[a2] ? o2[a2].parts.push(s2) : n3.push(o2[a2] = { id: a2, parts: [s2] });
              }
              return n3;
            }
            function h(t3, e3) {
              var n3 = s(t3.insertInto);
              if (!n3)
                throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
              var o2 = u[u.length - 1];
              if ("top" === t3.insertAt)
                o2 ? o2.nextSibling ? n3.insertBefore(e3, o2.nextSibling) : n3.appendChild(e3) : n3.insertBefore(e3, n3.firstChild), u.push(e3);
              else if ("bottom" === t3.insertAt)
                n3.appendChild(e3);
              else {
                if ("object" != typeof t3.insertAt || !t3.insertAt.before)
                  throw new Error("[Style Loader]\n\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\n Must be 'top', 'bottom', or Object.\n (https://github.com/webpack-contrib/style-loader#insertat)\n");
                var r2 = s(t3.insertInto + " " + t3.insertAt.before);
                n3.insertBefore(e3, r2);
              }
            }
            function v(t3) {
              if (null === t3.parentNode)
                return false;
              t3.parentNode.removeChild(t3);
              var e3 = u.indexOf(t3);
              e3 >= 0 && u.splice(e3, 1);
            }
            function g(t3) {
              var e3 = document.createElement("style");
              return void 0 === t3.attrs.type && (t3.attrs.type = "text/css"), y(e3, t3.attrs), h(t3, e3), e3;
            }
            function y(t3, e3) {
              Object.keys(e3).forEach(function(n3) {
                t3.setAttribute(n3, e3[n3]);
              });
            }
            function b(t3, e3) {
              var n3, o2, r2, i2;
              if (e3.transform && t3.css) {
                if (!(i2 = e3.transform(t3.css)))
                  return function() {
                  };
                t3.css = i2;
              }
              if (e3.singleton) {
                var a2 = c++;
                n3 = l || (l = g(e3)), o2 = x.bind(null, n3, a2, false), r2 = x.bind(null, n3, a2, true);
              } else
                t3.sourceMap && "function" == typeof URL && "function" == typeof URL.createObjectURL && "function" == typeof URL.revokeObjectURL && "function" == typeof Blob && "function" == typeof btoa ? (n3 = function(t4) {
                  var e4 = document.createElement("link");
                  return void 0 === t4.attrs.type && (t4.attrs.type = "text/css"), t4.attrs.rel = "stylesheet", y(e4, t4.attrs), h(t4, e4), e4;
                }(e3), o2 = function(t4, e4, n4) {
                  var o3 = n4.css, r3 = n4.sourceMap, i3 = void 0 === e4.convertToAbsoluteUrls && r3;
                  (e4.convertToAbsoluteUrls || i3) && (o3 = f(o3)), r3 && (o3 += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(r3)))) + " */");
                  var a3 = new Blob([o3], { type: "text/css" }), s2 = t4.href;
                  t4.href = URL.createObjectURL(a3), s2 && URL.revokeObjectURL(s2);
                }.bind(null, n3, e3), r2 = function() {
                  v(n3), n3.href && URL.revokeObjectURL(n3.href);
                }) : (n3 = g(e3), o2 = function(t4, e4) {
                  var n4 = e4.css, o3 = e4.media;
                  if (o3 && t4.setAttribute("media", o3), t4.styleSheet)
                    t4.styleSheet.cssText = n4;
                  else {
                    for (; t4.firstChild; )
                      t4.removeChild(t4.firstChild);
                    t4.appendChild(document.createTextNode(n4));
                  }
                }.bind(null, n3), r2 = function() {
                  v(n3);
                });
              return o2(t3), function(e4) {
                if (e4) {
                  if (e4.css === t3.css && e4.media === t3.media && e4.sourceMap === t3.sourceMap)
                    return;
                  o2(t3 = e4);
                } else
                  r2();
              };
            }
            t2.exports = function(t3, e3) {
              if ("object" != typeof document)
                throw new Error("The style-loader cannot be used in a non-browser environment");
              (e3 = e3 || {}).attrs = "object" == typeof e3.attrs ? e3.attrs : {}, e3.singleton || "boolean" == typeof e3.singleton || (e3.singleton = a()), e3.insertInto || (e3.insertInto = "head"), e3.insertAt || (e3.insertAt = "bottom");
              var n3 = p(t3, e3);
              return d(n3, e3), function(t4) {
                for (var o2 = [], r2 = 0; r2 < n3.length; r2++) {
                  var a2 = n3[r2];
                  (s2 = i[a2.id]).refs--, o2.push(s2);
                }
                for (t4 && d(p(t4, e3), e3), r2 = 0; r2 < o2.length; r2++) {
                  var s2;
                  if (0 === (s2 = o2[r2]).refs) {
                    for (var l2 = 0; l2 < s2.parts.length; l2++)
                      s2.parts[l2]();
                    delete i[s2.id];
                  }
                }
              };
            };
            var m, k = (m = [], function(t3, e3) {
              return m[t3] = e3, m.filter(Boolean).join("\n");
            });
            function x(t3, e3, n3, o2) {
              var r2 = n3 ? "" : o2.css;
              if (t3.styleSheet)
                t3.styleSheet.cssText = k(e3, r2);
              else {
                var i2 = document.createTextNode(r2), a2 = t3.childNodes;
                a2[e3] && t3.removeChild(a2[e3]), a2.length ? t3.insertBefore(i2, a2[e3]) : t3.appendChild(i2);
              }
            }
          }, function(t2, e2) {
            t2.exports = function(t3) {
              var e3 = "undefined" != typeof window && window.location;
              if (!e3)
                throw new Error("fixUrls requires window.location");
              if (!t3 || "string" != typeof t3)
                return t3;
              var n2 = e3.protocol + "//" + e3.host, o = n2 + e3.pathname.replace(/\/[^\/]*$/, "/");
              return t3.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function(t4, e4) {
                var r, i = e4.trim().replace(/^"(.*)"$/, function(t5, e5) {
                  return e5;
                }).replace(/^'(.*)'$/, function(t5, e5) {
                  return e5;
                });
                return /^(#|data:|http:\/\/|https:\/\/|file:\/\/\/|\s*$)/i.test(i) ? t4 : (r = 0 === i.indexOf("//") ? i : 0 === i.indexOf("/") ? n2 + i : o + i.replace(/^\.\//, ""), "url(" + JSON.stringify(r) + ")");
              });
            };
          }, function(t2, e2, n2) {
            "use strict";
            var o, r, i, a, s, l;
            t2.exports = (o = "cdx-notify", r = "cdx-notify__cross", i = "cdx-notify__button--confirm", a = "cdx-notify__button", s = "cdx-notify__btns-wrapper", { alert: l = function(t3) {
              var e3 = document.createElement("DIV"), n3 = document.createElement("DIV"), i2 = t3.message, a2 = t3.style;
              return e3.classList.add(o), a2 && e3.classList.add(o + "--" + a2), e3.innerHTML = i2, n3.classList.add(r), n3.addEventListener("click", e3.remove.bind(e3)), e3.appendChild(n3), e3;
            }, confirm: function(t3) {
              var e3 = l(t3), n3 = document.createElement("div"), o2 = document.createElement("button"), c = document.createElement("button"), u = e3.querySelector("." + r), f = t3.cancelHandler, d = t3.okHandler;
              return n3.classList.add(s), o2.innerHTML = t3.okText || "Confirm", c.innerHTML = t3.cancelText || "Cancel", o2.classList.add(a), c.classList.add(a), o2.classList.add(i), c.classList.add("cdx-notify__button--cancel"), f && "function" == typeof f && (c.addEventListener("click", f), u.addEventListener("click", f)), d && "function" == typeof d && o2.addEventListener("click", d), o2.addEventListener("click", e3.remove.bind(e3)), c.addEventListener("click", e3.remove.bind(e3)), n3.appendChild(o2), n3.appendChild(c), e3.appendChild(n3), e3;
            }, prompt: function(t3) {
              var e3 = l(t3), n3 = document.createElement("div"), o2 = document.createElement("button"), c = document.createElement("input"), u = e3.querySelector("." + r), f = t3.cancelHandler, d = t3.okHandler;
              return n3.classList.add(s), o2.innerHTML = t3.okText || "Ok", o2.classList.add(a), o2.classList.add(i), c.classList.add("cdx-notify__input"), t3.placeholder && c.setAttribute("placeholder", t3.placeholder), t3.default && (c.value = t3.default), t3.inputType && (c.type = t3.inputType), f && "function" == typeof f && u.addEventListener("click", f), d && "function" == typeof d && o2.addEventListener("click", function() {
                d(c.value);
              }), o2.addEventListener("click", e3.remove.bind(e3)), n3.appendChild(c), n3.appendChild(o2), e3.appendChild(n3), e3;
            }, getWrapper: function() {
              var t3 = document.createElement("DIV");
              return t3.classList.add("cdx-notifies"), t3;
            } });
          }]);
        }, function(t, e, n) {
          var o, r;
          void 0 === (r = "function" == typeof (o = function() {
            function t2(t3) {
              var e3 = t3.tags;
              if (!Object.keys(e3).map(function(t4) {
                return typeof e3[t4];
              }).every(function(t4) {
                return "object" === t4 || "boolean" === t4 || "function" === t4;
              }))
                throw new Error("The configuration was invalid");
              this.config = t3;
            }
            var e2 = ["P", "LI", "TD", "TH", "DIV", "H1", "H2", "H3", "H4", "H5", "H6", "PRE"];
            function n2(t3) {
              return -1 !== e2.indexOf(t3.nodeName);
            }
            var o2 = ["A", "B", "STRONG", "I", "EM", "SUB", "SUP", "U", "STRIKE"];
            function r2(t3) {
              return -1 !== o2.indexOf(t3.nodeName);
            }
            function i(t3, e3, n3) {
              return "function" == typeof t3.tags[e3] ? t3.tags[e3](n3) : t3.tags[e3];
            }
            function a(t3, e3) {
              return void 0 === e3 || "boolean" == typeof e3 && !e3;
            }
            function s(t3, e3, n3) {
              var o3 = t3.name.toLowerCase();
              return true !== e3 && ("function" == typeof e3[o3] ? !e3[o3](t3.value, n3) : void 0 === e3[o3] || false === e3[o3] || "string" == typeof e3[o3] && e3[o3] !== t3.value);
            }
            return t2.prototype.clean = function(t3) {
              const e3 = document.implementation.createHTMLDocument(), n3 = e3.createElement("div");
              return n3.innerHTML = t3, this._sanitize(e3, n3), n3.innerHTML;
            }, t2.prototype._sanitize = function(t3, e3) {
              var o3 = function(t4, e4) {
                return t4.createTreeWalker(e4, NodeFilter.SHOW_TEXT | NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT, null, false);
              }(t3, e3), l = o3.firstChild();
              if (l)
                do {
                  if (l.nodeType !== Node.TEXT_NODE) {
                    if (l.nodeType === Node.COMMENT_NODE) {
                      e3.removeChild(l), this._sanitize(t3, e3);
                      break;
                    }
                    var c, u = r2(l);
                    u && (c = Array.prototype.some.call(l.childNodes, n2));
                    var f = !!e3.parentNode, d = n2(e3) && n2(l) && f, p = l.nodeName.toLowerCase(), h = i(this.config, p, l);
                    if (u && c || a(0, h) || !this.config.keepNestedBlockElements && d) {
                      if ("SCRIPT" !== l.nodeName && "STYLE" !== l.nodeName)
                        for (; l.childNodes.length > 0; )
                          e3.insertBefore(l.childNodes[0], l);
                      e3.removeChild(l), this._sanitize(t3, e3);
                      break;
                    }
                    for (var v = 0; v < l.attributes.length; v += 1) {
                      var g = l.attributes[v];
                      s(g, h, l) && (l.removeAttribute(g.name), v -= 1);
                    }
                    this._sanitize(t3, l);
                  } else if ("" === l.data.trim() && (l.previousElementSibling && n2(l.previousElementSibling) || l.nextElementSibling && n2(l.nextElementSibling))) {
                    e3.removeChild(l), this._sanitize(t3, e3);
                    break;
                  }
                } while (l = o3.nextSibling());
            }, t2;
          }) ? o.call(e, n, e, t) : o) || (t.exports = r);
        }, function(t, e, n) {
          window, t.exports = function(t2) {
            var e2 = {};
            function n2(o) {
              if (e2[o])
                return e2[o].exports;
              var r = e2[o] = { i: o, l: false, exports: {} };
              return t2[o].call(r.exports, r, r.exports, n2), r.l = true, r.exports;
            }
            return n2.m = t2, n2.c = e2, n2.d = function(t3, e3, o) {
              n2.o(t3, e3) || Object.defineProperty(t3, e3, { enumerable: true, get: o });
            }, n2.r = function(t3) {
              "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t3, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t3, "__esModule", { value: true });
            }, n2.t = function(t3, e3) {
              if (1 & e3 && (t3 = n2(t3)), 8 & e3)
                return t3;
              if (4 & e3 && "object" == typeof t3 && t3 && t3.__esModule)
                return t3;
              var o = /* @__PURE__ */ Object.create(null);
              if (n2.r(o), Object.defineProperty(o, "default", { enumerable: true, value: t3 }), 2 & e3 && "string" != typeof t3)
                for (var r in t3)
                  n2.d(o, r, function(e4) {
                    return t3[e4];
                  }.bind(null, r));
              return o;
            }, n2.n = function(t3) {
              var e3 = t3 && t3.__esModule ? function() {
                return t3.default;
              } : function() {
                return t3;
              };
              return n2.d(e3, "a", e3), e3;
            }, n2.o = function(t3, e3) {
              return Object.prototype.hasOwnProperty.call(t3, e3);
            }, n2.p = "", n2(n2.s = 0);
          }([function(t2, e2, n2) {
            t2.exports = n2(1);
          }, function(t2, e2, n2) {
            "use strict";
            n2.r(e2), n2.d(e2, "default", function() {
              return o;
            });
            class o {
              constructor() {
                this.nodes = { wrapper: null, content: null }, this.showed = false, this.offsetTop = 10, this.offsetLeft = 10, this.offsetRight = 10, this.hidingDelay = 0, this.handleWindowScroll = () => {
                  this.showed && this.hide(true);
                }, this.loadStyles(), this.prepare(), window.addEventListener("scroll", this.handleWindowScroll, { passive: true });
              }
              get CSS() {
                return { tooltip: "ct", tooltipContent: "ct__content", tooltipShown: "ct--shown", placement: { left: "ct--left", bottom: "ct--bottom", right: "ct--right", top: "ct--top" } };
              }
              show(t3, e3, n3) {
                this.nodes.wrapper || this.prepare(), this.hidingTimeout && clearTimeout(this.hidingTimeout);
                const o2 = Object.assign({ placement: "bottom", marginTop: 0, marginLeft: 0, marginRight: 0, marginBottom: 0, delay: 70, hidingDelay: 0 }, n3);
                if (o2.hidingDelay && (this.hidingDelay = o2.hidingDelay), this.nodes.content.innerHTML = "", "string" == typeof e3)
                  this.nodes.content.appendChild(document.createTextNode(e3));
                else {
                  if (!(e3 instanceof Node))
                    throw Error("[CodeX Tooltip] Wrong type of \xABcontent\xBB passed. It should be an instance of Node or String. But " + typeof e3 + " given.");
                  this.nodes.content.appendChild(e3);
                }
                switch (this.nodes.wrapper.classList.remove(...Object.values(this.CSS.placement)), o2.placement) {
                  case "top":
                    this.placeTop(t3, o2);
                    break;
                  case "left":
                    this.placeLeft(t3, o2);
                    break;
                  case "right":
                    this.placeRight(t3, o2);
                    break;
                  case "bottom":
                  default:
                    this.placeBottom(t3, o2);
                }
                o2 && o2.delay ? this.showingTimeout = setTimeout(() => {
                  this.nodes.wrapper.classList.add(this.CSS.tooltipShown), this.showed = true;
                }, o2.delay) : (this.nodes.wrapper.classList.add(this.CSS.tooltipShown), this.showed = true);
              }
              hide(t3 = false) {
                if (this.hidingDelay && !t3)
                  return this.hidingTimeout && clearTimeout(this.hidingTimeout), void (this.hidingTimeout = setTimeout(() => {
                    this.hide(true);
                  }, this.hidingDelay));
                this.nodes.wrapper.classList.remove(this.CSS.tooltipShown), this.showed = false, this.showingTimeout && clearTimeout(this.showingTimeout);
              }
              onHover(t3, e3, n3) {
                t3.addEventListener("mouseenter", () => {
                  this.show(t3, e3, n3);
                }), t3.addEventListener("mouseleave", () => {
                  this.hide();
                });
              }
              destroy() {
                this.nodes.wrapper.remove(), window.removeEventListener("scroll", this.handleWindowScroll);
              }
              prepare() {
                this.nodes.wrapper = this.make("div", this.CSS.tooltip), this.nodes.content = this.make("div", this.CSS.tooltipContent), this.append(this.nodes.wrapper, this.nodes.content), this.append(document.body, this.nodes.wrapper);
              }
              loadStyles() {
                const t3 = "codex-tooltips-style";
                if (document.getElementById(t3))
                  return;
                const e3 = n2(2), o2 = this.make("style", null, { textContent: e3.toString(), id: t3 });
                this.prepend(document.head, o2);
              }
              placeBottom(t3, e3) {
                const n3 = t3.getBoundingClientRect(), o2 = n3.left + t3.clientWidth / 2 - this.nodes.wrapper.offsetWidth / 2, r = n3.bottom + window.pageYOffset + this.offsetTop + e3.marginTop;
                this.applyPlacement("bottom", o2, r);
              }
              placeTop(t3, e3) {
                const n3 = t3.getBoundingClientRect(), o2 = n3.left + t3.clientWidth / 2 - this.nodes.wrapper.offsetWidth / 2, r = n3.top + window.pageYOffset - this.nodes.wrapper.clientHeight - this.offsetTop;
                this.applyPlacement("top", o2, r);
              }
              placeLeft(t3, e3) {
                const n3 = t3.getBoundingClientRect(), o2 = n3.left - this.nodes.wrapper.offsetWidth - this.offsetLeft - e3.marginLeft, r = n3.top + window.pageYOffset + t3.clientHeight / 2 - this.nodes.wrapper.offsetHeight / 2;
                this.applyPlacement("left", o2, r);
              }
              placeRight(t3, e3) {
                const n3 = t3.getBoundingClientRect(), o2 = n3.right + this.offsetRight + e3.marginRight, r = n3.top + window.pageYOffset + t3.clientHeight / 2 - this.nodes.wrapper.offsetHeight / 2;
                this.applyPlacement("right", o2, r);
              }
              applyPlacement(t3, e3, n3) {
                this.nodes.wrapper.classList.add(this.CSS.placement[t3]), this.nodes.wrapper.style.left = e3 + "px", this.nodes.wrapper.style.top = n3 + "px";
              }
              make(t3, e3 = null, n3 = {}) {
                const o2 = document.createElement(t3);
                Array.isArray(e3) ? o2.classList.add(...e3) : e3 && o2.classList.add(e3);
                for (const t4 in n3)
                  n3.hasOwnProperty(t4) && (o2[t4] = n3[t4]);
                return o2;
              }
              append(t3, e3) {
                Array.isArray(e3) ? e3.forEach((e4) => t3.appendChild(e4)) : t3.appendChild(e3);
              }
              prepend(t3, e3) {
                Array.isArray(e3) ? (e3 = e3.reverse()).forEach((e4) => t3.prepend(e4)) : t3.prepend(e3);
              }
            }
          }, function(t2, e2) {
            t2.exports = `.ct{z-index:999;opacity:0;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;pointer-events:none;-webkit-transition:opacity 50ms ease-in,-webkit-transform 70ms cubic-bezier(.215,.61,.355,1);transition:opacity 50ms ease-in,-webkit-transform 70ms cubic-bezier(.215,.61,.355,1);transition:opacity 50ms ease-in,transform 70ms cubic-bezier(.215,.61,.355,1);transition:opacity 50ms ease-in,transform 70ms cubic-bezier(.215,.61,.355,1),-webkit-transform 70ms cubic-bezier(.215,.61,.355,1);will-change:opacity,top,left;-webkit-box-shadow:0 8px 12px 0 rgba(29,32,43,.17),0 4px 5px -3px rgba(5,6,12,.49);box-shadow:0 8px 12px 0 rgba(29,32,43,.17),0 4px 5px -3px rgba(5,6,12,.49);border-radius:9px}.ct,.ct:before{position:absolute;top:0;left:0}.ct:before{content:"";bottom:0;right:0;background-color:#1d202b;z-index:-1;border-radius:4px}@supports(-webkit-mask-box-image:url("")){.ct:before{border-radius:0;-webkit-mask-box-image:url('data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24"><path d="M10.71 0h2.58c3.02 0 4.64.42 6.1 1.2a8.18 8.18 0 013.4 3.4C23.6 6.07 24 7.7 24 10.71v2.58c0 3.02-.42 4.64-1.2 6.1a8.18 8.18 0 01-3.4 3.4c-1.47.8-3.1 1.21-6.11 1.21H10.7c-3.02 0-4.64-.42-6.1-1.2a8.18 8.18 0 01-3.4-3.4C.4 17.93 0 16.3 0 13.29V10.7c0-3.02.42-4.64 1.2-6.1a8.18 8.18 0 013.4-3.4C6.07.4 7.7 0 10.71 0z"/></svg>') 48% 41% 37.9% 53.3%}}@media (--mobile){.ct{display:none}}.ct__content{padding:6px 10px;color:#cdd1e0;font-size:12px;text-align:center;letter-spacing:.02em;line-height:1em}.ct:after{content:"";width:8px;height:8px;position:absolute;background-color:#1d202b;z-index:-1}.ct--bottom{-webkit-transform:translateY(5px);transform:translateY(5px)}.ct--bottom:after{top:-3px;left:50%;-webkit-transform:translateX(-50%) rotate(-45deg);transform:translateX(-50%) rotate(-45deg)}.ct--top{-webkit-transform:translateY(-5px);transform:translateY(-5px)}.ct--top:after{top:auto;bottom:-3px;left:50%;-webkit-transform:translateX(-50%) rotate(-45deg);transform:translateX(-50%) rotate(-45deg)}.ct--left{-webkit-transform:translateX(-5px);transform:translateX(-5px)}.ct--left:after{top:50%;left:auto;right:0;-webkit-transform:translate(41.6%,-50%) rotate(-45deg);transform:translate(41.6%,-50%) rotate(-45deg)}.ct--right{-webkit-transform:translateX(5px);transform:translateX(5px)}.ct--right:after{top:50%;left:0;-webkit-transform:translate(-41.6%,-50%) rotate(-45deg);transform:translate(-41.6%,-50%) rotate(-45deg)}.ct--shown{opacity:1;-webkit-transform:none;transform:none}`;
          }]).default;
        }, function(t, e, n) {
          var o, r, i;
          "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self && self, r = [e, n(2), n(3), n(14), n(7), n(25)], void 0 === (i = "function" == typeof (o = function(o2, r2, i2, a, s, l) {
            "use strict";
            var c = n(8), u = n(1);
            Object.defineProperty(o2, "__esModule", { value: true }), o2.default = void 0, r2 = u(r2), i2 = u(i2), a = u(a), s = c(s), l = u(l);
            var f = function() {
              function t2(e2, n2) {
                (0, r2.default)(this, t2), this.cursor = -1, this.items = [], this.items = e2 || [], this.focusedCssClass = n2;
              }
              return (0, i2.default)(t2, [{ key: "setItems", value: function(t3) {
                this.items = t3;
              } }, { key: "next", value: function() {
                this.cursor = this.leafNodesAndReturnIndex(t2.directions.RIGHT);
              } }, { key: "previous", value: function() {
                this.cursor = this.leafNodesAndReturnIndex(t2.directions.LEFT);
              } }, { key: "dropCursor", value: function() {
                -1 !== this.cursor && (this.items[this.cursor].classList.remove(this.focusedCssClass), this.cursor = -1);
              } }, { key: "leafNodesAndReturnIndex", value: function(e2) {
                var n2 = this;
                if (0 === this.items.length)
                  return this.cursor;
                var o3 = this.cursor;
                return -1 === o3 ? o3 = e2 === t2.directions.RIGHT ? -1 : 0 : this.items[o3].classList.remove(this.focusedCssClass), o3 = e2 === t2.directions.RIGHT ? (o3 + 1) % this.items.length : (this.items.length + o3 - 1) % this.items.length, a.default.canSetCaret(this.items[o3]) && s.delay(function() {
                  return l.default.setCursor(n2.items[o3]);
                }, 50)(), this.items[o3].classList.add(this.focusedCssClass), o3;
              } }, { key: "currentItem", get: function() {
                return -1 === this.cursor ? null : this.items[this.cursor];
              } }]), t2;
            }();
            o2.default = f, f.displayName = "DomIterator", f.directions = { RIGHT: "right", LEFT: "left" }, t.exports = e.default;
          }) ? o.apply(e, r) : o) || (t.exports = i);
        }, function(t, e, n) {
          var o, r, i;
          "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self && self, r = [e, n(2), n(3), n(7), n(14), n(61)], void 0 === (i = "function" == typeof (o = function(o2, r2, i2, a, s, l) {
            "use strict";
            var c = n(8), u = n(1);
            Object.defineProperty(o2, "__esModule", { value: true }), o2.default = void 0, r2 = u(r2), i2 = u(i2), a = c(a), s = u(s);
            var f = function() {
              function t2(e2) {
                (0, r2.default)(this, t2), this.blocks = [], this.workingArea = e2;
              }
              return (0, i2.default)(t2, [{ key: "push", value: function(t3) {
                this.blocks.push(t3), this.insertToDOM(t3);
              } }, { key: "swap", value: function(t3, e2) {
                var n2 = this.blocks[e2];
                s.default.swap(this.blocks[t3].holder, n2.holder), this.blocks[e2] = this.blocks[t3], this.blocks[t3] = n2;
              } }, { key: "move", value: function(t3, e2) {
                var n2 = this.blocks.splice(e2, 1)[0], o3 = t3 - 1, r3 = Math.max(0, o3), i3 = this.blocks[r3];
                t3 > 0 ? this.insertToDOM(n2, "afterend", i3) : this.insertToDOM(n2, "beforebegin", i3), this.blocks.splice(t3, 0, n2);
                var a2 = this.composeBlockEvent("move", { fromIndex: e2, toIndex: t3 });
                n2.call(l.BlockToolAPI.MOVED, a2);
              } }, { key: "insert", value: function(t3, e2) {
                var n2 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
                if (this.length) {
                  t3 > this.length && (t3 = this.length), n2 && (this.blocks[t3].holder.remove(), this.blocks[t3].call(l.BlockToolAPI.REMOVED));
                  var o3 = n2 ? 1 : 0;
                  if (this.blocks.splice(t3, o3, e2), t3 > 0) {
                    var r3 = this.blocks[t3 - 1];
                    this.insertToDOM(e2, "afterend", r3);
                  } else {
                    var i3 = this.blocks[t3 + 1];
                    i3 ? this.insertToDOM(e2, "beforebegin", i3) : this.insertToDOM(e2);
                  }
                } else
                  this.push(e2);
              } }, { key: "remove", value: function(t3) {
                isNaN(t3) && (t3 = this.length - 1), this.blocks[t3].holder.remove(), this.blocks[t3].call(l.BlockToolAPI.REMOVED), this.blocks.splice(t3, 1);
              } }, { key: "removeAll", value: function() {
                this.workingArea.innerHTML = "", this.blocks.forEach(function(t3) {
                  return t3.call(l.BlockToolAPI.REMOVED);
                }), this.blocks.length = 0;
              } }, { key: "insertAfter", value: function(t3, e2) {
                var n2 = this.blocks.indexOf(t3);
                this.insert(n2 + 1, e2);
              } }, { key: "get", value: function(t3) {
                return this.blocks[t3];
              } }, { key: "indexOf", value: function(t3) {
                return this.blocks.indexOf(t3);
              } }, { key: "insertToDOM", value: function(t3, e2, n2) {
                e2 ? n2.holder.insertAdjacentElement(e2, t3.holder) : this.workingArea.appendChild(t3.holder), t3.call(l.BlockToolAPI.RENDERED);
              } }, { key: "composeBlockEvent", value: function(t3, e2) {
                return new CustomEvent(t3, { detail: e2 });
              } }, { key: "length", get: function() {
                return this.blocks.length;
              } }, { key: "array", get: function() {
                return this.blocks;
              } }, { key: "nodes", get: function() {
                return a.array(this.workingArea.children);
              } }], [{ key: "set", value: function(t3, e2, n2) {
                return isNaN(Number(e2)) ? (Reflect.set(t3, e2, n2), true) : (t3.insert(+e2, n2), true);
              } }, { key: "get", value: function(t3, e2) {
                return isNaN(Number(e2)) ? Reflect.get(t3, e2) : t3.get(+e2);
              } }]), t2;
            }();
            o2.default = f, f.displayName = "Blocks", t.exports = e.default;
          }) ? o.apply(e, r) : o) || (t.exports = i);
        }, function(t, e, n) {
          var o, r, i;
          "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self && self, r = [e], void 0 === (i = "function" == typeof (o = function(t2) {
            "use strict";
            var e2;
            Object.defineProperty(t2, "__esModule", { value: true }), t2.BlockMutationType = void 0, t2.BlockMutationType = e2, function(t3) {
              t3.Added = "block-added", t3.Removed = "block-removed", t3.Moved = "block-moved", t3.Changed = "block-changed";
            }(e2 || (t2.BlockMutationType = e2 = {}));
          }) ? o.apply(e, r) : o) || (t.exports = i);
        }, function(t, e, n) {
          window, t.exports = function(t2) {
            var e2 = {};
            function n2(o) {
              if (e2[o])
                return e2[o].exports;
              var r = e2[o] = { i: o, l: false, exports: {} };
              return t2[o].call(r.exports, r, r.exports, n2), r.l = true, r.exports;
            }
            return n2.m = t2, n2.c = e2, n2.d = function(t3, e3, o) {
              n2.o(t3, e3) || Object.defineProperty(t3, e3, { enumerable: true, get: o });
            }, n2.r = function(t3) {
              "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t3, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t3, "__esModule", { value: true });
            }, n2.t = function(t3, e3) {
              if (1 & e3 && (t3 = n2(t3)), 8 & e3)
                return t3;
              if (4 & e3 && "object" == typeof t3 && t3 && t3.__esModule)
                return t3;
              var o = /* @__PURE__ */ Object.create(null);
              if (n2.r(o), Object.defineProperty(o, "default", { enumerable: true, value: t3 }), 2 & e3 && "string" != typeof t3)
                for (var r in t3)
                  n2.d(o, r, function(e4) {
                    return t3[e4];
                  }.bind(null, r));
              return o;
            }, n2.n = function(t3) {
              var e3 = t3 && t3.__esModule ? function() {
                return t3.default;
              } : function() {
                return t3;
              };
              return n2.d(e3, "a", e3), e3;
            }, n2.o = function(t3, e3) {
              return Object.prototype.hasOwnProperty.call(t3, e3);
            }, n2.p = "", n2(n2.s = 0);
          }([function(t2, e2, n2) {
            "use strict";
            function o(t3, e3) {
              for (var n3 = 0; n3 < e3.length; n3++) {
                var o2 = e3[n3];
                o2.enumerable = o2.enumerable || false, o2.configurable = true, "value" in o2 && (o2.writable = true), Object.defineProperty(t3, o2.key, o2);
              }
            }
            function r(t3, e3, n3) {
              return e3 && o(t3.prototype, e3), n3 && o(t3, n3), t3;
            }
            n2.r(e2);
            var i = function() {
              function t3(e3) {
                var n3 = this;
                !function(t4, e4) {
                  if (!(t4 instanceof e4))
                    throw new TypeError("Cannot call a class as a function");
                }(this, t3), this.commands = {}, this.keys = {}, this.name = e3.name, this.parseShortcutName(e3.name), this.element = e3.on, this.callback = e3.callback, this.executeShortcut = function(t4) {
                  n3.execute(t4);
                }, this.element.addEventListener("keydown", this.executeShortcut, false);
              }
              return r(t3, null, [{ key: "supportedCommands", get: function() {
                return { SHIFT: ["SHIFT"], CMD: ["CMD", "CONTROL", "COMMAND", "WINDOWS", "CTRL"], ALT: ["ALT", "OPTION"] };
              } }, { key: "keyCodes", get: function() {
                return { 0: 48, 1: 49, 2: 50, 3: 51, 4: 52, 5: 53, 6: 54, 7: 55, 8: 56, 9: 57, A: 65, B: 66, C: 67, D: 68, E: 69, F: 70, G: 71, H: 72, I: 73, J: 74, K: 75, L: 76, M: 77, N: 78, O: 79, P: 80, Q: 81, R: 82, S: 83, T: 84, U: 85, V: 86, W: 87, X: 88, Y: 89, Z: 90, BACKSPACE: 8, ENTER: 13, ESCAPE: 27, LEFT: 37, UP: 38, RIGHT: 39, DOWN: 40, INSERT: 45, DELETE: 46 };
              } }]), r(t3, [{ key: "parseShortcutName", value: function(e3) {
                e3 = e3.split("+");
                for (var n3 = 0; n3 < e3.length; n3++) {
                  e3[n3] = e3[n3].toUpperCase();
                  var o2 = false;
                  for (var r2 in t3.supportedCommands)
                    if (t3.supportedCommands[r2].includes(e3[n3])) {
                      o2 = this.commands[r2] = true;
                      break;
                    }
                  o2 || (this.keys[e3[n3]] = true);
                }
                for (var i2 in t3.supportedCommands)
                  this.commands[i2] || (this.commands[i2] = false);
              } }, { key: "execute", value: function(e3) {
                var n3, o2 = { CMD: e3.ctrlKey || e3.metaKey, SHIFT: e3.shiftKey, ALT: e3.altKey }, r2 = true;
                for (n3 in this.commands)
                  this.commands[n3] !== o2[n3] && (r2 = false);
                var i2, a = true;
                for (i2 in this.keys)
                  a = a && e3.keyCode === t3.keyCodes[i2];
                r2 && a && this.callback(e3);
              } }, { key: "remove", value: function() {
                this.element.removeEventListener("keydown", this.executeShortcut);
              } }]), t3;
            }();
            e2.default = i;
          }]).default;
        }, function(t, e, n) {
          var o, r, i;
          "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self && self, r = [e, n(20), n(21), n(2), n(3), n(113), n(5), n(6), n(4), n(59), n(7), n(61), n(115), n(81), n(386), n(60), n(84)], void 0 === (i = "function" == typeof (o = function(t2, e2, o2, r2, i2, a, s, l, c, u, f, d, p, h, v, g, y) {
            "use strict";
            var b = n(8), m = n(1);
            function k() {
              if ("undefined" == typeof Reflect || !Reflect.construct)
                return false;
              if (Reflect.construct.sham)
                return false;
              if ("function" == typeof Proxy)
                return true;
              try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
                })), true;
              } catch (t3) {
                return false;
              }
            }
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = t2.ToolboxEvent = void 0, e2 = m(e2), o2 = m(o2), r2 = m(r2), i2 = m(i2), a = m(a), s = m(s), l = m(l), c = m(c), u = m(u), f = b(f), p = m(p), h = m(h), v = b(v), g = m(g);
            var x, w = function(t3, e3, n2, o3) {
              var r3, i3 = arguments.length, a2 = i3 < 3 ? e3 : null === o3 ? o3 = Object.getOwnPropertyDescriptor(e3, n2) : o3;
              if ("object" === ("undefined" == typeof Reflect ? "undefined" : (0, u.default)(Reflect)) && "function" == typeof Reflect.decorate)
                a2 = Reflect.decorate(t3, e3, n2, o3);
              else
                for (var s2 = t3.length - 1; s2 >= 0; s2--)
                  (r3 = t3[s2]) && (a2 = (i3 < 3 ? r3(a2) : i3 > 3 ? r3(e3, n2, a2) : r3(e3, n2)) || a2);
              return i3 > 3 && a2 && Object.defineProperty(e3, n2, a2), a2;
            };
            t2.ToolboxEvent = x, function(t3) {
              t3.Opened = "toolbox-opened", t3.Closed = "toolbox-closed", t3.BlockAdded = "toolbox-block-added";
            }(x || (t2.ToolboxEvent = x = {}));
            var S = function(t3) {
              (0, s.default)(b2, t3);
              var n2, u2, h2 = (n2 = b2, function() {
                var t4, e3 = (0, c.default)(n2);
                if (k()) {
                  var o3 = (0, c.default)(this).constructor;
                  t4 = Reflect.construct(e3, arguments, o3);
                } else
                  t4 = e3.apply(this, arguments);
                return (0, l.default)(this, t4);
              });
              function b2(t4) {
                var e3, n3 = t4.api, o3 = t4.tools, i3 = t4.i18nLabels;
                return (0, r2.default)(this, b2), (e3 = h2.call(this)).opened = false, e3.nodes = { toolbox: null }, e3.clickListenerId = null, e3.onOverlayClicked = function() {
                  e3.close();
                }, e3.api = n3, e3.tools = o3, e3.i18nLabels = i3, e3;
              }
              return (0, i2.default)(b2, [{ key: "make", value: function() {
                return this.popover = new v.default({ className: b2.CSS.toolbox, searchable: true, filterLabel: this.i18nLabels.filter, nothingFoundLabel: this.i18nLabels.nothingFound, items: this.toolboxItemsToBeDisplayed }), this.popover.on(v.PopoverEvent.OverlayClicked, this.onOverlayClicked), this.enableShortcuts(), this.nodes.toolbox = this.popover.getElement(), this.nodes.toolbox;
              } }, { key: "hasFocus", value: function() {
                return this.popover.hasFocus();
              } }, { key: "destroy", value: function() {
                (0, a.default)((0, c.default)(b2.prototype), "destroy", this).call(this), this.nodes && this.nodes.toolbox && (this.nodes.toolbox.remove(), this.nodes.toolbox = null), this.api.listeners.offById(this.clickListenerId), this.removeAllShortcuts(), this.popover.off(v.PopoverEvent.OverlayClicked, this.onOverlayClicked);
              } }, { key: "toolButtonActivated", value: function(t4, e3) {
                this.insertNewBlock(t4, e3);
              } }, { key: "open", value: function() {
                this.isEmpty || (this.shouldOpenPopoverBottom || (this.nodes.toolbox.style.setProperty("--popover-height", this.popover.calculateHeight() + "px"), this.nodes.toolbox.classList.add(b2.CSS.toolboxOpenedTop)), this.popover.show(), this.opened = true, this.emit(x.Opened));
              } }, { key: "close", value: function() {
                this.popover.hide(), this.opened = false, this.nodes.toolbox.classList.remove(b2.CSS.toolboxOpenedTop), this.emit(x.Closed);
              } }, { key: "toggle", value: function() {
                this.opened ? this.close() : this.open();
              } }, { key: "areToolboxSettingsValid", value: function(t4, e3) {
                return !(!t4 || t4 && !t4.icon && (f.log("Toolbar icon is missed. Tool %o skipped", "warn", e3), 1));
              } }, { key: "enableShortcuts", value: function() {
                var t4 = this;
                this.toolsToBeDisplayed.forEach(function(e3) {
                  var n3 = e3.shortcut;
                  n3 && t4.enableShortcutForTool(e3.name, n3);
                });
              } }, { key: "enableShortcutForTool", value: function(t4, e3) {
                var n3 = this;
                p.default.add({ name: e3, on: this.api.ui.nodes.redactor, handler: function(e4) {
                  e4.preventDefault(), n3.insertNewBlock(t4);
                } });
              } }, { key: "removeAllShortcuts", value: function() {
                var t4 = this;
                this.toolsToBeDisplayed.forEach(function(e3) {
                  var n3 = e3.shortcut;
                  n3 && p.default.remove(t4.api.ui.nodes.redactor, n3);
                });
              } }, { key: "insertNewBlock", value: (u2 = (0, o2.default)(e2.default.mark(function t4(n3, o3) {
                var r3, i3, a2, s2, l2, c2;
                return e2.default.wrap(function(t5) {
                  for (; ; )
                    switch (t5.prev = t5.next) {
                      case 0:
                        if (r3 = this.api.blocks.getCurrentBlockIndex(), i3 = this.api.blocks.getBlockByIndex(r3)) {
                          t5.next = 4;
                          break;
                        }
                        return t5.abrupt("return");
                      case 4:
                        if (a2 = i3.isEmpty ? r3 : r3 + 1, !o3) {
                          t5.next = 10;
                          break;
                        }
                        return t5.next = 8, this.api.blocks.composeBlockData(n3);
                      case 8:
                        l2 = t5.sent, s2 = Object.assign(l2, o3);
                      case 10:
                        (c2 = this.api.blocks.insert(n3, s2, void 0, a2, void 0, i3.isEmpty)).call(d.BlockToolAPI.APPEND_CALLBACK), this.api.caret.setToBlock(a2), this.emit(x.BlockAdded, { block: c2 }), this.api.toolbar.close();
                      case 15:
                      case "end":
                        return t5.stop();
                    }
                }, t4, this);
              })), function(t4, e3) {
                return u2.apply(this, arguments);
              }) }, { key: "isEmpty", get: function() {
                return 0 === this.toolsToBeDisplayed.length;
              } }, { key: "shouldOpenPopoverBottom", get: function() {
                var t4 = this.nodes.toolbox.getBoundingClientRect(), e3 = this.api.ui.nodes.redactor.getBoundingClientRect(), n3 = this.popover.calculateHeight(), o3 = t4.top + n3, r3 = t4.top - n3, i3 = Math.min(window.innerHeight, e3.bottom);
                return r3 < e3.top || o3 <= i3;
              } }, { key: "toolsToBeDisplayed", get: function() {
                var t4 = this;
                return Array.from(this.tools.values()).reduce(function(e3, n3) {
                  var o3 = n3.toolbox;
                  if (o3) {
                    var r3 = o3.filter(function(e4) {
                      return t4.areToolboxSettingsValid(e4, n3.name);
                    });
                    e3.push(Object.assign(Object.assign({}, n3), { toolbox: r3 }));
                  }
                  return e3;
                }, []);
              } }, { key: "toolboxItemsToBeDisplayed", get: function() {
                var t4 = this, e3 = function(e4, n3) {
                  return { icon: e4.icon, label: g.default.t(y.I18nInternalNS.toolNames, e4.title || f.capitalize(n3.name)), name: n3.name, onClick: function(o3) {
                    t4.toolButtonActivated(n3.name, e4.data);
                  }, secondaryLabel: n3.shortcut ? f.beautifyShortcut(n3.shortcut) : "" };
                };
                return this.toolsToBeDisplayed.reduce(function(t5, n3) {
                  return Array.isArray(n3.toolbox) ? n3.toolbox.forEach(function(o3) {
                    t5.push(e3(o3, n3));
                  }) : t5.push(e3(n3.toolbox, n3)), t5;
                }, []);
              } }], [{ key: "CSS", get: function() {
                return { toolbox: "ce-toolbox", toolboxOpenedTop: "ce-toolbox--opened-top" };
              } }]), b2;
            }(h.default);
            t2.default = S, S.displayName = "Toolbox", w([f.cacheable], S.prototype, "toolsToBeDisplayed", null), w([f.cacheable], S.prototype, "toolboxItemsToBeDisplayed", null);
          }) ? o.apply(e, r) : o) || (t.exports = i);
        }, function(t, e, n) {
          var o, r, i;
          "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self && self, r = [e, n(2), n(3), n(5), n(6), n(4), n(59), n(14), n(111), n(62), n(387), n(81), n(7), n(388)], void 0 === (i = "function" == typeof (o = function(t2, e2, o2, r2, i2, a, s, l, c, u, f, d, p, h) {
            "use strict";
            var v = n(1);
            function g() {
              if ("undefined" == typeof Reflect || !Reflect.construct)
                return false;
              if (Reflect.construct.sham)
                return false;
              if ("function" == typeof Proxy)
                return true;
              try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
                })), true;
              } catch (t3) {
                return false;
              }
            }
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = t2.PopoverEvent = void 0, e2 = v(e2), o2 = v(o2), r2 = v(r2), i2 = v(i2), a = v(a), s = v(s), l = v(l), c = v(c), u = v(u), f = v(f), d = v(d), h = v(h);
            var y, b = function(t3, e3, n2, o3) {
              var r3, i3 = arguments.length, a2 = i3 < 3 ? e3 : null === o3 ? o3 = Object.getOwnPropertyDescriptor(e3, n2) : o3;
              if ("object" === ("undefined" == typeof Reflect ? "undefined" : (0, s.default)(Reflect)) && "function" == typeof Reflect.decorate)
                a2 = Reflect.decorate(t3, e3, n2, o3);
              else
                for (var l2 = t3.length - 1; l2 >= 0; l2--)
                  (r3 = t3[l2]) && (a2 = (i3 < 3 ? r3(a2) : i3 > 3 ? r3(e3, n2, a2) : r3(e3, n2)) || a2);
              return i3 > 3 && a2 && Object.defineProperty(e3, n2, a2), a2;
            };
            t2.PopoverEvent = y, function(t3) {
              t3.OverlayClicked = "overlay-clicked";
            }(y || (t2.PopoverEvent = y = {}));
            var m = function(t3) {
              (0, r2.default)(d2, t3);
              var n2, s2 = (n2 = d2, function() {
                var t4, e3 = (0, a.default)(n2);
                if (g()) {
                  var o3 = (0, a.default)(this).constructor;
                  t4 = Reflect.construct(e3, arguments, o3);
                } else
                  t4 = e3.apply(this, arguments);
                return (0, i2.default)(this, t4);
              });
              function d2(t4) {
                var n3, o3 = t4.items, r3 = t4.className, i3 = t4.searchable, a2 = t4.filterLabel, l2 = t4.nothingFoundLabel;
                return (0, e2.default)(this, d2), (n3 = s2.call(this)).isShown = false, n3.nodes = { wrapper: null, popover: null, items: null, nothingFound: null, overlay: null }, n3.scrollLocker = new h.default(), n3.items = o3, n3.className = r3 || "", n3.searchable = i3, n3.listeners = new c.default(), n3.filterLabel = a2, n3.nothingFoundLabel = l2, n3.render(), n3.enableFlipper(), n3;
              }
              return (0, o2.default)(d2, [{ key: "getElement", value: function() {
                return this.nodes.wrapper;
              } }, { key: "show", value: function() {
                var t4 = this;
                this.search.clear(), this.nodes.items.scrollTop = 0, this.nodes.popover.classList.add(d2.CSS.popoverOpened), this.nodes.overlay.classList.remove(d2.CSS.popoverOverlayHidden), this.flipper.activate(), this.searchable && window.requestAnimationFrame(function() {
                  t4.search.focus();
                }), (0, p.isMobileScreen)() && this.scrollLocker.lock(), this.isShown = true;
              } }, { key: "hide", value: function() {
                this.isShown && (this.nodes.popover.classList.remove(d2.CSS.popoverOpened), this.nodes.overlay.classList.add(d2.CSS.popoverOverlayHidden), this.flipper.deactivate(), (0, p.isMobileScreen)() && this.scrollLocker.unlock(), this.isShown = false);
              } }, { key: "destroy", value: function() {
                this.listeners.removeAll();
              } }, { key: "hasFocus", value: function() {
                return this.flipper.hasFocus();
              } }, { key: "calculateHeight", value: function() {
                var t4, e3 = this.nodes.popover.cloneNode(true);
                return e3.style.visibility = "hidden", e3.style.position = "absolute", e3.style.top = "-1000px", e3.classList.add(d2.CSS.popoverOpened), document.body.appendChild(e3), t4 = e3.offsetHeight, e3.remove(), t4;
              } }, { key: "render", value: function() {
                var t4 = this;
                this.nodes.wrapper = l.default.make("div", this.className), this.nodes.popover = l.default.make("div", d2.CSS.popover), this.nodes.wrapper.appendChild(this.nodes.popover), this.nodes.overlay = l.default.make("div", [d2.CSS.popoverOverlay, d2.CSS.popoverOverlayHidden]), this.nodes.wrapper.appendChild(this.nodes.overlay), this.searchable && this.addSearch(this.nodes.popover), this.nodes.items = l.default.make("div", d2.CSS.itemsWrapper), this.items.forEach(function(e3) {
                  t4.nodes.items.appendChild(t4.createItem(e3));
                }), this.nodes.popover.appendChild(this.nodes.items), this.nodes.nothingFound = l.default.make("div", [d2.CSS.noFoundMessage], { textContent: this.nothingFoundLabel }), this.nodes.popover.appendChild(this.nodes.nothingFound), this.listeners.on(this.nodes.popover, "click", function(e3) {
                  var n3 = e3.target.closest(".".concat(d2.CSS.item));
                  n3 && t4.itemClicked(n3);
                }), this.listeners.on(this.nodes.overlay, "click", function() {
                  t4.emit(y.OverlayClicked);
                });
              } }, { key: "addSearch", value: function(t4) {
                var e3 = this;
                this.search = new f.default({ items: this.items, placeholder: this.filterLabel, onSearch: function(t5) {
                  var n4 = [];
                  e3.items.forEach(function(o3, r3) {
                    var i3 = e3.nodes.items.children[r3];
                    t5.includes(o3) ? (n4.push(i3), i3.classList.remove(d2.CSS.itemHidden)) : i3.classList.add(d2.CSS.itemHidden);
                  }), e3.nodes.nothingFound.classList.toggle(d2.CSS.noFoundMessageShown, 0 === n4.length), e3.flipper.deactivate(), e3.flipper.activate(n4), e3.flipper.focusFirst();
                } });
                var n3 = this.search.getElement();
                t4.appendChild(n3);
              } }, { key: "createItem", value: function(t4) {
                var e3 = l.default.make("div", d2.CSS.item);
                e3.dataset.itemName = t4.name;
                var n3 = l.default.make("div", d2.CSS.itemLabel, { innerHTML: t4.label });
                return t4.icon && e3.appendChild(l.default.make("div", d2.CSS.itemIcon, { innerHTML: t4.icon })), e3.appendChild(n3), t4.secondaryLabel && e3.appendChild(l.default.make("div", d2.CSS.itemSecondaryLabel, { textContent: t4.secondaryLabel })), e3;
              } }, { key: "itemClicked", value: function(t4) {
                var e3 = this.nodes.wrapper.querySelectorAll(".".concat(d2.CSS.item)), n3 = Array.from(e3).indexOf(t4), o3 = this.items[n3];
                o3.onClick(o3);
              } }, { key: "enableFlipper", value: function() {
                var t4 = Array.from(this.nodes.wrapper.querySelectorAll(".".concat(d2.CSS.item)));
                this.flipper = new u.default({ items: t4, focusedItemClass: d2.CSS.itemFocused, allowedKeys: [p.keyCodes.TAB, p.keyCodes.UP, p.keyCodes.DOWN, p.keyCodes.ENTER] });
              } }], [{ key: "CSS", get: function() {
                return { popover: "ce-popover", popoverOpened: "ce-popover--opened", itemsWrapper: "ce-popover__items", item: "ce-popover__item", itemHidden: "ce-popover__item--hidden", itemFocused: "ce-popover__item--focused", itemLabel: "ce-popover__item-label", itemIcon: "ce-popover__item-icon", itemSecondaryLabel: "ce-popover__item-secondary-label", noFoundMessage: "ce-popover__no-found", noFoundMessageShown: "ce-popover__no-found--shown", popoverOverlay: "ce-popover__overlay", popoverOverlayHidden: "ce-popover__overlay--hidden" };
              } }]), d2;
            }(d.default);
            t2.default = m, m.displayName = "Popover", b([p.cacheable], m.prototype, "calculateHeight", null);
          }) ? o.apply(e, r) : o) || (t.exports = i);
        }, function(t, e, n) {
          var o, r, i;
          "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self && self, r = [e, n(2), n(3), n(14), n(111)], void 0 === (i = "function" == typeof (o = function(o2, r2, i2, a, s) {
            "use strict";
            var l = n(1);
            Object.defineProperty(o2, "__esModule", { value: true }), o2.default = void 0, r2 = l(r2), i2 = l(i2), a = l(a), s = l(s);
            var c = function() {
              function t2(e2) {
                var n2 = e2.items, o3 = e2.onSearch, i3 = e2.placeholder;
                (0, r2.default)(this, t2), this.listeners = new s.default(), this.items = n2, this.onSearch = o3, this.render(i3);
              }
              return (0, i2.default)(t2, [{ key: "getElement", value: function() {
                return this.wrapper;
              } }, { key: "focus", value: function() {
                this.input.focus();
              } }, { key: "clear", value: function() {
                this.input.value = "", this.searchQuery = "", this.onSearch(this.foundItems);
              } }, { key: "destroy", value: function() {
                this.listeners.removeAll();
              } }, { key: "render", value: function(e2) {
                var n2 = this;
                this.wrapper = a.default.make("div", t2.CSS.wrapper);
                var o3 = a.default.make("div", t2.CSS.icon), r3 = a.default.svg("search", 16, 16);
                this.input = a.default.make("input", t2.CSS.input, { placeholder: e2 }), o3.appendChild(r3), this.wrapper.appendChild(o3), this.wrapper.appendChild(this.input), this.listeners.on(this.input, "input", function() {
                  n2.searchQuery = n2.input.value, n2.onSearch(n2.foundItems);
                });
              } }, { key: "checkItem", value: function(t3) {
                var e2 = t3.label.toLowerCase(), n2 = this.searchQuery.toLowerCase();
                return e2.includes(n2);
              } }, { key: "foundItems", get: function() {
                var t3 = this;
                return this.items.filter(function(e2) {
                  return t3.checkItem(e2);
                });
              } }], [{ key: "CSS", get: function() {
                return { wrapper: "cdx-search-field", icon: "cdx-search-field__icon", input: "cdx-search-field__input" };
              } }]), t2;
            }();
            o2.default = c, c.displayName = "SearchInput", t.exports = e.default;
          }) ? o.apply(e, r) : o) || (t.exports = i);
        }, function(t, e, n) {
          var o, r, i;
          "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self && self, r = [e, n(2), n(3), n(7)], void 0 === (i = "function" == typeof (o = function(o2, r2, i2, a) {
            "use strict";
            var s = n(1);
            Object.defineProperty(o2, "__esModule", { value: true }), o2.default = void 0, r2 = s(r2), i2 = s(i2);
            var l = function() {
              function t2() {
                (0, r2.default)(this, t2);
              }
              return (0, i2.default)(t2, [{ key: "lock", value: function() {
                a.isIosDevice ? this.lockHard() : document.body.classList.add(t2.CSS.scrollLocked);
              } }, { key: "unlock", value: function() {
                a.isIosDevice ? this.unlockHard() : document.body.classList.remove(t2.CSS.scrollLocked);
              } }, { key: "lockHard", value: function() {
                this.scrollPosition = window.pageYOffset, document.documentElement.style.setProperty("--window-scroll-offset", "".concat(this.scrollPosition, "px")), document.body.classList.add(t2.CSS.scrollLockedHard);
              } }, { key: "unlockHard", value: function() {
                document.body.classList.remove(t2.CSS.scrollLockedHard), null !== this.scrollPosition && window.scrollTo(0, this.scrollPosition), this.scrollPosition = null;
              } }]), t2;
            }();
            o2.default = l, l.displayName = "ScrollLocker", l.CSS = { scrollLocked: "ce-scroll-locked", scrollLockedHard: "ce-scroll-locked--hard" }, t.exports = e.default;
          }) ? o.apply(e, r) : o) || (t.exports = i);
        }, function(t, e, n) {
          window, t.exports = function(t2) {
            var e2 = {};
            function n2(o) {
              if (e2[o])
                return e2[o].exports;
              var r = e2[o] = { i: o, l: false, exports: {} };
              return t2[o].call(r.exports, r, r.exports, n2), r.l = true, r.exports;
            }
            return n2.m = t2, n2.c = e2, n2.d = function(t3, e3, o) {
              n2.o(t3, e3) || Object.defineProperty(t3, e3, { enumerable: true, get: o });
            }, n2.r = function(t3) {
              "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t3, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t3, "__esModule", { value: true });
            }, n2.t = function(t3, e3) {
              if (1 & e3 && (t3 = n2(t3)), 8 & e3)
                return t3;
              if (4 & e3 && "object" == typeof t3 && t3 && t3.__esModule)
                return t3;
              var o = /* @__PURE__ */ Object.create(null);
              if (n2.r(o), Object.defineProperty(o, "default", { enumerable: true, value: t3 }), 2 & e3 && "string" != typeof t3)
                for (var r in t3)
                  n2.d(o, r, function(e4) {
                    return t3[e4];
                  }.bind(null, r));
              return o;
            }, n2.n = function(t3) {
              var e3 = t3 && t3.__esModule ? function() {
                return t3.default;
              } : function() {
                return t3;
              };
              return n2.d(e3, "a", e3), e3;
            }, n2.o = function(t3, e3) {
              return Object.prototype.hasOwnProperty.call(t3, e3);
            }, n2.p = "/", n2(n2.s = 0);
          }([function(t2, e2, n2) {
            function o(t3, e3) {
              for (var n3 = 0; n3 < e3.length; n3++) {
                var o2 = e3[n3];
                o2.enumerable = o2.enumerable || false, o2.configurable = true, "value" in o2 && (o2.writable = true), Object.defineProperty(t3, o2.key, o2);
              }
            }
            function r(t3, e3, n3) {
              return e3 && o(t3.prototype, e3), n3 && o(t3, n3), t3;
            }
            n2(1).toString();
            var i = function() {
              function t3(e3) {
                var n3 = e3.data, o2 = e3.config, r2 = e3.api, i2 = e3.readOnly;
                !function(t4, e4) {
                  if (!(t4 instanceof e4))
                    throw new TypeError("Cannot call a class as a function");
                }(this, t3), this.api = r2, this.readOnly = i2, this._CSS = { block: this.api.styles.block, wrapper: "ce-paragraph" }, this.readOnly || (this.onKeyUp = this.onKeyUp.bind(this)), this._placeholder = o2.placeholder ? o2.placeholder : t3.DEFAULT_PLACEHOLDER, this._data = {}, this._element = this.drawView(), this._preserveBlank = void 0 !== o2.preserveBlank && o2.preserveBlank, this.data = n3;
              }
              return r(t3, null, [{ key: "DEFAULT_PLACEHOLDER", get: function() {
                return "";
              } }]), r(t3, [{ key: "onKeyUp", value: function(t4) {
                "Backspace" !== t4.code && "Delete" !== t4.code || "" === this._element.textContent && (this._element.innerHTML = "");
              } }, { key: "drawView", value: function() {
                var t4 = document.createElement("DIV");
                return t4.classList.add(this._CSS.wrapper, this._CSS.block), t4.contentEditable = false, t4.dataset.placeholder = this.api.i18n.t(this._placeholder), this.readOnly || (t4.contentEditable = true, t4.addEventListener("keyup", this.onKeyUp)), t4;
              } }, { key: "render", value: function() {
                return this._element;
              } }, { key: "merge", value: function(t4) {
                var e3 = { text: this.data.text + t4.text };
                this.data = e3;
              } }, { key: "validate", value: function(t4) {
                return !("" === t4.text.trim() && !this._preserveBlank);
              } }, { key: "save", value: function(t4) {
                return { text: t4.innerHTML };
              } }, { key: "onPaste", value: function(t4) {
                var e3 = { text: t4.detail.data.innerHTML };
                this.data = e3;
              } }, { key: "data", get: function() {
                var t4 = this._element.innerHTML;
                return this._data.text = t4, this._data;
              }, set: function(t4) {
                this._data = t4 || {}, this._element.innerHTML = this._data.text || "";
              } }], [{ key: "conversionConfig", get: function() {
                return { export: "text", import: "text" };
              } }, { key: "sanitize", get: function() {
                return { text: { br: true } };
              } }, { key: "isReadOnlySupported", get: function() {
                return true;
              } }, { key: "pasteConfig", get: function() {
                return { tags: ["P"] };
              } }, { key: "toolbox", get: function() {
                return { icon: n2(5).default, title: "Text" };
              } }]), t3;
            }();
            t2.exports = i;
          }, function(t2, e2, n2) {
            var o = n2(2), r = n2(3);
            "string" == typeof (r = r.__esModule ? r.default : r) && (r = [[t2.i, r, ""]]), o(r, { insert: "head", singleton: false }), t2.exports = r.locals || {};
          }, function(t2, e2, n2) {
            "use strict";
            var o, r = /* @__PURE__ */ function() {
              var t3 = {};
              return function(e3) {
                if (void 0 === t3[e3]) {
                  var n3 = document.querySelector(e3);
                  if (window.HTMLIFrameElement && n3 instanceof window.HTMLIFrameElement)
                    try {
                      n3 = n3.contentDocument.head;
                    } catch (t4) {
                      n3 = null;
                    }
                  t3[e3] = n3;
                }
                return t3[e3];
              };
            }(), i = [];
            function a(t3) {
              for (var e3 = -1, n3 = 0; n3 < i.length; n3++)
                if (i[n3].identifier === t3) {
                  e3 = n3;
                  break;
                }
              return e3;
            }
            function s(t3, e3) {
              for (var n3 = {}, o2 = [], r2 = 0; r2 < t3.length; r2++) {
                var s2 = t3[r2], l2 = e3.base ? s2[0] + e3.base : s2[0], c2 = n3[l2] || 0, u2 = "".concat(l2, " ").concat(c2);
                n3[l2] = c2 + 1;
                var f2 = a(u2), d2 = { css: s2[1], media: s2[2], sourceMap: s2[3] };
                -1 !== f2 ? (i[f2].references++, i[f2].updater(d2)) : i.push({ identifier: u2, updater: v(d2, e3), references: 1 }), o2.push(u2);
              }
              return o2;
            }
            function l(t3) {
              var e3 = document.createElement("style"), o2 = t3.attributes || {};
              if (void 0 === o2.nonce) {
                var i2 = n2.nc;
                i2 && (o2.nonce = i2);
              }
              if (Object.keys(o2).forEach(function(t4) {
                e3.setAttribute(t4, o2[t4]);
              }), "function" == typeof t3.insert)
                t3.insert(e3);
              else {
                var a2 = r(t3.insert || "head");
                if (!a2)
                  throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
                a2.appendChild(e3);
              }
              return e3;
            }
            var c, u = (c = [], function(t3, e3) {
              return c[t3] = e3, c.filter(Boolean).join("\n");
            });
            function f(t3, e3, n3, o2) {
              var r2 = n3 ? "" : o2.media ? "@media ".concat(o2.media, " {").concat(o2.css, "}") : o2.css;
              if (t3.styleSheet)
                t3.styleSheet.cssText = u(e3, r2);
              else {
                var i2 = document.createTextNode(r2), a2 = t3.childNodes;
                a2[e3] && t3.removeChild(a2[e3]), a2.length ? t3.insertBefore(i2, a2[e3]) : t3.appendChild(i2);
              }
            }
            function d(t3, e3, n3) {
              var o2 = n3.css, r2 = n3.media, i2 = n3.sourceMap;
              if (r2 ? t3.setAttribute("media", r2) : t3.removeAttribute("media"), i2 && btoa && (o2 += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(i2)))), " */")), t3.styleSheet)
                t3.styleSheet.cssText = o2;
              else {
                for (; t3.firstChild; )
                  t3.removeChild(t3.firstChild);
                t3.appendChild(document.createTextNode(o2));
              }
            }
            var p = null, h = 0;
            function v(t3, e3) {
              var n3, o2, r2;
              if (e3.singleton) {
                var i2 = h++;
                n3 = p || (p = l(e3)), o2 = f.bind(null, n3, i2, false), r2 = f.bind(null, n3, i2, true);
              } else
                n3 = l(e3), o2 = d.bind(null, n3, e3), r2 = function() {
                  !function(t4) {
                    if (null === t4.parentNode)
                      return false;
                    t4.parentNode.removeChild(t4);
                  }(n3);
                };
              return o2(t3), function(e4) {
                if (e4) {
                  if (e4.css === t3.css && e4.media === t3.media && e4.sourceMap === t3.sourceMap)
                    return;
                  o2(t3 = e4);
                } else
                  r2();
              };
            }
            t2.exports = function(t3, e3) {
              (e3 = e3 || {}).singleton || "boolean" == typeof e3.singleton || (e3.singleton = (void 0 === o && (o = Boolean(window && document && document.all && !window.atob)), o));
              var n3 = s(t3 = t3 || [], e3);
              return function(t4) {
                if (t4 = t4 || [], "[object Array]" === Object.prototype.toString.call(t4)) {
                  for (var o2 = 0; o2 < n3.length; o2++) {
                    var r2 = a(n3[o2]);
                    i[r2].references--;
                  }
                  for (var l2 = s(t4, e3), c2 = 0; c2 < n3.length; c2++) {
                    var u2 = a(n3[c2]);
                    0 === i[u2].references && (i[u2].updater(), i.splice(u2, 1));
                  }
                  n3 = l2;
                }
              };
            };
          }, function(t2, e2, n2) {
            (e2 = n2(4)(false)).push([t2.i, ".ce-paragraph {\n    line-height: 1.6em;\n    outline: none;\n}\n\n.ce-paragraph[data-placeholder]:empty::before{\n  content: attr(data-placeholder);\n  color: #707684;\n  font-weight: normal;\n  opacity: 0;\n}\n\n/** Show placeholder at the first paragraph if Editor is empty */\n.codex-editor--empty .ce-block:first-child .ce-paragraph[data-placeholder]:empty::before {\n  opacity: 1;\n}\n\n.codex-editor--toolbox-opened .ce-block:first-child .ce-paragraph[data-placeholder]:empty::before,\n.codex-editor--empty .ce-block:first-child .ce-paragraph[data-placeholder]:empty:focus::before {\n  opacity: 0;\n}\n\n.ce-paragraph p:first-of-type{\n    margin-top: 0;\n}\n\n.ce-paragraph p:last-of-type{\n    margin-bottom: 0;\n}\n", ""]), t2.exports = e2;
          }, function(t2, e2, n2) {
            "use strict";
            t2.exports = function(t3) {
              var e3 = [];
              return e3.toString = function() {
                return this.map(function(e4) {
                  var n3 = function(t4, e5) {
                    var n4, o, r, i = t4[1] || "", a = t4[3];
                    if (!a)
                      return i;
                    if (e5 && "function" == typeof btoa) {
                      var s = (n4 = a, o = btoa(unescape(encodeURIComponent(JSON.stringify(n4)))), r = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(o), "/*# ".concat(r, " */")), l = a.sources.map(function(t5) {
                        return "/*# sourceURL=".concat(a.sourceRoot || "").concat(t5, " */");
                      });
                      return [i].concat(l).concat([s]).join("\n");
                    }
                    return [i].join("\n");
                  }(e4, t3);
                  return e4[2] ? "@media ".concat(e4[2], " {").concat(n3, "}") : n3;
                }).join("");
              }, e3.i = function(t4, n3, o) {
                "string" == typeof t4 && (t4 = [[null, t4, ""]]);
                var r = {};
                if (o)
                  for (var i = 0; i < this.length; i++) {
                    var a = this[i][0];
                    null != a && (r[a] = true);
                  }
                for (var s = 0; s < t4.length; s++) {
                  var l = [].concat(t4[s]);
                  o && r[l[0]] || (n3 && (l[2] ? l[2] = "".concat(n3, " and ").concat(l[2]) : l[2] = n3), e3.push(l));
                }
              }, e3;
            };
          }, function(t2, e2, n2) {
            "use strict";
            n2.r(e2), e2.default = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0.2 -0.3 9 11.4" width="12" height="14">\n  <path d="M0 2.77V.92A1 1 0 01.2.28C.35.1.56 0 .83 0h7.66c.28.01.48.1.63.28.14.17.21.38.21.64v1.85c0 .26-.08.48-.23.66-.15.17-.37.26-.66.26-.28 0-.5-.09-.64-.26a1 1 0 01-.21-.66V1.69H5.6v7.58h.5c.25 0 .45.08.6.23.17.16.25.35.25.6s-.08.45-.24.6a.87.87 0 01-.62.22H3.21a.87.87 0 01-.61-.22.78.78 0 01-.24-.6c0-.25.08-.44.24-.6a.85.85 0 01.61-.23h.5V1.7H1.73v1.08c0 .26-.08.48-.23.66-.15.17-.37.26-.66.26-.28 0-.5-.09-.64-.26A1 1 0 010 2.77z"/>\n</svg>\n';
          }]);
        }, function(t, e, n) {
          var o, r, i;
          "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self && self, r = [e, n(2), n(3), n(14)], void 0 === (i = "function" == typeof (o = function(o2, r2, i2, a) {
            "use strict";
            var s = n(1);
            Object.defineProperty(o2, "__esModule", { value: true }), o2.default = void 0, r2 = s(r2), i2 = s(i2), a = s(a);
            var l = function() {
              function t2() {
                (0, r2.default)(this, t2), this.commandName = "bold", this.CSS = { button: "ce-inline-tool", buttonActive: "ce-inline-tool--active", buttonModifier: "ce-inline-tool--bold" }, this.nodes = { button: void 0 };
              }
              return (0, i2.default)(t2, [{ key: "render", value: function() {
                return this.nodes.button = document.createElement("button"), this.nodes.button.type = "button", this.nodes.button.classList.add(this.CSS.button, this.CSS.buttonModifier), this.nodes.button.appendChild(a.default.svg("bold", 12, 14)), this.nodes.button;
              } }, { key: "surround", value: function(t3) {
                document.execCommand(this.commandName);
              } }, { key: "checkState", value: function(t3) {
                var e2 = document.queryCommandState(this.commandName);
                return this.nodes.button.classList.toggle(this.CSS.buttonActive, e2), e2;
              } }, { key: "shortcut", get: function() {
                return "CMD+B";
              } }], [{ key: "sanitize", get: function() {
                return { b: {} };
              } }]), t2;
            }();
            o2.default = l, l.displayName = "BoldInlineTool", l.isInline = true, l.title = "Bold", t.exports = e.default;
          }) ? o.apply(e, r) : o) || (t.exports = i);
        }, function(t, e, n) {
          var o, r, i;
          "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self && self, r = [e, n(2), n(3), n(14)], void 0 === (i = "function" == typeof (o = function(o2, r2, i2, a) {
            "use strict";
            var s = n(1);
            Object.defineProperty(o2, "__esModule", { value: true }), o2.default = void 0, r2 = s(r2), i2 = s(i2), a = s(a);
            var l = function() {
              function t2() {
                (0, r2.default)(this, t2), this.commandName = "italic", this.CSS = { button: "ce-inline-tool", buttonActive: "ce-inline-tool--active", buttonModifier: "ce-inline-tool--italic" }, this.nodes = { button: null };
              }
              return (0, i2.default)(t2, [{ key: "render", value: function() {
                return this.nodes.button = document.createElement("button"), this.nodes.button.type = "button", this.nodes.button.classList.add(this.CSS.button, this.CSS.buttonModifier), this.nodes.button.appendChild(a.default.svg("italic", 4, 11)), this.nodes.button;
              } }, { key: "surround", value: function(t3) {
                document.execCommand(this.commandName);
              } }, { key: "checkState", value: function(t3) {
                var e2 = document.queryCommandState(this.commandName);
                return this.nodes.button.classList.toggle(this.CSS.buttonActive, e2), e2;
              } }, { key: "shortcut", get: function() {
                return "CMD+I";
              } }], [{ key: "sanitize", get: function() {
                return { i: {} };
              } }]), t2;
            }();
            o2.default = l, l.displayName = "ItalicInlineTool", l.isInline = true, l.title = "Italic", t.exports = e.default;
          }) ? o.apply(e, r) : o) || (t.exports = i);
        }, function(t, e, n) {
          var o, r, i;
          "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self && self, r = [e, n(2), n(3), n(25), n(14), n(7)], void 0 === (i = "function" == typeof (o = function(o2, r2, i2, a, s, l) {
            "use strict";
            var c = n(8), u = n(1);
            Object.defineProperty(o2, "__esModule", { value: true }), o2.default = void 0, r2 = u(r2), i2 = u(i2), a = u(a), s = u(s), l = c(l);
            var f = function() {
              function t2(e2) {
                var n2 = e2.api;
                (0, r2.default)(this, t2), this.commandLink = "createLink", this.commandUnlink = "unlink", this.ENTER_KEY = 13, this.CSS = { button: "ce-inline-tool", buttonActive: "ce-inline-tool--active", buttonModifier: "ce-inline-tool--link", buttonUnlink: "ce-inline-tool--unlink", input: "ce-inline-tool-input", inputShowed: "ce-inline-tool-input--showed" }, this.nodes = { button: null, input: null }, this.inputOpened = false, this.toolbar = n2.toolbar, this.inlineToolbar = n2.inlineToolbar, this.notifier = n2.notifier, this.i18n = n2.i18n, this.selection = new a.default();
              }
              return (0, i2.default)(t2, [{ key: "render", value: function() {
                return this.nodes.button = document.createElement("button"), this.nodes.button.type = "button", this.nodes.button.classList.add(this.CSS.button, this.CSS.buttonModifier), this.nodes.button.appendChild(s.default.svg("link", 14, 10)), this.nodes.button.appendChild(s.default.svg("unlink", 15, 11)), this.nodes.button;
              } }, { key: "renderActions", value: function() {
                var t3 = this;
                return this.nodes.input = document.createElement("input"), this.nodes.input.placeholder = this.i18n.t("Add a link"), this.nodes.input.classList.add(this.CSS.input), this.nodes.input.addEventListener("keydown", function(e2) {
                  e2.keyCode === t3.ENTER_KEY && t3.enterPressed(e2);
                }), this.nodes.input;
              } }, { key: "surround", value: function(t3) {
                if (t3) {
                  this.inputOpened ? (this.selection.restore(), this.selection.removeFakeBackground()) : (this.selection.setFakeBackground(), this.selection.save());
                  var e2 = this.selection.findParentTag("A");
                  if (e2)
                    return this.selection.expandToTag(e2), this.unlink(), this.closeActions(), this.checkState(), void this.toolbar.close();
                }
                this.toggleActions();
              } }, { key: "checkState", value: function(t3) {
                var e2 = this.selection.findParentTag("A");
                if (e2) {
                  this.nodes.button.classList.add(this.CSS.buttonUnlink), this.nodes.button.classList.add(this.CSS.buttonActive), this.openActions();
                  var n2 = e2.getAttribute("href");
                  this.nodes.input.value = "null" !== n2 ? n2 : "", this.selection.save();
                } else
                  this.nodes.button.classList.remove(this.CSS.buttonUnlink), this.nodes.button.classList.remove(this.CSS.buttonActive);
                return !!e2;
              } }, { key: "clear", value: function() {
                this.closeActions();
              } }, { key: "toggleActions", value: function() {
                this.inputOpened ? this.closeActions(false) : this.openActions(true);
              } }, { key: "openActions", value: function() {
                var t3 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
                this.nodes.input.classList.add(this.CSS.inputShowed), t3 && this.nodes.input.focus(), this.inputOpened = true;
              } }, { key: "closeActions", value: function() {
                var t3 = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
                if (this.selection.isFakeBackgroundEnabled) {
                  var e2 = new a.default();
                  e2.save(), this.selection.restore(), this.selection.removeFakeBackground(), e2.restore();
                }
                this.nodes.input.classList.remove(this.CSS.inputShowed), this.nodes.input.value = "", t3 && this.selection.clearSaved(), this.inputOpened = false;
              } }, { key: "enterPressed", value: function(t3) {
                var e2 = this.nodes.input.value || "";
                return e2.trim() ? this.validateURL(e2) ? (e2 = this.prepareLink(e2), this.selection.restore(), this.selection.removeFakeBackground(), this.insertLink(e2), t3.preventDefault(), t3.stopPropagation(), t3.stopImmediatePropagation(), this.selection.collapseToEnd(), void this.inlineToolbar.close()) : (this.notifier.show({ message: "Pasted link is not valid.", style: "error" }), void l.log("Incorrect Link pasted", "warn", e2)) : (this.selection.restore(), this.unlink(), t3.preventDefault(), void this.closeActions());
              } }, { key: "validateURL", value: function(t3) {
                return !/\s/.test(t3);
              } }, { key: "prepareLink", value: function(t3) {
                return t3 = t3.trim(), t3 = this.addProtocol(t3);
              } }, { key: "addProtocol", value: function(t3) {
                if (/^(\w+):(\/\/)?/.test(t3))
                  return t3;
                var e2 = /^\/[^/\s]/.test(t3), n2 = "#" === t3.substring(0, 1), o3 = /^\/\/[^/\s]/.test(t3);
                return e2 || n2 || o3 || (t3 = "http://" + t3), t3;
              } }, { key: "insertLink", value: function(t3) {
                var e2 = this.selection.findParentTag("A");
                e2 && this.selection.expandToTag(e2), document.execCommand(this.commandLink, false, t3);
              } }, { key: "unlink", value: function() {
                document.execCommand(this.commandUnlink);
              } }, { key: "shortcut", get: function() {
                return "CMD+K";
              } }], [{ key: "sanitize", get: function() {
                return { a: { href: true, target: "_blank", rel: "nofollow" } };
              } }]), t2;
            }();
            o2.default = f, f.displayName = "LinkInlineTool", f.isInline = true, f.title = "Link", t.exports = e.default;
          }) ? o.apply(e, r) : o) || (t.exports = i);
        }, function(t, e, n) {
          var o, r, i;
          "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self && self, r = [e, n(2), n(3), n(14)], void 0 === (i = "function" == typeof (o = function(o2, r2, i2, a) {
            "use strict";
            var s = n(1);
            Object.defineProperty(o2, "__esModule", { value: true }), o2.default = void 0, r2 = s(r2), i2 = s(i2), a = s(a);
            var l = function() {
              function t2(e2) {
                var n2 = e2.data, o3 = e2.api;
                (0, r2.default)(this, t2), this.CSS = { wrapper: "ce-stub", info: "ce-stub__info", title: "ce-stub__title", subtitle: "ce-stub__subtitle" }, this.api = o3, this.title = n2.title || this.api.i18n.t("Error"), this.subtitle = this.api.i18n.t("The block can not be displayed correctly."), this.savedData = n2.savedData, this.wrapper = this.make();
              }
              return (0, i2.default)(t2, [{ key: "render", value: function() {
                return this.wrapper;
              } }, { key: "save", value: function() {
                return this.savedData;
              } }, { key: "make", value: function() {
                var t3 = a.default.make("div", this.CSS.wrapper), e2 = a.default.svg("sad-face", 52, 52), n2 = a.default.make("div", this.CSS.info), o3 = a.default.make("div", this.CSS.title, { textContent: this.title }), r3 = a.default.make("div", this.CSS.subtitle, { textContent: this.subtitle });
                return t3.appendChild(e2), n2.appendChild(o3), n2.appendChild(r3), t3.appendChild(n2), t3;
              } }]), t2;
            }();
            o2.default = l, l.displayName = "Stub", l.isReadOnlySupported = true, t.exports = e.default;
          }) ? o.apply(e, r) : o) || (t.exports = i);
        }, function(t, e, n) {
          var o, r, i;
          "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self && self, r = [e, n(2), n(3), n(68), n(395), n(396), n(397)], void 0 === (i = "function" == typeof (o = function(o2, r2, i2, a, s, l, c) {
            "use strict";
            var u = n(1);
            Object.defineProperty(o2, "__esModule", { value: true }), o2.default = void 0, r2 = u(r2), i2 = u(i2), s = u(s), l = u(l), c = u(c);
            var f = function(t2, e2) {
              var n2 = {};
              for (var o3 in t2)
                Object.prototype.hasOwnProperty.call(t2, o3) && e2.indexOf(o3) < 0 && (n2[o3] = t2[o3]);
              if (null != t2 && "function" == typeof Object.getOwnPropertySymbols) {
                var r3 = 0;
                for (o3 = Object.getOwnPropertySymbols(t2); r3 < o3.length; r3++)
                  e2.indexOf(o3[r3]) < 0 && Object.prototype.propertyIsEnumerable.call(t2, o3[r3]) && (n2[o3[r3]] = t2[o3[r3]]);
              }
              return n2;
            }, d = function() {
              function t2(e2, n2, o3) {
                (0, r2.default)(this, t2), this.api = o3, this.config = e2, this.editorConfig = n2;
              }
              return (0, i2.default)(t2, [{ key: "get", value: function(t3) {
                var e2 = this.config[t3], n2 = e2.class, o3 = e2.isInternal, r3 = void 0 !== o3 && o3, i3 = f(e2, ["class", "isInternal"]);
                return new (this.getConstructor(n2))({ name: t3, constructable: n2, config: i3, api: this.api, isDefault: t3 === this.editorConfig.defaultBlock, defaultPlaceholder: this.editorConfig.placeholder, isInternal: r3 });
              } }, { key: "getConstructor", value: function(t3) {
                switch (true) {
                  case t3[a.InternalInlineToolSettings.IsInline]:
                    return s.default;
                  case t3[a.InternalTuneSettings.IsTune]:
                    return l.default;
                  default:
                    return c.default;
                }
              } }]), t2;
            }();
            o2.default = d, d.displayName = "ToolsFactory", t.exports = e.default;
          }) ? o.apply(e, r) : o) || (t.exports = i);
        }, function(t, e, n) {
          var o, r, i;
          "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self && self, r = [e, n(2), n(3), n(5), n(6), n(4), n(68)], void 0 === (i = "function" == typeof (o = function(o2, r2, i2, a, s, l, c) {
            "use strict";
            var u = n(8), f = n(1);
            function d() {
              if ("undefined" == typeof Reflect || !Reflect.construct)
                return false;
              if (Reflect.construct.sham)
                return false;
              if ("function" == typeof Proxy)
                return true;
              try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
                })), true;
              } catch (t2) {
                return false;
              }
            }
            Object.defineProperty(o2, "__esModule", { value: true }), o2.default = void 0, r2 = f(r2), i2 = f(i2), a = f(a), s = f(s), l = f(l);
            var p = function(t2) {
              (0, a.default)(o3, t2);
              var e2, n2 = (e2 = o3, function() {
                var t3, n3 = (0, l.default)(e2);
                if (d()) {
                  var o4 = (0, l.default)(this).constructor;
                  t3 = Reflect.construct(n3, arguments, o4);
                } else
                  t3 = n3.apply(this, arguments);
                return (0, s.default)(this, t3);
              });
              function o3() {
                var t3;
                return (0, r2.default)(this, o3), (t3 = n2.apply(this, arguments)).type = c.ToolType.Inline, t3;
              }
              return (0, i2.default)(o3, [{ key: "create", value: function() {
                return new this.constructable({ api: this.api.getMethodsForTool(this), config: this.settings });
              } }, { key: "title", get: function() {
                return this.constructable[c.InternalInlineToolSettings.Title];
              } }]), o3;
            }((c = u(c)).default);
            o2.default = p, p.displayName = "InlineTool", t.exports = e.default;
          }) ? o.apply(e, r) : o) || (t.exports = i);
        }, function(t, e, n) {
          var o, r, i;
          "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self && self, r = [e, n(2), n(3), n(5), n(6), n(4), n(68)], void 0 === (i = "function" == typeof (o = function(o2, r2, i2, a, s, l, c) {
            "use strict";
            var u = n(8), f = n(1);
            function d() {
              if ("undefined" == typeof Reflect || !Reflect.construct)
                return false;
              if (Reflect.construct.sham)
                return false;
              if ("function" == typeof Proxy)
                return true;
              try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
                })), true;
              } catch (t2) {
                return false;
              }
            }
            Object.defineProperty(o2, "__esModule", { value: true }), o2.default = void 0, r2 = f(r2), i2 = f(i2), a = f(a), s = f(s), l = f(l);
            var p = function(t2) {
              (0, a.default)(o3, t2);
              var e2, n2 = (e2 = o3, function() {
                var t3, n3 = (0, l.default)(e2);
                if (d()) {
                  var o4 = (0, l.default)(this).constructor;
                  t3 = Reflect.construct(n3, arguments, o4);
                } else
                  t3 = n3.apply(this, arguments);
                return (0, s.default)(this, t3);
              });
              function o3() {
                var t3;
                return (0, r2.default)(this, o3), (t3 = n2.apply(this, arguments)).type = c.ToolType.Tune, t3;
              }
              return (0, i2.default)(o3, [{ key: "create", value: function(t3, e3) {
                return new this.constructable({ api: this.api.getMethodsForTool(this), config: this.settings, block: e3, data: t3 });
              } }]), o3;
            }((c = u(c)).default);
            o2.default = p, p.displayName = "BlockTune", t.exports = e.default;
          }) ? o.apply(e, r) : o) || (t.exports = i);
        }, function(t, e, n) {
          var o, r, i;
          "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self && self, r = [e, n(2), n(3), n(113), n(5), n(6), n(4), n(59), n(68), n(7), n(185)], void 0 === (i = "function" == typeof (o = function(o2, r2, i2, a, s, l, c, u, f, d, p) {
            "use strict";
            var h = n(8), v = n(1);
            function g() {
              if ("undefined" == typeof Reflect || !Reflect.construct)
                return false;
              if (Reflect.construct.sham)
                return false;
              if ("function" == typeof Proxy)
                return true;
              try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
                })), true;
              } catch (t2) {
                return false;
              }
            }
            Object.defineProperty(o2, "__esModule", { value: true }), o2.default = void 0, r2 = v(r2), i2 = v(i2), a = v(a), s = v(s), l = v(l), c = v(c), u = v(u), f = h(f), d = h(d), p = v(p);
            var y = function(t2, e2, n2, o3) {
              var r3, i3 = arguments.length, a2 = i3 < 3 ? e2 : null === o3 ? o3 = Object.getOwnPropertyDescriptor(e2, n2) : o3;
              if ("object" === ("undefined" == typeof Reflect ? "undefined" : (0, u.default)(Reflect)) && "function" == typeof Reflect.decorate)
                a2 = Reflect.decorate(t2, e2, n2, o3);
              else
                for (var s2 = t2.length - 1; s2 >= 0; s2--)
                  (r3 = t2[s2]) && (a2 = (i3 < 3 ? r3(a2) : i3 > 3 ? r3(e2, n2, a2) : r3(e2, n2)) || a2);
              return i3 > 3 && a2 && Object.defineProperty(e2, n2, a2), a2;
            }, b = function(t2) {
              (0, s.default)(o3, t2);
              var e2, n2 = (e2 = o3, function() {
                var t3, n3 = (0, c.default)(e2);
                if (g()) {
                  var o4 = (0, c.default)(this).constructor;
                  t3 = Reflect.construct(n3, arguments, o4);
                } else
                  t3 = n3.apply(this, arguments);
                return (0, l.default)(this, t3);
              });
              function o3() {
                var t3;
                return (0, r2.default)(this, o3), (t3 = n2.apply(this, arguments)).type = f.ToolType.Block, t3.inlineTools = new p.default(), t3.tunes = new p.default(), t3;
              }
              return (0, i2.default)(o3, [{ key: "create", value: function(t3, e3, n3) {
                return new this.constructable({ data: t3, block: e3, readOnly: n3, api: this.api.getMethodsForTool(this), config: this.settings });
              } }, { key: "isReadOnlySupported", get: function() {
                return true === this.constructable[f.InternalBlockToolSettings.IsReadOnlySupported];
              } }, { key: "isLineBreaksEnabled", get: function() {
                return this.constructable[f.InternalBlockToolSettings.IsEnabledLineBreaks];
              } }, { key: "toolbox", get: function() {
                var t3 = this.constructable[f.InternalBlockToolSettings.Toolbox], e3 = this.config[f.UserSettings.Toolbox];
                if (!d.isEmpty(t3) && false !== e3)
                  return e3 ? Array.isArray(t3) ? Array.isArray(e3) ? e3.map(function(e4, n3) {
                    var o4 = t3[n3];
                    return o4 ? Object.assign(Object.assign({}, o4), e4) : e4;
                  }) : [e3] : Array.isArray(e3) ? e3 : [Object.assign(Object.assign({}, t3), e3)] : Array.isArray(t3) ? t3 : [t3];
              } }, { key: "conversionConfig", get: function() {
                return this.constructable[f.InternalBlockToolSettings.ConversionConfig];
              } }, { key: "enabledInlineTools", get: function() {
                return this.config[f.UserSettings.EnabledInlineTools] || false;
              } }, { key: "enabledBlockTunes", get: function() {
                return this.config[f.UserSettings.EnabledBlockTunes];
              } }, { key: "pasteConfig", get: function() {
                return this.constructable[f.InternalBlockToolSettings.PasteConfig] || {};
              } }, { key: "sanitizeConfig", get: function() {
                var t3 = (0, a.default)((0, c.default)(o3.prototype), "sanitizeConfig", this), e3 = this.baseSanitizeConfig;
                if (d.isEmpty(t3))
                  return e3;
                var n3 = {};
                for (var r3 in t3)
                  if (Object.prototype.hasOwnProperty.call(t3, r3)) {
                    var i3 = t3[r3];
                    d.isObject(i3) ? n3[r3] = Object.assign({}, e3, i3) : n3[r3] = i3;
                  }
                return n3;
              } }, { key: "baseSanitizeConfig", get: function() {
                var t3 = {};
                return Array.from(this.inlineTools.values()).forEach(function(e3) {
                  return Object.assign(t3, e3.sanitizeConfig);
                }), Array.from(this.tunes.values()).forEach(function(e3) {
                  return Object.assign(t3, e3.sanitizeConfig);
                }), t3;
              } }]), o3;
            }(f.default);
            o2.default = b, b.displayName = "BlockTool", y([d.cacheable], b.prototype, "sanitizeConfig", null), y([d.cacheable], b.prototype, "baseSanitizeConfig", null), t.exports = e.default;
          }) ? o.apply(e, r) : o) || (t.exports = i);
        }, function(t, e, n) {
          var o, r, i;
          "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self && self, r = [e, n(2), n(3), n(14)], void 0 === (i = "function" == typeof (o = function(o2, r2, i2, a) {
            "use strict";
            var s = n(1);
            Object.defineProperty(o2, "__esModule", { value: true }), o2.default = void 0, r2 = s(r2), i2 = s(i2), a = s(a);
            var l = function() {
              function t2(e2) {
                var n2 = e2.api;
                (0, r2.default)(this, t2), this.CSS = { button: "ce-settings__button", wrapper: "ce-tune-move-down", animation: "wobble" }, this.api = n2;
              }
              return (0, i2.default)(t2, [{ key: "render", value: function() {
                var t3 = this, e2 = a.default.make("div", [this.CSS.button, this.CSS.wrapper], {});
                return e2.appendChild(a.default.svg("arrow-down", 14, 14)), this.api.listeners.on(e2, "click", function(n2) {
                  return t3.handleClick(n2, e2);
                }, false), this.api.tooltip.onHover(e2, this.api.i18n.t("Move down"), { hidingDelay: 300 }), e2;
              } }, { key: "handleClick", value: function(t3, e2) {
                var n2 = this, o3 = this.api.blocks.getCurrentBlockIndex(), r3 = this.api.blocks.getBlockByIndex(o3 + 1);
                if (!r3)
                  return e2.classList.add(this.CSS.animation), void window.setTimeout(function() {
                    e2.classList.remove(n2.CSS.animation);
                  }, 500);
                var i3 = r3.holder, a2 = i3.getBoundingClientRect(), s2 = Math.abs(window.innerHeight - i3.offsetHeight);
                a2.top < window.innerHeight && (s2 = window.scrollY + i3.offsetHeight), window.scrollTo(0, s2), this.api.blocks.move(o3 + 1), this.api.toolbar.toggleBlockSettings(true), this.api.tooltip.hide();
              } }]), t2;
            }();
            o2.default = l, l.displayName = "MoveDownTune", l.isTune = true, t.exports = e.default;
          }) ? o.apply(e, r) : o) || (t.exports = i);
        }, function(t, e, n) {
          var o, r, i;
          "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self && self, r = [e, n(2), n(3), n(14)], void 0 === (i = "function" == typeof (o = function(o2, r2, i2, a) {
            "use strict";
            var s = n(1);
            Object.defineProperty(o2, "__esModule", { value: true }), o2.default = void 0, r2 = s(r2), i2 = s(i2), a = s(a);
            var l = function() {
              function t2(e2) {
                var n2 = this, o3 = e2.api;
                (0, r2.default)(this, t2), this.CSS = { button: "ce-settings__button", buttonDelete: "ce-settings__button--delete", buttonConfirm: "ce-settings__button--confirm" }, this.nodes = { button: null }, this.api = o3, this.resetConfirmation = function() {
                  n2.setConfirmation(false);
                };
              }
              return (0, i2.default)(t2, [{ key: "render", value: function() {
                var t3 = this;
                return this.nodes.button = a.default.make("div", [this.CSS.button, this.CSS.buttonDelete], {}), this.nodes.button.appendChild(a.default.svg("cross", 12, 12)), this.api.listeners.on(this.nodes.button, "click", function(e2) {
                  return t3.handleClick(e2);
                }, false), this.api.tooltip.onHover(this.nodes.button, this.api.i18n.t("Delete"), { hidingDelay: 300 }), this.nodes.button;
              } }, { key: "handleClick", value: function(t3) {
                this.needConfirmation ? (this.api.events.off("block-settings-closed", this.resetConfirmation), this.api.blocks.delete(), this.api.toolbar.close(), this.api.tooltip.hide(), t3.stopPropagation()) : (this.setConfirmation(true), this.api.events.on("block-settings-closed", this.resetConfirmation));
              } }, { key: "setConfirmation", value: function(t3) {
                this.needConfirmation = t3, this.nodes.button.classList.add(this.CSS.buttonConfirm);
              } }]), t2;
            }();
            o2.default = l, l.displayName = "DeleteTune", l.isTune = true, t.exports = e.default;
          }) ? o.apply(e, r) : o) || (t.exports = i);
        }, function(t, e, n) {
          var o, r, i;
          "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self && self, r = [e, n(2), n(3), n(14)], void 0 === (i = "function" == typeof (o = function(o2, r2, i2, a) {
            "use strict";
            var s = n(1);
            Object.defineProperty(o2, "__esModule", { value: true }), o2.default = void 0, r2 = s(r2), i2 = s(i2), a = s(a);
            var l = function() {
              function t2(e2) {
                var n2 = e2.api;
                (0, r2.default)(this, t2), this.CSS = { button: "ce-settings__button", wrapper: "ce-tune-move-up", animation: "wobble" }, this.api = n2;
              }
              return (0, i2.default)(t2, [{ key: "render", value: function() {
                var t3 = this, e2 = a.default.make("div", [this.CSS.button, this.CSS.wrapper], {});
                return e2.appendChild(a.default.svg("arrow-up", 14, 14)), this.api.listeners.on(e2, "click", function(n2) {
                  return t3.handleClick(n2, e2);
                }, false), this.api.tooltip.onHover(e2, this.api.i18n.t("Move up"), { hidingDelay: 300 }), e2;
              } }, { key: "handleClick", value: function(t3, e2) {
                var n2 = this, o3 = this.api.blocks.getCurrentBlockIndex(), r3 = this.api.blocks.getBlockByIndex(o3), i3 = this.api.blocks.getBlockByIndex(o3 - 1);
                if (0 === o3 || !r3 || !i3)
                  return e2.classList.add(this.CSS.animation), void window.setTimeout(function() {
                    e2.classList.remove(n2.CSS.animation);
                  }, 500);
                var a2, s2 = r3.holder, l2 = i3.holder, c = s2.getBoundingClientRect(), u = l2.getBoundingClientRect();
                a2 = u.top > 0 ? Math.abs(c.top) - Math.abs(u.top) : window.innerHeight - Math.abs(c.top) + Math.abs(u.top), window.scrollBy(0, -1 * a2), this.api.blocks.move(o3 - 1), this.api.toolbar.toggleBlockSettings(true), this.api.tooltip.hide();
              } }]), t2;
            }();
            o2.default = l, l.displayName = "MoveUpTune", l.isTune = true, t.exports = e.default;
          }) ? o.apply(e, r) : o) || (t.exports = i);
        }, function(t, e, n) {
          "use strict";
          n.r(e), e.default = '<?xml version="1.0" encoding="utf-8"?>\n<svg xmlns="http://www.w3.org/2000/svg">\n<symbol id="arrow-down" viewBox="0 0 14 14">\n  <path transform="matrix(1 0 0 -1 0 14)" d="M8.024 4.1v8.6a1.125 1.125 0 0 1-2.25 0V4.1L2.18 7.695A1.125 1.125 0 1 1 .59 6.104L6.103.588c.44-.439 1.151-.439 1.59 0l5.516 5.516a1.125 1.125 0 0 1-1.59 1.59L8.023 4.1z"/>\n\n</symbol>\n<symbol id="arrow-up" viewBox="0 0 14 14">\n    <path d="M8.024 4.1v8.6a1.125 1.125 0 0 1-2.25 0V4.1L2.18 7.695A1.125 1.125 0 1 1 .59 6.104L6.103.588c.44-.439 1.151-.439 1.59 0l5.516 5.516a1.125 1.125 0 0 1-1.59 1.59L8.023 4.1z"/>\n\n</symbol>\n<symbol id="bold" viewBox="0 0 12 14"><path d="M5.997 14H1.72c-.618 0-1.058-.138-1.323-.415C.132 13.308 0 12.867 0 12.262V1.738C0 1.121.135.676.406.406.676.136 1.114 0 1.719 0h4.536c.669 0 1.248.041 1.738.124.49.083.93.242 1.318.478a3.458 3.458 0 0 1 1.461 1.752c.134.366.2.753.2 1.16 0 1.401-.7 2.426-2.1 3.075 1.84.586 2.76 1.726 2.76 3.42 0 .782-.2 1.487-.602 2.114a3.61 3.61 0 0 1-1.623 1.39 5.772 5.772 0 0 1-1.471.377c-.554.073-1.2.11-1.939.11zm-.21-6.217h-2.95v4.087h3.046c1.916 0 2.874-.69 2.874-2.072 0-.707-.248-1.22-.745-1.537-.496-.319-1.238-.478-2.225-.478zM2.837 2.13v3.619h2.597c.707 0 1.252-.067 1.638-.2.385-.134.68-.389.883-.765.16-.267.239-.566.239-.897 0-.707-.252-1.176-.755-1.409-.503-.232-1.27-.348-2.301-.348H2.836z"/>\n</symbol>\n<symbol id="cross" viewBox="0 0 237 237">\n  <path transform="rotate(45 280.675 51.325)" d="M191 191V73c0-5.523 4.477-10 10-10h25c5.523 0 10 4.477 10 10v118h118c5.523 0 10 4.477 10 10v25c0 5.523-4.477 10-10 10H236v118c0 5.523-4.477 10-10 10h-25c-5.523 0-10-4.477-10-10V236H73c-5.523 0-10-4.477-10-10v-25c0-5.523 4.477-10 10-10h118z"/>\n\n</symbol>\n<symbol id="dots" viewBox="0 0 16 16">\n  <g transform="translate(4 1.5)" fill-rule="evenodd">\n    <circle cx="1.3" cy="1.3" r="1.3"/>\n    <circle cx="6.5" cy="1.3" r="1.3"/>\n    <circle cx="6.5" cy="6.5" r="1.3"/>\n    <circle cx="1.3" cy="6.5" r="1.3"/>\n    <circle cx="6.5" cy="11.7" r="1.3"/>\n    <circle cx="1.3" cy="11.7" r="1.3"/>\n  </g>\n\n</symbol>\n<symbol id="italic" viewBox="0 0 4 11">\n    <path d="M3.289 4.17L2.164 9.713c-.078.384-.238.674-.48.87-.243.198-.52.296-.831.296-.312 0-.545-.1-.699-.302-.153-.202-.192-.49-.116-.864L1.15 4.225c.077-.38.232-.665.466-.857a1.25 1.25 0 01.818-.288c.312 0 .55.096.713.288.163.192.21.46.141.801zm-.667-2.09c-.295 0-.53-.09-.706-.273-.176-.181-.233-.439-.173-.77.055-.302.207-.55.457-.745C2.45.097 2.716 0 3 0c.273 0 .5.088.68.265.179.176.238.434.177.771-.06.327-.21.583-.45.767-.24.185-.502.277-.785.277z"/>\n\n</symbol>\n<symbol id="link" viewBox="0 0 14 10">\n  <path d="M6 0v2H5a3 3 0 000 6h1v2H5A5 5 0 115 0h1zm2 0h1a5 5 0 110 10H8V8h1a3 3 0 000-6H8V0zM5 4h4a1 1 0 110 2H5a1 1 0 110-2z"/>\n\n</symbol>\n<symbol id="plus" viewBox="0 0 16 16">\n  <g transform="translate(1 1.5)" fill-rule="evenodd">\n    <rect x="6" width="2" height="13" rx="1"/>\n    <rect x=".5" y="5.5" width="13" height="2" rx="1"/>\n  </g>\n\n</symbol>\n<symbol id="sad-face" viewBox="0 0 52 52">\n    <path fill="#D76B6B" fill-rule="nonzero" d="M26 52C11.64 52 0 40.36 0 26S11.64 0 26 0s26 11.64 26 26-11.64 26-26 26zm0-3.25c12.564 0 22.75-10.186 22.75-22.75S38.564 3.25 26 3.25 3.25 13.436 3.25 26 13.436 48.75 26 48.75zM15.708 33.042a2.167 2.167 0 1 1 0-4.334 2.167 2.167 0 0 1 0 4.334zm23.834 0a2.167 2.167 0 1 1 0-4.334 2.167 2.167 0 0 1 0 4.334zm-15.875 5.452a1.083 1.083 0 1 1-1.834-1.155c1.331-2.114 3.49-3.179 6.334-3.179 2.844 0 5.002 1.065 6.333 3.18a1.083 1.083 0 1 1-1.833 1.154c-.913-1.45-2.366-2.167-4.5-2.167s-3.587.717-4.5 2.167z"/>\n\n</symbol>\n<symbol id="search" viewBox="0 0 16 16">\n  <path d="M12.711 2.18a7.448 7.448 0 0 1 .79 9.603l2.143 2.144a1.214 1.214 0 1 1-1.717 1.717L11.783 13.5a7.446 7.446 0 1 1 .928-11.32ZM11.39 3.61a5.5 5.5 0 1 0-7.778 7.78 5.5 5.5 0 0 0 7.778-7.78Z" fill-rule="evenodd"/>\n\n</symbol>\n<symbol id="toggler-down">\n  <path d="M6.5 9.294a.792.792 0 01-.562-.232L2.233 5.356a.794.794 0 011.123-1.123L6.5 7.377l3.144-3.144a.794.794 0 011.123 1.123L7.062 9.062a.792.792 0 01-.562.232z"/>\n\n</symbol>\n<symbol id="unlink" viewBox="0 0 15 11">\n  <path d="M13.073 2.099l-1.448 1.448A3 3 0 009 2H8V0h1c1.68 0 3.166.828 4.073 2.099zM6.929 4l-.879.879L7.172 6H5a1 1 0 110-2h1.929zM6 0v2H5a3 3 0 100 6h1v2H5A5 5 0 115 0h1zm6.414 7l2.122 2.121-1.415 1.415L11 8.414l-2.121 2.122L7.464 9.12 9.586 7 7.464 4.879 8.88 3.464 11 5.586l2.121-2.122 1.415 1.415L12.414 7z"/>\n\n</symbol></svg>';
        }, function(t, e) {
          t.exports = '.codex-editor{position:relative;-webkit-box-sizing:border-box;box-sizing:border-box;z-index:1}.codex-editor .hide,.codex-editor__redactor--hidden{display:none}.codex-editor__redactor [contenteditable]:empty:after{content:"\\feff "}@media (min-width:651px){.codex-editor--narrow .codex-editor__redactor{margin-right:50px}}@media (min-width:651px){.codex-editor--narrow.codex-editor--rtl .codex-editor__redactor{margin-left:50px;margin-right:0}}@media (min-width:651px){.codex-editor--narrow .ce-toolbar__actions{right:-5px}}.codex-editor__loader{position:relative;height:30vh}.codex-editor__loader:before{content:"";position:absolute;left:50%;top:50%;width:30px;height:30px;margin-top:-15px;margin-left:-15px;border-radius:50%;border:2px solid rgba(201,201,204,.48);border-top-color:transparent;-webkit-box-sizing:border-box;box-sizing:border-box;-webkit-animation:editor-loader-spin .8s linear infinite;animation:editor-loader-spin .8s linear infinite;will-change:transform}.codex-editor-copyable{position:absolute;height:1px;width:1px;top:-400%;opacity:.001}.codex-editor-overlay{position:fixed;top:0;left:0;right:0;bottom:0;z-index:999;pointer-events:none;overflow:hidden}.codex-editor-overlay__container{position:relative;pointer-events:auto;z-index:0}.codex-editor-overlay__rectangle{position:absolute;pointer-events:none;background-color:rgba(46,170,220,.2);border:1px solid transparent}.codex-editor svg{fill:currentColor;vertical-align:middle;max-height:100%}::-moz-selection{background-color:#d4ecff}::selection{background-color:#d4ecff}.codex-editor--toolbox-opened [contentEditable=true][data-placeholder]:focus:before{opacity:0!important}@-webkit-keyframes editor-loader-spin{0%{-webkit-transform:rotate(0deg);transform:rotate(0deg)}to{-webkit-transform:rotate(1turn);transform:rotate(1turn)}}@keyframes editor-loader-spin{0%{-webkit-transform:rotate(0deg);transform:rotate(0deg)}to{-webkit-transform:rotate(1turn);transform:rotate(1turn)}}.ce-scroll-locked{overflow:hidden}.ce-scroll-locked--hard{overflow:hidden;top:calc(-1*var(--window-scroll-offset));position:fixed;width:100%}.ce-toolbar{position:absolute;left:0;right:0;top:0;-webkit-transition:opacity .1s ease;transition:opacity .1s ease;will-change:opacity,top;display:none}.ce-toolbar--opened{display:block}.ce-toolbar__content{max-width:650px;margin:0 auto;position:relative}.ce-toolbar__plus{color:#1d202b;cursor:pointer;width:26px;height:26px;border-radius:7px;display:-webkit-inline-box;display:-ms-inline-flexbox;display:inline-flex;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}@media (max-width:650px){.ce-toolbar__plus{width:36px;height:36px}}@media (hover:hover){.ce-toolbar__plus:hover{background-color:#eff2f5}}.ce-toolbar__plus{-ms-flex-negative:0;flex-shrink:0}.ce-toolbar__plus--active{background-color:#eff2f5;-webkit-animation:bounceIn .75s 1;animation:bounceIn .75s 1;-webkit-animation-fill-mode:forwards;animation-fill-mode:forwards}.ce-toolbar__plus-shortcut{opacity:.6;word-spacing:-2px;margin-top:5px}@media (max-width:650px){.ce-toolbar__plus{position:absolute;background-color:#fff;border:1px solid #e8e8eb;-webkit-box-shadow:0 3px 15px -3px rgba(13,20,33,.13);box-shadow:0 3px 15px -3px rgba(13,20,33,.13);border-radius:6px;z-index:2}}@media (max-width:650px) and (max-width:650px){.ce-toolbar__plus{-webkit-box-shadow:0 8px 6px -6px rgba(33,48,73,.19);box-shadow:0 8px 6px -6px rgba(33,48,73,.19);border-bottom-color:#c7c7c7}}@media (max-width:650px){.ce-toolbar__plus{position:static}.ce-toolbar__plus--left-oriented:before{left:15px;margin-left:0}.ce-toolbar__plus--right-oriented:before{left:auto;right:15px;margin-left:0}}.ce-toolbar__actions{position:absolute;right:100%;opacity:0;display:-webkit-box;display:-ms-flexbox;display:flex;padding-right:5px}.ce-toolbar__actions--opened{opacity:1}@media (max-width:650px){.ce-toolbar__actions{right:auto}}.ce-toolbar__settings-btn{color:#1d202b;width:26px;height:26px;border-radius:7px;display:-webkit-inline-box;display:-ms-inline-flexbox;display:inline-flex;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center}@media (max-width:650px){.ce-toolbar__settings-btn{width:36px;height:36px}}@media (hover:hover){.ce-toolbar__settings-btn:hover{background-color:#eff2f5}}.ce-toolbar__settings-btn{margin-left:5px;cursor:pointer;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.ce-toolbar__settings-btn--active{background-color:#eff2f5;-webkit-animation:bounceIn .75s 1;animation:bounceIn .75s 1;-webkit-animation-fill-mode:forwards;animation-fill-mode:forwards}@media (min-width:651px){.ce-toolbar__settings-btn{width:18px}}.ce-toolbar__settings-btn--hidden{display:none}@media (max-width:650px){.ce-toolbar__settings-btn{position:absolute;background-color:#fff;border:1px solid #e8e8eb;-webkit-box-shadow:0 3px 15px -3px rgba(13,20,33,.13);box-shadow:0 3px 15px -3px rgba(13,20,33,.13);border-radius:6px;z-index:2}}@media (max-width:650px) and (max-width:650px){.ce-toolbar__settings-btn{-webkit-box-shadow:0 8px 6px -6px rgba(33,48,73,.19);box-shadow:0 8px 6px -6px rgba(33,48,73,.19);border-bottom-color:#c7c7c7}}@media (max-width:650px){.ce-toolbar__settings-btn{position:static}.ce-toolbar__settings-btn--left-oriented:before{left:15px;margin-left:0}.ce-toolbar__settings-btn--right-oriented:before{left:auto;right:15px;margin-left:0}}@media (min-width:651px){.codex-editor--narrow .ce-toolbar__plus{left:5px}}.ce-toolbox{--gap:8px}@media (min-width:651px){.ce-toolbox{position:absolute;top:calc(26px + var(--gap));left:0}.ce-toolbox--opened-top{top:calc(-1*(var(--gap) + var(--popover-height)))}}@media (min-width:651px){.codex-editor--narrow .ce-toolbox{left:auto;right:0}.codex-editor--narrow .ce-toolbox .ce-popover{right:0}}.ce-inline-toolbar{position:absolute;background-color:#fff;border:1px solid #e8e8eb;-webkit-box-shadow:0 3px 15px -3px rgba(13,20,33,.13);box-shadow:0 3px 15px -3px rgba(13,20,33,.13);border-radius:6px;z-index:2}@media (max-width:650px){.ce-inline-toolbar{-webkit-box-shadow:0 8px 6px -6px rgba(33,48,73,.19);box-shadow:0 8px 6px -6px rgba(33,48,73,.19);border-bottom-color:#c7c7c7}}.ce-inline-toolbar{-webkit-transform:translateX(-50%) translateY(8px) scale(.9);transform:translateX(-50%) translateY(8px) scale(.9);opacity:0;visibility:hidden;-webkit-transition:opacity .25s ease,-webkit-transform .15s ease;transition:opacity .25s ease,-webkit-transform .15s ease;transition:transform .15s ease,opacity .25s ease;transition:transform .15s ease,opacity .25s ease,-webkit-transform .15s ease;will-change:transform,opacity;top:0;left:0;z-index:3}.ce-inline-toolbar--left-oriented:before{left:15px;margin-left:0}.ce-inline-toolbar--right-oriented:before{left:auto;right:15px;margin-left:0}.ce-inline-toolbar--showed{opacity:1;visibility:visible;-webkit-transform:translateX(-50%);transform:translateX(-50%)}.ce-inline-toolbar--left-oriented{-webkit-transform:translateX(-23px) translateY(8px) scale(.9);transform:translateX(-23px) translateY(8px) scale(.9)}.ce-inline-toolbar--left-oriented.ce-inline-toolbar--showed{-webkit-transform:translateX(-23px);transform:translateX(-23px)}.ce-inline-toolbar--right-oriented{-webkit-transform:translateX(-100%) translateY(8px) scale(.9);transform:translateX(-100%) translateY(8px) scale(.9);margin-left:23px}.ce-inline-toolbar--right-oriented.ce-inline-toolbar--showed{-webkit-transform:translateX(-100%);transform:translateX(-100%)}.ce-inline-toolbar [hidden]{display:none!important}.ce-inline-toolbar__toggler-and-button-wrapper{width:100%;padding:0 6px}.ce-inline-toolbar__buttons,.ce-inline-toolbar__toggler-and-button-wrapper{display:-webkit-box;display:-ms-flexbox;display:flex}.ce-inline-toolbar__dropdown{display:-webkit-inline-box;display:-ms-inline-flexbox;display:inline-flex;height:34px;padding:0 9px 0 10px;margin:0 6px 0 -6px;-webkit-box-align:center;-ms-flex-align:center;align-items:center;cursor:pointer;border-right:1px solid rgba(201,201,204,.48)}.ce-inline-toolbar__dropdown:hover{background:#eff2f5}.ce-inline-toolbar__dropdown--hidden{display:none}.ce-inline-toolbar__dropdown-content{display:-webkit-box;display:-ms-flexbox;display:flex;font-weight:500;font-size:14px}.ce-inline-toolbar__dropdown-content svg{height:12px}.ce-inline-toolbar__dropdown .icon--toggler-down{margin-left:4px}.ce-inline-toolbar__shortcut{opacity:.6;word-spacing:-3px;margin-top:3px}.ce-inline-tool{display:-webkit-inline-box;display:-ms-inline-flexbox;display:inline-flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;width:34px;height:34px;line-height:34px;padding:0!important;text-align:center;border-radius:3px;cursor:pointer;border:0;outline:none;background-color:transparent;vertical-align:bottom;color:#000;margin:0}.ce-inline-tool:hover{background-color:#eff2f5}.ce-inline-tool{border-radius:0;line-height:normal;width:auto;padding:0 5px!important;min-width:24px}.ce-inline-tool--active{color:#388ae5}.ce-inline-tool--focused{-webkit-box-shadow:inset 0 0 0 1px rgba(7,161,227,.08);box-shadow:inset 0 0 0 1px rgba(7,161,227,.08);background:rgba(34,186,255,.08)!important}.ce-inline-tool--focused-animated{-webkit-animation-name:buttonClicked;animation-name:buttonClicked;-webkit-animation-duration:.25s;animation-duration:.25s}.ce-inline-tool:not(:last-of-type){margin-right:2px}.ce-inline-tool .icon{height:12px}.ce-inline-tool--link .icon--unlink,.ce-inline-tool--unlink .icon--link{display:none}.ce-inline-tool--unlink .icon--unlink{display:inline-block;margin-bottom:-1px}.ce-inline-tool-input{outline:none;border:0;border-radius:0 0 4px 4px;margin:0;font-size:13px;padding:10px;width:100%;-webkit-box-sizing:border-box;box-sizing:border-box;display:none;font-weight:500;border-top:1px solid rgba(201,201,204,.48)}.ce-inline-tool-input::-webkit-input-placeholder{color:#707684}.ce-inline-tool-input::-moz-placeholder{color:#707684}.ce-inline-tool-input:-ms-input-placeholder{color:#707684}.ce-inline-tool-input::-ms-input-placeholder{color:#707684}.ce-inline-tool-input::placeholder{color:#707684}.ce-inline-tool-input--showed{display:block}.ce-conversion-toolbar{position:absolute;background-color:#fff;border:1px solid #e8e8eb;-webkit-box-shadow:0 3px 15px -3px rgba(13,20,33,.13);box-shadow:0 3px 15px -3px rgba(13,20,33,.13);border-radius:6px;z-index:2}@media (max-width:650px){.ce-conversion-toolbar{-webkit-box-shadow:0 8px 6px -6px rgba(33,48,73,.19);box-shadow:0 8px 6px -6px rgba(33,48,73,.19);border-bottom-color:#c7c7c7}}.ce-conversion-toolbar{opacity:0;visibility:hidden;will-change:transform,opacity;-webkit-transition:opacity .1s ease,-webkit-transform .1s ease;transition:opacity .1s ease,-webkit-transform .1s ease;transition:transform .1s ease,opacity .1s ease;transition:transform .1s ease,opacity .1s ease,-webkit-transform .1s ease;-webkit-transform:translateY(-8px);transform:translateY(-8px);left:-1px;width:150px;margin-top:5px;-webkit-box-sizing:content-box;box-sizing:content-box}.ce-conversion-toolbar--left-oriented:before{left:15px;margin-left:0}.ce-conversion-toolbar--right-oriented:before{left:auto;right:15px;margin-left:0}.ce-conversion-toolbar--showed{opacity:1;visibility:visible;-webkit-transform:none;transform:none}.ce-conversion-toolbar [hidden]{display:none!important}.ce-conversion-toolbar__buttons{display:-webkit-box;display:-ms-flexbox;display:flex}.ce-conversion-toolbar__label{color:#707684;font-size:11px;font-weight:500;letter-spacing:.33px;padding:10px 10px 5px;text-transform:uppercase}.ce-conversion-tool{display:-webkit-box;display:-ms-flexbox;display:flex;padding:5px 10px;font-size:14px;line-height:20px;font-weight:500;cursor:pointer;-webkit-box-align:center;-ms-flex-align:center;align-items:center}.ce-conversion-tool--hidden{display:none}.ce-conversion-tool--focused{-webkit-box-shadow:inset 0 0 0 1px rgba(7,161,227,.08);box-shadow:inset 0 0 0 1px rgba(7,161,227,.08);background:rgba(34,186,255,.08)!important}.ce-conversion-tool--focused-animated{-webkit-animation-name:buttonClicked;animation-name:buttonClicked;-webkit-animation-duration:.25s;animation-duration:.25s}.ce-conversion-tool:hover{background:#eff2f5}.ce-conversion-tool__icon{display:-webkit-inline-box;display:-ms-inline-flexbox;display:inline-flex;width:20px;height:20px;border:1px solid rgba(201,201,204,.48);border-radius:3px;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;margin-right:10px;background:#fff}.ce-conversion-tool__icon svg{width:11px;height:11px}.ce-conversion-tool--last{margin-right:0!important}.ce-conversion-tool--active{color:#388ae5!important;-webkit-animation:bounceIn .75s 1;animation:bounceIn .75s 1;-webkit-animation-fill-mode:forwards;animation-fill-mode:forwards}.ce-settings{position:absolute;background-color:#fff;border:1px solid #e8e8eb;-webkit-box-shadow:0 3px 15px -3px rgba(13,20,33,.13);box-shadow:0 3px 15px -3px rgba(13,20,33,.13);border-radius:6px;z-index:2}@media (max-width:650px){.ce-settings{-webkit-box-shadow:0 8px 6px -6px rgba(33,48,73,.19);box-shadow:0 8px 6px -6px rgba(33,48,73,.19);border-bottom-color:#c7c7c7}}.ce-settings{top:34px;left:0;min-width:114px;-webkit-box-sizing:content-box;box-sizing:content-box}.ce-settings--left-oriented:before{left:15px;margin-left:0}.ce-settings--right-oriented:before{left:auto;right:15px;margin-left:0}@media (max-width:650px){.ce-settings{bottom:40px;right:auto;top:auto}}.ce-settings:before{left:auto;right:12px}@media (max-width:650px){.ce-settings:before{bottom:-5px;top:auto}}.ce-settings{display:none}.ce-settings--opened{display:block;-webkit-animation-duration:.1s;animation-duration:.1s;-webkit-animation-name:panelShowing;animation-name:panelShowing}.ce-settings__plugin-zone:not(:empty){padding:3px 3px 0}.ce-settings__default-zone:not(:empty){padding:3px}.ce-settings__button{display:-webkit-inline-box;display:-ms-inline-flexbox;display:inline-flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;width:34px;height:34px;line-height:34px;padding:0!important;text-align:center;border-radius:3px;cursor:pointer;border:0;outline:none;background-color:transparent;vertical-align:bottom;color:#000;margin:0}.ce-settings__button:hover{background-color:#eff2f5}.ce-settings__button--active{color:#388ae5}.ce-settings__button--focused{-webkit-box-shadow:inset 0 0 0 1px rgba(7,161,227,.08);box-shadow:inset 0 0 0 1px rgba(7,161,227,.08);background:rgba(34,186,255,.08)!important}.ce-settings__button--focused-animated{-webkit-animation-name:buttonClicked;animation-name:buttonClicked;-webkit-animation-duration:.25s;animation-duration:.25s}.ce-settings__button:not(:nth-child(3n+3)){margin-right:3px}.ce-settings__button:nth-child(n+4){margin-top:3px}.ce-settings__button{line-height:32px}.ce-settings__button--disabled{cursor:not-allowed!important;opacity:.3}.ce-settings__button--selected{color:#388ae5}.ce-settings__button--delete{-webkit-transition:background-color .3s ease;transition:background-color .3s ease;will-change:background-color}.ce-settings__button--delete .icon{-webkit-transition:-webkit-transform .2s ease-out;transition:-webkit-transform .2s ease-out;transition:transform .2s ease-out;transition:transform .2s ease-out,-webkit-transform .2s ease-out;will-change:transform}.ce-settings__button--confirm{background-color:#e24a4a!important;color:#fff}.ce-settings__button--confirm:hover{background-color:#d54a4a!important}.ce-settings__button--confirm .icon{-webkit-transform:rotate(90deg);transform:rotate(90deg)}@-webkit-keyframes fade-in{0%{opacity:0}to{opacity:1}}@keyframes fade-in{0%{opacity:0}to{opacity:1}}.ce-block{-webkit-animation:fade-in .3s ease;animation:fade-in .3s ease;-webkit-animation-fill-mode:none;-webkit-animation-fill-mode:initial;animation-fill-mode:none}.ce-block:first-of-type{margin-top:0}.ce-block--selected .ce-block__content{background:#e1f2ff}.ce-block--selected .ce-block__content [contenteditable]{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.ce-block--selected .ce-block__content .ce-stub,.ce-block--selected .ce-block__content img{opacity:.55}.ce-block--stretched .ce-block__content{max-width:none}.ce-block__content{position:relative;max-width:650px;margin:0 auto;-webkit-transition:background-color .15s ease;transition:background-color .15s ease}.ce-block--drop-target .ce-block__content:before{content:"";position:absolute;top:100%;left:-20px;margin-top:-1px;height:8px;width:8px;border:solid #388ae5;border-width:1px 1px 0 0;-webkit-transform-origin:right;transform-origin:right;-webkit-transform:rotate(45deg);transform:rotate(45deg)}.ce-block--drop-target .ce-block__content:after{content:"";position:absolute;top:100%;height:1px;width:100%;color:#388ae5;background:repeating-linear-gradient(90deg,#388ae5,#388ae5 1px,#fff 0,#fff 6px)}.ce-block a{cursor:pointer;text-decoration:underline}.ce-block b{font-weight:700}.ce-block i{font-style:italic}@media (min-width:651px){.codex-editor--narrow .ce-block--focused{margin-right:-50px;padding-right:50px}}.wobble{-webkit-animation-name:wobble;animation-name:wobble;-webkit-animation-duration:.4s;animation-duration:.4s}@-webkit-keyframes wobble{0%{-webkit-transform:translateZ(0);transform:translateZ(0)}15%{-webkit-transform:translate3d(-5%,0,0) rotate(-5deg);transform:translate3d(-5%,0,0) rotate(-5deg)}30%{-webkit-transform:translate3d(2%,0,0) rotate(3deg);transform:translate3d(2%,0,0) rotate(3deg)}45%{-webkit-transform:translate3d(-3%,0,0) rotate(-3deg);transform:translate3d(-3%,0,0) rotate(-3deg)}60%{-webkit-transform:translate3d(2%,0,0) rotate(2deg);transform:translate3d(2%,0,0) rotate(2deg)}75%{-webkit-transform:translate3d(-1%,0,0) rotate(-1deg);transform:translate3d(-1%,0,0) rotate(-1deg)}to{-webkit-transform:translateZ(0);transform:translateZ(0)}}@keyframes wobble{0%{-webkit-transform:translateZ(0);transform:translateZ(0)}15%{-webkit-transform:translate3d(-5%,0,0) rotate(-5deg);transform:translate3d(-5%,0,0) rotate(-5deg)}30%{-webkit-transform:translate3d(2%,0,0) rotate(3deg);transform:translate3d(2%,0,0) rotate(3deg)}45%{-webkit-transform:translate3d(-3%,0,0) rotate(-3deg);transform:translate3d(-3%,0,0) rotate(-3deg)}60%{-webkit-transform:translate3d(2%,0,0) rotate(2deg);transform:translate3d(2%,0,0) rotate(2deg)}75%{-webkit-transform:translate3d(-1%,0,0) rotate(-1deg);transform:translate3d(-1%,0,0) rotate(-1deg)}to{-webkit-transform:translateZ(0);transform:translateZ(0)}}@-webkit-keyframes bounceIn{0%,20%,40%,60%,80%,to{-webkit-animation-timing-function:cubic-bezier(.215,.61,.355,1);animation-timing-function:cubic-bezier(.215,.61,.355,1)}0%{-webkit-transform:scale3d(.9,.9,.9);transform:scale3d(.9,.9,.9)}20%{-webkit-transform:scale3d(1.03,1.03,1.03);transform:scale3d(1.03,1.03,1.03)}60%{-webkit-transform:scaleX(1);transform:scaleX(1)}}@keyframes bounceIn{0%,20%,40%,60%,80%,to{-webkit-animation-timing-function:cubic-bezier(.215,.61,.355,1);animation-timing-function:cubic-bezier(.215,.61,.355,1)}0%{-webkit-transform:scale3d(.9,.9,.9);transform:scale3d(.9,.9,.9)}20%{-webkit-transform:scale3d(1.03,1.03,1.03);transform:scale3d(1.03,1.03,1.03)}60%{-webkit-transform:scaleX(1);transform:scaleX(1)}}@-webkit-keyframes selectionBounce{0%,20%,40%,60%,80%,to{-webkit-animation-timing-function:cubic-bezier(.215,.61,.355,1);animation-timing-function:cubic-bezier(.215,.61,.355,1)}50%{-webkit-transform:scale3d(1.01,1.01,1.01);transform:scale3d(1.01,1.01,1.01)}70%{-webkit-transform:scaleX(1);transform:scaleX(1)}}@keyframes selectionBounce{0%,20%,40%,60%,80%,to{-webkit-animation-timing-function:cubic-bezier(.215,.61,.355,1);animation-timing-function:cubic-bezier(.215,.61,.355,1)}50%{-webkit-transform:scale3d(1.01,1.01,1.01);transform:scale3d(1.01,1.01,1.01)}70%{-webkit-transform:scaleX(1);transform:scaleX(1)}}@-webkit-keyframes buttonClicked{0%,20%,40%,60%,80%,to{-webkit-animation-timing-function:cubic-bezier(.215,.61,.355,1);animation-timing-function:cubic-bezier(.215,.61,.355,1)}0%{-webkit-transform:scale3d(.95,.95,.95);transform:scale3d(.95,.95,.95)}60%{-webkit-transform:scale3d(1.02,1.02,1.02);transform:scale3d(1.02,1.02,1.02)}80%{-webkit-transform:scaleX(1);transform:scaleX(1)}}@keyframes buttonClicked{0%,20%,40%,60%,80%,to{-webkit-animation-timing-function:cubic-bezier(.215,.61,.355,1);animation-timing-function:cubic-bezier(.215,.61,.355,1)}0%{-webkit-transform:scale3d(.95,.95,.95);transform:scale3d(.95,.95,.95)}60%{-webkit-transform:scale3d(1.02,1.02,1.02);transform:scale3d(1.02,1.02,1.02)}80%{-webkit-transform:scaleX(1);transform:scaleX(1)}}@-webkit-keyframes panelShowing{0%{opacity:0;-webkit-transform:translateY(-8px) scale(.9);transform:translateY(-8px) scale(.9)}70%{opacity:1;-webkit-transform:translateY(2px);transform:translateY(2px)}to{-webkit-transform:translateY(0);transform:translateY(0)}}@keyframes panelShowing{0%{opacity:0;-webkit-transform:translateY(-8px) scale(.9);transform:translateY(-8px) scale(.9)}70%{opacity:1;-webkit-transform:translateY(2px);transform:translateY(2px)}to{-webkit-transform:translateY(0);transform:translateY(0)}}@-webkit-keyframes panelShowingMobile{0%{opacity:0;-webkit-transform:translateY(14px) scale(.98);transform:translateY(14px) scale(.98)}70%{opacity:1;-webkit-transform:translateY(-4px);transform:translateY(-4px)}to{-webkit-transform:translateY(0);transform:translateY(0)}}@keyframes panelShowingMobile{0%{opacity:0;-webkit-transform:translateY(14px) scale(.98);transform:translateY(14px) scale(.98)}70%{opacity:1;-webkit-transform:translateY(-4px);transform:translateY(-4px)}to{-webkit-transform:translateY(0);transform:translateY(0)}}.cdx-block{padding:.4em 0}.cdx-block::-webkit-input-placeholder{line-height:normal!important}.cdx-input{border:1px solid rgba(201,201,204,.48);-webkit-box-shadow:inset 0 1px 2px 0 rgba(35,44,72,.06);box-shadow:inset 0 1px 2px 0 rgba(35,44,72,.06);border-radius:3px;padding:10px 12px;outline:none;width:100%;-webkit-box-sizing:border-box;box-sizing:border-box}.cdx-input[data-placeholder]:before{position:static!important;display:inline-block;width:0;white-space:nowrap;pointer-events:none}.cdx-settings-button{display:-webkit-inline-box;display:-ms-inline-flexbox;display:inline-flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;width:34px;height:34px;line-height:34px;padding:0!important;text-align:center;border-radius:3px;cursor:pointer;border:0;outline:none;background-color:transparent;vertical-align:bottom;color:#000;margin:0}.cdx-settings-button:hover{background-color:#eff2f5}.cdx-settings-button--focused{-webkit-box-shadow:inset 0 0 0 1px rgba(7,161,227,.08);box-shadow:inset 0 0 0 1px rgba(7,161,227,.08);background:rgba(34,186,255,.08)!important}.cdx-settings-button--focused-animated{-webkit-animation-name:buttonClicked;animation-name:buttonClicked;-webkit-animation-duration:.25s;animation-duration:.25s}.cdx-settings-button:not(:nth-child(3n+3)){margin-right:3px}.cdx-settings-button:nth-child(n+4){margin-top:3px}.cdx-settings-button--active{color:#388ae5}.cdx-loader{position:relative;border:1px solid rgba(201,201,204,.48)}.cdx-loader:before{content:"";position:absolute;left:50%;top:50%;width:18px;height:18px;margin:-11px 0 0 -11px;border:2px solid rgba(201,201,204,.48);border-left-color:#388ae5;border-radius:50%;-webkit-animation:cdxRotation 1.2s linear infinite;animation:cdxRotation 1.2s linear infinite}@-webkit-keyframes cdxRotation{0%{-webkit-transform:rotate(0deg);transform:rotate(0deg)}to{-webkit-transform:rotate(1turn);transform:rotate(1turn)}}@keyframes cdxRotation{0%{-webkit-transform:rotate(0deg);transform:rotate(0deg)}to{-webkit-transform:rotate(1turn);transform:rotate(1turn)}}.cdx-button{padding:13px;border-radius:3px;border:1px solid rgba(201,201,204,.48);font-size:14.9px;background:#fff;-webkit-box-shadow:0 2px 2px 0 rgba(18,30,57,.04);box-shadow:0 2px 2px 0 rgba(18,30,57,.04);color:#707684;text-align:center;cursor:pointer}.cdx-button:hover{background:#fbfcfe;-webkit-box-shadow:0 1px 3px 0 rgba(18,30,57,.08);box-shadow:0 1px 3px 0 rgba(18,30,57,.08)}.cdx-button svg{height:20px;margin-right:.2em;margin-top:-2px}.ce-stub{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;width:100%;padding:3.5em 0;margin:17px 0;border-radius:3px;background:#fcf7f7;color:#b46262}.ce-stub__info{margin-left:20px}.ce-stub__title{margin-bottom:3px;font-weight:600;font-size:18px;text-transform:capitalize}.ce-stub__subtitle{font-size:16px}.codex-editor.codex-editor--rtl{direction:rtl}.codex-editor.codex-editor--rtl .cdx-list{padding-left:0;padding-right:40px}.codex-editor.codex-editor--rtl .ce-toolbar__plus{right:-26px;left:auto}.codex-editor.codex-editor--rtl .ce-toolbar__actions{right:auto;left:-26px}@media (max-width:650px){.codex-editor.codex-editor--rtl .ce-toolbar__actions{margin-left:0;margin-right:auto;padding-right:0;padding-left:10px}}.codex-editor.codex-editor--rtl .ce-settings{left:5px;right:auto}.codex-editor.codex-editor--rtl .ce-settings:before{right:auto;left:25px}.codex-editor.codex-editor--rtl .ce-settings__button:not(:nth-child(3n+3)){margin-left:3px;margin-right:0}.codex-editor.codex-editor--rtl .ce-conversion-tool__icon{margin-right:0;margin-left:10px}.codex-editor.codex-editor--rtl .ce-inline-toolbar__dropdown{border-right:0 solid transparent;border-left:1px solid rgba(201,201,204,.48);margin:0 -6px 0 6px}.codex-editor.codex-editor--rtl .ce-inline-toolbar__dropdown .icon--toggler-down{margin-left:0;margin-right:4px}@media (min-width:651px){.codex-editor--narrow.codex-editor--rtl .ce-toolbar__plus{left:0;right:5px}}@media (min-width:651px){.codex-editor--narrow.codex-editor--rtl .ce-toolbar__actions{left:-5px}}.ce-popover{opacity:0;will-change:opacity,transform;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;padding:6px;min-width:200px;overflow:hidden;-webkit-box-sizing:border-box;box-sizing:border-box;-ms-flex-negative:0;flex-shrink:0;max-height:0;pointer-events:none;position:absolute;background-color:#fff;border:1px solid #e8e8eb;-webkit-box-shadow:0 3px 15px -3px rgba(13,20,33,.13);box-shadow:0 3px 15px -3px rgba(13,20,33,.13);border-radius:6px;z-index:2}@media (max-width:650px){.ce-popover{-webkit-box-shadow:0 8px 6px -6px rgba(33,48,73,.19);box-shadow:0 8px 6px -6px rgba(33,48,73,.19);border-bottom-color:#c7c7c7}}.ce-popover{z-index:4;-ms-flex-wrap:nowrap;flex-wrap:nowrap}.ce-popover--left-oriented:before{left:15px;margin-left:0}.ce-popover--right-oriented:before{left:auto;right:15px;margin-left:0}.ce-popover--opened{opacity:1;max-height:270px;pointer-events:auto;-webkit-animation:panelShowing .1s ease;animation:panelShowing .1s ease}@media (max-width:650px){.ce-popover--opened{-webkit-animation:panelShowingMobile .25s ease;animation:panelShowingMobile .25s ease}}.ce-popover::-webkit-scrollbar{width:7px}.ce-popover::-webkit-scrollbar-thumb{-webkit-box-sizing:border-box;box-sizing:border-box;-webkit-box-shadow:inset 0 0 2px 2px #eff2f5;box-shadow:inset 0 0 2px 2px #eff2f5;border-color:transparent;border-style:solid;border-width:4px 3px 4px 0}@media (max-width:650px){.ce-popover{position:fixed;max-width:none;min-width:auto;left:5px;right:5px;bottom:calc(5px + env(safe-area-inset-bottom));top:auto;border-radius:10px}}.ce-popover__items{overflow-y:auto;-ms-scroll-chaining:none;overscroll-behavior:contain}@media (min-width:651px){.ce-popover__items{margin-top:5px}}.ce-popover__item{display:grid;grid-template-columns:auto auto 1fr;grid-template-rows:auto;-webkit-box-pack:start;-ms-flex-pack:start;justify-content:start;white-space:nowrap;padding:3px;font-size:14px;line-height:20px;font-weight:500;cursor:pointer;-webkit-box-align:center;-ms-flex-align:center;align-items:center;border-radius:6px}.ce-popover__item:not(:last-of-type){margin-bottom:1px}@media (hover:hover){.ce-popover__item:hover{background-color:#eff2f5}}@media (max-width:650px){.ce-popover__item{font-size:16px;padding:4px}}.ce-popover__item--focused{-webkit-box-shadow:inset 0 0 0 1px rgba(7,161,227,.08);box-shadow:inset 0 0 0 1px rgba(7,161,227,.08);background:rgba(34,186,255,.08)!important}.ce-popover__item--hidden{display:none}.ce-popover__item-icon{display:-webkit-inline-box;display:-ms-inline-flexbox;display:inline-flex;width:26px;height:26px;border:1px solid rgba(201,201,204,.48);border-radius:5px;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;background:#fff;-webkit-box-sizing:border-box;box-sizing:border-box;-ms-flex-negative:0;flex-shrink:0;margin-right:10px}@media (max-width:650px){.ce-popover__item-icon{width:36px;height:36px;border-radius:8px}}.ce-popover__item-icon svg{width:12px;height:12px}.ce-popover__item-label:after{content:"";width:25px;display:inline-block}.ce-popover__item-secondary-label{color:#707684;font-size:12px;margin-left:auto;white-space:nowrap;letter-spacing:-.1em;padding-right:5px;margin-bottom:-2px;opacity:.6}@media (max-width:650px){.ce-popover__item-secondary-label{display:none}}.ce-popover__no-found{display:grid;grid-template-columns:auto auto 1fr;grid-template-rows:auto;-webkit-box-pack:start;-ms-flex-pack:start;justify-content:start;white-space:nowrap;padding:3px;font-size:14px;line-height:20px;font-weight:500;cursor:pointer;-webkit-box-align:center;-ms-flex-align:center;align-items:center;border-radius:6px}.ce-popover__no-found:not(:last-of-type){margin-bottom:1px}@media (hover:hover){.ce-popover__no-found:hover{background-color:#eff2f5}}@media (max-width:650px){.ce-popover__no-found{font-size:16px;padding:4px}}.ce-popover__no-found{color:#707684;display:none;cursor:default}.ce-popover__no-found--shown{display:block}.ce-popover__no-found:hover{background-color:transparent}@media (max-width:650px){.ce-popover__overlay{position:fixed;top:0;bottom:0;left:0;right:0;background:#1d202b;opacity:.5;z-index:3;-webkit-transition:opacity .12s ease-in;transition:opacity .12s ease-in;will-change:opacity;visibility:visible}.ce-popover .cdx-search-field{display:none}}.ce-popover__overlay--hidden{z-index:0;opacity:0;visibility:hidden}.cdx-search-field{--icon-margin-right:10px;background:rgba(232,232,235,.49);border:1px solid rgba(226,226,229,.2);border-radius:6px;padding:2px;display:grid;grid-template-columns:auto auto 1fr;grid-template-rows:auto}.cdx-search-field__icon{width:26px;height:26px;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;margin-right:var(--icon-margin-right)}.cdx-search-field__icon .icon{width:14px;height:14px;color:#707684;-ms-flex-negative:0;flex-shrink:0}.cdx-search-field__input{font-size:14px;outline:none;font-weight:500;font-family:inherit;border:0;background:transparent;margin:0;padding:0;line-height:22px;min-width:calc(100% - 26px - var(--icon-margin-right))}.cdx-search-field__input::-webkit-input-placeholder{color:#707684;font-weight:500}.cdx-search-field__input::-moz-placeholder{color:#707684;font-weight:500}.cdx-search-field__input:-ms-input-placeholder{color:#707684;font-weight:500}.cdx-search-field__input::-ms-input-placeholder{color:#707684;font-weight:500}.cdx-search-field__input::placeholder{color:#707684;font-weight:500}';
        }, function(t, e, n) {
          "use strict";
          n.r(e), n.d(e, "nanoid", function() {
            return s;
          }), n.d(e, "customAlphabet", function() {
            return a;
          }), n.d(e, "customRandom", function() {
            return i;
          }), n.d(e, "urlAlphabet", function() {
            return o;
          }), n.d(e, "random", function() {
            return r;
          });
          let o = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
          let r = (t2) => crypto.getRandomValues(new Uint8Array(t2)), i = (t2, e2, n2) => {
            let o2 = (2 << Math.log(t2.length - 1) / Math.LN2) - 1, r2 = -~(1.6 * o2 * e2 / t2.length);
            return () => {
              let i2 = "";
              for (; ; ) {
                let a2 = n2(r2), s2 = r2;
                for (; s2--; )
                  if (i2 += t2[a2[s2] & o2] || "", i2.length === e2)
                    return i2;
              }
            };
          }, a = (t2, e2) => i(t2, e2, r), s = (t2 = 21) => {
            let e2 = "", n2 = crypto.getRandomValues(new Uint8Array(t2));
            for (; t2--; ) {
              let o2 = 63 & n2[t2];
              e2 += o2 < 36 ? o2.toString(36) : o2 < 62 ? (o2 - 26).toString(36).toUpperCase() : o2 < 63 ? "_" : "-";
            }
            return e2;
          };
        }]);
      });
    }
  });

  // app/javascript/ace/ace.js
  var require_ace = __commonJS({
    "app/javascript/ace/ace.js"(exports, module) {
      (function() {
        function o(n2) {
          var i2 = e;
          n2 && (e[n2] || (e[n2] = {}), i2 = e[n2]);
          if (!i2.define || !i2.define.packaged)
            t.original = i2.define, i2.define = t, i2.define.packaged = true;
          if (!i2.require || !i2.require.packaged)
            r.original = i2.require, i2.require = r, i2.require.packaged = true;
        }
        var ACE_NAMESPACE = "ace", e = /* @__PURE__ */ function() {
          return this;
        }();
        !e && typeof window != "undefined" && (e = window);
        if (!ACE_NAMESPACE && typeof requirejs != "undefined")
          return;
        var t = function(e2, n2, r2) {
          if (typeof e2 != "string") {
            t.original ? t.original.apply(this, arguments) : (console.error("dropping module because define wasn't a string."), console.trace());
            return;
          }
          arguments.length == 2 && (r2 = n2), t.modules[e2] || (t.payloads[e2] = r2, t.modules[e2] = null);
        };
        t.modules = {}, t.payloads = {};
        var n = function(e2, t2, n2) {
          if (typeof t2 == "string") {
            var i2 = s(e2, t2);
            if (i2 != void 0)
              return n2 && n2(), i2;
          } else if (Object.prototype.toString.call(t2) === "[object Array]") {
            var o2 = [];
            for (var u = 0, a = t2.length; u < a; ++u) {
              var f = s(e2, t2[u]);
              if (f == void 0 && r.original)
                return;
              o2.push(f);
            }
            return n2 && n2.apply(null, o2) || true;
          }
        }, r = function(e2, t2) {
          var i2 = n("", e2, t2);
          return i2 == void 0 && r.original ? r.original.apply(this, arguments) : i2;
        }, i = function(e2, t2) {
          if (t2.indexOf("!") !== -1) {
            var n2 = t2.split("!");
            return i(e2, n2[0]) + "!" + i(e2, n2[1]);
          }
          if (t2.charAt(0) == ".") {
            var r2 = e2.split("/").slice(0, -1).join("/");
            t2 = r2 + "/" + t2;
            while (t2.indexOf(".") !== -1 && s2 != t2) {
              var s2 = t2;
              t2 = t2.replace(/\/\.\//, "/").replace(/[^\/]+\/\.\.\//, "");
            }
          }
          return t2;
        }, s = function(e2, r2) {
          r2 = i(e2, r2);
          var s2 = t.modules[r2];
          if (!s2) {
            s2 = t.payloads[r2];
            if (typeof s2 == "function") {
              var o2 = {}, u = { id: r2, uri: "", exports: o2, packaged: true }, a = function(e3, t2) {
                return n(r2, e3, t2);
              }, f = s2(a, o2, u);
              o2 = f || u.exports, t.modules[r2] = o2, delete t.payloads[r2];
            }
            s2 = t.modules[r2] = o2 || s2;
          }
          return s2;
        };
        o(ACE_NAMESPACE);
      })(), ace.define("ace/lib/es6-shim", ["require", "exports", "module"], function(e, t, n) {
        function r(e2, t2, n2) {
          Object.defineProperty(e2, t2, { value: n2, enumerable: false, writable: true, configurable: true });
        }
        String.prototype.startsWith || r(String.prototype, "startsWith", function(e2, t2) {
          return t2 = t2 || 0, this.lastIndexOf(e2, t2) === t2;
        }), String.prototype.endsWith || r(String.prototype, "endsWith", function(e2, t2) {
          var n2 = this;
          if (t2 === void 0 || t2 > n2.length)
            t2 = n2.length;
          t2 -= e2.length;
          var r2 = n2.indexOf(e2, t2);
          return r2 !== -1 && r2 === t2;
        }), String.prototype.repeat || r(String.prototype, "repeat", function(e2) {
          var t2 = "", n2 = this;
          while (e2 > 0) {
            e2 & 1 && (t2 += n2);
            if (e2 >>= 1)
              n2 += n2;
          }
          return t2;
        }), String.prototype.includes || r(String.prototype, "includes", function(e2, t2) {
          return this.indexOf(e2, t2) != -1;
        }), Object.assign || (Object.assign = function(e2) {
          if (e2 === void 0 || e2 === null)
            throw new TypeError("Cannot convert undefined or null to object");
          var t2 = Object(e2);
          for (var n2 = 1; n2 < arguments.length; n2++) {
            var r2 = arguments[n2];
            r2 !== void 0 && r2 !== null && Object.keys(r2).forEach(function(e3) {
              t2[e3] = r2[e3];
            });
          }
          return t2;
        }), Object.values || (Object.values = function(e2) {
          return Object.keys(e2).map(function(t2) {
            return e2[t2];
          });
        }), Array.prototype.find || r(Array.prototype, "find", function(e2) {
          var t2 = this.length, n2 = arguments[1];
          for (var r2 = 0; r2 < t2; r2++) {
            var i = this[r2];
            if (e2.call(n2, i, r2, this))
              return i;
          }
        }), Array.prototype.findIndex || r(Array.prototype, "findIndex", function(e2) {
          var t2 = this.length, n2 = arguments[1];
          for (var r2 = 0; r2 < t2; r2++) {
            var i = this[r2];
            if (e2.call(n2, i, r2, this))
              return r2;
          }
        }), Array.prototype.includes || r(Array.prototype, "includes", function(e2, t2) {
          return this.indexOf(e2, t2) != -1;
        }), Array.prototype.fill || r(Array.prototype, "fill", function(e2) {
          var t2 = this, n2 = t2.length >>> 0, r2 = arguments[1], i = r2 >> 0, s = i < 0 ? Math.max(n2 + i, 0) : Math.min(i, n2), o = arguments[2], u = o === void 0 ? n2 : o >> 0, a = u < 0 ? Math.max(n2 + u, 0) : Math.min(u, n2);
          while (s < a)
            t2[s] = e2, s++;
          return t2;
        }), Array.of || r(Array, "of", function() {
          return Array.prototype.slice.call(arguments);
        });
      }), ace.define("ace/lib/fixoldbrowsers", ["require", "exports", "module", "ace/lib/es6-shim"], function(e, t, n) {
        "use strict";
        e("./es6-shim");
      }), ace.define("ace/lib/useragent", ["require", "exports", "module"], function(e, t, n) {
        "use strict";
        t.OS = { LINUX: "LINUX", MAC: "MAC", WINDOWS: "WINDOWS" }, t.getOS = function() {
          return t.isMac ? t.OS.MAC : t.isLinux ? t.OS.LINUX : t.OS.WINDOWS;
        };
        var r = typeof navigator == "object" ? navigator : {}, i = (/mac|win|linux/i.exec(r.platform) || ["other"])[0].toLowerCase(), s = r.userAgent || "", o = r.appName || "";
        t.isWin = i == "win", t.isMac = i == "mac", t.isLinux = i == "linux", t.isIE = o == "Microsoft Internet Explorer" || o.indexOf("MSAppHost") >= 0 ? parseFloat((s.match(/(?:MSIE |Trident\/[0-9]+[\.0-9]+;.*rv:)([0-9]+[\.0-9]+)/) || [])[1]) : parseFloat((s.match(/(?:Trident\/[0-9]+[\.0-9]+;.*rv:)([0-9]+[\.0-9]+)/) || [])[1]), t.isOldIE = t.isIE && t.isIE < 9, t.isGecko = t.isMozilla = s.match(/ Gecko\/\d+/), t.isOpera = typeof opera == "object" && Object.prototype.toString.call(window.opera) == "[object Opera]", t.isWebKit = parseFloat(s.split("WebKit/")[1]) || void 0, t.isChrome = parseFloat(s.split(" Chrome/")[1]) || void 0, t.isEdge = parseFloat(s.split(" Edge/")[1]) || void 0, t.isAIR = s.indexOf("AdobeAIR") >= 0, t.isAndroid = s.indexOf("Android") >= 0, t.isChromeOS = s.indexOf(" CrOS ") >= 0, t.isIOS = /iPad|iPhone|iPod/.test(s) && !window.MSStream, t.isIOS && (t.isMac = true), t.isMobile = t.isIOS || t.isAndroid;
      }), ace.define("ace/lib/dom", ["require", "exports", "module", "ace/lib/useragent"], function(e, t, n) {
        "use strict";
        function u() {
          var e2 = o;
          o = null, e2 && e2.forEach(function(e3) {
            a(e3[0], e3[1]);
          });
        }
        function a(e2, n2, r2) {
          if (typeof document == "undefined")
            return;
          if (o) {
            if (r2)
              u();
            else if (r2 === false)
              return o.push([e2, n2]);
          }
          if (s)
            return;
          var i2 = r2;
          if (!r2 || !r2.getRootNode)
            i2 = document;
          else {
            i2 = r2.getRootNode();
            if (!i2 || i2 == r2)
              i2 = document;
          }
          var a2 = i2.ownerDocument || i2;
          if (n2 && t.hasCssString(n2, i2))
            return null;
          n2 && (e2 += "\n/*# sourceURL=ace/css/" + n2 + " */");
          var f2 = t.createElement("style");
          f2.appendChild(a2.createTextNode(e2)), n2 && (f2.id = n2), i2 == a2 && (i2 = t.getDocumentHead(a2)), i2.insertBefore(f2, i2.firstChild);
        }
        var r = e("./useragent"), i = "http://www.w3.org/1999/xhtml";
        t.buildDom = function l(e2, t2, n2) {
          if (typeof e2 == "string" && e2) {
            var r2 = document.createTextNode(e2);
            return t2 && t2.appendChild(r2), r2;
          }
          if (!Array.isArray(e2))
            return e2 && e2.appendChild && t2 && t2.appendChild(e2), e2;
          if (typeof e2[0] != "string" || !e2[0]) {
            var i2 = [];
            for (var s2 = 0; s2 < e2.length; s2++) {
              var o2 = l(e2[s2], t2, n2);
              o2 && i2.push(o2);
            }
            return i2;
          }
          var u2 = document.createElement(e2[0]), a2 = e2[1], f2 = 1;
          a2 && typeof a2 == "object" && !Array.isArray(a2) && (f2 = 2);
          for (var s2 = f2; s2 < e2.length; s2++)
            l(e2[s2], u2, n2);
          return f2 == 2 && Object.keys(a2).forEach(function(e3) {
            var t3 = a2[e3];
            e3 === "class" ? u2.className = Array.isArray(t3) ? t3.join(" ") : t3 : typeof t3 == "function" || e3 == "value" || e3[0] == "$" ? u2[e3] = t3 : e3 === "ref" ? n2 && (n2[t3] = u2) : e3 === "style" ? typeof t3 == "string" && (u2.style.cssText = t3) : t3 != null && u2.setAttribute(e3, t3);
          }), t2 && t2.appendChild(u2), u2;
        }, t.getDocumentHead = function(e2) {
          return e2 || (e2 = document), e2.head || e2.getElementsByTagName("head")[0] || e2.documentElement;
        }, t.createElement = function(e2, t2) {
          return document.createElementNS ? document.createElementNS(t2 || i, e2) : document.createElement(e2);
        }, t.removeChildren = function(e2) {
          e2.innerHTML = "";
        }, t.createTextNode = function(e2, t2) {
          var n2 = t2 ? t2.ownerDocument : document;
          return n2.createTextNode(e2);
        }, t.createFragment = function(e2) {
          var t2 = e2 ? e2.ownerDocument : document;
          return t2.createDocumentFragment();
        }, t.hasCssClass = function(e2, t2) {
          var n2 = (e2.className + "").split(/\s+/g);
          return n2.indexOf(t2) !== -1;
        }, t.addCssClass = function(e2, n2) {
          t.hasCssClass(e2, n2) || (e2.className += " " + n2);
        }, t.removeCssClass = function(e2, t2) {
          var n2 = e2.className.split(/\s+/g);
          for (; ; ) {
            var r2 = n2.indexOf(t2);
            if (r2 == -1)
              break;
            n2.splice(r2, 1);
          }
          e2.className = n2.join(" ");
        }, t.toggleCssClass = function(e2, t2) {
          var n2 = e2.className.split(/\s+/g), r2 = true;
          for (; ; ) {
            var i2 = n2.indexOf(t2);
            if (i2 == -1)
              break;
            r2 = false, n2.splice(i2, 1);
          }
          return r2 && n2.push(t2), e2.className = n2.join(" "), r2;
        }, t.setCssClass = function(e2, n2, r2) {
          r2 ? t.addCssClass(e2, n2) : t.removeCssClass(e2, n2);
        }, t.hasCssString = function(e2, t2) {
          var n2 = 0, r2;
          t2 = t2 || document;
          if (r2 = t2.querySelectorAll("style")) {
            while (n2 < r2.length)
              if (r2[n2++].id === e2)
                return true;
          }
        }, t.removeElementById = function(e2, t2) {
          t2 = t2 || document, t2.getElementById(e2) && t2.getElementById(e2).remove();
        };
        var s, o = [];
        t.useStrictCSP = function(e2) {
          s = e2, e2 == 0 ? u() : o || (o = []);
        }, t.importCssString = a, t.importCssStylsheet = function(e2, n2) {
          t.buildDom(["link", { rel: "stylesheet", href: e2 }], t.getDocumentHead(n2));
        }, t.scrollbarWidth = function(e2) {
          var n2 = t.createElement("ace_inner");
          n2.style.width = "100%", n2.style.minWidth = "0px", n2.style.height = "200px", n2.style.display = "block";
          var r2 = t.createElement("ace_outer"), i2 = r2.style;
          i2.position = "absolute", i2.left = "-10000px", i2.overflow = "hidden", i2.width = "200px", i2.minWidth = "0px", i2.height = "150px", i2.display = "block", r2.appendChild(n2);
          var s2 = e2.documentElement;
          s2.appendChild(r2);
          var o2 = n2.offsetWidth;
          i2.overflow = "scroll";
          var u2 = n2.offsetWidth;
          return o2 == u2 && (u2 = r2.clientWidth), s2.removeChild(r2), o2 - u2;
        }, t.computedStyle = function(e2, t2) {
          return window.getComputedStyle(e2, "") || {};
        }, t.setStyle = function(e2, t2, n2) {
          e2[t2] !== n2 && (e2[t2] = n2);
        }, t.HAS_CSS_ANIMATION = false, t.HAS_CSS_TRANSFORMS = false, t.HI_DPI = r.isWin ? typeof window != "undefined" && window.devicePixelRatio >= 1.5 : true, r.isChromeOS && (t.HI_DPI = false);
        if (typeof document != "undefined") {
          var f = document.createElement("div");
          t.HI_DPI && f.style.transform !== void 0 && (t.HAS_CSS_TRANSFORMS = true), !r.isEdge && typeof f.style.animationName != "undefined" && (t.HAS_CSS_ANIMATION = true), f = null;
        }
        t.HAS_CSS_TRANSFORMS ? t.translate = function(e2, t2, n2) {
          e2.style.transform = "translate(" + Math.round(t2) + "px, " + Math.round(n2) + "px)";
        } : t.translate = function(e2, t2, n2) {
          e2.style.top = Math.round(n2) + "px", e2.style.left = Math.round(t2) + "px";
        };
      }), ace.define("ace/lib/oop", ["require", "exports", "module"], function(e, t, n) {
        "use strict";
        t.inherits = function(e2, t2) {
          e2.super_ = t2, e2.prototype = Object.create(t2.prototype, { constructor: { value: e2, enumerable: false, writable: true, configurable: true } });
        }, t.mixin = function(e2, t2) {
          for (var n2 in t2)
            e2[n2] = t2[n2];
          return e2;
        }, t.implement = function(e2, n2) {
          t.mixin(e2, n2);
        };
      }), ace.define("ace/lib/keys", ["require", "exports", "module", "ace/lib/oop"], function(e, t, n) {
        "use strict";
        var r = e("./oop"), i = function() {
          var e2 = { MODIFIER_KEYS: { 16: "Shift", 17: "Ctrl", 18: "Alt", 224: "Meta", 91: "MetaLeft", 92: "MetaRight", 93: "ContextMenu" }, KEY_MODS: { ctrl: 1, alt: 2, option: 2, shift: 4, "super": 8, meta: 8, command: 8, cmd: 8, control: 1 }, FUNCTION_KEYS: { 8: "Backspace", 9: "Tab", 13: "Return", 19: "Pause", 27: "Esc", 32: "Space", 33: "PageUp", 34: "PageDown", 35: "End", 36: "Home", 37: "Left", 38: "Up", 39: "Right", 40: "Down", 44: "Print", 45: "Insert", 46: "Delete", 96: "Numpad0", 97: "Numpad1", 98: "Numpad2", 99: "Numpad3", 100: "Numpad4", 101: "Numpad5", 102: "Numpad6", 103: "Numpad7", 104: "Numpad8", 105: "Numpad9", "-13": "NumpadEnter", 112: "F1", 113: "F2", 114: "F3", 115: "F4", 116: "F5", 117: "F6", 118: "F7", 119: "F8", 120: "F9", 121: "F10", 122: "F11", 123: "F12", 144: "Numlock", 145: "Scrolllock" }, PRINTABLE_KEYS: { 32: " ", 48: "0", 49: "1", 50: "2", 51: "3", 52: "4", 53: "5", 54: "6", 55: "7", 56: "8", 57: "9", 59: ";", 61: "=", 65: "a", 66: "b", 67: "c", 68: "d", 69: "e", 70: "f", 71: "g", 72: "h", 73: "i", 74: "j", 75: "k", 76: "l", 77: "m", 78: "n", 79: "o", 80: "p", 81: "q", 82: "r", 83: "s", 84: "t", 85: "u", 86: "v", 87: "w", 88: "x", 89: "y", 90: "z", 107: "+", 109: "-", 110: ".", 186: ";", 187: "=", 188: ",", 189: "-", 190: ".", 191: "/", 192: "`", 219: "[", 220: "\\", 221: "]", 222: "'", 111: "/", 106: "*" } }, t2, n2;
          for (n2 in e2.FUNCTION_KEYS)
            t2 = e2.FUNCTION_KEYS[n2].toLowerCase(), e2[t2] = parseInt(n2, 10);
          for (n2 in e2.PRINTABLE_KEYS)
            t2 = e2.PRINTABLE_KEYS[n2].toLowerCase(), e2[t2] = parseInt(n2, 10);
          return r.mixin(e2, e2.MODIFIER_KEYS), r.mixin(e2, e2.PRINTABLE_KEYS), r.mixin(e2, e2.FUNCTION_KEYS), e2.enter = e2["return"], e2.escape = e2.esc, e2.del = e2["delete"], e2[173] = "-", function() {
            var t3 = ["cmd", "ctrl", "alt", "shift"];
            for (var n3 = Math.pow(2, t3.length); n3--; )
              e2.KEY_MODS[n3] = t3.filter(function(t4) {
                return n3 & e2.KEY_MODS[t4];
              }).join("-") + "-";
          }(), e2.KEY_MODS[0] = "", e2.KEY_MODS[-1] = "input-", e2;
        }();
        r.mixin(t, i), t.keyCodeToString = function(e2) {
          var t2 = i[e2];
          return typeof t2 != "string" && (t2 = String.fromCharCode(e2)), t2.toLowerCase();
        };
      }), ace.define("ace/lib/event", ["require", "exports", "module", "ace/lib/keys", "ace/lib/useragent"], function(e, t, n) {
        "use strict";
        function a() {
          u = false;
          try {
            document.createComment("").addEventListener("test", function() {
            }, { get passive() {
              u = { passive: false };
            } });
          } catch (e2) {
          }
        }
        function f() {
          return u == void 0 && a(), u;
        }
        function l(e2, t2, n2) {
          this.elem = e2, this.type = t2, this.callback = n2;
        }
        function d(e2, t2, n2) {
          var u2 = p(t2);
          if (!i.isMac && s) {
            t2.getModifierState && (t2.getModifierState("OS") || t2.getModifierState("Win")) && (u2 |= 8);
            if (s.altGr) {
              if ((3 & u2) == 3)
                return;
              s.altGr = 0;
            }
            if (n2 === 18 || n2 === 17) {
              var a2 = "location" in t2 ? t2.location : t2.keyLocation;
              if (n2 === 17 && a2 === 1)
                s[n2] == 1 && (o = t2.timeStamp);
              else if (n2 === 18 && u2 === 3 && a2 === 2) {
                var f2 = t2.timeStamp - o;
                f2 < 50 && (s.altGr = true);
              }
            }
          }
          n2 in r.MODIFIER_KEYS && (n2 = -1);
          if (!u2 && n2 === 13) {
            var a2 = "location" in t2 ? t2.location : t2.keyLocation;
            if (a2 === 3) {
              e2(t2, u2, -n2);
              if (t2.defaultPrevented)
                return;
            }
          }
          if (i.isChromeOS && u2 & 8) {
            e2(t2, u2, n2);
            if (t2.defaultPrevented)
              return;
            u2 &= -9;
          }
          return !!u2 || n2 in r.FUNCTION_KEYS || n2 in r.PRINTABLE_KEYS ? e2(t2, u2, n2) : false;
        }
        function v() {
          s = /* @__PURE__ */ Object.create(null);
        }
        var r = e("./keys"), i = e("./useragent"), s = null, o = 0, u;
        l.prototype.destroy = function() {
          h(this.elem, this.type, this.callback), this.elem = this.type = this.callback = void 0;
        };
        var c = t.addListener = function(e2, t2, n2, r2) {
          e2.addEventListener(t2, n2, f()), r2 && r2.$toDestroy.push(new l(e2, t2, n2));
        }, h = t.removeListener = function(e2, t2, n2) {
          e2.removeEventListener(t2, n2, f());
        };
        t.stopEvent = function(e2) {
          return t.stopPropagation(e2), t.preventDefault(e2), false;
        }, t.stopPropagation = function(e2) {
          e2.stopPropagation && e2.stopPropagation();
        }, t.preventDefault = function(e2) {
          e2.preventDefault && e2.preventDefault();
        }, t.getButton = function(e2) {
          return e2.type == "dblclick" ? 0 : e2.type == "contextmenu" || i.isMac && e2.ctrlKey && !e2.altKey && !e2.shiftKey ? 2 : e2.button;
        }, t.capture = function(e2, t2, n2) {
          function i2(e3) {
            t2 && t2(e3), n2 && n2(e3), h(r2, "mousemove", t2), h(r2, "mouseup", i2), h(r2, "dragstart", i2);
          }
          var r2 = e2 && e2.ownerDocument || document;
          return c(r2, "mousemove", t2), c(r2, "mouseup", i2), c(r2, "dragstart", i2), i2;
        }, t.addMouseWheelListener = function(e2, t2, n2) {
          c(e2, "wheel", function(e3) {
            var n3 = 0.15, r2 = e3.deltaX || 0, i2 = e3.deltaY || 0;
            switch (e3.deltaMode) {
              case e3.DOM_DELTA_PIXEL:
                e3.wheelX = r2 * n3, e3.wheelY = i2 * n3;
                break;
              case e3.DOM_DELTA_LINE:
                var s2 = 15;
                e3.wheelX = r2 * s2, e3.wheelY = i2 * s2;
                break;
              case e3.DOM_DELTA_PAGE:
                var o2 = 150;
                e3.wheelX = r2 * o2, e3.wheelY = i2 * o2;
            }
            t2(e3);
          }, n2);
        }, t.addMultiMouseDownListener = function(e2, n2, r2, s2, o2) {
          function p2(e3) {
            t.getButton(e3) !== 0 ? u2 = 0 : e3.detail > 1 ? (u2++, u2 > 4 && (u2 = 1)) : u2 = 1;
            if (i.isIE) {
              var o3 = Math.abs(e3.clientX - a2) > 5 || Math.abs(e3.clientY - f2) > 5;
              if (!l2 || o3)
                u2 = 1;
              l2 && clearTimeout(l2), l2 = setTimeout(function() {
                l2 = null;
              }, n2[u2 - 1] || 600), u2 == 1 && (a2 = e3.clientX, f2 = e3.clientY);
            }
            e3._clicks = u2, r2[s2]("mousedown", e3);
            if (u2 > 4)
              u2 = 0;
            else if (u2 > 1)
              return r2[s2](h2[u2], e3);
          }
          var u2 = 0, a2, f2, l2, h2 = { 2: "dblclick", 3: "tripleclick", 4: "quadclick" };
          Array.isArray(e2) || (e2 = [e2]), e2.forEach(function(e3) {
            c(e3, "mousedown", p2, o2);
          });
        };
        var p = function(e2) {
          return 0 | (e2.ctrlKey ? 1 : 0) | (e2.altKey ? 2 : 0) | (e2.shiftKey ? 4 : 0) | (e2.metaKey ? 8 : 0);
        };
        t.getModifierString = function(e2) {
          return r.KEY_MODS[p(e2)];
        }, t.addCommandKeyListener = function(e2, n2, r2) {
          if (i.isOldGecko || i.isOpera && !("KeyboardEvent" in window)) {
            var o2 = null;
            c(e2, "keydown", function(e3) {
              o2 = e3.keyCode;
            }, r2), c(e2, "keypress", function(e3) {
              return d(n2, e3, o2);
            }, r2);
          } else {
            var u2 = null;
            c(e2, "keydown", function(e3) {
              s[e3.keyCode] = (s[e3.keyCode] || 0) + 1;
              var t2 = d(n2, e3, e3.keyCode);
              return u2 = e3.defaultPrevented, t2;
            }, r2), c(e2, "keypress", function(e3) {
              u2 && (e3.ctrlKey || e3.altKey || e3.shiftKey || e3.metaKey) && (t.stopEvent(e3), u2 = null);
            }, r2), c(e2, "keyup", function(e3) {
              s[e3.keyCode] = null;
            }, r2), s || (v(), c(window, "focus", v));
          }
        };
        if (typeof window == "object" && window.postMessage && !i.isOldIE) {
          var m = 1;
          t.nextTick = function(e2, n2) {
            n2 = n2 || window;
            var r2 = "zero-timeout-message-" + m++, i2 = function(s2) {
              s2.data == r2 && (t.stopPropagation(s2), h(n2, "message", i2), e2());
            };
            c(n2, "message", i2), n2.postMessage(r2, "*");
          };
        }
        t.$idleBlocked = false, t.onIdle = function(e2, n2) {
          return setTimeout(function r2() {
            t.$idleBlocked ? setTimeout(r2, 100) : e2();
          }, n2);
        }, t.$idleBlockId = null, t.blockIdle = function(e2) {
          t.$idleBlockId && clearTimeout(t.$idleBlockId), t.$idleBlocked = true, t.$idleBlockId = setTimeout(function() {
            t.$idleBlocked = false;
          }, e2 || 100);
        }, t.nextFrame = typeof window == "object" && (window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame || window.oRequestAnimationFrame), t.nextFrame ? t.nextFrame = t.nextFrame.bind(window) : t.nextFrame = function(e2) {
          setTimeout(e2, 17);
        };
      }), ace.define("ace/range", ["require", "exports", "module"], function(e, t, n) {
        "use strict";
        var r = function(e2, t2) {
          return e2.row - t2.row || e2.column - t2.column;
        }, i = function(e2, t2, n2, r2) {
          this.start = { row: e2, column: t2 }, this.end = { row: n2, column: r2 };
        };
        (function() {
          this.isEqual = function(e2) {
            return this.start.row === e2.start.row && this.end.row === e2.end.row && this.start.column === e2.start.column && this.end.column === e2.end.column;
          }, this.toString = function() {
            return "Range: [" + this.start.row + "/" + this.start.column + "] -> [" + this.end.row + "/" + this.end.column + "]";
          }, this.contains = function(e2, t2) {
            return this.compare(e2, t2) == 0;
          }, this.compareRange = function(e2) {
            var t2, n2 = e2.end, r2 = e2.start;
            return t2 = this.compare(n2.row, n2.column), t2 == 1 ? (t2 = this.compare(r2.row, r2.column), t2 == 1 ? 2 : t2 == 0 ? 1 : 0) : t2 == -1 ? -2 : (t2 = this.compare(r2.row, r2.column), t2 == -1 ? -1 : t2 == 1 ? 42 : 0);
          }, this.comparePoint = function(e2) {
            return this.compare(e2.row, e2.column);
          }, this.containsRange = function(e2) {
            return this.comparePoint(e2.start) == 0 && this.comparePoint(e2.end) == 0;
          }, this.intersects = function(e2) {
            var t2 = this.compareRange(e2);
            return t2 == -1 || t2 == 0 || t2 == 1;
          }, this.isEnd = function(e2, t2) {
            return this.end.row == e2 && this.end.column == t2;
          }, this.isStart = function(e2, t2) {
            return this.start.row == e2 && this.start.column == t2;
          }, this.setStart = function(e2, t2) {
            typeof e2 == "object" ? (this.start.column = e2.column, this.start.row = e2.row) : (this.start.row = e2, this.start.column = t2);
          }, this.setEnd = function(e2, t2) {
            typeof e2 == "object" ? (this.end.column = e2.column, this.end.row = e2.row) : (this.end.row = e2, this.end.column = t2);
          }, this.inside = function(e2, t2) {
            return this.compare(e2, t2) == 0 ? this.isEnd(e2, t2) || this.isStart(e2, t2) ? false : true : false;
          }, this.insideStart = function(e2, t2) {
            return this.compare(e2, t2) == 0 ? this.isEnd(e2, t2) ? false : true : false;
          }, this.insideEnd = function(e2, t2) {
            return this.compare(e2, t2) == 0 ? this.isStart(e2, t2) ? false : true : false;
          }, this.compare = function(e2, t2) {
            return !this.isMultiLine() && e2 === this.start.row ? t2 < this.start.column ? -1 : t2 > this.end.column ? 1 : 0 : e2 < this.start.row ? -1 : e2 > this.end.row ? 1 : this.start.row === e2 ? t2 >= this.start.column ? 0 : -1 : this.end.row === e2 ? t2 <= this.end.column ? 0 : 1 : 0;
          }, this.compareStart = function(e2, t2) {
            return this.start.row == e2 && this.start.column == t2 ? -1 : this.compare(e2, t2);
          }, this.compareEnd = function(e2, t2) {
            return this.end.row == e2 && this.end.column == t2 ? 1 : this.compare(e2, t2);
          }, this.compareInside = function(e2, t2) {
            return this.end.row == e2 && this.end.column == t2 ? 1 : this.start.row == e2 && this.start.column == t2 ? -1 : this.compare(e2, t2);
          }, this.clipRows = function(e2, t2) {
            if (this.end.row > t2)
              var n2 = { row: t2 + 1, column: 0 };
            else if (this.end.row < e2)
              var n2 = { row: e2, column: 0 };
            if (this.start.row > t2)
              var r2 = { row: t2 + 1, column: 0 };
            else if (this.start.row < e2)
              var r2 = { row: e2, column: 0 };
            return i.fromPoints(r2 || this.start, n2 || this.end);
          }, this.extend = function(e2, t2) {
            var n2 = this.compare(e2, t2);
            if (n2 == 0)
              return this;
            if (n2 == -1)
              var r2 = { row: e2, column: t2 };
            else
              var s = { row: e2, column: t2 };
            return i.fromPoints(r2 || this.start, s || this.end);
          }, this.isEmpty = function() {
            return this.start.row === this.end.row && this.start.column === this.end.column;
          }, this.isMultiLine = function() {
            return this.start.row !== this.end.row;
          }, this.clone = function() {
            return i.fromPoints(this.start, this.end);
          }, this.collapseRows = function() {
            return this.end.column == 0 ? new i(this.start.row, 0, Math.max(this.start.row, this.end.row - 1), 0) : new i(this.start.row, 0, this.end.row, 0);
          }, this.toScreenRange = function(e2) {
            var t2 = e2.documentToScreenPosition(this.start), n2 = e2.documentToScreenPosition(this.end);
            return new i(t2.row, t2.column, n2.row, n2.column);
          }, this.moveBy = function(e2, t2) {
            this.start.row += e2, this.start.column += t2, this.end.row += e2, this.end.column += t2;
          };
        }).call(i.prototype), i.fromPoints = function(e2, t2) {
          return new i(e2.row, e2.column, t2.row, t2.column);
        }, i.comparePoints = r, i.comparePoints = function(e2, t2) {
          return e2.row - t2.row || e2.column - t2.column;
        }, t.Range = i;
      }), ace.define("ace/lib/lang", ["require", "exports", "module"], function(e, t, n) {
        "use strict";
        t.last = function(e2) {
          return e2[e2.length - 1];
        }, t.stringReverse = function(e2) {
          return e2.split("").reverse().join("");
        }, t.stringRepeat = function(e2, t2) {
          var n2 = "";
          while (t2 > 0) {
            t2 & 1 && (n2 += e2);
            if (t2 >>= 1)
              e2 += e2;
          }
          return n2;
        };
        var r = /^\s\s*/, i = /\s\s*$/;
        t.stringTrimLeft = function(e2) {
          return e2.replace(r, "");
        }, t.stringTrimRight = function(e2) {
          return e2.replace(i, "");
        }, t.copyObject = function(e2) {
          var t2 = {};
          for (var n2 in e2)
            t2[n2] = e2[n2];
          return t2;
        }, t.copyArray = function(e2) {
          var t2 = [];
          for (var n2 = 0, r2 = e2.length; n2 < r2; n2++)
            e2[n2] && typeof e2[n2] == "object" ? t2[n2] = this.copyObject(e2[n2]) : t2[n2] = e2[n2];
          return t2;
        }, t.deepCopy = function s(e2) {
          if (typeof e2 != "object" || !e2)
            return e2;
          var t2;
          if (Array.isArray(e2)) {
            t2 = [];
            for (var n2 = 0; n2 < e2.length; n2++)
              t2[n2] = s(e2[n2]);
            return t2;
          }
          if (Object.prototype.toString.call(e2) !== "[object Object]")
            return e2;
          t2 = {};
          for (var n2 in e2)
            t2[n2] = s(e2[n2]);
          return t2;
        }, t.arrayToMap = function(e2) {
          var t2 = {};
          for (var n2 = 0; n2 < e2.length; n2++)
            t2[e2[n2]] = 1;
          return t2;
        }, t.createMap = function(e2) {
          var t2 = /* @__PURE__ */ Object.create(null);
          for (var n2 in e2)
            t2[n2] = e2[n2];
          return t2;
        }, t.arrayRemove = function(e2, t2) {
          for (var n2 = 0; n2 <= e2.length; n2++)
            t2 === e2[n2] && e2.splice(n2, 1);
        }, t.escapeRegExp = function(e2) {
          return e2.replace(/([.*+?^${}()|[\]\/\\])/g, "\\$1");
        }, t.escapeHTML = function(e2) {
          return ("" + e2).replace(/&/g, "&#38;").replace(/"/g, "&#34;").replace(/'/g, "&#39;").replace(/</g, "&#60;");
        }, t.getMatchOffsets = function(e2, t2) {
          var n2 = [];
          return e2.replace(t2, function(e3) {
            n2.push({ offset: arguments[arguments.length - 2], length: e3.length });
          }), n2;
        }, t.deferredCall = function(e2) {
          var t2 = null, n2 = function() {
            t2 = null, e2();
          }, r2 = function(e3) {
            return r2.cancel(), t2 = setTimeout(n2, e3 || 0), r2;
          };
          return r2.schedule = r2, r2.call = function() {
            return this.cancel(), e2(), r2;
          }, r2.cancel = function() {
            return clearTimeout(t2), t2 = null, r2;
          }, r2.isPending = function() {
            return t2;
          }, r2;
        }, t.delayedCall = function(e2, t2) {
          var n2 = null, r2 = function() {
            n2 = null, e2();
          }, i2 = function(e3) {
            n2 == null && (n2 = setTimeout(r2, e3 || t2));
          };
          return i2.delay = function(e3) {
            n2 && clearTimeout(n2), n2 = setTimeout(r2, e3 || t2);
          }, i2.schedule = i2, i2.call = function() {
            this.cancel(), e2();
          }, i2.cancel = function() {
            n2 && clearTimeout(n2), n2 = null;
          }, i2.isPending = function() {
            return n2;
          }, i2;
        };
      }), ace.define("ace/clipboard", ["require", "exports", "module"], function(e, t, n) {
        "use strict";
        var r;
        n.exports = { lineMode: false, pasteCancelled: function() {
          return r && r > Date.now() - 50 ? true : r = false;
        }, cancel: function() {
          r = Date.now();
        } };
      }), ace.define("ace/keyboard/textinput", ["require", "exports", "module", "ace/lib/event", "ace/lib/useragent", "ace/lib/dom", "ace/lib/lang", "ace/clipboard", "ace/lib/keys"], function(e, t, n) {
        "use strict";
        var r = e("../lib/event"), i = e("../lib/useragent"), s = e("../lib/dom"), o = e("../lib/lang"), u = e("../clipboard"), a = i.isChrome < 18, f = i.isIE, l = i.isChrome > 63, c = 400, h = e("../lib/keys"), p = h.KEY_MODS, d = i.isIOS, v = d ? /\s/ : /\n/, m = i.isMobile, g = function(e2, t2) {
          function X() {
            x = true, n2.blur(), n2.focus(), x = false;
          }
          function $(e3) {
            e3.keyCode == 27 && n2.value.length < n2.selectionStart && (b || (T = n2.value), N = C = -1, O()), V();
          }
          function K() {
            clearTimeout(J), J = setTimeout(function() {
              E && (n2.style.cssText = E, E = ""), t2.renderer.$isMousePressed = false, t2.renderer.$keepTextAreaAtCursor && t2.renderer.$moveTextAreaToCursor();
            }, 0);
          }
          function G(e3, t3, n3) {
            var r2 = null, i2 = false;
            n3.addEventListener("keydown", function(e4) {
              r2 && clearTimeout(r2), i2 = true;
            }, true), n3.addEventListener("keyup", function(e4) {
              r2 = setTimeout(function() {
                i2 = false;
              }, 100);
            }, true);
            var s2 = function(e4) {
              if (document.activeElement !== n3)
                return;
              if (i2 || b || t3.$mouseHandler.isMousePressed)
                return;
              if (g2)
                return;
              var r3 = n3.selectionStart, s3 = n3.selectionEnd, o2 = null, u2 = 0;
              if (r3 == 0)
                o2 = h.up;
              else if (r3 == 1)
                o2 = h.home;
              else if (s3 > C && T[s3] == "\n")
                o2 = h.end;
              else if (r3 < N && T[r3 - 1] == " ")
                o2 = h.left, u2 = p.option;
              else if (r3 < N || r3 == N && C != N && r3 == s3)
                o2 = h.left;
              else if (s3 > C && T.slice(0, s3).split("\n").length > 2)
                o2 = h.down;
              else if (s3 > C && T[s3 - 1] == " ")
                o2 = h.right, u2 = p.option;
              else if (s3 > C || s3 == C && C != N && r3 == s3)
                o2 = h.right;
              r3 !== s3 && (u2 |= p.shift);
              if (o2) {
                var a2 = t3.onCommandKey({}, u2, o2);
                if (!a2 && t3.commands) {
                  o2 = h.keyCodeToString(o2);
                  var f2 = t3.commands.findKeyCommand(u2, o2);
                  f2 && t3.execCommand(f2);
                }
                N = r3, C = s3, O("");
              }
            };
            document.addEventListener("selectionchange", s2), t3.on("destroy", function() {
              document.removeEventListener("selectionchange", s2);
            });
          }
          var n2 = s.createElement("textarea");
          n2.className = "ace_text-input", n2.setAttribute("wrap", "off"), n2.setAttribute("autocorrect", "off"), n2.setAttribute("autocapitalize", "off"), n2.setAttribute("spellcheck", false), n2.style.opacity = "0", e2.insertBefore(n2, e2.firstChild);
          var g2 = false, y = false, b = false, w = false, E = "";
          m || (n2.style.fontSize = "1px");
          var S = false, x = false, T = "", N = 0, C = 0, k = 0;
          try {
            var L = document.activeElement === n2;
          } catch (A) {
          }
          r.addListener(n2, "blur", function(e3) {
            if (x)
              return;
            t2.onBlur(e3), L = false;
          }, t2), r.addListener(n2, "focus", function(e3) {
            if (x)
              return;
            L = true;
            if (i.isEdge)
              try {
                if (!document.hasFocus())
                  return;
              } catch (e4) {
              }
            t2.onFocus(e3), i.isEdge ? setTimeout(O) : O();
          }, t2), this.$focusScroll = false, this.focus = function() {
            if (E || l || this.$focusScroll == "browser")
              return n2.focus({ preventScroll: true });
            var e3 = n2.style.top;
            n2.style.position = "fixed", n2.style.top = "0px";
            try {
              var t3 = n2.getBoundingClientRect().top != 0;
            } catch (r2) {
              return;
            }
            var i2 = [];
            if (t3) {
              var s2 = n2.parentElement;
              while (s2 && s2.nodeType == 1)
                i2.push(s2), s2.setAttribute("ace_nocontext", true), !s2.parentElement && s2.getRootNode ? s2 = s2.getRootNode().host : s2 = s2.parentElement;
            }
            n2.focus({ preventScroll: true }), t3 && i2.forEach(function(e4) {
              e4.removeAttribute("ace_nocontext");
            }), setTimeout(function() {
              n2.style.position = "", n2.style.top == "0px" && (n2.style.top = e3);
            }, 0);
          }, this.blur = function() {
            n2.blur();
          }, this.isFocused = function() {
            return L;
          }, t2.on("beforeEndOperation", function() {
            var e3 = t2.curOp, r2 = e3 && e3.command && e3.command.name;
            if (r2 == "insertstring")
              return;
            var i2 = r2 && (e3.docChanged || e3.selectionChanged);
            b && i2 && (T = n2.value = "", W()), O();
          });
          var O = d ? function(e3) {
            if (!L || g2 && !e3 || w)
              return;
            e3 || (e3 = "");
            var r2 = "\n ab" + e3 + "cde fg\n";
            r2 != n2.value && (n2.value = T = r2);
            var i2 = 4, s2 = 4 + (e3.length || (t2.selection.isEmpty() ? 0 : 1));
            (N != i2 || C != s2) && n2.setSelectionRange(i2, s2), N = i2, C = s2;
          } : function() {
            if (b || w)
              return;
            if (!L && !P)
              return;
            b = true;
            var e3 = 0, r2 = 0, i2 = "";
            if (t2.session) {
              var s2 = t2.selection, o2 = s2.getRange(), u2 = s2.cursor.row;
              e3 = o2.start.column, r2 = o2.end.column, i2 = t2.session.getLine(u2);
              if (o2.start.row != u2) {
                var a2 = t2.session.getLine(u2 - 1);
                e3 = o2.start.row < u2 - 1 ? 0 : e3, r2 += a2.length + 1, i2 = a2 + "\n" + i2;
              } else if (o2.end.row != u2) {
                var f2 = t2.session.getLine(u2 + 1);
                r2 = o2.end.row > u2 + 1 ? f2.length : r2, r2 += i2.length + 1, i2 = i2 + "\n" + f2;
              } else
                m && u2 > 0 && (i2 = "\n" + i2, r2 += 1, e3 += 1);
              i2.length > c && (e3 < c && r2 < c ? i2 = i2.slice(0, c) : (i2 = "\n", e3 == r2 ? e3 = r2 = 0 : (e3 = 0, r2 = 1)));
            }
            var l2 = i2 + "\n\n";
            l2 != T && (n2.value = T = l2, N = C = l2.length), P && (N = n2.selectionStart, C = n2.selectionEnd);
            if (C != r2 || N != e3 || n2.selectionEnd != C)
              try {
                n2.setSelectionRange(e3, r2), N = e3, C = r2;
              } catch (h2) {
              }
            b = false;
          };
          this.resetSelection = O, L && t2.onFocus();
          var M = function(e3) {
            return e3.selectionStart === 0 && e3.selectionEnd >= T.length && e3.value === T && T && e3.selectionEnd !== C;
          }, _2 = function(e3) {
            if (b)
              return;
            g2 ? g2 = false : M(n2) ? (t2.selectAll(), O()) : m && n2.selectionStart != N && O();
          }, D = null;
          this.setInputHandler = function(e3) {
            D = e3;
          }, this.getInputHandler = function() {
            return D;
          };
          var P = false, H = function(e3, r2) {
            P && (P = false);
            if (y)
              return O(), e3 && t2.onPaste(e3), y = false, "";
            var s2 = n2.selectionStart, o2 = n2.selectionEnd, u2 = N, a2 = T.length - C, f2 = e3, l2 = e3.length - s2, c2 = e3.length - o2, h2 = 0;
            while (u2 > 0 && T[h2] == e3[h2])
              h2++, u2--;
            f2 = f2.slice(h2), h2 = 1;
            while (a2 > 0 && T.length - h2 > N - 1 && T[T.length - h2] == e3[e3.length - h2])
              h2++, a2--;
            l2 -= h2 - 1, c2 -= h2 - 1;
            var p2 = f2.length - h2 + 1;
            p2 < 0 && (u2 = -p2, p2 = 0), f2 = f2.slice(0, p2);
            if (!r2 && !f2 && !l2 && !u2 && !a2 && !c2)
              return "";
            w = true;
            var d2 = false;
            return i.isAndroid && f2 == ". " && (f2 = "  ", d2 = true), f2 && !u2 && !a2 && !l2 && !c2 || S ? t2.onTextInput(f2) : t2.onTextInput(f2, { extendLeft: u2, extendRight: a2, restoreStart: l2, restoreEnd: c2 }), w = false, T = e3, N = s2, C = o2, k = c2, d2 ? "\n" : f2;
          }, B = function(e3) {
            if (b)
              return z();
            if (e3 && e3.inputType) {
              if (e3.inputType == "historyUndo")
                return t2.execCommand("undo");
              if (e3.inputType == "historyRedo")
                return t2.execCommand("redo");
            }
            var r2 = n2.value, i2 = H(r2, true);
            (r2.length > c + 100 || v.test(i2) || m && N < 1 && N == C) && O();
          }, j = function(e3, t3, n3) {
            var r2 = e3.clipboardData || window.clipboardData;
            if (!r2 || a)
              return;
            var i2 = f || n3 ? "Text" : "text/plain";
            try {
              return t3 ? r2.setData(i2, t3) !== false : r2.getData(i2);
            } catch (e4) {
              if (!n3)
                return j(e4, t3, true);
            }
          }, F = function(e3, i2) {
            var s2 = t2.getCopyText();
            if (!s2)
              return r.preventDefault(e3);
            j(e3, s2) ? (d && (O(s2), g2 = s2, setTimeout(function() {
              g2 = false;
            }, 10)), i2 ? t2.onCut() : t2.onCopy(), r.preventDefault(e3)) : (g2 = true, n2.value = s2, n2.select(), setTimeout(function() {
              g2 = false, O(), i2 ? t2.onCut() : t2.onCopy();
            }));
          }, I = function(e3) {
            F(e3, true);
          }, q = function(e3) {
            F(e3, false);
          }, R = function(e3) {
            var s2 = j(e3);
            if (u.pasteCancelled())
              return;
            typeof s2 == "string" ? (s2 && t2.onPaste(s2, e3), i.isIE && setTimeout(O), r.preventDefault(e3)) : (n2.value = "", y = true);
          };
          r.addCommandKeyListener(n2, t2.onCommandKey.bind(t2), t2), r.addListener(n2, "select", _2, t2), r.addListener(n2, "input", B, t2), r.addListener(n2, "cut", I, t2), r.addListener(n2, "copy", q, t2), r.addListener(n2, "paste", R, t2), (!("oncut" in n2) || !("oncopy" in n2) || !("onpaste" in n2)) && r.addListener(e2, "keydown", function(e3) {
            if (i.isMac && !e3.metaKey || !e3.ctrlKey)
              return;
            switch (e3.keyCode) {
              case 67:
                q(e3);
                break;
              case 86:
                R(e3);
                break;
              case 88:
                I(e3);
            }
          }, t2);
          var U = function(e3) {
            if (b || !t2.onCompositionStart || t2.$readOnly)
              return;
            b = {};
            if (S)
              return;
            e3.data && (b.useTextareaForIME = false), setTimeout(z, 0), t2._signal("compositionStart"), t2.on("mousedown", X);
            var r2 = t2.getSelectionRange();
            r2.end.row = r2.start.row, r2.end.column = r2.start.column, b.markerRange = r2, b.selectionStart = N, t2.onCompositionStart(b), b.useTextareaForIME ? (T = n2.value = "", N = 0, C = 0) : (n2.msGetInputContext && (b.context = n2.msGetInputContext()), n2.getInputContext && (b.context = n2.getInputContext()));
          }, z = function() {
            if (!b || !t2.onCompositionUpdate || t2.$readOnly)
              return;
            if (S)
              return X();
            if (b.useTextareaForIME)
              t2.onCompositionUpdate(n2.value);
            else {
              var e3 = n2.value;
              H(e3), b.markerRange && (b.context && (b.markerRange.start.column = b.selectionStart = b.context.compositionStartOffset), b.markerRange.end.column = b.markerRange.start.column + C - b.selectionStart + k);
            }
          }, W = function(e3) {
            if (!t2.onCompositionEnd || t2.$readOnly)
              return;
            b = false, t2.onCompositionEnd(), t2.off("mousedown", X), e3 && B();
          }, V = o.delayedCall(z, 50).schedule.bind(null, null);
          r.addListener(n2, "compositionstart", U, t2), r.addListener(n2, "compositionupdate", z, t2), r.addListener(n2, "keyup", $, t2), r.addListener(n2, "keydown", V, t2), r.addListener(n2, "compositionend", W, t2), this.getElement = function() {
            return n2;
          }, this.setCommandMode = function(e3) {
            S = e3, n2.readOnly = false;
          }, this.setReadOnly = function(e3) {
            S || (n2.readOnly = e3);
          }, this.setCopyWithEmptySelection = function(e3) {
          }, this.onContextMenu = function(e3) {
            P = true, O(), t2._emit("nativecontextmenu", { target: t2, domEvent: e3 }), this.moveToMouse(e3, true);
          }, this.moveToMouse = function(e3, o2) {
            E || (E = n2.style.cssText), n2.style.cssText = (o2 ? "z-index:100000;" : "") + (i.isIE ? "opacity:0.1;" : "") + "text-indent: -" + (N + C) * t2.renderer.characterWidth * 0.5 + "px;";
            var u2 = t2.container.getBoundingClientRect(), a2 = s.computedStyle(t2.container), f2 = u2.top + (parseInt(a2.borderTopWidth) || 0), l2 = u2.left + (parseInt(u2.borderLeftWidth) || 0), c2 = u2.bottom - f2 - n2.clientHeight - 2, h2 = function(e4) {
              s.translate(n2, e4.clientX - l2 - 2, Math.min(e4.clientY - f2 - 2, c2));
            };
            h2(e3);
            if (e3.type != "mousedown")
              return;
            t2.renderer.$isMousePressed = true, clearTimeout(J), i.isWin && r.capture(t2.container, h2, K);
          }, this.onContextMenuClose = K;
          var J, Q = function(e3) {
            t2.textInput.onContextMenu(e3), K();
          };
          r.addListener(n2, "mouseup", Q, t2), r.addListener(n2, "mousedown", function(e3) {
            e3.preventDefault(), K();
          }, t2), r.addListener(t2.renderer.scroller, "contextmenu", Q, t2), r.addListener(n2, "contextmenu", Q, t2), d && G(e2, t2, n2), this.destroy = function() {
            n2.parentElement && n2.parentElement.removeChild(n2);
          };
        };
        t.TextInput = g, t.$setUserAgentForTests = function(e2, t2) {
          m = e2, d = t2;
        };
      }), ace.define("ace/mouse/default_handlers", ["require", "exports", "module", "ace/lib/useragent"], function(e, t, n) {
        "use strict";
        function o(e2) {
          e2.$clickSelection = null;
          var t2 = e2.editor;
          t2.setDefaultHandler("mousedown", this.onMouseDown.bind(e2)), t2.setDefaultHandler("dblclick", this.onDoubleClick.bind(e2)), t2.setDefaultHandler("tripleclick", this.onTripleClick.bind(e2)), t2.setDefaultHandler("quadclick", this.onQuadClick.bind(e2)), t2.setDefaultHandler("mousewheel", this.onMouseWheel.bind(e2));
          var n2 = ["select", "startSelect", "selectEnd", "selectAllEnd", "selectByWordsEnd", "selectByLinesEnd", "dragWait", "dragWaitEnd", "focusWait"];
          n2.forEach(function(t3) {
            e2[t3] = this[t3];
          }, this), e2.selectByLines = this.extendSelectionBy.bind(e2, "getLineRange"), e2.selectByWords = this.extendSelectionBy.bind(e2, "getWordRange");
        }
        function u(e2, t2, n2, r2) {
          return Math.sqrt(Math.pow(n2 - e2, 2) + Math.pow(r2 - t2, 2));
        }
        function a(e2, t2) {
          if (e2.start.row == e2.end.row)
            var n2 = 2 * t2.column - e2.start.column - e2.end.column;
          else if (e2.start.row == e2.end.row - 1 && !e2.start.column && !e2.end.column)
            var n2 = t2.column - 4;
          else
            var n2 = 2 * t2.row - e2.start.row - e2.end.row;
          return n2 < 0 ? { cursor: e2.start, anchor: e2.end } : { cursor: e2.end, anchor: e2.start };
        }
        var r = e("../lib/useragent"), i = 0, s = 550;
        (function() {
          this.onMouseDown = function(e2) {
            var t2 = e2.inSelection(), n2 = e2.getDocumentPosition();
            this.mousedownEvent = e2;
            var i2 = this.editor, s2 = e2.getButton();
            if (s2 !== 0) {
              var o2 = i2.getSelectionRange(), u2 = o2.isEmpty();
              (u2 || s2 == 1) && i2.selection.moveToPosition(n2), s2 == 2 && (i2.textInput.onContextMenu(e2.domEvent), r.isMozilla || e2.preventDefault());
              return;
            }
            this.mousedownEvent.time = Date.now();
            if (t2 && !i2.isFocused()) {
              i2.focus();
              if (this.$focusTimeout && !this.$clickSelection && !i2.inMultiSelectMode) {
                this.setState("focusWait"), this.captureMouse(e2);
                return;
              }
            }
            return this.captureMouse(e2), this.startSelect(n2, e2.domEvent._clicks > 1), e2.preventDefault();
          }, this.startSelect = function(e2, t2) {
            e2 = e2 || this.editor.renderer.screenToTextCoordinates(this.x, this.y);
            var n2 = this.editor;
            if (!this.mousedownEvent)
              return;
            this.mousedownEvent.getShiftKey() ? n2.selection.selectToPosition(e2) : t2 || n2.selection.moveToPosition(e2), t2 || this.select(), n2.renderer.scroller.setCapture && n2.renderer.scroller.setCapture(), n2.setStyle("ace_selecting"), this.setState("select");
          }, this.select = function() {
            var e2, t2 = this.editor, n2 = t2.renderer.screenToTextCoordinates(this.x, this.y);
            if (this.$clickSelection) {
              var r2 = this.$clickSelection.comparePoint(n2);
              if (r2 == -1)
                e2 = this.$clickSelection.end;
              else if (r2 == 1)
                e2 = this.$clickSelection.start;
              else {
                var i2 = a(this.$clickSelection, n2);
                n2 = i2.cursor, e2 = i2.anchor;
              }
              t2.selection.setSelectionAnchor(e2.row, e2.column);
            }
            t2.selection.selectToPosition(n2), t2.renderer.scrollCursorIntoView();
          }, this.extendSelectionBy = function(e2) {
            var t2, n2 = this.editor, r2 = n2.renderer.screenToTextCoordinates(this.x, this.y), i2 = n2.selection[e2](r2.row, r2.column);
            if (this.$clickSelection) {
              var s2 = this.$clickSelection.comparePoint(i2.start), o2 = this.$clickSelection.comparePoint(i2.end);
              if (s2 == -1 && o2 <= 0) {
                t2 = this.$clickSelection.end;
                if (i2.end.row != r2.row || i2.end.column != r2.column)
                  r2 = i2.start;
              } else if (o2 == 1 && s2 >= 0) {
                t2 = this.$clickSelection.start;
                if (i2.start.row != r2.row || i2.start.column != r2.column)
                  r2 = i2.end;
              } else if (s2 == -1 && o2 == 1)
                r2 = i2.end, t2 = i2.start;
              else {
                var u2 = a(this.$clickSelection, r2);
                r2 = u2.cursor, t2 = u2.anchor;
              }
              n2.selection.setSelectionAnchor(t2.row, t2.column);
            }
            n2.selection.selectToPosition(r2), n2.renderer.scrollCursorIntoView();
          }, this.selectEnd = this.selectAllEnd = this.selectByWordsEnd = this.selectByLinesEnd = function() {
            this.$clickSelection = null, this.editor.unsetStyle("ace_selecting"), this.editor.renderer.scroller.releaseCapture && this.editor.renderer.scroller.releaseCapture();
          }, this.focusWait = function() {
            var e2 = u(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y), t2 = Date.now();
            (e2 > i || t2 - this.mousedownEvent.time > this.$focusTimeout) && this.startSelect(this.mousedownEvent.getDocumentPosition());
          }, this.onDoubleClick = function(e2) {
            var t2 = e2.getDocumentPosition(), n2 = this.editor, r2 = n2.session, i2 = r2.getBracketRange(t2);
            i2 ? (i2.isEmpty() && (i2.start.column--, i2.end.column++), this.setState("select")) : (i2 = n2.selection.getWordRange(t2.row, t2.column), this.setState("selectByWords")), this.$clickSelection = i2, this.select();
          }, this.onTripleClick = function(e2) {
            var t2 = e2.getDocumentPosition(), n2 = this.editor;
            this.setState("selectByLines");
            var r2 = n2.getSelectionRange();
            r2.isMultiLine() && r2.contains(t2.row, t2.column) ? (this.$clickSelection = n2.selection.getLineRange(r2.start.row), this.$clickSelection.end = n2.selection.getLineRange(r2.end.row).end) : this.$clickSelection = n2.selection.getLineRange(t2.row), this.select();
          }, this.onQuadClick = function(e2) {
            var t2 = this.editor;
            t2.selectAll(), this.$clickSelection = t2.getSelectionRange(), this.setState("selectAll");
          }, this.onMouseWheel = function(e2) {
            if (e2.getAccelKey())
              return;
            e2.getShiftKey() && e2.wheelY && !e2.wheelX && (e2.wheelX = e2.wheelY, e2.wheelY = 0);
            var t2 = this.editor;
            this.$lastScroll || (this.$lastScroll = { t: 0, vx: 0, vy: 0, allowed: 0 });
            var n2 = this.$lastScroll, r2 = e2.domEvent.timeStamp, i2 = r2 - n2.t, o2 = i2 ? e2.wheelX / i2 : n2.vx, u2 = i2 ? e2.wheelY / i2 : n2.vy;
            i2 < s && (o2 = (o2 + n2.vx) / 2, u2 = (u2 + n2.vy) / 2);
            var a2 = Math.abs(o2 / u2), f = false;
            a2 >= 1 && t2.renderer.isScrollableBy(e2.wheelX * e2.speed, 0) && (f = true), a2 <= 1 && t2.renderer.isScrollableBy(0, e2.wheelY * e2.speed) && (f = true);
            if (f)
              n2.allowed = r2;
            else if (r2 - n2.allowed < s) {
              var l = Math.abs(o2) <= 1.5 * Math.abs(n2.vx) && Math.abs(u2) <= 1.5 * Math.abs(n2.vy);
              l ? (f = true, n2.allowed = r2) : n2.allowed = 0;
            }
            n2.t = r2, n2.vx = o2, n2.vy = u2;
            if (f)
              return t2.renderer.scrollBy(e2.wheelX * e2.speed, e2.wheelY * e2.speed), e2.stop();
          };
        }).call(o.prototype), t.DefaultHandlers = o;
      }), ace.define("ace/tooltip", ["require", "exports", "module", "ace/lib/oop", "ace/lib/dom"], function(e, t, n) {
        "use strict";
        function o(e2) {
          this.isOpen = false, this.$element = null, this.$parentNode = e2;
        }
        var r = e("./lib/oop"), i = e("./lib/dom"), s = "ace_tooltip";
        (function() {
          this.$init = function() {
            return this.$element = i.createElement("div"), this.$element.className = s, this.$element.style.display = "none", this.$parentNode.appendChild(this.$element), this.$element;
          }, this.getElement = function() {
            return this.$element || this.$init();
          }, this.setText = function(e2) {
            this.getElement().textContent = e2;
          }, this.setHtml = function(e2) {
            this.getElement().innerHTML = e2;
          }, this.setPosition = function(e2, t2) {
            this.getElement().style.left = e2 + "px", this.getElement().style.top = t2 + "px";
          }, this.setClassName = function(e2) {
            i.addCssClass(this.getElement(), e2);
          }, this.show = function(e2, t2, n2) {
            e2 != null && this.setText(e2), t2 != null && n2 != null && this.setPosition(t2, n2), this.isOpen || (this.getElement().style.display = "block", this.isOpen = true);
          }, this.hide = function() {
            this.isOpen && (this.getElement().style.display = "none", this.getElement().className = s, this.isOpen = false);
          }, this.getHeight = function() {
            return this.getElement().offsetHeight;
          }, this.getWidth = function() {
            return this.getElement().offsetWidth;
          }, this.destroy = function() {
            this.isOpen = false, this.$element && this.$element.parentNode && this.$element.parentNode.removeChild(this.$element);
          };
        }).call(o.prototype), t.Tooltip = o;
      }), ace.define("ace/mouse/default_gutter_handler", ["require", "exports", "module", "ace/lib/dom", "ace/lib/oop", "ace/lib/event", "ace/tooltip"], function(e, t, n) {
        "use strict";
        function u(e2) {
          function l() {
            var r2 = u2.getDocumentPosition().row, s2 = n2.$annotations[r2];
            if (!s2)
              return c();
            var o3 = t2.session.getLength();
            if (r2 == o3) {
              var a2 = t2.renderer.pixelToScreenCoordinates(0, u2.y).row, l2 = u2.$pos;
              if (a2 > t2.session.documentToScreenRow(l2.row, l2.column))
                return c();
            }
            if (f == s2)
              return;
            f = s2.text.join("<br/>"), i2.setHtml(f);
            var p = s2.className;
            p && i2.setClassName(p.trim()), i2.show(), t2._signal("showGutterTooltip", i2), t2.on("mousewheel", c);
            if (e2.$tooltipFollowsMouse)
              h(u2);
            else {
              var d = u2.domEvent.target, v = d.getBoundingClientRect(), m = i2.getElement().style;
              m.left = v.right + "px", m.top = v.bottom + "px";
            }
          }
          function c() {
            o2 && (o2 = clearTimeout(o2)), f && (i2.hide(), f = null, t2._signal("hideGutterTooltip", i2), t2.off("mousewheel", c));
          }
          function h(e3) {
            i2.setPosition(e3.x, e3.y);
          }
          var t2 = e2.editor, n2 = t2.renderer.$gutterLayer, i2 = new a(t2.container);
          e2.editor.setDefaultHandler("guttermousedown", function(r2) {
            if (!t2.isFocused() || r2.getButton() != 0)
              return;
            var i3 = n2.getRegion(r2);
            if (i3 == "foldWidgets")
              return;
            var s2 = r2.getDocumentPosition().row, o3 = t2.session.selection;
            if (r2.getShiftKey())
              o3.selectTo(s2, 0);
            else {
              if (r2.domEvent.detail == 2)
                return t2.selectAll(), r2.preventDefault();
              e2.$clickSelection = t2.selection.getLineRange(s2);
            }
            return e2.setState("selectByLines"), e2.captureMouse(r2), r2.preventDefault();
          });
          var o2, u2, f;
          e2.editor.setDefaultHandler("guttermousemove", function(t3) {
            var n3 = t3.domEvent.target || t3.domEvent.srcElement;
            if (r.hasCssClass(n3, "ace_fold-widget"))
              return c();
            f && e2.$tooltipFollowsMouse && h(t3), u2 = t3;
            if (o2)
              return;
            o2 = setTimeout(function() {
              o2 = null, u2 && !e2.isMousePressed ? l() : c();
            }, 50);
          }), s.addListener(t2.renderer.$gutter, "mouseout", function(e3) {
            u2 = null;
            if (!f || o2)
              return;
            o2 = setTimeout(function() {
              o2 = null, c();
            }, 50);
          }, t2), t2.on("changeSession", c);
        }
        function a(e2) {
          o.call(this, e2);
        }
        var r = e("../lib/dom"), i = e("../lib/oop"), s = e("../lib/event"), o = e("../tooltip").Tooltip;
        i.inherits(a, o), function() {
          this.setPosition = function(e2, t2) {
            var n2 = window.innerWidth || document.documentElement.clientWidth, r2 = window.innerHeight || document.documentElement.clientHeight, i2 = this.getWidth(), s2 = this.getHeight();
            e2 += 15, t2 += 15, e2 + i2 > n2 && (e2 -= e2 + i2 - n2), t2 + s2 > r2 && (t2 -= 20 + s2), o.prototype.setPosition.call(this, e2, t2);
          };
        }.call(a.prototype), t.GutterHandler = u;
      }), ace.define("ace/mouse/mouse_event", ["require", "exports", "module", "ace/lib/event", "ace/lib/useragent"], function(e, t, n) {
        "use strict";
        var r = e("../lib/event"), i = e("../lib/useragent"), s = t.MouseEvent = function(e2, t2) {
          this.domEvent = e2, this.editor = t2, this.x = this.clientX = e2.clientX, this.y = this.clientY = e2.clientY, this.$pos = null, this.$inSelection = null, this.propagationStopped = false, this.defaultPrevented = false;
        };
        (function() {
          this.stopPropagation = function() {
            r.stopPropagation(this.domEvent), this.propagationStopped = true;
          }, this.preventDefault = function() {
            r.preventDefault(this.domEvent), this.defaultPrevented = true;
          }, this.stop = function() {
            this.stopPropagation(), this.preventDefault();
          }, this.getDocumentPosition = function() {
            return this.$pos ? this.$pos : (this.$pos = this.editor.renderer.screenToTextCoordinates(this.clientX, this.clientY), this.$pos);
          }, this.inSelection = function() {
            if (this.$inSelection !== null)
              return this.$inSelection;
            var e2 = this.editor, t2 = e2.getSelectionRange();
            if (t2.isEmpty())
              this.$inSelection = false;
            else {
              var n2 = this.getDocumentPosition();
              this.$inSelection = t2.contains(n2.row, n2.column);
            }
            return this.$inSelection;
          }, this.getButton = function() {
            return r.getButton(this.domEvent);
          }, this.getShiftKey = function() {
            return this.domEvent.shiftKey;
          }, this.getAccelKey = i.isMac ? function() {
            return this.domEvent.metaKey;
          } : function() {
            return this.domEvent.ctrlKey;
          };
        }).call(s.prototype);
      }), ace.define("ace/mouse/dragdrop_handler", ["require", "exports", "module", "ace/lib/dom", "ace/lib/event", "ace/lib/useragent"], function(e, t, n) {
        "use strict";
        function f(e2) {
          function T(e3, n3) {
            var r2 = Date.now(), i2 = !n3 || e3.row != n3.row, s2 = !n3 || e3.column != n3.column;
            if (!S || i2 || s2)
              t2.moveCursorToPosition(e3), S = r2, x = { x: p, y: d };
            else {
              var o2 = l(x.x, x.y, p, d);
              o2 > a ? S = null : r2 - S >= u && (t2.renderer.scrollCursorIntoView(), S = null);
            }
          }
          function N(e3, n3) {
            var r2 = Date.now(), i2 = t2.renderer.layerConfig.lineHeight, s2 = t2.renderer.layerConfig.characterWidth, u2 = t2.renderer.scroller.getBoundingClientRect(), a2 = { x: { left: p - u2.left, right: u2.right - p }, y: { top: d - u2.top, bottom: u2.bottom - d } }, f3 = Math.min(a2.x.left, a2.x.right), l2 = Math.min(a2.y.top, a2.y.bottom), c2 = { row: e3.row, column: e3.column };
            f3 / s2 <= 2 && (c2.column += a2.x.left < a2.x.right ? -3 : 2), l2 / i2 <= 1 && (c2.row += a2.y.top < a2.y.bottom ? -1 : 1);
            var h2 = e3.row != c2.row, v2 = e3.column != c2.column, m2 = !n3 || e3.row != n3.row;
            h2 || v2 && !m2 ? E ? r2 - E >= o && t2.renderer.scrollCursorIntoView(c2) : E = r2 : E = null;
          }
          function C() {
            var e3 = g;
            g = t2.renderer.screenToTextCoordinates(p, d), T(g, e3), N(g, e3);
          }
          function k() {
            m = t2.selection.toOrientedRange(), h = t2.session.addMarker(m, "ace_selection", t2.getSelectionStyle()), t2.clearSelection(), t2.isFocused() && t2.renderer.$cursorLayer.setBlinking(false), clearInterval(v), C(), v = setInterval(C, 20), y = 0, i.addListener(document, "mousemove", O);
          }
          function L() {
            clearInterval(v), t2.session.removeMarker(h), h = null, t2.selection.fromOrientedRange(m), t2.isFocused() && !w && t2.$resetCursorStyle(), m = null, g = null, y = 0, E = null, S = null, i.removeListener(document, "mousemove", O);
          }
          function O() {
            A == null && (A = setTimeout(function() {
              A != null && h && L();
            }, 20));
          }
          function M(e3) {
            var t3 = e3.types;
            return !t3 || Array.prototype.some.call(t3, function(e4) {
              return e4 == "text/plain" || e4 == "Text";
            });
          }
          function _2(e3) {
            var t3 = ["copy", "copymove", "all", "uninitialized"], n3 = ["move", "copymove", "linkmove", "all", "uninitialized"], r2 = s.isMac ? e3.altKey : e3.ctrlKey, i2 = "uninitialized";
            try {
              i2 = e3.dataTransfer.effectAllowed.toLowerCase();
            } catch (e4) {
            }
            var o2 = "none";
            return r2 && t3.indexOf(i2) >= 0 ? o2 = "copy" : n3.indexOf(i2) >= 0 ? o2 = "move" : t3.indexOf(i2) >= 0 && (o2 = "copy"), o2;
          }
          var t2 = e2.editor, n2 = r.createElement("div");
          n2.style.cssText = "top:-100px;position:absolute;z-index:2147483647;opacity:0.5", n2.textContent = "\xA0";
          var f2 = ["dragWait", "dragWaitEnd", "startDrag", "dragReadyEnd", "onMouseDrag"];
          f2.forEach(function(t3) {
            e2[t3] = this[t3];
          }, this), t2.on("mousedown", this.onMouseDown.bind(e2));
          var c = t2.container, h, p, d, v, m, g, y = 0, b, w, E, S, x;
          this.onDragStart = function(e3) {
            if (this.cancelDrag || !c.draggable) {
              var r2 = this;
              return setTimeout(function() {
                r2.startSelect(), r2.captureMouse(e3);
              }, 0), e3.preventDefault();
            }
            m = t2.getSelectionRange();
            var i2 = e3.dataTransfer;
            i2.effectAllowed = t2.getReadOnly() ? "copy" : "copyMove", t2.container.appendChild(n2), i2.setDragImage && i2.setDragImage(n2, 0, 0), setTimeout(function() {
              t2.container.removeChild(n2);
            }), i2.clearData(), i2.setData("Text", t2.session.getTextRange()), w = true, this.setState("drag");
          }, this.onDragEnd = function(e3) {
            c.draggable = false, w = false, this.setState(null);
            if (!t2.getReadOnly()) {
              var n3 = e3.dataTransfer.dropEffect;
              !b && n3 == "move" && t2.session.remove(t2.getSelectionRange()), t2.$resetCursorStyle();
            }
            this.editor.unsetStyle("ace_dragging"), this.editor.renderer.setCursorStyle("");
          }, this.onDragEnter = function(e3) {
            if (t2.getReadOnly() || !M(e3.dataTransfer))
              return;
            return p = e3.clientX, d = e3.clientY, h || k(), y++, e3.dataTransfer.dropEffect = b = _2(e3), i.preventDefault(e3);
          }, this.onDragOver = function(e3) {
            if (t2.getReadOnly() || !M(e3.dataTransfer))
              return;
            return p = e3.clientX, d = e3.clientY, h || (k(), y++), A !== null && (A = null), e3.dataTransfer.dropEffect = b = _2(e3), i.preventDefault(e3);
          }, this.onDragLeave = function(e3) {
            y--;
            if (y <= 0 && h)
              return L(), b = null, i.preventDefault(e3);
          }, this.onDrop = function(e3) {
            if (!g)
              return;
            var n3 = e3.dataTransfer;
            if (w)
              switch (b) {
                case "move":
                  m.contains(g.row, g.column) ? m = { start: g, end: g } : m = t2.moveText(m, g);
                  break;
                case "copy":
                  m = t2.moveText(m, g, true);
              }
            else {
              var r2 = n3.getData("Text");
              m = { start: g, end: t2.session.insert(g, r2) }, t2.focus(), b = null;
            }
            return L(), i.preventDefault(e3);
          }, i.addListener(c, "dragstart", this.onDragStart.bind(e2), t2), i.addListener(c, "dragend", this.onDragEnd.bind(e2), t2), i.addListener(c, "dragenter", this.onDragEnter.bind(e2), t2), i.addListener(c, "dragover", this.onDragOver.bind(e2), t2), i.addListener(c, "dragleave", this.onDragLeave.bind(e2), t2), i.addListener(c, "drop", this.onDrop.bind(e2), t2);
          var A = null;
        }
        function l(e2, t2, n2, r2) {
          return Math.sqrt(Math.pow(n2 - e2, 2) + Math.pow(r2 - t2, 2));
        }
        var r = e("../lib/dom"), i = e("../lib/event"), s = e("../lib/useragent"), o = 200, u = 200, a = 5;
        (function() {
          this.dragWait = function() {
            var e2 = Date.now() - this.mousedownEvent.time;
            e2 > this.editor.getDragDelay() && this.startDrag();
          }, this.dragWaitEnd = function() {
            var e2 = this.editor.container;
            e2.draggable = false, this.startSelect(this.mousedownEvent.getDocumentPosition()), this.selectEnd();
          }, this.dragReadyEnd = function(e2) {
            this.editor.$resetCursorStyle(), this.editor.unsetStyle("ace_dragging"), this.editor.renderer.setCursorStyle(""), this.dragWaitEnd();
          }, this.startDrag = function() {
            this.cancelDrag = false;
            var e2 = this.editor, t2 = e2.container;
            t2.draggable = true, e2.renderer.$cursorLayer.setBlinking(false), e2.setStyle("ace_dragging");
            var n2 = s.isWin ? "default" : "move";
            e2.renderer.setCursorStyle(n2), this.setState("dragReady");
          }, this.onMouseDrag = function(e2) {
            var t2 = this.editor.container;
            if (s.isIE && this.state == "dragReady") {
              var n2 = l(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);
              n2 > 3 && t2.dragDrop();
            }
            if (this.state === "dragWait") {
              var n2 = l(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);
              n2 > 0 && (t2.draggable = false, this.startSelect(this.mousedownEvent.getDocumentPosition()));
            }
          }, this.onMouseDown = function(e2) {
            if (!this.$dragEnabled)
              return;
            this.mousedownEvent = e2;
            var t2 = this.editor, n2 = e2.inSelection(), r2 = e2.getButton(), i2 = e2.domEvent.detail || 1;
            if (i2 === 1 && r2 === 0 && n2) {
              if (e2.editor.inMultiSelectMode && (e2.getAccelKey() || e2.getShiftKey()))
                return;
              this.mousedownEvent.time = Date.now();
              var o2 = e2.domEvent.target || e2.domEvent.srcElement;
              "unselectable" in o2 && (o2.unselectable = "on");
              if (t2.getDragDelay()) {
                if (s.isWebKit) {
                  this.cancelDrag = true;
                  var u2 = t2.container;
                  u2.draggable = true;
                }
                this.setState("dragWait");
              } else
                this.startDrag();
              this.captureMouse(e2, this.onMouseDrag.bind(this)), e2.defaultPrevented = true;
            }
          };
        }).call(f.prototype), t.DragdropHandler = f;
      }), ace.define("ace/mouse/touch_handler", ["require", "exports", "module", "ace/mouse/mouse_event", "ace/lib/event", "ace/lib/dom"], function(e, t, n) {
        "use strict";
        var r = e("./mouse_event").MouseEvent, i = e("../lib/event"), s = e("../lib/dom");
        t.addTouchListeners = function(e2, t2) {
          function b() {
            var e3 = window.navigator && window.navigator.clipboard, r2 = false, i2 = function() {
              var n3 = t2.getCopyText(), i3 = t2.session.getUndoManager().hasUndo();
              y.replaceChild(s.buildDom(r2 ? ["span", !n3 && ["span", { "class": "ace_mobile-button", action: "selectall" }, "Select All"], n3 && ["span", { "class": "ace_mobile-button", action: "copy" }, "Copy"], n3 && ["span", { "class": "ace_mobile-button", action: "cut" }, "Cut"], e3 && ["span", { "class": "ace_mobile-button", action: "paste" }, "Paste"], i3 && ["span", { "class": "ace_mobile-button", action: "undo" }, "Undo"], ["span", { "class": "ace_mobile-button", action: "find" }, "Find"], ["span", { "class": "ace_mobile-button", action: "openCommandPallete" }, "Pallete"]] : ["span"]), y.firstChild);
            }, o2 = function(n3) {
              var s2 = n3.target.getAttribute("action");
              if (s2 == "more" || !r2)
                return r2 = !r2, i2();
              if (s2 == "paste")
                e3.readText().then(function(e4) {
                  t2.execCommand(s2, e4);
                });
              else if (s2) {
                if (s2 == "cut" || s2 == "copy")
                  e3 ? e3.writeText(t2.getCopyText()) : document.execCommand("copy");
                t2.execCommand(s2);
              }
              y.firstChild.style.display = "none", r2 = false, s2 != "openCommandPallete" && t2.focus();
            };
            y = s.buildDom(["div", { "class": "ace_mobile-menu", ontouchstart: function(e4) {
              n2 = "menu", e4.stopPropagation(), e4.preventDefault(), t2.textInput.focus();
            }, ontouchend: function(e4) {
              e4.stopPropagation(), e4.preventDefault(), o2(e4);
            }, onclick: o2 }, ["span"], ["span", { "class": "ace_mobile-button", action: "more" }, "..."]], t2.container);
          }
          function w() {
            y || b();
            var e3 = t2.selection.cursor, n3 = t2.renderer.textToScreenCoordinates(e3.row, e3.column), r2 = t2.renderer.textToScreenCoordinates(0, 0).pageX, i2 = t2.renderer.scrollLeft, s2 = t2.container.getBoundingClientRect();
            y.style.top = n3.pageY - s2.top - 3 + "px", n3.pageX - s2.left < s2.width - 70 ? (y.style.left = "", y.style.right = "10px") : (y.style.right = "", y.style.left = r2 + i2 - s2.left + "px"), y.style.display = "", y.firstChild.style.display = "none", t2.on("input", E);
          }
          function E(e3) {
            y && (y.style.display = "none"), t2.off("input", E);
          }
          function S() {
            l = null, clearTimeout(l);
            var e3 = t2.selection.getRange(), r2 = e3.contains(p.row, p.column);
            if (e3.isEmpty() || !r2)
              t2.selection.moveToPosition(p), t2.selection.selectWord();
            n2 = "wait", w();
          }
          function x() {
            l = null, clearTimeout(l), t2.selection.moveToPosition(p);
            var e3 = d >= 2 ? t2.selection.getLineRange(p.row) : t2.session.getBracketRange(p);
            e3 && !e3.isEmpty() ? t2.selection.setRange(e3) : t2.selection.selectWord(), n2 = "wait";
          }
          function T() {
            h += 60, c = setInterval(function() {
              h-- <= 0 && (clearInterval(c), c = null), Math.abs(v) < 0.01 && (v = 0), Math.abs(m) < 0.01 && (m = 0), h < 20 && (v = 0.9 * v), h < 20 && (m = 0.9 * m);
              var e3 = t2.session.getScrollTop();
              t2.renderer.scrollBy(10 * v, 10 * m), e3 == t2.session.getScrollTop() && (h = 0);
            }, 10);
          }
          var n2 = "scroll", o, u, a, f, l, c, h = 0, p, d = 0, v = 0, m = 0, g, y;
          i.addListener(e2, "contextmenu", function(e3) {
            if (!g)
              return;
            var n3 = t2.textInput.getElement();
            n3.focus();
          }, t2), i.addListener(e2, "touchstart", function(e3) {
            var i2 = e3.touches;
            if (l || i2.length > 1) {
              clearTimeout(l), l = null, a = -1, n2 = "zoom";
              return;
            }
            g = t2.$mouseHandler.isMousePressed = true;
            var s2 = t2.renderer.layerConfig.lineHeight, c2 = t2.renderer.layerConfig.lineHeight, y2 = e3.timeStamp;
            f = y2;
            var b2 = i2[0], w2 = b2.clientX, E2 = b2.clientY;
            Math.abs(o - w2) + Math.abs(u - E2) > s2 && (a = -1), o = e3.clientX = w2, u = e3.clientY = E2, v = m = 0;
            var T2 = new r(e3, t2);
            p = T2.getDocumentPosition();
            if (y2 - a < 500 && i2.length == 1 && !h)
              d++, e3.preventDefault(), e3.button = 0, x();
            else {
              d = 0;
              var N = t2.selection.cursor, C = t2.selection.isEmpty() ? N : t2.selection.anchor, k = t2.renderer.$cursorLayer.getPixelPosition(N, true), L = t2.renderer.$cursorLayer.getPixelPosition(C, true), A = t2.renderer.scroller.getBoundingClientRect(), O = t2.renderer.layerConfig.offset, M = t2.renderer.scrollLeft, _2 = function(e4, t3) {
                return e4 /= c2, t3 = t3 / s2 - 0.75, e4 * e4 + t3 * t3;
              };
              if (e3.clientX < A.left) {
                n2 = "zoom";
                return;
              }
              var D = _2(e3.clientX - A.left - k.left + M, e3.clientY - A.top - k.top + O), P = _2(e3.clientX - A.left - L.left + M, e3.clientY - A.top - L.top + O);
              D < 3.5 && P < 3.5 && (n2 = D > P ? "cursor" : "anchor"), P < 3.5 ? n2 = "anchor" : D < 3.5 ? n2 = "cursor" : n2 = "scroll", l = setTimeout(S, 450);
            }
            a = y2;
          }, t2), i.addListener(e2, "touchend", function(e3) {
            g = t2.$mouseHandler.isMousePressed = false, c && clearInterval(c), n2 == "zoom" ? (n2 = "", h = 0) : l ? (t2.selection.moveToPosition(p), h = 0, w()) : n2 == "scroll" ? (T(), E()) : w(), clearTimeout(l), l = null;
          }, t2), i.addListener(e2, "touchmove", function(e3) {
            l && (clearTimeout(l), l = null);
            var i2 = e3.touches;
            if (i2.length > 1 || n2 == "zoom")
              return;
            var s2 = i2[0], a2 = o - s2.clientX, c2 = u - s2.clientY;
            if (n2 == "wait") {
              if (!(a2 * a2 + c2 * c2 > 4))
                return e3.preventDefault();
              n2 = "cursor";
            }
            o = s2.clientX, u = s2.clientY, e3.clientX = s2.clientX, e3.clientY = s2.clientY;
            var h2 = e3.timeStamp, p2 = h2 - f;
            f = h2;
            if (n2 == "scroll") {
              var d2 = new r(e3, t2);
              d2.speed = 1, d2.wheelX = a2, d2.wheelY = c2, 10 * Math.abs(a2) < Math.abs(c2) && (a2 = 0), 10 * Math.abs(c2) < Math.abs(a2) && (c2 = 0), p2 != 0 && (v = a2 / p2, m = c2 / p2), t2._emit("mousewheel", d2), d2.propagationStopped || (v = m = 0);
            } else {
              var g2 = new r(e3, t2), y2 = g2.getDocumentPosition();
              n2 == "cursor" ? t2.selection.moveCursorToPosition(y2) : n2 == "anchor" && t2.selection.setSelectionAnchor(y2.row, y2.column), t2.renderer.scrollCursorIntoView(y2), e3.preventDefault();
            }
          }, t2);
        };
      }), ace.define("ace/lib/net", ["require", "exports", "module", "ace/lib/dom"], function(e, t, n) {
        "use strict";
        var r = e("./dom");
        t.get = function(e2, t2) {
          var n2 = new XMLHttpRequest();
          n2.open("GET", e2, true), n2.onreadystatechange = function() {
            n2.readyState === 4 && t2(n2.responseText);
          }, n2.send(null);
        }, t.loadScript = function(e2, t2) {
          var n2 = r.getDocumentHead(), i = document.createElement("script");
          i.src = e2, n2.appendChild(i), i.onload = i.onreadystatechange = function(e3, n3) {
            if (n3 || !i.readyState || i.readyState == "loaded" || i.readyState == "complete")
              i = i.onload = i.onreadystatechange = null, n3 || t2();
          };
        }, t.qualifyURL = function(e2) {
          var t2 = document.createElement("a");
          return t2.href = e2, t2.href;
        };
      }), ace.define("ace/lib/event_emitter", ["require", "exports", "module"], function(e, t, n) {
        "use strict";
        var r = {}, i = function() {
          this.propagationStopped = true;
        }, s = function() {
          this.defaultPrevented = true;
        };
        r._emit = r._dispatchEvent = function(e2, t2) {
          this._eventRegistry || (this._eventRegistry = {}), this._defaultHandlers || (this._defaultHandlers = {});
          var n2 = this._eventRegistry[e2] || [], r2 = this._defaultHandlers[e2];
          if (!n2.length && !r2)
            return;
          if (typeof t2 != "object" || !t2)
            t2 = {};
          t2.type || (t2.type = e2), t2.stopPropagation || (t2.stopPropagation = i), t2.preventDefault || (t2.preventDefault = s), n2 = n2.slice();
          for (var o = 0; o < n2.length; o++) {
            n2[o](t2, this);
            if (t2.propagationStopped)
              break;
          }
          if (r2 && !t2.defaultPrevented)
            return r2(t2, this);
        }, r._signal = function(e2, t2) {
          var n2 = (this._eventRegistry || {})[e2];
          if (!n2)
            return;
          n2 = n2.slice();
          for (var r2 = 0; r2 < n2.length; r2++)
            n2[r2](t2, this);
        }, r.once = function(e2, t2) {
          var n2 = this;
          this.on(e2, function r2() {
            n2.off(e2, r2), t2.apply(null, arguments);
          });
          if (!t2)
            return new Promise(function(e3) {
              t2 = e3;
            });
        }, r.setDefaultHandler = function(e2, t2) {
          var n2 = this._defaultHandlers;
          n2 || (n2 = this._defaultHandlers = { _disabled_: {} });
          if (n2[e2]) {
            var r2 = n2[e2], i2 = n2._disabled_[e2];
            i2 || (n2._disabled_[e2] = i2 = []), i2.push(r2);
            var s2 = i2.indexOf(t2);
            s2 != -1 && i2.splice(s2, 1);
          }
          n2[e2] = t2;
        }, r.removeDefaultHandler = function(e2, t2) {
          var n2 = this._defaultHandlers;
          if (!n2)
            return;
          var r2 = n2._disabled_[e2];
          if (n2[e2] == t2)
            r2 && this.setDefaultHandler(e2, r2.pop());
          else if (r2) {
            var i2 = r2.indexOf(t2);
            i2 != -1 && r2.splice(i2, 1);
          }
        }, r.on = r.addEventListener = function(e2, t2, n2) {
          this._eventRegistry = this._eventRegistry || {};
          var r2 = this._eventRegistry[e2];
          return r2 || (r2 = this._eventRegistry[e2] = []), r2.indexOf(t2) == -1 && r2[n2 ? "unshift" : "push"](t2), t2;
        }, r.off = r.removeListener = r.removeEventListener = function(e2, t2) {
          this._eventRegistry = this._eventRegistry || {};
          var n2 = this._eventRegistry[e2];
          if (!n2)
            return;
          var r2 = n2.indexOf(t2);
          r2 !== -1 && n2.splice(r2, 1);
        }, r.removeAllListeners = function(e2) {
          e2 || (this._eventRegistry = this._defaultHandlers = void 0), this._eventRegistry && (this._eventRegistry[e2] = void 0), this._defaultHandlers && (this._defaultHandlers[e2] = void 0);
        }, t.EventEmitter = r;
      }), ace.define("ace/lib/app_config", ["require", "exports", "module", "ace/lib/oop", "ace/lib/event_emitter"], function(e, t, n) {
        "no use strict";
        function o(e2) {
          typeof console != "undefined" && console.warn && console.warn.apply(console, arguments);
        }
        function u(e2, t2) {
          var n2 = new Error(e2);
          n2.data = t2, typeof console == "object" && console.error && console.error(n2), setTimeout(function() {
            throw n2;
          });
        }
        var r = e("./oop"), i = e("./event_emitter").EventEmitter, s = { setOptions: function(e2) {
          Object.keys(e2).forEach(function(t2) {
            this.setOption(t2, e2[t2]);
          }, this);
        }, getOptions: function(e2) {
          var t2 = {};
          if (!e2) {
            var n2 = this.$options;
            e2 = Object.keys(n2).filter(function(e3) {
              return !n2[e3].hidden;
            });
          } else
            Array.isArray(e2) || (t2 = e2, e2 = Object.keys(t2));
          return e2.forEach(function(e3) {
            t2[e3] = this.getOption(e3);
          }, this), t2;
        }, setOption: function(e2, t2) {
          if (this["$" + e2] === t2)
            return;
          var n2 = this.$options[e2];
          if (!n2)
            return o('misspelled option "' + e2 + '"');
          if (n2.forwardTo)
            return this[n2.forwardTo] && this[n2.forwardTo].setOption(e2, t2);
          n2.handlesSet || (this["$" + e2] = t2), n2 && n2.set && n2.set.call(this, t2);
        }, getOption: function(e2) {
          var t2 = this.$options[e2];
          return t2 ? t2.forwardTo ? this[t2.forwardTo] && this[t2.forwardTo].getOption(e2) : t2 && t2.get ? t2.get.call(this) : this["$" + e2] : o('misspelled option "' + e2 + '"');
        } }, a = function() {
          this.$defaultOptions = {};
        };
        (function() {
          r.implement(this, i), this.defineOptions = function(e2, t2, n2) {
            return e2.$options || (this.$defaultOptions[t2] = e2.$options = {}), Object.keys(n2).forEach(function(t3) {
              var r2 = n2[t3];
              typeof r2 == "string" && (r2 = { forwardTo: r2 }), r2.name || (r2.name = t3), e2.$options[r2.name] = r2, "initialValue" in r2 && (e2["$" + r2.name] = r2.initialValue);
            }), r.implement(e2, s), this;
          }, this.resetOptions = function(e2) {
            Object.keys(e2.$options).forEach(function(t2) {
              var n2 = e2.$options[t2];
              "value" in n2 && e2.setOption(t2, n2.value);
            });
          }, this.setDefaultValue = function(e2, t2, n2) {
            if (!e2) {
              for (e2 in this.$defaultOptions)
                if (this.$defaultOptions[e2][t2])
                  break;
              if (!this.$defaultOptions[e2][t2])
                return false;
            }
            var r2 = this.$defaultOptions[e2] || (this.$defaultOptions[e2] = {});
            r2[t2] && (r2.forwardTo ? this.setDefaultValue(r2.forwardTo, t2, n2) : r2[t2].value = n2);
          }, this.setDefaultValues = function(e2, t2) {
            Object.keys(t2).forEach(function(n2) {
              this.setDefaultValue(e2, n2, t2[n2]);
            }, this);
          }, this.warn = o, this.reportError = u;
        }).call(a.prototype), t.AppConfig = a;
      }), ace.define("ace/config", ["require", "exports", "module", "ace/lib/lang", "ace/lib/oop", "ace/lib/net", "ace/lib/dom", "ace/lib/app_config"], function(e, t, n) {
        "no use strict";
        function c(r2) {
          if (!a || !a.document)
            return;
          f.packaged = r2 || e.packaged || n.packaged || a.define && define.packaged;
          var i2 = {}, s2 = "", o2 = document.currentScript || document._currentScript, u2 = o2 && o2.ownerDocument || document, l2 = u2.getElementsByTagName("script");
          for (var c2 = 0; c2 < l2.length; c2++) {
            var p = l2[c2], d = p.src || p.getAttribute("src");
            if (!d)
              continue;
            var v = p.attributes;
            for (var m = 0, g = v.length; m < g; m++) {
              var y = v[m];
              y.name.indexOf("data-ace-") === 0 && (i2[h(y.name.replace(/^data-ace-/, ""))] = y.value);
            }
            var b = d.match(/^(.*)\/ace(\-\w+)?\.js(\?|$)/);
            b && (s2 = b[1]);
          }
          s2 && (i2.base = i2.base || s2, i2.packaged = true), i2.basePath = i2.base, i2.workerPath = i2.workerPath || i2.base, i2.modePath = i2.modePath || i2.base, i2.themePath = i2.themePath || i2.base, delete i2.base;
          for (var w in i2)
            typeof i2[w] != "undefined" && t.set(w, i2[w]);
        }
        function h(e2) {
          return e2.replace(/-(.)/g, function(e3, t2) {
            return t2.toUpperCase();
          });
        }
        var r = e("./lib/lang"), i = e("./lib/oop"), s = e("./lib/net"), o = e("./lib/dom"), u = e("./lib/app_config").AppConfig;
        n.exports = t = new u();
        var a = /* @__PURE__ */ function() {
          return this || typeof window != "undefined" && window;
        }(), f = { packaged: false, workerPath: null, modePath: null, themePath: null, basePath: "", suffix: ".js", $moduleUrls: {}, loadWorkerFromBlob: true, sharedPopups: false, useStrictCSP: null };
        t.get = function(e2) {
          if (!f.hasOwnProperty(e2))
            throw new Error("Unknown config key: " + e2);
          return f[e2];
        }, t.set = function(e2, t2) {
          if (f.hasOwnProperty(e2))
            f[e2] = t2;
          else if (this.setDefaultValue("", e2, t2) == 0)
            throw new Error("Unknown config key: " + e2);
          e2 == "useStrictCSP" && o.useStrictCSP(t2);
        }, t.all = function() {
          return r.copyObject(f);
        }, t.$modes = {}, t.moduleUrl = function(e2, t2) {
          if (f.$moduleUrls[e2])
            return f.$moduleUrls[e2];
          var n2 = e2.split("/");
          t2 = t2 || n2[n2.length - 2] || "";
          var r2 = t2 == "snippets" ? "/" : "-", i2 = n2[n2.length - 1];
          if (t2 == "worker" && r2 == "-") {
            var s2 = new RegExp("^" + t2 + "[\\-_]|[\\-_]" + t2 + "$", "g");
            i2 = i2.replace(s2, "");
          }
          (!i2 || i2 == t2) && n2.length > 1 && (i2 = n2[n2.length - 2]);
          var o2 = f[t2 + "Path"];
          return o2 == null ? o2 = f.basePath : r2 == "/" && (t2 = r2 = ""), o2 && o2.slice(-1) != "/" && (o2 += "/"), o2 + t2 + r2 + i2 + this.get("suffix");
        }, t.setModuleUrl = function(e2, t2) {
          return f.$moduleUrls[e2] = t2;
        }, t.$loading = {}, t.loadModule = function(n2, r2) {
          var i2, o2;
          Array.isArray(n2) && (o2 = n2[0], n2 = n2[1]);
          try {
            i2 = e(n2);
          } catch (u2) {
          }
          if (i2 && !t.$loading[n2])
            return r2 && r2(i2);
          t.$loading[n2] || (t.$loading[n2] = []), t.$loading[n2].push(r2);
          if (t.$loading[n2].length > 1)
            return;
          var a2 = function() {
            e([n2], function(e2) {
              t._emit("load.module", { name: n2, module: e2 });
              var r3 = t.$loading[n2];
              t.$loading[n2] = null, r3.forEach(function(t2) {
                t2 && t2(e2);
              });
            });
          };
          if (!t.get("packaged"))
            return a2();
          s.loadScript(t.moduleUrl(n2, o2), a2), l();
        };
        var l = function() {
          !f.basePath && !f.workerPath && !f.modePath && !f.themePath && !Object.keys(f.$moduleUrls).length && (console.error("Unable to infer path to ace from script src,", "use ace.config.set('basePath', 'path') to enable dynamic loading of modes and themes", "or with webpack use ace/webpack-resolver"), l = function() {
          });
        };
        t.init = c, t.version = "1.6.0";
      }), ace.define("ace/mouse/mouse_handler", ["require", "exports", "module", "ace/lib/event", "ace/lib/useragent", "ace/mouse/default_handlers", "ace/mouse/default_gutter_handler", "ace/mouse/mouse_event", "ace/mouse/dragdrop_handler", "ace/mouse/touch_handler", "ace/config"], function(e, t, n) {
        "use strict";
        var r = e("../lib/event"), i = e("../lib/useragent"), s = e("./default_handlers").DefaultHandlers, o = e("./default_gutter_handler").GutterHandler, u = e("./mouse_event").MouseEvent, a = e("./dragdrop_handler").DragdropHandler, f = e("./touch_handler").addTouchListeners, l = e("../config"), c = function(e2) {
          var t2 = this;
          this.editor = e2, new s(this), new o(this), new a(this);
          var n2 = function(t3) {
            var n3 = !document.hasFocus || !document.hasFocus() || !e2.isFocused() && document.activeElement == (e2.textInput && e2.textInput.getElement());
            n3 && window.focus(), e2.focus(), setTimeout(function() {
              e2.isFocused() || e2.focus();
            });
          }, u2 = e2.renderer.getMouseEventTarget();
          r.addListener(u2, "click", this.onMouseEvent.bind(this, "click"), e2), r.addListener(u2, "mousemove", this.onMouseMove.bind(this, "mousemove"), e2), r.addMultiMouseDownListener([u2, e2.renderer.scrollBarV && e2.renderer.scrollBarV.inner, e2.renderer.scrollBarH && e2.renderer.scrollBarH.inner, e2.textInput && e2.textInput.getElement()].filter(Boolean), [400, 300, 250], this, "onMouseEvent", e2), r.addMouseWheelListener(e2.container, this.onMouseWheel.bind(this, "mousewheel"), e2), f(e2.container, e2);
          var l2 = e2.renderer.$gutter;
          r.addListener(l2, "mousedown", this.onMouseEvent.bind(this, "guttermousedown"), e2), r.addListener(l2, "click", this.onMouseEvent.bind(this, "gutterclick"), e2), r.addListener(l2, "dblclick", this.onMouseEvent.bind(this, "gutterdblclick"), e2), r.addListener(l2, "mousemove", this.onMouseEvent.bind(this, "guttermousemove"), e2), r.addListener(u2, "mousedown", n2, e2), r.addListener(l2, "mousedown", n2, e2), i.isIE && e2.renderer.scrollBarV && (r.addListener(e2.renderer.scrollBarV.element, "mousedown", n2, e2), r.addListener(e2.renderer.scrollBarH.element, "mousedown", n2, e2)), e2.on("mousemove", function(n3) {
            if (t2.state || t2.$dragDelay || !t2.$dragEnabled)
              return;
            var r2 = e2.renderer.screenToTextCoordinates(n3.x, n3.y), i2 = e2.session.selection.getRange(), s2 = e2.renderer;
            !i2.isEmpty() && i2.insideStart(r2.row, r2.column) ? s2.setCursorStyle("default") : s2.setCursorStyle("");
          }, e2);
        };
        (function() {
          this.onMouseEvent = function(e2, t2) {
            if (!this.editor.session)
              return;
            this.editor._emit(e2, new u(t2, this.editor));
          }, this.onMouseMove = function(e2, t2) {
            var n2 = this.editor._eventRegistry && this.editor._eventRegistry.mousemove;
            if (!n2 || !n2.length)
              return;
            this.editor._emit(e2, new u(t2, this.editor));
          }, this.onMouseWheel = function(e2, t2) {
            var n2 = new u(t2, this.editor);
            n2.speed = this.$scrollSpeed * 2, n2.wheelX = t2.wheelX, n2.wheelY = t2.wheelY, this.editor._emit(e2, n2);
          }, this.setState = function(e2) {
            this.state = e2;
          }, this.captureMouse = function(e2, t2) {
            this.x = e2.x, this.y = e2.y, this.isMousePressed = true;
            var n2 = this.editor, s2 = this.editor.renderer;
            s2.$isMousePressed = true;
            var o2 = this, a2 = function(e3) {
              if (!e3)
                return;
              if (i.isWebKit && !e3.which && o2.releaseMouse)
                return o2.releaseMouse();
              o2.x = e3.clientX, o2.y = e3.clientY, t2 && t2(e3), o2.mouseEvent = new u(e3, o2.editor), o2.$mouseMoved = true;
            }, f2 = function(e3) {
              n2.off("beforeEndOperation", c2), clearInterval(h), n2.session && l2(), o2[o2.state + "End"] && o2[o2.state + "End"](e3), o2.state = "", o2.isMousePressed = s2.$isMousePressed = false, s2.$keepTextAreaAtCursor && s2.$moveTextAreaToCursor(), o2.$onCaptureMouseMove = o2.releaseMouse = null, e3 && o2.onMouseEvent("mouseup", e3), n2.endOperation();
            }, l2 = function() {
              o2[o2.state] && o2[o2.state](), o2.$mouseMoved = false;
            };
            if (i.isOldIE && e2.domEvent.type == "dblclick")
              return setTimeout(function() {
                f2(e2);
              });
            var c2 = function(e3) {
              if (!o2.releaseMouse)
                return;
              n2.curOp.command.name && n2.curOp.selectionChanged && (o2[o2.state + "End"] && o2[o2.state + "End"](), o2.state = "", o2.releaseMouse());
            };
            n2.on("beforeEndOperation", c2), n2.startOperation({ command: { name: "mouse" } }), o2.$onCaptureMouseMove = a2, o2.releaseMouse = r.capture(this.editor.container, a2, f2);
            var h = setInterval(l2, 20);
          }, this.releaseMouse = null, this.cancelContextMenu = function() {
            var e2 = function(t2) {
              if (t2 && t2.domEvent && t2.domEvent.type != "contextmenu")
                return;
              this.editor.off("nativecontextmenu", e2), t2 && t2.domEvent && r.stopEvent(t2.domEvent);
            }.bind(this);
            setTimeout(e2, 10), this.editor.on("nativecontextmenu", e2);
          }, this.destroy = function() {
            this.releaseMouse && this.releaseMouse();
          };
        }).call(c.prototype), l.defineOptions(c.prototype, "mouseHandler", { scrollSpeed: { initialValue: 2 }, dragDelay: { initialValue: i.isMac ? 150 : 0 }, dragEnabled: { initialValue: true }, focusTimeout: { initialValue: 0 }, tooltipFollowsMouse: { initialValue: true } }), t.MouseHandler = c;
      }), ace.define("ace/mouse/fold_handler", ["require", "exports", "module", "ace/lib/dom"], function(e, t, n) {
        "use strict";
        function i(e2) {
          e2.on("click", function(t2) {
            var n2 = t2.getDocumentPosition(), i2 = e2.session, s = i2.getFoldAt(n2.row, n2.column, 1);
            s && (t2.getAccelKey() ? i2.removeFold(s) : i2.expandFold(s), t2.stop());
            var o = t2.domEvent && t2.domEvent.target;
            o && r.hasCssClass(o, "ace_inline_button") && r.hasCssClass(o, "ace_toggle_wrap") && (i2.setOption("wrap", !i2.getUseWrapMode()), e2.renderer.scrollCursorIntoView());
          }), e2.on("gutterclick", function(t2) {
            var n2 = e2.renderer.$gutterLayer.getRegion(t2);
            if (n2 == "foldWidgets") {
              var r2 = t2.getDocumentPosition().row, i2 = e2.session;
              i2.foldWidgets && i2.foldWidgets[r2] && e2.session.onFoldWidgetClick(r2, t2), e2.isFocused() || e2.focus(), t2.stop();
            }
          }), e2.on("gutterdblclick", function(t2) {
            var n2 = e2.renderer.$gutterLayer.getRegion(t2);
            if (n2 == "foldWidgets") {
              var r2 = t2.getDocumentPosition().row, i2 = e2.session, s = i2.getParentFoldRangeData(r2, true), o = s.range || s.firstRange;
              if (o) {
                r2 = o.start.row;
                var u = i2.getFoldAt(r2, i2.getLine(r2).length, 1);
                u ? i2.removeFold(u) : (i2.addFold("...", o), e2.renderer.scrollCursorIntoView({ row: o.start.row, column: 0 }));
              }
              t2.stop();
            }
          });
        }
        var r = e("../lib/dom");
        t.FoldHandler = i;
      }), ace.define("ace/keyboard/keybinding", ["require", "exports", "module", "ace/lib/keys", "ace/lib/event"], function(e, t, n) {
        "use strict";
        var r = e("../lib/keys"), i = e("../lib/event"), s = function(e2) {
          this.$editor = e2, this.$data = { editor: e2 }, this.$handlers = [], this.setDefaultHandler(e2.commands);
        };
        (function() {
          this.setDefaultHandler = function(e2) {
            this.removeKeyboardHandler(this.$defaultHandler), this.$defaultHandler = e2, this.addKeyboardHandler(e2, 0);
          }, this.setKeyboardHandler = function(e2) {
            var t2 = this.$handlers;
            if (t2[t2.length - 1] == e2)
              return;
            while (t2[t2.length - 1] && t2[t2.length - 1] != this.$defaultHandler)
              this.removeKeyboardHandler(t2[t2.length - 1]);
            this.addKeyboardHandler(e2, 1);
          }, this.addKeyboardHandler = function(e2, t2) {
            if (!e2)
              return;
            typeof e2 == "function" && !e2.handleKeyboard && (e2.handleKeyboard = e2);
            var n2 = this.$handlers.indexOf(e2);
            n2 != -1 && this.$handlers.splice(n2, 1), t2 == void 0 ? this.$handlers.push(e2) : this.$handlers.splice(t2, 0, e2), n2 == -1 && e2.attach && e2.attach(this.$editor);
          }, this.removeKeyboardHandler = function(e2) {
            var t2 = this.$handlers.indexOf(e2);
            return t2 == -1 ? false : (this.$handlers.splice(t2, 1), e2.detach && e2.detach(this.$editor), true);
          }, this.getKeyboardHandler = function() {
            return this.$handlers[this.$handlers.length - 1];
          }, this.getStatusText = function() {
            var e2 = this.$data, t2 = e2.editor;
            return this.$handlers.map(function(n2) {
              return n2.getStatusText && n2.getStatusText(t2, e2) || "";
            }).filter(Boolean).join(" ");
          }, this.$callKeyboardHandlers = function(e2, t2, n2, r2) {
            var s2, o = false, u = this.$editor.commands;
            for (var a = this.$handlers.length; a--; ) {
              s2 = this.$handlers[a].handleKeyboard(this.$data, e2, t2, n2, r2);
              if (!s2 || !s2.command)
                continue;
              s2.command == "null" ? o = true : o = u.exec(s2.command, this.$editor, s2.args, r2), o && r2 && e2 != -1 && s2.passEvent != 1 && s2.command.passEvent != 1 && i.stopEvent(r2);
              if (o)
                break;
            }
            return !o && e2 == -1 && (s2 = { command: "insertstring" }, o = u.exec("insertstring", this.$editor, t2)), o && this.$editor._signal && this.$editor._signal("keyboardActivity", s2), o;
          }, this.onCommandKey = function(e2, t2, n2) {
            var i2 = r.keyCodeToString(n2);
            return this.$callKeyboardHandlers(t2, i2, n2, e2);
          }, this.onTextInput = function(e2) {
            return this.$callKeyboardHandlers(-1, e2);
          };
        }).call(s.prototype), t.KeyBinding = s;
      }), ace.define("ace/lib/bidiutil", ["require", "exports", "module"], function(e, t, n) {
        "use strict";
        function F(e2, t2, n2, r2) {
          var i2 = s ? d : p, c2 = null, h2 = null, v2 = null, m2 = 0, g2 = null, y2 = null, b2 = -1, w2 = null, E2 = null, T2 = [];
          if (!r2)
            for (w2 = 0, r2 = []; w2 < n2; w2++)
              r2[w2] = R(e2[w2]);
          o = s, u = false, a = false, f = false, l = false;
          for (E2 = 0; E2 < n2; E2++) {
            c2 = m2, T2[E2] = h2 = q(e2, r2, T2, E2), m2 = i2[c2][h2], g2 = m2 & 240, m2 &= 15, t2[E2] = v2 = i2[m2][5];
            if (g2 > 0)
              if (g2 == 16) {
                for (w2 = b2; w2 < E2; w2++)
                  t2[w2] = 1;
                b2 = -1;
              } else
                b2 = -1;
            y2 = i2[m2][6];
            if (y2)
              b2 == -1 && (b2 = E2);
            else if (b2 > -1) {
              for (w2 = b2; w2 < E2; w2++)
                t2[w2] = v2;
              b2 = -1;
            }
            r2[E2] == S && (t2[E2] = 0), o |= v2;
          }
          if (l) {
            for (w2 = 0; w2 < n2; w2++)
              if (r2[w2] == x) {
                t2[w2] = s;
                for (var C2 = w2 - 1; C2 >= 0; C2--) {
                  if (r2[C2] != N)
                    break;
                  t2[C2] = s;
                }
              }
          }
        }
        function I(e2, t2, n2) {
          if (o < e2)
            return;
          if (e2 == 1 && s == m && !f) {
            n2.reverse();
            return;
          }
          var r2 = n2.length, i2 = 0, u2, a2, l2, c2;
          while (i2 < r2) {
            if (t2[i2] >= e2) {
              u2 = i2 + 1;
              while (u2 < r2 && t2[u2] >= e2)
                u2++;
              for (a2 = i2, l2 = u2 - 1; a2 < l2; a2++, l2--)
                c2 = n2[a2], n2[a2] = n2[l2], n2[l2] = c2;
              i2 = u2;
            }
            i2++;
          }
        }
        function q(e2, t2, n2, r2) {
          var i2 = t2[r2], o2, c2, h2, p2;
          switch (i2) {
            case g:
            case y:
              u = false;
            case E:
            case w:
              return i2;
            case b:
              return u ? w : b;
            case T:
              return u = true, a = true, y;
            case N:
              return E;
            case C:
              if (r2 < 1 || r2 + 1 >= t2.length || (o2 = n2[r2 - 1]) != b && o2 != w || (c2 = t2[r2 + 1]) != b && c2 != w)
                return E;
              return u && (c2 = w), c2 == o2 ? c2 : E;
            case k:
              o2 = r2 > 0 ? n2[r2 - 1] : S;
              if (o2 == b && r2 + 1 < t2.length && t2[r2 + 1] == b)
                return b;
              return E;
            case L:
              if (r2 > 0 && n2[r2 - 1] == b)
                return b;
              if (u)
                return E;
              p2 = r2 + 1, h2 = t2.length;
              while (p2 < h2 && t2[p2] == L)
                p2++;
              if (p2 < h2 && t2[p2] == b)
                return b;
              return E;
            case A:
              h2 = t2.length, p2 = r2 + 1;
              while (p2 < h2 && t2[p2] == A)
                p2++;
              if (p2 < h2) {
                var d2 = e2[r2], v2 = d2 >= 1425 && d2 <= 2303 || d2 == 64286;
                o2 = t2[p2];
                if (v2 && (o2 == y || o2 == T))
                  return y;
              }
              if (r2 < 1 || (o2 = t2[r2 - 1]) == S)
                return E;
              return n2[r2 - 1];
            case S:
              return u = false, f = true, s;
            case x:
              return l = true, E;
            case O:
            case M:
            case D:
            case P:
            case _2:
              u = false;
            case H:
              return E;
          }
        }
        function R(e2) {
          var t2 = e2.charCodeAt(0), n2 = t2 >> 8;
          return n2 == 0 ? t2 > 191 ? g : B[t2] : n2 == 5 ? /[\u0591-\u05f4]/.test(e2) ? y : g : n2 == 6 ? /[\u0610-\u061a\u064b-\u065f\u06d6-\u06e4\u06e7-\u06ed]/.test(e2) ? A : /[\u0660-\u0669\u066b-\u066c]/.test(e2) ? w : t2 == 1642 ? L : /[\u06f0-\u06f9]/.test(e2) ? b : T : n2 == 32 && t2 <= 8287 ? j[t2 & 255] : n2 == 254 ? t2 >= 65136 ? T : E : E;
        }
        function U(e2) {
          return e2 >= "\u064B" && e2 <= "\u0655";
        }
        var r = ["\u0621", "\u0641"], i = ["\u063A", "\u064A"], s = 0, o = 0, u = false, a = false, f = false, l = false, c = false, h = false, p = [[0, 3, 0, 1, 0, 0, 0], [0, 3, 0, 1, 2, 2, 0], [0, 3, 0, 17, 2, 0, 1], [0, 3, 5, 5, 4, 1, 0], [0, 3, 21, 21, 4, 0, 1], [0, 3, 5, 5, 4, 2, 0]], d = [[2, 0, 1, 1, 0, 1, 0], [2, 0, 1, 1, 0, 2, 0], [2, 0, 2, 1, 3, 2, 0], [2, 0, 2, 33, 3, 1, 1]], v = 0, m = 1, g = 0, y = 1, b = 2, w = 3, E = 4, S = 5, x = 6, T = 7, N = 8, C = 9, k = 10, L = 11, A = 12, O = 13, M = 14, _2 = 15, D = 16, P = 17, H = 18, B = [H, H, H, H, H, H, H, H, H, x, S, x, N, S, H, H, H, H, H, H, H, H, H, H, H, H, H, H, S, S, S, x, N, E, E, L, L, L, E, E, E, E, E, k, C, k, C, C, b, b, b, b, b, b, b, b, b, b, C, E, E, E, E, E, E, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, E, E, E, E, E, E, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, E, E, E, E, H, H, H, H, H, H, S, H, H, H, H, H, H, H, H, H, H, H, H, H, H, H, H, H, H, H, H, H, H, H, H, H, H, C, E, L, L, L, L, E, E, E, E, g, E, E, H, E, E, L, L, b, b, E, g, E, E, E, b, g, E, E, E, E, E], j = [N, N, N, N, N, N, N, N, N, N, N, H, H, H, g, y, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, N, S, O, M, _2, D, P, C, L, L, L, L, L, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, C, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, N];
        t.L = g, t.R = y, t.EN = b, t.ON_R = 3, t.AN = 4, t.R_H = 5, t.B = 6, t.RLE = 7, t.DOT = "\xB7", t.doBidiReorder = function(e2, n2, r2) {
          if (e2.length < 2)
            return {};
          var i2 = e2.split(""), o2 = new Array(i2.length), u2 = new Array(i2.length), a2 = [];
          s = r2 ? m : v, F(i2, a2, i2.length, n2);
          for (var f2 = 0; f2 < o2.length; o2[f2] = f2, f2++)
            ;
          I(2, a2, o2), I(1, a2, o2);
          for (var f2 = 0; f2 < o2.length - 1; f2++)
            n2[f2] === w ? a2[f2] = t.AN : a2[f2] === y && (n2[f2] > T && n2[f2] < O || n2[f2] === E || n2[f2] === H) ? a2[f2] = t.ON_R : f2 > 0 && i2[f2 - 1] === "\u0644" && /\u0622|\u0623|\u0625|\u0627/.test(i2[f2]) && (a2[f2 - 1] = a2[f2] = t.R_H, f2++);
          i2[i2.length - 1] === t.DOT && (a2[i2.length - 1] = t.B), i2[0] === "\u202B" && (a2[0] = t.RLE);
          for (var f2 = 0; f2 < o2.length; f2++)
            u2[f2] = a2[o2[f2]];
          return { logicalFromVisual: o2, bidiLevels: u2 };
        }, t.hasBidiCharacters = function(e2, t2) {
          var n2 = false;
          for (var r2 = 0; r2 < e2.length; r2++)
            t2[r2] = R(e2.charAt(r2)), !n2 && (t2[r2] == y || t2[r2] == T || t2[r2] == w) && (n2 = true);
          return n2;
        }, t.getVisualFromLogicalIdx = function(e2, t2) {
          for (var n2 = 0; n2 < t2.logicalFromVisual.length; n2++)
            if (t2.logicalFromVisual[n2] == e2)
              return n2;
          return 0;
        };
      }), ace.define("ace/bidihandler", ["require", "exports", "module", "ace/lib/bidiutil", "ace/lib/lang"], function(e, t, n) {
        "use strict";
        var r = e("./lib/bidiutil"), i = e("./lib/lang"), s = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\u202B]/, o = function(e2) {
          this.session = e2, this.bidiMap = {}, this.currentRow = null, this.bidiUtil = r, this.charWidths = [], this.EOL = "\xAC", this.showInvisibles = true, this.isRtlDir = false, this.$isRtl = false, this.line = "", this.wrapIndent = 0, this.EOF = "\xB6", this.RLE = "\u202B", this.contentWidth = 0, this.fontMetrics = null, this.rtlLineOffset = 0, this.wrapOffset = 0, this.isMoveLeftOperation = false, this.seenBidi = s.test(e2.getValue());
        };
        (function() {
          this.isBidiRow = function(e2, t2, n2) {
            return this.seenBidi ? (e2 !== this.currentRow && (this.currentRow = e2, this.updateRowLine(t2, n2), this.updateBidiMap()), this.bidiMap.bidiLevels) : false;
          }, this.onChange = function(e2) {
            this.seenBidi ? this.currentRow = null : e2.action == "insert" && s.test(e2.lines.join("\n")) && (this.seenBidi = true, this.currentRow = null);
          }, this.getDocumentRow = function() {
            var e2 = 0, t2 = this.session.$screenRowCache;
            if (t2.length) {
              var n2 = this.session.$getRowCacheIndex(t2, this.currentRow);
              n2 >= 0 && (e2 = this.session.$docRowCache[n2]);
            }
            return e2;
          }, this.getSplitIndex = function() {
            var e2 = 0, t2 = this.session.$screenRowCache;
            if (t2.length) {
              var n2, r2 = this.session.$getRowCacheIndex(t2, this.currentRow);
              while (this.currentRow - e2 > 0) {
                n2 = this.session.$getRowCacheIndex(t2, this.currentRow - e2 - 1);
                if (n2 !== r2)
                  break;
                r2 = n2, e2++;
              }
            } else
              e2 = this.currentRow;
            return e2;
          }, this.updateRowLine = function(e2, t2) {
            e2 === void 0 && (e2 = this.getDocumentRow());
            var n2 = e2 === this.session.getLength() - 1, s2 = n2 ? this.EOF : this.EOL;
            this.wrapIndent = 0, this.line = this.session.getLine(e2), this.isRtlDir = this.$isRtl || this.line.charAt(0) === this.RLE;
            if (this.session.$useWrapMode) {
              var o2 = this.session.$wrapData[e2];
              o2 && (t2 === void 0 && (t2 = this.getSplitIndex()), t2 > 0 && o2.length ? (this.wrapIndent = o2.indent, this.wrapOffset = this.wrapIndent * this.charWidths[r.L], this.line = t2 < o2.length ? this.line.substring(o2[t2 - 1], o2[t2]) : this.line.substring(o2[o2.length - 1])) : this.line = this.line.substring(0, o2[t2])), t2 == o2.length && (this.line += this.showInvisibles ? s2 : r.DOT);
            } else
              this.line += this.showInvisibles ? s2 : r.DOT;
            var u = this.session, a = 0, f;
            this.line = this.line.replace(/\t|[\u1100-\u2029, \u202F-\uFFE6]/g, function(e3, t3) {
              return e3 === "	" || u.isFullWidth(e3.charCodeAt(0)) ? (f = e3 === "	" ? u.getScreenTabSize(t3 + a) : 2, a += f - 1, i.stringRepeat(r.DOT, f)) : e3;
            }), this.isRtlDir && (this.fontMetrics.$main.textContent = this.line.charAt(this.line.length - 1) == r.DOT ? this.line.substr(0, this.line.length - 1) : this.line, this.rtlLineOffset = this.contentWidth - this.fontMetrics.$main.getBoundingClientRect().width);
          }, this.updateBidiMap = function() {
            var e2 = [];
            r.hasBidiCharacters(this.line, e2) || this.isRtlDir ? this.bidiMap = r.doBidiReorder(this.line, e2, this.isRtlDir) : this.bidiMap = {};
          }, this.markAsDirty = function() {
            this.currentRow = null;
          }, this.updateCharacterWidths = function(e2) {
            if (this.characterWidth === e2.$characterSize.width)
              return;
            this.fontMetrics = e2;
            var t2 = this.characterWidth = e2.$characterSize.width, n2 = e2.$measureCharWidth("\u05D4");
            this.charWidths[r.L] = this.charWidths[r.EN] = this.charWidths[r.ON_R] = t2, this.charWidths[r.R] = this.charWidths[r.AN] = n2, this.charWidths[r.R_H] = n2 * 0.45, this.charWidths[r.B] = this.charWidths[r.RLE] = 0, this.currentRow = null;
          }, this.setShowInvisibles = function(e2) {
            this.showInvisibles = e2, this.currentRow = null;
          }, this.setEolChar = function(e2) {
            this.EOL = e2;
          }, this.setContentWidth = function(e2) {
            this.contentWidth = e2;
          }, this.isRtlLine = function(e2) {
            return this.$isRtl ? true : e2 != void 0 ? this.session.getLine(e2).charAt(0) == this.RLE : this.isRtlDir;
          }, this.setRtlDirection = function(e2, t2) {
            var n2 = e2.getCursorPosition();
            for (var r2 = e2.selection.getSelectionAnchor().row; r2 <= n2.row; r2++)
              !t2 && e2.session.getLine(r2).charAt(0) === e2.session.$bidiHandler.RLE ? e2.session.doc.removeInLine(r2, 0, 1) : t2 && e2.session.getLine(r2).charAt(0) !== e2.session.$bidiHandler.RLE && e2.session.doc.insert({ column: 0, row: r2 }, e2.session.$bidiHandler.RLE);
          }, this.getPosLeft = function(e2) {
            e2 -= this.wrapIndent;
            var t2 = this.line.charAt(0) === this.RLE ? 1 : 0, n2 = e2 > t2 ? this.session.getOverwrite() ? e2 : e2 - 1 : t2, i2 = r.getVisualFromLogicalIdx(n2, this.bidiMap), s2 = this.bidiMap.bidiLevels, o2 = 0;
            !this.session.getOverwrite() && e2 <= t2 && s2[i2] % 2 !== 0 && i2++;
            for (var u = 0; u < i2; u++)
              o2 += this.charWidths[s2[u]];
            return !this.session.getOverwrite() && e2 > t2 && s2[i2] % 2 === 0 && (o2 += this.charWidths[s2[i2]]), this.wrapIndent && (o2 += this.isRtlDir ? -1 * this.wrapOffset : this.wrapOffset), this.isRtlDir && (o2 += this.rtlLineOffset), o2;
          }, this.getSelections = function(e2, t2) {
            var n2 = this.bidiMap, r2 = n2.bidiLevels, i2, s2 = [], o2 = 0, u = Math.min(e2, t2) - this.wrapIndent, a = Math.max(e2, t2) - this.wrapIndent, f = false, l = false, c = 0;
            this.wrapIndent && (o2 += this.isRtlDir ? -1 * this.wrapOffset : this.wrapOffset);
            for (var h, p = 0; p < r2.length; p++)
              h = n2.logicalFromVisual[p], i2 = r2[p], f = h >= u && h < a, f && !l ? c = o2 : !f && l && s2.push({ left: c, width: o2 - c }), o2 += this.charWidths[i2], l = f;
            f && p === r2.length && s2.push({ left: c, width: o2 - c });
            if (this.isRtlDir)
              for (var d = 0; d < s2.length; d++)
                s2[d].left += this.rtlLineOffset;
            return s2;
          }, this.offsetToCol = function(e2) {
            this.isRtlDir && (e2 -= this.rtlLineOffset);
            var t2 = 0, e2 = Math.max(e2, 0), n2 = 0, r2 = 0, i2 = this.bidiMap.bidiLevels, s2 = this.charWidths[i2[r2]];
            this.wrapIndent && (e2 -= this.isRtlDir ? -1 * this.wrapOffset : this.wrapOffset);
            while (e2 > n2 + s2 / 2) {
              n2 += s2;
              if (r2 === i2.length - 1) {
                s2 = 0;
                break;
              }
              s2 = this.charWidths[i2[++r2]];
            }
            return r2 > 0 && i2[r2 - 1] % 2 !== 0 && i2[r2] % 2 === 0 ? (e2 < n2 && r2--, t2 = this.bidiMap.logicalFromVisual[r2]) : r2 > 0 && i2[r2 - 1] % 2 === 0 && i2[r2] % 2 !== 0 ? t2 = 1 + (e2 > n2 ? this.bidiMap.logicalFromVisual[r2] : this.bidiMap.logicalFromVisual[r2 - 1]) : this.isRtlDir && r2 === i2.length - 1 && s2 === 0 && i2[r2 - 1] % 2 === 0 || !this.isRtlDir && r2 === 0 && i2[r2] % 2 !== 0 ? t2 = 1 + this.bidiMap.logicalFromVisual[r2] : (r2 > 0 && i2[r2 - 1] % 2 !== 0 && s2 !== 0 && r2--, t2 = this.bidiMap.logicalFromVisual[r2]), t2 === 0 && this.isRtlDir && t2++, t2 + this.wrapIndent;
          };
        }).call(o.prototype), t.BidiHandler = o;
      }), ace.define("ace/selection", ["require", "exports", "module", "ace/lib/oop", "ace/lib/lang", "ace/lib/event_emitter", "ace/range"], function(e, t, n) {
        "use strict";
        var r = e("./lib/oop"), i = e("./lib/lang"), s = e("./lib/event_emitter").EventEmitter, o = e("./range").Range, u = function(e2) {
          this.session = e2, this.doc = e2.getDocument(), this.clearSelection(), this.cursor = this.lead = this.doc.createAnchor(0, 0), this.anchor = this.doc.createAnchor(0, 0), this.$silent = false;
          var t2 = this;
          this.cursor.on("change", function(e3) {
            t2.$cursorChanged = true, t2.$silent || t2._emit("changeCursor"), !t2.$isEmpty && !t2.$silent && t2._emit("changeSelection"), !t2.$keepDesiredColumnOnChange && e3.old.column != e3.value.column && (t2.$desiredColumn = null);
          }), this.anchor.on("change", function() {
            t2.$anchorChanged = true, !t2.$isEmpty && !t2.$silent && t2._emit("changeSelection");
          });
        };
        (function() {
          r.implement(this, s), this.isEmpty = function() {
            return this.$isEmpty || this.anchor.row == this.lead.row && this.anchor.column == this.lead.column;
          }, this.isMultiLine = function() {
            return !this.$isEmpty && this.anchor.row != this.cursor.row;
          }, this.getCursor = function() {
            return this.lead.getPosition();
          }, this.setSelectionAnchor = function(e2, t2) {
            this.$isEmpty = false, this.anchor.setPosition(e2, t2);
          }, this.getAnchor = this.getSelectionAnchor = function() {
            return this.$isEmpty ? this.getSelectionLead() : this.anchor.getPosition();
          }, this.getSelectionLead = function() {
            return this.lead.getPosition();
          }, this.isBackwards = function() {
            var e2 = this.anchor, t2 = this.lead;
            return e2.row > t2.row || e2.row == t2.row && e2.column > t2.column;
          }, this.getRange = function() {
            var e2 = this.anchor, t2 = this.lead;
            return this.$isEmpty ? o.fromPoints(t2, t2) : this.isBackwards() ? o.fromPoints(t2, e2) : o.fromPoints(e2, t2);
          }, this.clearSelection = function() {
            this.$isEmpty || (this.$isEmpty = true, this._emit("changeSelection"));
          }, this.selectAll = function() {
            this.$setSelection(0, 0, Number.MAX_VALUE, Number.MAX_VALUE);
          }, this.setRange = this.setSelectionRange = function(e2, t2) {
            var n2 = t2 ? e2.end : e2.start, r2 = t2 ? e2.start : e2.end;
            this.$setSelection(n2.row, n2.column, r2.row, r2.column);
          }, this.$setSelection = function(e2, t2, n2, r2) {
            if (this.$silent)
              return;
            var i2 = this.$isEmpty, s2 = this.inMultiSelectMode;
            this.$silent = true, this.$cursorChanged = this.$anchorChanged = false, this.anchor.setPosition(e2, t2), this.cursor.setPosition(n2, r2), this.$isEmpty = !o.comparePoints(this.anchor, this.cursor), this.$silent = false, this.$cursorChanged && this._emit("changeCursor"), (this.$cursorChanged || this.$anchorChanged || i2 != this.$isEmpty || s2) && this._emit("changeSelection");
          }, this.$moveSelection = function(e2) {
            var t2 = this.lead;
            this.$isEmpty && this.setSelectionAnchor(t2.row, t2.column), e2.call(this);
          }, this.selectTo = function(e2, t2) {
            this.$moveSelection(function() {
              this.moveCursorTo(e2, t2);
            });
          }, this.selectToPosition = function(e2) {
            this.$moveSelection(function() {
              this.moveCursorToPosition(e2);
            });
          }, this.moveTo = function(e2, t2) {
            this.clearSelection(), this.moveCursorTo(e2, t2);
          }, this.moveToPosition = function(e2) {
            this.clearSelection(), this.moveCursorToPosition(e2);
          }, this.selectUp = function() {
            this.$moveSelection(this.moveCursorUp);
          }, this.selectDown = function() {
            this.$moveSelection(this.moveCursorDown);
          }, this.selectRight = function() {
            this.$moveSelection(this.moveCursorRight);
          }, this.selectLeft = function() {
            this.$moveSelection(this.moveCursorLeft);
          }, this.selectLineStart = function() {
            this.$moveSelection(this.moveCursorLineStart);
          }, this.selectLineEnd = function() {
            this.$moveSelection(this.moveCursorLineEnd);
          }, this.selectFileEnd = function() {
            this.$moveSelection(this.moveCursorFileEnd);
          }, this.selectFileStart = function() {
            this.$moveSelection(this.moveCursorFileStart);
          }, this.selectWordRight = function() {
            this.$moveSelection(this.moveCursorWordRight);
          }, this.selectWordLeft = function() {
            this.$moveSelection(this.moveCursorWordLeft);
          }, this.getWordRange = function(e2, t2) {
            if (typeof t2 == "undefined") {
              var n2 = e2 || this.lead;
              e2 = n2.row, t2 = n2.column;
            }
            return this.session.getWordRange(e2, t2);
          }, this.selectWord = function() {
            this.setSelectionRange(this.getWordRange());
          }, this.selectAWord = function() {
            var e2 = this.getCursor(), t2 = this.session.getAWordRange(e2.row, e2.column);
            this.setSelectionRange(t2);
          }, this.getLineRange = function(e2, t2) {
            var n2 = typeof e2 == "number" ? e2 : this.lead.row, r2, i2 = this.session.getFoldLine(n2);
            return i2 ? (n2 = i2.start.row, r2 = i2.end.row) : r2 = n2, t2 === true ? new o(n2, 0, r2, this.session.getLine(r2).length) : new o(n2, 0, r2 + 1, 0);
          }, this.selectLine = function() {
            this.setSelectionRange(this.getLineRange());
          }, this.moveCursorUp = function() {
            this.moveCursorBy(-1, 0);
          }, this.moveCursorDown = function() {
            this.moveCursorBy(1, 0);
          }, this.wouldMoveIntoSoftTab = function(e2, t2, n2) {
            var r2 = e2.column, i2 = e2.column + t2;
            return n2 < 0 && (r2 = e2.column - t2, i2 = e2.column), this.session.isTabStop(e2) && this.doc.getLine(e2.row).slice(r2, i2).split(" ").length - 1 == t2;
          }, this.moveCursorLeft = function() {
            var e2 = this.lead.getPosition(), t2;
            if (t2 = this.session.getFoldAt(e2.row, e2.column, -1))
              this.moveCursorTo(t2.start.row, t2.start.column);
            else if (e2.column === 0)
              e2.row > 0 && this.moveCursorTo(e2.row - 1, this.doc.getLine(e2.row - 1).length);
            else {
              var n2 = this.session.getTabSize();
              this.wouldMoveIntoSoftTab(e2, n2, -1) && !this.session.getNavigateWithinSoftTabs() ? this.moveCursorBy(0, -n2) : this.moveCursorBy(0, -1);
            }
          }, this.moveCursorRight = function() {
            var e2 = this.lead.getPosition(), t2;
            if (t2 = this.session.getFoldAt(e2.row, e2.column, 1))
              this.moveCursorTo(t2.end.row, t2.end.column);
            else if (this.lead.column == this.doc.getLine(this.lead.row).length)
              this.lead.row < this.doc.getLength() - 1 && this.moveCursorTo(this.lead.row + 1, 0);
            else {
              var n2 = this.session.getTabSize(), e2 = this.lead;
              this.wouldMoveIntoSoftTab(e2, n2, 1) && !this.session.getNavigateWithinSoftTabs() ? this.moveCursorBy(0, n2) : this.moveCursorBy(0, 1);
            }
          }, this.moveCursorLineStart = function() {
            var e2 = this.lead.row, t2 = this.lead.column, n2 = this.session.documentToScreenRow(e2, t2), r2 = this.session.screenToDocumentPosition(n2, 0), i2 = this.session.getDisplayLine(e2, null, r2.row, r2.column), s2 = i2.match(/^\s*/);
            s2[0].length != t2 && !this.session.$useEmacsStyleLineStart && (r2.column += s2[0].length), this.moveCursorToPosition(r2);
          }, this.moveCursorLineEnd = function() {
            var e2 = this.lead, t2 = this.session.getDocumentLastRowColumnPosition(e2.row, e2.column);
            if (this.lead.column == t2.column) {
              var n2 = this.session.getLine(t2.row);
              if (t2.column == n2.length) {
                var r2 = n2.search(/\s+$/);
                r2 > 0 && (t2.column = r2);
              }
            }
            this.moveCursorTo(t2.row, t2.column);
          }, this.moveCursorFileEnd = function() {
            var e2 = this.doc.getLength() - 1, t2 = this.doc.getLine(e2).length;
            this.moveCursorTo(e2, t2);
          }, this.moveCursorFileStart = function() {
            this.moveCursorTo(0, 0);
          }, this.moveCursorLongWordRight = function() {
            var e2 = this.lead.row, t2 = this.lead.column, n2 = this.doc.getLine(e2), r2 = n2.substring(t2);
            this.session.nonTokenRe.lastIndex = 0, this.session.tokenRe.lastIndex = 0;
            var i2 = this.session.getFoldAt(e2, t2, 1);
            if (i2) {
              this.moveCursorTo(i2.end.row, i2.end.column);
              return;
            }
            this.session.nonTokenRe.exec(r2) && (t2 += this.session.nonTokenRe.lastIndex, this.session.nonTokenRe.lastIndex = 0, r2 = n2.substring(t2));
            if (t2 >= n2.length) {
              this.moveCursorTo(e2, n2.length), this.moveCursorRight(), e2 < this.doc.getLength() - 1 && this.moveCursorWordRight();
              return;
            }
            this.session.tokenRe.exec(r2) && (t2 += this.session.tokenRe.lastIndex, this.session.tokenRe.lastIndex = 0), this.moveCursorTo(e2, t2);
          }, this.moveCursorLongWordLeft = function() {
            var e2 = this.lead.row, t2 = this.lead.column, n2;
            if (n2 = this.session.getFoldAt(e2, t2, -1)) {
              this.moveCursorTo(n2.start.row, n2.start.column);
              return;
            }
            var r2 = this.session.getFoldStringAt(e2, t2, -1);
            r2 == null && (r2 = this.doc.getLine(e2).substring(0, t2));
            var s2 = i.stringReverse(r2);
            this.session.nonTokenRe.lastIndex = 0, this.session.tokenRe.lastIndex = 0, this.session.nonTokenRe.exec(s2) && (t2 -= this.session.nonTokenRe.lastIndex, s2 = s2.slice(this.session.nonTokenRe.lastIndex), this.session.nonTokenRe.lastIndex = 0);
            if (t2 <= 0) {
              this.moveCursorTo(e2, 0), this.moveCursorLeft(), e2 > 0 && this.moveCursorWordLeft();
              return;
            }
            this.session.tokenRe.exec(s2) && (t2 -= this.session.tokenRe.lastIndex, this.session.tokenRe.lastIndex = 0), this.moveCursorTo(e2, t2);
          }, this.$shortWordEndIndex = function(e2) {
            var t2 = 0, n2, r2 = /\s/, i2 = this.session.tokenRe;
            i2.lastIndex = 0;
            if (this.session.tokenRe.exec(e2))
              t2 = this.session.tokenRe.lastIndex;
            else {
              while ((n2 = e2[t2]) && r2.test(n2))
                t2++;
              if (t2 < 1) {
                i2.lastIndex = 0;
                while ((n2 = e2[t2]) && !i2.test(n2)) {
                  i2.lastIndex = 0, t2++;
                  if (r2.test(n2)) {
                    if (t2 > 2) {
                      t2--;
                      break;
                    }
                    while ((n2 = e2[t2]) && r2.test(n2))
                      t2++;
                    if (t2 > 2)
                      break;
                  }
                }
              }
            }
            return i2.lastIndex = 0, t2;
          }, this.moveCursorShortWordRight = function() {
            var e2 = this.lead.row, t2 = this.lead.column, n2 = this.doc.getLine(e2), r2 = n2.substring(t2), i2 = this.session.getFoldAt(e2, t2, 1);
            if (i2)
              return this.moveCursorTo(i2.end.row, i2.end.column);
            if (t2 == n2.length) {
              var s2 = this.doc.getLength();
              do
                e2++, r2 = this.doc.getLine(e2);
              while (e2 < s2 && /^\s*$/.test(r2));
              /^\s+/.test(r2) || (r2 = ""), t2 = 0;
            }
            var o2 = this.$shortWordEndIndex(r2);
            this.moveCursorTo(e2, t2 + o2);
          }, this.moveCursorShortWordLeft = function() {
            var e2 = this.lead.row, t2 = this.lead.column, n2;
            if (n2 = this.session.getFoldAt(e2, t2, -1))
              return this.moveCursorTo(n2.start.row, n2.start.column);
            var r2 = this.session.getLine(e2).substring(0, t2);
            if (t2 === 0) {
              do
                e2--, r2 = this.doc.getLine(e2);
              while (e2 > 0 && /^\s*$/.test(r2));
              t2 = r2.length, /\s+$/.test(r2) || (r2 = "");
            }
            var s2 = i.stringReverse(r2), o2 = this.$shortWordEndIndex(s2);
            return this.moveCursorTo(e2, t2 - o2);
          }, this.moveCursorWordRight = function() {
            this.session.$selectLongWords ? this.moveCursorLongWordRight() : this.moveCursorShortWordRight();
          }, this.moveCursorWordLeft = function() {
            this.session.$selectLongWords ? this.moveCursorLongWordLeft() : this.moveCursorShortWordLeft();
          }, this.moveCursorBy = function(e2, t2) {
            var n2 = this.session.documentToScreenPosition(this.lead.row, this.lead.column), r2;
            t2 === 0 && (e2 !== 0 && (this.session.$bidiHandler.isBidiRow(n2.row, this.lead.row) ? (r2 = this.session.$bidiHandler.getPosLeft(n2.column), n2.column = Math.round(r2 / this.session.$bidiHandler.charWidths[0])) : r2 = n2.column * this.session.$bidiHandler.charWidths[0]), this.$desiredColumn ? n2.column = this.$desiredColumn : this.$desiredColumn = n2.column);
            if (e2 != 0 && this.session.lineWidgets && this.session.lineWidgets[this.lead.row]) {
              var i2 = this.session.lineWidgets[this.lead.row];
              e2 < 0 ? e2 -= i2.rowsAbove || 0 : e2 > 0 && (e2 += i2.rowCount - (i2.rowsAbove || 0));
            }
            var s2 = this.session.screenToDocumentPosition(n2.row + e2, n2.column, r2);
            e2 !== 0 && t2 === 0 && s2.row === this.lead.row && s2.column === this.lead.column, this.moveCursorTo(s2.row, s2.column + t2, t2 === 0);
          }, this.moveCursorToPosition = function(e2) {
            this.moveCursorTo(e2.row, e2.column);
          }, this.moveCursorTo = function(e2, t2, n2) {
            var r2 = this.session.getFoldAt(e2, t2, 1);
            r2 && (e2 = r2.start.row, t2 = r2.start.column), this.$keepDesiredColumnOnChange = true;
            var i2 = this.session.getLine(e2);
            /[\uDC00-\uDFFF]/.test(i2.charAt(t2)) && i2.charAt(t2 - 1) && (this.lead.row == e2 && this.lead.column == t2 + 1 ? t2 -= 1 : t2 += 1), this.lead.setPosition(e2, t2), this.$keepDesiredColumnOnChange = false, n2 || (this.$desiredColumn = null);
          }, this.moveCursorToScreen = function(e2, t2, n2) {
            var r2 = this.session.screenToDocumentPosition(e2, t2);
            this.moveCursorTo(r2.row, r2.column, n2);
          }, this.detach = function() {
            this.lead.detach(), this.anchor.detach();
          }, this.fromOrientedRange = function(e2) {
            this.setSelectionRange(e2, e2.cursor == e2.start), this.$desiredColumn = e2.desiredColumn || this.$desiredColumn;
          }, this.toOrientedRange = function(e2) {
            var t2 = this.getRange();
            return e2 ? (e2.start.column = t2.start.column, e2.start.row = t2.start.row, e2.end.column = t2.end.column, e2.end.row = t2.end.row) : e2 = t2, e2.cursor = this.isBackwards() ? e2.start : e2.end, e2.desiredColumn = this.$desiredColumn, e2;
          }, this.getRangeOfMovements = function(e2) {
            var t2 = this.getCursor();
            try {
              e2(this);
              var n2 = this.getCursor();
              return o.fromPoints(t2, n2);
            } catch (r2) {
              return o.fromPoints(t2, t2);
            } finally {
              this.moveCursorToPosition(t2);
            }
          }, this.toJSON = function() {
            if (this.rangeCount)
              var e2 = this.ranges.map(function(e3) {
                var t2 = e3.clone();
                return t2.isBackwards = e3.cursor == e3.start, t2;
              });
            else {
              var e2 = this.getRange();
              e2.isBackwards = this.isBackwards();
            }
            return e2;
          }, this.fromJSON = function(e2) {
            if (e2.start == void 0) {
              if (this.rangeList && e2.length > 1) {
                this.toSingleRange(e2[0]);
                for (var t2 = e2.length; t2--; ) {
                  var n2 = o.fromPoints(e2[t2].start, e2[t2].end);
                  e2[t2].isBackwards && (n2.cursor = n2.start), this.addRange(n2, true);
                }
                return;
              }
              e2 = e2[0];
            }
            this.rangeList && this.toSingleRange(e2), this.setSelectionRange(e2, e2.isBackwards);
          }, this.isEqual = function(e2) {
            if ((e2.length || this.rangeCount) && e2.length != this.rangeCount)
              return false;
            if (!e2.length || !this.ranges)
              return this.getRange().isEqual(e2);
            for (var t2 = this.ranges.length; t2--; )
              if (!this.ranges[t2].isEqual(e2[t2]))
                return false;
            return true;
          };
        }).call(u.prototype), t.Selection = u;
      }), ace.define("ace/tokenizer", ["require", "exports", "module", "ace/config"], function(e, t, n) {
        "use strict";
        var r = e("./config"), i = 2e3, s = function(e2) {
          this.states = e2, this.regExps = {}, this.matchMappings = {};
          for (var t2 in this.states) {
            var n2 = this.states[t2], r2 = [], i2 = 0, s2 = this.matchMappings[t2] = { defaultToken: "text" }, o = "g", u = [];
            for (var a = 0; a < n2.length; a++) {
              var f = n2[a];
              f.defaultToken && (s2.defaultToken = f.defaultToken), f.caseInsensitive && o.indexOf("i") === -1 && (o += "i"), f.unicode && o.indexOf("u") === -1 && (o += "u");
              if (f.regex == null)
                continue;
              f.regex instanceof RegExp && (f.regex = f.regex.toString().slice(1, -1));
              var l = f.regex, c = new RegExp("(?:(" + l + ")|(.))").exec("a").length - 2;
              Array.isArray(f.token) ? f.token.length == 1 || c == 1 ? f.token = f.token[0] : c - 1 != f.token.length ? (this.reportError("number of classes and regexp groups doesn't match", { rule: f, groupCount: c - 1 }), f.token = f.token[0]) : (f.tokenArray = f.token, f.token = null, f.onMatch = this.$arrayTokens) : typeof f.token == "function" && !f.onMatch && (c > 1 ? f.onMatch = this.$applyToken : f.onMatch = f.token), c > 1 && (/\\\d/.test(f.regex) ? l = f.regex.replace(/\\([0-9]+)/g, function(e3, t3) {
                return "\\" + (parseInt(t3, 10) + i2 + 1);
              }) : (c = 1, l = this.removeCapturingGroups(f.regex)), !f.splitRegex && typeof f.token != "string" && u.push(f)), s2[i2] = a, i2 += c, r2.push(l), f.onMatch || (f.onMatch = null);
            }
            r2.length || (s2[0] = 0, r2.push("$")), u.forEach(function(e3) {
              e3.splitRegex = this.createSplitterRegexp(e3.regex, o);
            }, this), this.regExps[t2] = new RegExp("(" + r2.join(")|(") + ")|($)", o);
          }
        };
        (function() {
          this.$setMaxTokenCount = function(e2) {
            i = e2 | 0;
          }, this.$applyToken = function(e2) {
            var t2 = this.splitRegex.exec(e2).slice(1), n2 = this.token.apply(this, t2);
            if (typeof n2 == "string")
              return [{ type: n2, value: e2 }];
            var r2 = [];
            for (var i2 = 0, s2 = n2.length; i2 < s2; i2++)
              t2[i2] && (r2[r2.length] = { type: n2[i2], value: t2[i2] });
            return r2;
          }, this.$arrayTokens = function(e2) {
            if (!e2)
              return [];
            var t2 = this.splitRegex.exec(e2);
            if (!t2)
              return "text";
            var n2 = [], r2 = this.tokenArray;
            for (var i2 = 0, s2 = r2.length; i2 < s2; i2++)
              t2[i2 + 1] && (n2[n2.length] = { type: r2[i2], value: t2[i2 + 1] });
            return n2;
          }, this.removeCapturingGroups = function(e2) {
            var t2 = e2.replace(/\\.|\[(?:\\.|[^\\\]])*|\(\?[:=!<]|(\()/g, function(e3, t3) {
              return t3 ? "(?:" : e3;
            });
            return t2;
          }, this.createSplitterRegexp = function(e2, t2) {
            if (e2.indexOf("(?=") != -1) {
              var n2 = 0, r2 = false, i2 = {};
              e2.replace(/(\\.)|(\((?:\?[=!])?)|(\))|([\[\]])/g, function(e3, t3, s2, o, u, a) {
                return r2 ? r2 = u != "]" : u ? r2 = true : o ? (n2 == i2.stack && (i2.end = a + 1, i2.stack = -1), n2--) : s2 && (n2++, s2.length != 1 && (i2.stack = n2, i2.start = a)), e3;
              }), i2.end != null && /^\)*$/.test(e2.substr(i2.end)) && (e2 = e2.substring(0, i2.start) + e2.substr(i2.end));
            }
            return e2.charAt(0) != "^" && (e2 = "^" + e2), e2.charAt(e2.length - 1) != "$" && (e2 += "$"), new RegExp(e2, (t2 || "").replace("g", ""));
          }, this.getLineTokens = function(e2, t2) {
            if (t2 && typeof t2 != "string") {
              var n2 = t2.slice(0);
              t2 = n2[0], t2 === "#tmp" && (n2.shift(), t2 = n2.shift());
            } else
              var n2 = [];
            var r2 = t2 || "start", s2 = this.states[r2];
            s2 || (r2 = "start", s2 = this.states[r2]);
            var o = this.matchMappings[r2], u = this.regExps[r2];
            u.lastIndex = 0;
            var a, f = [], l = 0, c = 0, h = { type: null, value: "" };
            while (a = u.exec(e2)) {
              var p = o.defaultToken, d = null, v = a[0], m = u.lastIndex;
              if (m - v.length > l) {
                var g = e2.substring(l, m - v.length);
                h.type == p ? h.value += g : (h.type && f.push(h), h = { type: p, value: g });
              }
              for (var y = 0; y < a.length - 2; y++) {
                if (a[y + 1] === void 0)
                  continue;
                d = s2[o[y]], d.onMatch ? p = d.onMatch(v, r2, n2, e2) : p = d.token, d.next && (typeof d.next == "string" ? r2 = d.next : r2 = d.next(r2, n2), s2 = this.states[r2], s2 || (this.reportError("state doesn't exist", r2), r2 = "start", s2 = this.states[r2]), o = this.matchMappings[r2], l = m, u = this.regExps[r2], u.lastIndex = m), d.consumeLineEnd && (l = m);
                break;
              }
              if (v) {
                if (typeof p == "string")
                  !!d && d.merge === false || h.type !== p ? (h.type && f.push(h), h = { type: p, value: v }) : h.value += v;
                else if (p) {
                  h.type && f.push(h), h = { type: null, value: "" };
                  for (var y = 0; y < p.length; y++)
                    f.push(p[y]);
                }
              }
              if (l == e2.length)
                break;
              l = m;
              if (c++ > i) {
                c > 2 * e2.length && this.reportError("infinite loop with in ace tokenizer", { startState: t2, line: e2 });
                while (l < e2.length)
                  h.type && f.push(h), h = { value: e2.substring(l, l += 500), type: "overflow" };
                r2 = "start", n2 = [];
                break;
              }
            }
            return h.type && f.push(h), n2.length > 1 && n2[0] !== r2 && n2.unshift("#tmp", r2), { tokens: f, state: n2.length ? n2 : r2 };
          }, this.reportError = r.reportError;
        }).call(s.prototype), t.Tokenizer = s;
      }), ace.define("ace/mode/text_highlight_rules", ["require", "exports", "module", "ace/lib/lang"], function(e, t, n) {
        "use strict";
        var r = e("../lib/lang"), i = function() {
          this.$rules = { start: [{ token: "empty_line", regex: "^$" }, { defaultToken: "text" }] };
        };
        (function() {
          this.addRules = function(e3, t3) {
            if (!t3) {
              for (var n2 in e3)
                this.$rules[n2] = e3[n2];
              return;
            }
            for (var n2 in e3) {
              var r2 = e3[n2];
              for (var i2 = 0; i2 < r2.length; i2++) {
                var s = r2[i2];
                if (s.next || s.onMatch)
                  typeof s.next == "string" && s.next.indexOf(t3) !== 0 && (s.next = t3 + s.next), s.nextState && s.nextState.indexOf(t3) !== 0 && (s.nextState = t3 + s.nextState);
              }
              this.$rules[t3 + n2] = r2;
            }
          }, this.getRules = function() {
            return this.$rules;
          }, this.embedRules = function(e3, t3, n2, i2, s) {
            var o = typeof e3 == "function" ? new e3().getRules() : e3;
            if (i2)
              for (var u = 0; u < i2.length; u++)
                i2[u] = t3 + i2[u];
            else {
              i2 = [];
              for (var a in o)
                i2.push(t3 + a);
            }
            this.addRules(o, t3);
            if (n2) {
              var f = Array.prototype[s ? "push" : "unshift"];
              for (var u = 0; u < i2.length; u++)
                f.apply(this.$rules[i2[u]], r.deepCopy(n2));
            }
            this.$embeds || (this.$embeds = []), this.$embeds.push(t3);
          }, this.getEmbeds = function() {
            return this.$embeds;
          };
          var e2 = function(e3, t3) {
            return (e3 != "start" || t3.length) && t3.unshift(this.nextState, e3), this.nextState;
          }, t2 = function(e3, t3) {
            return t3.shift(), t3.shift() || "start";
          };
          this.normalizeRules = function() {
            function i2(s) {
              var o = r2[s];
              o.processed = true;
              for (var u = 0; u < o.length; u++) {
                var a = o[u], f = null;
                Array.isArray(a) && (f = a, a = {}), !a.regex && a.start && (a.regex = a.start, a.next || (a.next = []), a.next.push({ defaultToken: a.token }, { token: a.token + ".end", regex: a.end || a.start, next: "pop" }), a.token = a.token + ".start", a.push = true);
                var l = a.next || a.push;
                if (l && Array.isArray(l)) {
                  var c = a.stateName;
                  c || (c = a.token, typeof c != "string" && (c = c[0] || ""), r2[c] && (c += n2++)), r2[c] = l, a.next = c, i2(c);
                } else
                  l == "pop" && (a.next = t2);
                a.push && (a.nextState = a.next || a.push, a.next = e2, delete a.push);
                if (a.rules)
                  for (var h in a.rules)
                    r2[h] ? r2[h].push && r2[h].push.apply(r2[h], a.rules[h]) : r2[h] = a.rules[h];
                var p = typeof a == "string" ? a : a.include;
                p && (Array.isArray(p) ? f = p.map(function(e3) {
                  return r2[e3];
                }) : f = r2[p]);
                if (f) {
                  var d = [u, 1].concat(f);
                  a.noEscape && (d = d.filter(function(e3) {
                    return !e3.next;
                  })), o.splice.apply(o, d), u--;
                }
                a.keywordMap && (a.token = this.createKeywordMapper(a.keywordMap, a.defaultToken || "text", a.caseInsensitive), delete a.defaultToken);
              }
            }
            var n2 = 0, r2 = this.$rules;
            Object.keys(r2).forEach(i2, this);
          }, this.createKeywordMapper = function(e3, t3, n2, r2) {
            var i2 = /* @__PURE__ */ Object.create(null);
            return this.$keywordList = [], Object.keys(e3).forEach(function(t4) {
              var s = e3[t4], o = s.split(r2 || "|");
              for (var u = o.length; u--; ) {
                var a = o[u];
                this.$keywordList.push(a), n2 && (a = a.toLowerCase()), i2[a] = t4;
              }
            }, this), e3 = null, n2 ? function(e4) {
              return i2[e4.toLowerCase()] || t3;
            } : function(e4) {
              return i2[e4] || t3;
            };
          }, this.getKeywords = function() {
            return this.$keywords;
          };
        }).call(i.prototype), t.TextHighlightRules = i;
      }), ace.define("ace/mode/behaviour", ["require", "exports", "module"], function(e, t, n) {
        "use strict";
        var r = function() {
          this.$behaviours = {};
        };
        (function() {
          this.add = function(e2, t2, n2) {
            switch (void 0) {
              case this.$behaviours:
                this.$behaviours = {};
              case this.$behaviours[e2]:
                this.$behaviours[e2] = {};
            }
            this.$behaviours[e2][t2] = n2;
          }, this.addBehaviours = function(e2) {
            for (var t2 in e2)
              for (var n2 in e2[t2])
                this.add(t2, n2, e2[t2][n2]);
          }, this.remove = function(e2) {
            this.$behaviours && this.$behaviours[e2] && delete this.$behaviours[e2];
          }, this.inherit = function(e2, t2) {
            if (typeof e2 == "function")
              var n2 = new e2().getBehaviours(t2);
            else
              var n2 = e2.getBehaviours(t2);
            this.addBehaviours(n2);
          }, this.getBehaviours = function(e2) {
            if (!e2)
              return this.$behaviours;
            var t2 = {};
            for (var n2 = 0; n2 < e2.length; n2++)
              this.$behaviours[e2[n2]] && (t2[e2[n2]] = this.$behaviours[e2[n2]]);
            return t2;
          };
        }).call(r.prototype), t.Behaviour = r;
      }), ace.define("ace/token_iterator", ["require", "exports", "module", "ace/range"], function(e, t, n) {
        "use strict";
        var r = e("./range").Range, i = function(e2, t2, n2) {
          this.$session = e2, this.$row = t2, this.$rowTokens = e2.getTokens(t2);
          var r2 = e2.getTokenAt(t2, n2);
          this.$tokenIndex = r2 ? r2.index : -1;
        };
        (function() {
          this.stepBackward = function() {
            this.$tokenIndex -= 1;
            while (this.$tokenIndex < 0) {
              this.$row -= 1;
              if (this.$row < 0)
                return this.$row = 0, null;
              this.$rowTokens = this.$session.getTokens(this.$row), this.$tokenIndex = this.$rowTokens.length - 1;
            }
            return this.$rowTokens[this.$tokenIndex];
          }, this.stepForward = function() {
            this.$tokenIndex += 1;
            var e2;
            while (this.$tokenIndex >= this.$rowTokens.length) {
              this.$row += 1, e2 || (e2 = this.$session.getLength());
              if (this.$row >= e2)
                return this.$row = e2 - 1, null;
              this.$rowTokens = this.$session.getTokens(this.$row), this.$tokenIndex = 0;
            }
            return this.$rowTokens[this.$tokenIndex];
          }, this.getCurrentToken = function() {
            return this.$rowTokens[this.$tokenIndex];
          }, this.getCurrentTokenRow = function() {
            return this.$row;
          }, this.getCurrentTokenColumn = function() {
            var e2 = this.$rowTokens, t2 = this.$tokenIndex, n2 = e2[t2].start;
            if (n2 !== void 0)
              return n2;
            n2 = 0;
            while (t2 > 0)
              t2 -= 1, n2 += e2[t2].value.length;
            return n2;
          }, this.getCurrentTokenPosition = function() {
            return { row: this.$row, column: this.getCurrentTokenColumn() };
          }, this.getCurrentTokenRange = function() {
            var e2 = this.$rowTokens[this.$tokenIndex], t2 = this.getCurrentTokenColumn();
            return new r(this.$row, t2, this.$row, t2 + e2.value.length);
          };
        }).call(i.prototype), t.TokenIterator = i;
      }), ace.define("ace/mode/behaviour/cstyle", ["require", "exports", "module", "ace/lib/oop", "ace/mode/behaviour", "ace/token_iterator", "ace/lib/lang"], function(e, t, n) {
        "use strict";
        var r = e("../../lib/oop"), i = e("../behaviour").Behaviour, s = e("../../token_iterator").TokenIterator, o = e("../../lib/lang"), u = ["text", "paren.rparen", "rparen", "paren", "punctuation.operator"], a = ["text", "paren.rparen", "rparen", "paren", "punctuation.operator", "comment"], f, l = {}, c = { '"': '"', "'": "'" }, h = function(e2) {
          var t2 = -1;
          e2.multiSelect && (t2 = e2.selection.index, l.rangeCount != e2.multiSelect.rangeCount && (l = { rangeCount: e2.multiSelect.rangeCount }));
          if (l[t2])
            return f = l[t2];
          f = l[t2] = { autoInsertedBrackets: 0, autoInsertedRow: -1, autoInsertedLineEnd: "", maybeInsertedBrackets: 0, maybeInsertedRow: -1, maybeInsertedLineStart: "", maybeInsertedLineEnd: "" };
        }, p = function(e2, t2, n2, r2) {
          var i2 = e2.end.row - e2.start.row;
          return { text: n2 + t2 + r2, selection: [0, e2.start.column + 1, i2, e2.end.column + (i2 ? 0 : 1)] };
        }, d = function(e2) {
          this.add("braces", "insertion", function(t2, n2, r2, i2, s2) {
            var u2 = r2.getCursorPosition(), a2 = i2.doc.getLine(u2.row);
            if (s2 == "{") {
              h(r2);
              var l2 = r2.getSelectionRange(), c2 = i2.doc.getTextRange(l2);
              if (c2 !== "" && c2 !== "{" && r2.getWrapBehavioursEnabled())
                return p(l2, c2, "{", "}");
              if (d.isSaneInsertion(r2, i2))
                return /[\]\}\)]/.test(a2[u2.column]) || r2.inMultiSelectMode || e2 && e2.braces ? (d.recordAutoInsert(r2, i2, "}"), { text: "{}", selection: [1, 1] }) : (d.recordMaybeInsert(r2, i2, "{"), { text: "{", selection: [1, 1] });
            } else if (s2 == "}") {
              h(r2);
              var v = a2.substring(u2.column, u2.column + 1);
              if (v == "}") {
                var m = i2.$findOpeningBracket("}", { column: u2.column + 1, row: u2.row });
                if (m !== null && d.isAutoInsertedClosing(u2, a2, s2))
                  return d.popAutoInsertedClosing(), { text: "", selection: [1, 1] };
              }
            } else {
              if (s2 == "\n" || s2 == "\r\n") {
                h(r2);
                var g = "";
                d.isMaybeInsertedClosing(u2, a2) && (g = o.stringRepeat("}", f.maybeInsertedBrackets), d.clearMaybeInsertedClosing());
                var v = a2.substring(u2.column, u2.column + 1);
                if (v === "}") {
                  var y = i2.findMatchingBracket({ row: u2.row, column: u2.column + 1 }, "}");
                  if (!y)
                    return null;
                  var b = this.$getIndent(i2.getLine(y.row));
                } else {
                  if (!g) {
                    d.clearMaybeInsertedClosing();
                    return;
                  }
                  var b = this.$getIndent(a2);
                }
                var w = b + i2.getTabString();
                return { text: "\n" + w + "\n" + b + g, selection: [1, w.length, 1, w.length] };
              }
              d.clearMaybeInsertedClosing();
            }
          }), this.add("braces", "deletion", function(e3, t2, n2, r2, i2) {
            var s2 = r2.doc.getTextRange(i2);
            if (!i2.isMultiLine() && s2 == "{") {
              h(n2);
              var o2 = r2.doc.getLine(i2.start.row), u2 = o2.substring(i2.end.column, i2.end.column + 1);
              if (u2 == "}")
                return i2.end.column++, i2;
              f.maybeInsertedBrackets--;
            }
          }), this.add("parens", "insertion", function(e3, t2, n2, r2, i2) {
            if (i2 == "(") {
              h(n2);
              var s2 = n2.getSelectionRange(), o2 = r2.doc.getTextRange(s2);
              if (o2 !== "" && n2.getWrapBehavioursEnabled())
                return p(s2, o2, "(", ")");
              if (d.isSaneInsertion(n2, r2))
                return d.recordAutoInsert(n2, r2, ")"), { text: "()", selection: [1, 1] };
            } else if (i2 == ")") {
              h(n2);
              var u2 = n2.getCursorPosition(), a2 = r2.doc.getLine(u2.row), f2 = a2.substring(u2.column, u2.column + 1);
              if (f2 == ")") {
                var l2 = r2.$findOpeningBracket(")", { column: u2.column + 1, row: u2.row });
                if (l2 !== null && d.isAutoInsertedClosing(u2, a2, i2))
                  return d.popAutoInsertedClosing(), { text: "", selection: [1, 1] };
              }
            }
          }), this.add("parens", "deletion", function(e3, t2, n2, r2, i2) {
            var s2 = r2.doc.getTextRange(i2);
            if (!i2.isMultiLine() && s2 == "(") {
              h(n2);
              var o2 = r2.doc.getLine(i2.start.row), u2 = o2.substring(i2.start.column + 1, i2.start.column + 2);
              if (u2 == ")")
                return i2.end.column++, i2;
            }
          }), this.add("brackets", "insertion", function(e3, t2, n2, r2, i2) {
            if (i2 == "[") {
              h(n2);
              var s2 = n2.getSelectionRange(), o2 = r2.doc.getTextRange(s2);
              if (o2 !== "" && n2.getWrapBehavioursEnabled())
                return p(s2, o2, "[", "]");
              if (d.isSaneInsertion(n2, r2))
                return d.recordAutoInsert(n2, r2, "]"), { text: "[]", selection: [1, 1] };
            } else if (i2 == "]") {
              h(n2);
              var u2 = n2.getCursorPosition(), a2 = r2.doc.getLine(u2.row), f2 = a2.substring(u2.column, u2.column + 1);
              if (f2 == "]") {
                var l2 = r2.$findOpeningBracket("]", { column: u2.column + 1, row: u2.row });
                if (l2 !== null && d.isAutoInsertedClosing(u2, a2, i2))
                  return d.popAutoInsertedClosing(), { text: "", selection: [1, 1] };
              }
            }
          }), this.add("brackets", "deletion", function(e3, t2, n2, r2, i2) {
            var s2 = r2.doc.getTextRange(i2);
            if (!i2.isMultiLine() && s2 == "[") {
              h(n2);
              var o2 = r2.doc.getLine(i2.start.row), u2 = o2.substring(i2.start.column + 1, i2.start.column + 2);
              if (u2 == "]")
                return i2.end.column++, i2;
            }
          }), this.add("string_dquotes", "insertion", function(e3, t2, n2, r2, i2) {
            var s2 = r2.$mode.$quotes || c;
            if (i2.length == 1 && s2[i2]) {
              if (this.lineCommentStart && this.lineCommentStart.indexOf(i2) != -1)
                return;
              h(n2);
              var o2 = i2, u2 = n2.getSelectionRange(), a2 = r2.doc.getTextRange(u2);
              if (a2 !== "" && (a2.length != 1 || !s2[a2]) && n2.getWrapBehavioursEnabled())
                return p(u2, a2, o2, o2);
              if (!a2) {
                var f2 = n2.getCursorPosition(), l2 = r2.doc.getLine(f2.row), d2 = l2.substring(f2.column - 1, f2.column), v = l2.substring(f2.column, f2.column + 1), m = r2.getTokenAt(f2.row, f2.column), g = r2.getTokenAt(f2.row, f2.column + 1);
                if (d2 == "\\" && m && /escape/.test(m.type))
                  return null;
                var y = m && /string|escape/.test(m.type), b = !g || /string|escape/.test(g.type), w;
                if (v == o2)
                  w = y !== b, w && /string\.end/.test(g.type) && (w = false);
                else {
                  if (y && !b)
                    return null;
                  if (y && b)
                    return null;
                  var E = r2.$mode.tokenRe;
                  E.lastIndex = 0;
                  var S = E.test(d2);
                  E.lastIndex = 0;
                  var x = E.test(d2);
                  if (S || x)
                    return null;
                  if (v && !/[\s;,.})\]\\]/.test(v))
                    return null;
                  var T = l2[f2.column - 2];
                  if (!(d2 != o2 || T != o2 && !E.test(T)))
                    return null;
                  w = true;
                }
                return { text: w ? o2 + o2 : "", selection: [1, 1] };
              }
            }
          }), this.add("string_dquotes", "deletion", function(e3, t2, n2, r2, i2) {
            var s2 = r2.$mode.$quotes || c, o2 = r2.doc.getTextRange(i2);
            if (!i2.isMultiLine() && s2.hasOwnProperty(o2)) {
              h(n2);
              var u2 = r2.doc.getLine(i2.start.row), a2 = u2.substring(i2.start.column + 1, i2.start.column + 2);
              if (a2 == o2)
                return i2.end.column++, i2;
            }
          });
        };
        d.isSaneInsertion = function(e2, t2) {
          var n2 = e2.getCursorPosition(), r2 = new s(t2, n2.row, n2.column);
          if (!this.$matchTokenType(r2.getCurrentToken() || "text", u)) {
            if (/[)}\]]/.test(e2.session.getLine(n2.row)[n2.column]))
              return true;
            var i2 = new s(t2, n2.row, n2.column + 1);
            if (!this.$matchTokenType(i2.getCurrentToken() || "text", u))
              return false;
          }
          return r2.stepForward(), r2.getCurrentTokenRow() !== n2.row || this.$matchTokenType(r2.getCurrentToken() || "text", a);
        }, d.$matchTokenType = function(e2, t2) {
          return t2.indexOf(e2.type || e2) > -1;
        }, d.recordAutoInsert = function(e2, t2, n2) {
          var r2 = e2.getCursorPosition(), i2 = t2.doc.getLine(r2.row);
          this.isAutoInsertedClosing(r2, i2, f.autoInsertedLineEnd[0]) || (f.autoInsertedBrackets = 0), f.autoInsertedRow = r2.row, f.autoInsertedLineEnd = n2 + i2.substr(r2.column), f.autoInsertedBrackets++;
        }, d.recordMaybeInsert = function(e2, t2, n2) {
          var r2 = e2.getCursorPosition(), i2 = t2.doc.getLine(r2.row);
          this.isMaybeInsertedClosing(r2, i2) || (f.maybeInsertedBrackets = 0), f.maybeInsertedRow = r2.row, f.maybeInsertedLineStart = i2.substr(0, r2.column) + n2, f.maybeInsertedLineEnd = i2.substr(r2.column), f.maybeInsertedBrackets++;
        }, d.isAutoInsertedClosing = function(e2, t2, n2) {
          return f.autoInsertedBrackets > 0 && e2.row === f.autoInsertedRow && n2 === f.autoInsertedLineEnd[0] && t2.substr(e2.column) === f.autoInsertedLineEnd;
        }, d.isMaybeInsertedClosing = function(e2, t2) {
          return f.maybeInsertedBrackets > 0 && e2.row === f.maybeInsertedRow && t2.substr(e2.column) === f.maybeInsertedLineEnd && t2.substr(0, e2.column) == f.maybeInsertedLineStart;
        }, d.popAutoInsertedClosing = function() {
          f.autoInsertedLineEnd = f.autoInsertedLineEnd.substr(1), f.autoInsertedBrackets--;
        }, d.clearMaybeInsertedClosing = function() {
          f && (f.maybeInsertedBrackets = 0, f.maybeInsertedRow = -1);
        }, r.inherits(d, i), t.CstyleBehaviour = d;
      }), ace.define("ace/unicode", ["require", "exports", "module"], function(e, t, n) {
        "use strict";
        var r = [48, 9, 8, 25, 5, 0, 2, 25, 48, 0, 11, 0, 5, 0, 6, 22, 2, 30, 2, 457, 5, 11, 15, 4, 8, 0, 2, 0, 18, 116, 2, 1, 3, 3, 9, 0, 2, 2, 2, 0, 2, 19, 2, 82, 2, 138, 2, 4, 3, 155, 12, 37, 3, 0, 8, 38, 10, 44, 2, 0, 2, 1, 2, 1, 2, 0, 9, 26, 6, 2, 30, 10, 7, 61, 2, 9, 5, 101, 2, 7, 3, 9, 2, 18, 3, 0, 17, 58, 3, 100, 15, 53, 5, 0, 6, 45, 211, 57, 3, 18, 2, 5, 3, 11, 3, 9, 2, 1, 7, 6, 2, 2, 2, 7, 3, 1, 3, 21, 2, 6, 2, 0, 4, 3, 3, 8, 3, 1, 3, 3, 9, 0, 5, 1, 2, 4, 3, 11, 16, 2, 2, 5, 5, 1, 3, 21, 2, 6, 2, 1, 2, 1, 2, 1, 3, 0, 2, 4, 5, 1, 3, 2, 4, 0, 8, 3, 2, 0, 8, 15, 12, 2, 2, 8, 2, 2, 2, 21, 2, 6, 2, 1, 2, 4, 3, 9, 2, 2, 2, 2, 3, 0, 16, 3, 3, 9, 18, 2, 2, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 3, 8, 3, 1, 3, 2, 9, 1, 5, 1, 2, 4, 3, 9, 2, 0, 17, 1, 2, 5, 4, 2, 2, 3, 4, 1, 2, 0, 2, 1, 4, 1, 4, 2, 4, 11, 5, 4, 4, 2, 2, 3, 3, 0, 7, 0, 15, 9, 18, 2, 2, 7, 2, 2, 2, 22, 2, 9, 2, 4, 4, 7, 2, 2, 2, 3, 8, 1, 2, 1, 7, 3, 3, 9, 19, 1, 2, 7, 2, 2, 2, 22, 2, 9, 2, 4, 3, 8, 2, 2, 2, 3, 8, 1, 8, 0, 2, 3, 3, 9, 19, 1, 2, 7, 2, 2, 2, 22, 2, 15, 4, 7, 2, 2, 2, 3, 10, 0, 9, 3, 3, 9, 11, 5, 3, 1, 2, 17, 4, 23, 2, 8, 2, 0, 3, 6, 4, 0, 5, 5, 2, 0, 2, 7, 19, 1, 14, 57, 6, 14, 2, 9, 40, 1, 2, 0, 3, 1, 2, 0, 3, 0, 7, 3, 2, 6, 2, 2, 2, 0, 2, 0, 3, 1, 2, 12, 2, 2, 3, 4, 2, 0, 2, 5, 3, 9, 3, 1, 35, 0, 24, 1, 7, 9, 12, 0, 2, 0, 2, 0, 5, 9, 2, 35, 5, 19, 2, 5, 5, 7, 2, 35, 10, 0, 58, 73, 7, 77, 3, 37, 11, 42, 2, 0, 4, 328, 2, 3, 3, 6, 2, 0, 2, 3, 3, 40, 2, 3, 3, 32, 2, 3, 3, 6, 2, 0, 2, 3, 3, 14, 2, 56, 2, 3, 3, 66, 5, 0, 33, 15, 17, 84, 13, 619, 3, 16, 2, 25, 6, 74, 22, 12, 2, 6, 12, 20, 12, 19, 13, 12, 2, 2, 2, 1, 13, 51, 3, 29, 4, 0, 5, 1, 3, 9, 34, 2, 3, 9, 7, 87, 9, 42, 6, 69, 11, 28, 4, 11, 5, 11, 11, 39, 3, 4, 12, 43, 5, 25, 7, 10, 38, 27, 5, 62, 2, 28, 3, 10, 7, 9, 14, 0, 89, 75, 5, 9, 18, 8, 13, 42, 4, 11, 71, 55, 9, 9, 4, 48, 83, 2, 2, 30, 14, 230, 23, 280, 3, 5, 3, 37, 3, 5, 3, 7, 2, 0, 2, 0, 2, 0, 2, 30, 3, 52, 2, 6, 2, 0, 4, 2, 2, 6, 4, 3, 3, 5, 5, 12, 6, 2, 2, 6, 67, 1, 20, 0, 29, 0, 14, 0, 17, 4, 60, 12, 5, 0, 4, 11, 18, 0, 5, 0, 3, 9, 2, 0, 4, 4, 7, 0, 2, 0, 2, 0, 2, 3, 2, 10, 3, 3, 6, 4, 5, 0, 53, 1, 2684, 46, 2, 46, 2, 132, 7, 6, 15, 37, 11, 53, 10, 0, 17, 22, 10, 6, 2, 6, 2, 6, 2, 6, 2, 6, 2, 6, 2, 6, 2, 6, 2, 31, 48, 0, 470, 1, 36, 5, 2, 4, 6, 1, 5, 85, 3, 1, 3, 2, 2, 89, 2, 3, 6, 40, 4, 93, 18, 23, 57, 15, 513, 6581, 75, 20939, 53, 1164, 68, 45, 3, 268, 4, 27, 21, 31, 3, 13, 13, 1, 2, 24, 9, 69, 11, 1, 38, 8, 3, 102, 3, 1, 111, 44, 25, 51, 13, 68, 12, 9, 7, 23, 4, 0, 5, 45, 3, 35, 13, 28, 4, 64, 15, 10, 39, 54, 10, 13, 3, 9, 7, 22, 4, 1, 5, 66, 25, 2, 227, 42, 2, 1, 3, 9, 7, 11171, 13, 22, 5, 48, 8453, 301, 3, 61, 3, 105, 39, 6, 13, 4, 6, 11, 2, 12, 2, 4, 2, 0, 2, 1, 2, 1, 2, 107, 34, 362, 19, 63, 3, 53, 41, 11, 5, 15, 17, 6, 13, 1, 25, 2, 33, 4, 2, 134, 20, 9, 8, 25, 5, 0, 2, 25, 12, 88, 4, 5, 3, 5, 3, 5, 3, 2], i = 0, s = [];
        for (var o = 0; o < r.length; o += 2)
          s.push(i += r[o]), r[o + 1] && s.push(45, i += r[o + 1]);
        t.wordChars = String.fromCharCode.apply(null, s);
      }), ace.define("ace/mode/text", ["require", "exports", "module", "ace/config", "ace/tokenizer", "ace/mode/text_highlight_rules", "ace/mode/behaviour/cstyle", "ace/unicode", "ace/lib/lang", "ace/token_iterator", "ace/range"], function(e, t, n) {
        "use strict";
        var r = e("../config"), i = e("../tokenizer").Tokenizer, s = e("./text_highlight_rules").TextHighlightRules, o = e("./behaviour/cstyle").CstyleBehaviour, u = e("../unicode"), a = e("../lib/lang"), f = e("../token_iterator").TokenIterator, l = e("../range").Range, c = function() {
          this.HighlightRules = s;
        };
        (function() {
          this.$defaultBehaviour = new o(), this.tokenRe = new RegExp("^[" + u.wordChars + "\\$_]+", "g"), this.nonTokenRe = new RegExp("^(?:[^" + u.wordChars + "\\$_]|\\s])+", "g"), this.getTokenizer = function() {
            return this.$tokenizer || (this.$highlightRules = this.$highlightRules || new this.HighlightRules(this.$highlightRuleConfig), this.$tokenizer = new i(this.$highlightRules.getRules())), this.$tokenizer;
          }, this.lineCommentStart = "", this.blockComment = "", this.toggleCommentLines = function(e2, t2, n2, r2) {
            function w(e3) {
              for (var t3 = n2; t3 <= r2; t3++)
                e3(i2.getLine(t3), t3);
            }
            var i2 = t2.doc, s2 = true, o2 = true, u2 = Infinity, f2 = t2.getTabSize(), l2 = false;
            if (!this.lineCommentStart) {
              if (!this.blockComment)
                return false;
              var c2 = this.blockComment.start, h = this.blockComment.end, p = new RegExp("^(\\s*)(?:" + a.escapeRegExp(c2) + ")"), d = new RegExp("(?:" + a.escapeRegExp(h) + ")\\s*$"), v = function(e3, t3) {
                if (g(e3, t3))
                  return;
                if (!s2 || /\S/.test(e3))
                  i2.insertInLine({ row: t3, column: e3.length }, h), i2.insertInLine({ row: t3, column: u2 }, c2);
              }, m = function(e3, t3) {
                var n3;
                (n3 = e3.match(d)) && i2.removeInLine(t3, e3.length - n3[0].length, e3.length), (n3 = e3.match(p)) && i2.removeInLine(t3, n3[1].length, n3[0].length);
              }, g = function(e3, n3) {
                if (p.test(e3))
                  return true;
                var r3 = t2.getTokens(n3);
                for (var i3 = 0; i3 < r3.length; i3++)
                  if (r3[i3].type === "comment")
                    return true;
              };
            } else {
              if (Array.isArray(this.lineCommentStart))
                var p = this.lineCommentStart.map(a.escapeRegExp).join("|"), c2 = this.lineCommentStart[0];
              else
                var p = a.escapeRegExp(this.lineCommentStart), c2 = this.lineCommentStart;
              p = new RegExp("^(\\s*)(?:" + p + ") ?"), l2 = t2.getUseSoftTabs();
              var m = function(e3, t3) {
                var n3 = e3.match(p);
                if (!n3)
                  return;
                var r3 = n3[1].length, s3 = n3[0].length;
                !b(e3, r3, s3) && n3[0][s3 - 1] == " " && s3--, i2.removeInLine(t3, r3, s3);
              }, y = c2 + " ", v = function(e3, t3) {
                if (!s2 || /\S/.test(e3))
                  b(e3, u2, u2) ? i2.insertInLine({ row: t3, column: u2 }, y) : i2.insertInLine({ row: t3, column: u2 }, c2);
              }, g = function(e3, t3) {
                return p.test(e3);
              }, b = function(e3, t3, n3) {
                var r3 = 0;
                while (t3-- && e3.charAt(t3) == " ")
                  r3++;
                if (r3 % f2 != 0)
                  return false;
                var r3 = 0;
                while (e3.charAt(n3++) == " ")
                  r3++;
                return f2 > 2 ? r3 % f2 != f2 - 1 : r3 % f2 == 0;
              };
            }
            var E = Infinity;
            w(function(e3, t3) {
              var n3 = e3.search(/\S/);
              n3 !== -1 ? (n3 < u2 && (u2 = n3), o2 && !g(e3, t3) && (o2 = false)) : E > e3.length && (E = e3.length);
            }), u2 == Infinity && (u2 = E, s2 = false, o2 = false), l2 && u2 % f2 != 0 && (u2 = Math.floor(u2 / f2) * f2), w(o2 ? m : v);
          }, this.toggleBlockComment = function(e2, t2, n2, r2) {
            var i2 = this.blockComment;
            if (!i2)
              return;
            !i2.start && i2[0] && (i2 = i2[0]);
            var s2 = new f(t2, r2.row, r2.column), o2 = s2.getCurrentToken(), u2 = t2.selection, a2 = t2.selection.toOrientedRange(), c2, h;
            if (o2 && /comment/.test(o2.type)) {
              var p, d;
              while (o2 && /comment/.test(o2.type)) {
                var v = o2.value.indexOf(i2.start);
                if (v != -1) {
                  var m = s2.getCurrentTokenRow(), g = s2.getCurrentTokenColumn() + v;
                  p = new l(m, g, m, g + i2.start.length);
                  break;
                }
                o2 = s2.stepBackward();
              }
              var s2 = new f(t2, r2.row, r2.column), o2 = s2.getCurrentToken();
              while (o2 && /comment/.test(o2.type)) {
                var v = o2.value.indexOf(i2.end);
                if (v != -1) {
                  var m = s2.getCurrentTokenRow(), g = s2.getCurrentTokenColumn() + v;
                  d = new l(m, g, m, g + i2.end.length);
                  break;
                }
                o2 = s2.stepForward();
              }
              d && t2.remove(d), p && (t2.remove(p), c2 = p.start.row, h = -i2.start.length);
            } else
              h = i2.start.length, c2 = n2.start.row, t2.insert(n2.end, i2.end), t2.insert(n2.start, i2.start);
            a2.start.row == c2 && (a2.start.column += h), a2.end.row == c2 && (a2.end.column += h), t2.selection.fromOrientedRange(a2);
          }, this.getNextLineIndent = function(e2, t2, n2) {
            return this.$getIndent(t2);
          }, this.checkOutdent = function(e2, t2, n2) {
            return false;
          }, this.autoOutdent = function(e2, t2, n2) {
          }, this.$getIndent = function(e2) {
            return e2.match(/^\s*/)[0];
          }, this.createWorker = function(e2) {
            return null;
          }, this.createModeDelegates = function(e2) {
            this.$embeds = [], this.$modes = {};
            for (var t2 in e2)
              if (e2[t2]) {
                var n2 = e2[t2], i2 = n2.prototype.$id, s2 = r.$modes[i2];
                s2 || (r.$modes[i2] = s2 = new n2()), r.$modes[t2] || (r.$modes[t2] = s2), this.$embeds.push(t2), this.$modes[t2] = s2;
              }
            var o2 = ["toggleBlockComment", "toggleCommentLines", "getNextLineIndent", "checkOutdent", "autoOutdent", "transformAction", "getCompletions"];
            for (var t2 = 0; t2 < o2.length; t2++)
              (function(e3) {
                var n3 = o2[t2], r2 = e3[n3];
                e3[o2[t2]] = function() {
                  return this.$delegator(n3, arguments, r2);
                };
              })(this);
          }, this.$delegator = function(e2, t2, n2) {
            var r2 = t2[0] || "start";
            if (typeof r2 != "string") {
              if (Array.isArray(r2[2])) {
                var i2 = r2[2][r2[2].length - 1], s2 = this.$modes[i2];
                if (s2)
                  return s2[e2].apply(s2, [r2[1]].concat([].slice.call(t2, 1)));
              }
              r2 = r2[0] || "start";
            }
            for (var o2 = 0; o2 < this.$embeds.length; o2++) {
              if (!this.$modes[this.$embeds[o2]])
                continue;
              var u2 = r2.split(this.$embeds[o2]);
              if (!u2[0] && u2[1]) {
                t2[0] = u2[1];
                var s2 = this.$modes[this.$embeds[o2]];
                return s2[e2].apply(s2, t2);
              }
            }
            var a2 = n2.apply(this, t2);
            return n2 ? a2 : void 0;
          }, this.transformAction = function(e2, t2, n2, r2, i2) {
            if (this.$behaviour) {
              var s2 = this.$behaviour.getBehaviours();
              for (var o2 in s2)
                if (s2[o2][t2]) {
                  var u2 = s2[o2][t2].apply(this, arguments);
                  if (u2)
                    return u2;
                }
            }
          }, this.getKeywords = function(e2) {
            if (!this.completionKeywords) {
              var t2 = this.$tokenizer.rules, n2 = [];
              for (var r2 in t2) {
                var i2 = t2[r2];
                for (var s2 = 0, o2 = i2.length; s2 < o2; s2++)
                  if (typeof i2[s2].token == "string")
                    /keyword|support|storage/.test(i2[s2].token) && n2.push(i2[s2].regex);
                  else if (typeof i2[s2].token == "object") {
                    for (var u2 = 0, a2 = i2[s2].token.length; u2 < a2; u2++)
                      if (/keyword|support|storage/.test(i2[s2].token[u2])) {
                        var r2 = i2[s2].regex.match(/\(.+?\)/g)[u2];
                        n2.push(r2.substr(1, r2.length - 2));
                      }
                  }
              }
              this.completionKeywords = n2;
            }
            return e2 ? n2.concat(this.$keywordList || []) : this.$keywordList;
          }, this.$createKeywordList = function() {
            return this.$highlightRules || this.getTokenizer(), this.$keywordList = this.$highlightRules.$keywordList || [];
          }, this.getCompletions = function(e2, t2, n2, r2) {
            var i2 = this.$keywordList || this.$createKeywordList();
            return i2.map(function(e3) {
              return { name: e3, value: e3, score: 0, meta: "keyword" };
            });
          }, this.$id = "ace/mode/text";
        }).call(c.prototype), t.Mode = c;
      }), ace.define("ace/apply_delta", ["require", "exports", "module"], function(e, t, n) {
        "use strict";
        function r(e2, t2) {
          throw console.log("Invalid Delta:", e2), "Invalid Delta: " + t2;
        }
        function i(e2, t2) {
          return t2.row >= 0 && t2.row < e2.length && t2.column >= 0 && t2.column <= e2[t2.row].length;
        }
        function s(e2, t2) {
          t2.action != "insert" && t2.action != "remove" && r(t2, "delta.action must be 'insert' or 'remove'"), t2.lines instanceof Array || r(t2, "delta.lines must be an Array"), (!t2.start || !t2.end) && r(t2, "delta.start/end must be an present");
          var n2 = t2.start;
          i(e2, t2.start) || r(t2, "delta.start must be contained in document");
          var s2 = t2.end;
          t2.action == "remove" && !i(e2, s2) && r(t2, "delta.end must contained in document for 'remove' actions");
          var o = s2.row - n2.row, u = s2.column - (o == 0 ? n2.column : 0);
          (o != t2.lines.length - 1 || t2.lines[o].length != u) && r(t2, "delta.range must match delta lines");
        }
        t.applyDelta = function(e2, t2, n2) {
          var r2 = t2.start.row, i2 = t2.start.column, s2 = e2[r2] || "";
          switch (t2.action) {
            case "insert":
              var o = t2.lines;
              if (o.length === 1)
                e2[r2] = s2.substring(0, i2) + t2.lines[0] + s2.substring(i2);
              else {
                var u = [r2, 1].concat(t2.lines);
                e2.splice.apply(e2, u), e2[r2] = s2.substring(0, i2) + e2[r2], e2[r2 + t2.lines.length - 1] += s2.substring(i2);
              }
              break;
            case "remove":
              var a = t2.end.column, f = t2.end.row;
              r2 === f ? e2[r2] = s2.substring(0, i2) + s2.substring(a) : e2.splice(r2, f - r2 + 1, s2.substring(0, i2) + e2[f].substring(a));
          }
        };
      }), ace.define("ace/anchor", ["require", "exports", "module", "ace/lib/oop", "ace/lib/event_emitter"], function(e, t, n) {
        "use strict";
        var r = e("./lib/oop"), i = e("./lib/event_emitter").EventEmitter, s = t.Anchor = function(e2, t2, n2) {
          this.$onChange = this.onChange.bind(this), this.attach(e2), typeof n2 == "undefined" ? this.setPosition(t2.row, t2.column) : this.setPosition(t2, n2);
        };
        (function() {
          function e2(e3, t3, n2) {
            var r2 = n2 ? e3.column <= t3.column : e3.column < t3.column;
            return e3.row < t3.row || e3.row == t3.row && r2;
          }
          function t2(t3, n2, r2) {
            var i2 = t3.action == "insert", s2 = (i2 ? 1 : -1) * (t3.end.row - t3.start.row), o = (i2 ? 1 : -1) * (t3.end.column - t3.start.column), u = t3.start, a = i2 ? u : t3.end;
            return e2(n2, u, r2) ? { row: n2.row, column: n2.column } : e2(a, n2, !r2) ? { row: n2.row + s2, column: n2.column + (n2.row == a.row ? o : 0) } : { row: u.row, column: u.column };
          }
          r.implement(this, i), this.getPosition = function() {
            return this.$clipPositionToDocument(this.row, this.column);
          }, this.getDocument = function() {
            return this.document;
          }, this.$insertRight = false, this.onChange = function(e3) {
            if (e3.start.row == e3.end.row && e3.start.row != this.row)
              return;
            if (e3.start.row > this.row)
              return;
            var n2 = t2(e3, { row: this.row, column: this.column }, this.$insertRight);
            this.setPosition(n2.row, n2.column, true);
          }, this.setPosition = function(e3, t3, n2) {
            var r2;
            n2 ? r2 = { row: e3, column: t3 } : r2 = this.$clipPositionToDocument(e3, t3);
            if (this.row == r2.row && this.column == r2.column)
              return;
            var i2 = { row: this.row, column: this.column };
            this.row = r2.row, this.column = r2.column, this._signal("change", { old: i2, value: r2 });
          }, this.detach = function() {
            this.document.off("change", this.$onChange);
          }, this.attach = function(e3) {
            this.document = e3 || this.document, this.document.on("change", this.$onChange);
          }, this.$clipPositionToDocument = function(e3, t3) {
            var n2 = {};
            return e3 >= this.document.getLength() ? (n2.row = Math.max(0, this.document.getLength() - 1), n2.column = this.document.getLine(n2.row).length) : e3 < 0 ? (n2.row = 0, n2.column = 0) : (n2.row = e3, n2.column = Math.min(this.document.getLine(n2.row).length, Math.max(0, t3))), t3 < 0 && (n2.column = 0), n2;
          };
        }).call(s.prototype);
      }), ace.define("ace/document", ["require", "exports", "module", "ace/lib/oop", "ace/apply_delta", "ace/lib/event_emitter", "ace/range", "ace/anchor"], function(e, t, n) {
        "use strict";
        var r = e("./lib/oop"), i = e("./apply_delta").applyDelta, s = e("./lib/event_emitter").EventEmitter, o = e("./range").Range, u = e("./anchor").Anchor, a = function(e2) {
          this.$lines = [""], e2.length === 0 ? this.$lines = [""] : Array.isArray(e2) ? this.insertMergedLines({ row: 0, column: 0 }, e2) : this.insert({ row: 0, column: 0 }, e2);
        };
        (function() {
          r.implement(this, s), this.setValue = function(e2) {
            var t2 = this.getLength() - 1;
            this.remove(new o(0, 0, t2, this.getLine(t2).length)), this.insert({ row: 0, column: 0 }, e2);
          }, this.getValue = function() {
            return this.getAllLines().join(this.getNewLineCharacter());
          }, this.createAnchor = function(e2, t2) {
            return new u(this, e2, t2);
          }, "aaa".split(/a/).length === 0 ? this.$split = function(e2) {
            return e2.replace(/\r\n|\r/g, "\n").split("\n");
          } : this.$split = function(e2) {
            return e2.split(/\r\n|\r|\n/);
          }, this.$detectNewLine = function(e2) {
            var t2 = e2.match(/^.*?(\r\n|\r|\n)/m);
            this.$autoNewLine = t2 ? t2[1] : "\n", this._signal("changeNewLineMode");
          }, this.getNewLineCharacter = function() {
            switch (this.$newLineMode) {
              case "windows":
                return "\r\n";
              case "unix":
                return "\n";
              default:
                return this.$autoNewLine || "\n";
            }
          }, this.$autoNewLine = "", this.$newLineMode = "auto", this.setNewLineMode = function(e2) {
            if (this.$newLineMode === e2)
              return;
            this.$newLineMode = e2, this._signal("changeNewLineMode");
          }, this.getNewLineMode = function() {
            return this.$newLineMode;
          }, this.isNewLine = function(e2) {
            return e2 == "\r\n" || e2 == "\r" || e2 == "\n";
          }, this.getLine = function(e2) {
            return this.$lines[e2] || "";
          }, this.getLines = function(e2, t2) {
            return this.$lines.slice(e2, t2 + 1);
          }, this.getAllLines = function() {
            return this.getLines(0, this.getLength());
          }, this.getLength = function() {
            return this.$lines.length;
          }, this.getTextRange = function(e2) {
            return this.getLinesForRange(e2).join(this.getNewLineCharacter());
          }, this.getLinesForRange = function(e2) {
            var t2;
            if (e2.start.row === e2.end.row)
              t2 = [this.getLine(e2.start.row).substring(e2.start.column, e2.end.column)];
            else {
              t2 = this.getLines(e2.start.row, e2.end.row), t2[0] = (t2[0] || "").substring(e2.start.column);
              var n2 = t2.length - 1;
              e2.end.row - e2.start.row == n2 && (t2[n2] = t2[n2].substring(0, e2.end.column));
            }
            return t2;
          }, this.insertLines = function(e2, t2) {
            return console.warn("Use of document.insertLines is deprecated. Use the insertFullLines method instead."), this.insertFullLines(e2, t2);
          }, this.removeLines = function(e2, t2) {
            return console.warn("Use of document.removeLines is deprecated. Use the removeFullLines method instead."), this.removeFullLines(e2, t2);
          }, this.insertNewLine = function(e2) {
            return console.warn("Use of document.insertNewLine is deprecated. Use insertMergedLines(position, ['', '']) instead."), this.insertMergedLines(e2, ["", ""]);
          }, this.insert = function(e2, t2) {
            return this.getLength() <= 1 && this.$detectNewLine(t2), this.insertMergedLines(e2, this.$split(t2));
          }, this.insertInLine = function(e2, t2) {
            var n2 = this.clippedPos(e2.row, e2.column), r2 = this.pos(e2.row, e2.column + t2.length);
            return this.applyDelta({ start: n2, end: r2, action: "insert", lines: [t2] }, true), this.clonePos(r2);
          }, this.clippedPos = function(e2, t2) {
            var n2 = this.getLength();
            e2 === void 0 ? e2 = n2 : e2 < 0 ? e2 = 0 : e2 >= n2 && (e2 = n2 - 1, t2 = void 0);
            var r2 = this.getLine(e2);
            return t2 == void 0 && (t2 = r2.length), t2 = Math.min(Math.max(t2, 0), r2.length), { row: e2, column: t2 };
          }, this.clonePos = function(e2) {
            return { row: e2.row, column: e2.column };
          }, this.pos = function(e2, t2) {
            return { row: e2, column: t2 };
          }, this.$clipPosition = function(e2) {
            var t2 = this.getLength();
            return e2.row >= t2 ? (e2.row = Math.max(0, t2 - 1), e2.column = this.getLine(t2 - 1).length) : (e2.row = Math.max(0, e2.row), e2.column = Math.min(Math.max(e2.column, 0), this.getLine(e2.row).length)), e2;
          }, this.insertFullLines = function(e2, t2) {
            e2 = Math.min(Math.max(e2, 0), this.getLength());
            var n2 = 0;
            e2 < this.getLength() ? (t2 = t2.concat([""]), n2 = 0) : (t2 = [""].concat(t2), e2--, n2 = this.$lines[e2].length), this.insertMergedLines({ row: e2, column: n2 }, t2);
          }, this.insertMergedLines = function(e2, t2) {
            var n2 = this.clippedPos(e2.row, e2.column), r2 = { row: n2.row + t2.length - 1, column: (t2.length == 1 ? n2.column : 0) + t2[t2.length - 1].length };
            return this.applyDelta({ start: n2, end: r2, action: "insert", lines: t2 }), this.clonePos(r2);
          }, this.remove = function(e2) {
            var t2 = this.clippedPos(e2.start.row, e2.start.column), n2 = this.clippedPos(e2.end.row, e2.end.column);
            return this.applyDelta({ start: t2, end: n2, action: "remove", lines: this.getLinesForRange({ start: t2, end: n2 }) }), this.clonePos(t2);
          }, this.removeInLine = function(e2, t2, n2) {
            var r2 = this.clippedPos(e2, t2), i2 = this.clippedPos(e2, n2);
            return this.applyDelta({ start: r2, end: i2, action: "remove", lines: this.getLinesForRange({ start: r2, end: i2 }) }, true), this.clonePos(r2);
          }, this.removeFullLines = function(e2, t2) {
            e2 = Math.min(Math.max(0, e2), this.getLength() - 1), t2 = Math.min(Math.max(0, t2), this.getLength() - 1);
            var n2 = t2 == this.getLength() - 1 && e2 > 0, r2 = t2 < this.getLength() - 1, i2 = n2 ? e2 - 1 : e2, s2 = n2 ? this.getLine(i2).length : 0, u2 = r2 ? t2 + 1 : t2, a2 = r2 ? 0 : this.getLine(u2).length, f = new o(i2, s2, u2, a2), l = this.$lines.slice(e2, t2 + 1);
            return this.applyDelta({ start: f.start, end: f.end, action: "remove", lines: this.getLinesForRange(f) }), l;
          }, this.removeNewLine = function(e2) {
            e2 < this.getLength() - 1 && e2 >= 0 && this.applyDelta({ start: this.pos(e2, this.getLine(e2).length), end: this.pos(e2 + 1, 0), action: "remove", lines: ["", ""] });
          }, this.replace = function(e2, t2) {
            e2 instanceof o || (e2 = o.fromPoints(e2.start, e2.end));
            if (t2.length === 0 && e2.isEmpty())
              return e2.start;
            if (t2 == this.getTextRange(e2))
              return e2.end;
            this.remove(e2);
            var n2;
            return t2 ? n2 = this.insert(e2.start, t2) : n2 = e2.start, n2;
          }, this.applyDeltas = function(e2) {
            for (var t2 = 0; t2 < e2.length; t2++)
              this.applyDelta(e2[t2]);
          }, this.revertDeltas = function(e2) {
            for (var t2 = e2.length - 1; t2 >= 0; t2--)
              this.revertDelta(e2[t2]);
          }, this.applyDelta = function(e2, t2) {
            var n2 = e2.action == "insert";
            if (n2 ? e2.lines.length <= 1 && !e2.lines[0] : !o.comparePoints(e2.start, e2.end))
              return;
            n2 && e2.lines.length > 2e4 ? this.$splitAndapplyLargeDelta(e2, 2e4) : (i(this.$lines, e2, t2), this._signal("change", e2));
          }, this.$safeApplyDelta = function(e2) {
            var t2 = this.$lines.length;
            (e2.action == "remove" && e2.start.row < t2 && e2.end.row < t2 || e2.action == "insert" && e2.start.row <= t2) && this.applyDelta(e2);
          }, this.$splitAndapplyLargeDelta = function(e2, t2) {
            var n2 = e2.lines, r2 = n2.length - t2 + 1, i2 = e2.start.row, s2 = e2.start.column;
            for (var o2 = 0, u2 = 0; o2 < r2; o2 = u2) {
              u2 += t2 - 1;
              var a2 = n2.slice(o2, u2);
              a2.push(""), this.applyDelta({ start: this.pos(i2 + o2, s2), end: this.pos(i2 + u2, s2 = 0), action: e2.action, lines: a2 }, true);
            }
            e2.lines = n2.slice(o2), e2.start.row = i2 + o2, e2.start.column = s2, this.applyDelta(e2, true);
          }, this.revertDelta = function(e2) {
            this.$safeApplyDelta({ start: this.clonePos(e2.start), end: this.clonePos(e2.end), action: e2.action == "insert" ? "remove" : "insert", lines: e2.lines.slice() });
          }, this.indexToPosition = function(e2, t2) {
            var n2 = this.$lines || this.getAllLines(), r2 = this.getNewLineCharacter().length;
            for (var i2 = t2 || 0, s2 = n2.length; i2 < s2; i2++) {
              e2 -= n2[i2].length + r2;
              if (e2 < 0)
                return { row: i2, column: e2 + n2[i2].length + r2 };
            }
            return { row: s2 - 1, column: e2 + n2[s2 - 1].length + r2 };
          }, this.positionToIndex = function(e2, t2) {
            var n2 = this.$lines || this.getAllLines(), r2 = this.getNewLineCharacter().length, i2 = 0, s2 = Math.min(e2.row, n2.length);
            for (var o2 = t2 || 0; o2 < s2; ++o2)
              i2 += n2[o2].length + r2;
            return i2 + e2.column;
          };
        }).call(a.prototype), t.Document = a;
      }), ace.define("ace/background_tokenizer", ["require", "exports", "module", "ace/lib/oop", "ace/lib/event_emitter"], function(e, t, n) {
        "use strict";
        var r = e("./lib/oop"), i = e("./lib/event_emitter").EventEmitter, s = function(e2, t2) {
          this.running = false, this.lines = [], this.states = [], this.currentLine = 0, this.tokenizer = e2;
          var n2 = this;
          this.$worker = function() {
            if (!n2.running)
              return;
            var e3 = /* @__PURE__ */ new Date(), t3 = n2.currentLine, r2 = -1, i2 = n2.doc, s2 = t3;
            while (n2.lines[t3])
              t3++;
            var o = i2.getLength(), u = 0;
            n2.running = false;
            while (t3 < o) {
              n2.$tokenizeRow(t3), r2 = t3;
              do
                t3++;
              while (n2.lines[t3]);
              u++;
              if (u % 5 === 0 && /* @__PURE__ */ new Date() - e3 > 20) {
                n2.running = setTimeout(n2.$worker, 20);
                break;
              }
            }
            n2.currentLine = t3, r2 == -1 && (r2 = t3), s2 <= r2 && n2.fireUpdateEvent(s2, r2);
          };
        };
        (function() {
          r.implement(this, i), this.setTokenizer = function(e2) {
            this.tokenizer = e2, this.lines = [], this.states = [], this.start(0);
          }, this.setDocument = function(e2) {
            this.doc = e2, this.lines = [], this.states = [], this.stop();
          }, this.fireUpdateEvent = function(e2, t2) {
            var n2 = { first: e2, last: t2 };
            this._signal("update", { data: n2 });
          }, this.start = function(e2) {
            this.currentLine = Math.min(e2 || 0, this.currentLine, this.doc.getLength()), this.lines.splice(this.currentLine, this.lines.length), this.states.splice(this.currentLine, this.states.length), this.stop(), this.running = setTimeout(this.$worker, 700);
          }, this.scheduleStart = function() {
            this.running || (this.running = setTimeout(this.$worker, 700));
          }, this.$updateOnChange = function(e2) {
            var t2 = e2.start.row, n2 = e2.end.row - t2;
            if (n2 === 0)
              this.lines[t2] = null;
            else if (e2.action == "remove")
              this.lines.splice(t2, n2 + 1, null), this.states.splice(t2, n2 + 1, null);
            else {
              var r2 = Array(n2 + 1);
              r2.unshift(t2, 1), this.lines.splice.apply(this.lines, r2), this.states.splice.apply(this.states, r2);
            }
            this.currentLine = Math.min(t2, this.currentLine, this.doc.getLength()), this.stop();
          }, this.stop = function() {
            this.running && clearTimeout(this.running), this.running = false;
          }, this.getTokens = function(e2) {
            return this.lines[e2] || this.$tokenizeRow(e2);
          }, this.getState = function(e2) {
            return this.currentLine == e2 && this.$tokenizeRow(e2), this.states[e2] || "start";
          }, this.$tokenizeRow = function(e2) {
            var t2 = this.doc.getLine(e2), n2 = this.states[e2 - 1], r2 = this.tokenizer.getLineTokens(t2, n2, e2);
            return this.states[e2] + "" != r2.state + "" ? (this.states[e2] = r2.state, this.lines[e2 + 1] = null, this.currentLine > e2 + 1 && (this.currentLine = e2 + 1)) : this.currentLine == e2 && (this.currentLine = e2 + 1), this.lines[e2] = r2.tokens;
          }, this.cleanup = function() {
            this.running = false, this.lines = [], this.states = [], this.currentLine = 0, this.removeAllListeners();
          };
        }).call(s.prototype), t.BackgroundTokenizer = s;
      }), ace.define("ace/search_highlight", ["require", "exports", "module", "ace/lib/lang", "ace/lib/oop", "ace/range"], function(e, t, n) {
        "use strict";
        var r = e("./lib/lang"), i = e("./lib/oop"), s = e("./range").Range, o = function(e2, t2, n2) {
          this.setRegexp(e2), this.clazz = t2, this.type = n2 || "text";
        };
        (function() {
          this.MAX_RANGES = 500, this.setRegexp = function(e2) {
            if (this.regExp + "" == e2 + "")
              return;
            this.regExp = e2, this.cache = [];
          }, this.update = function(e2, t2, n2, i2) {
            if (!this.regExp)
              return;
            var o2 = i2.firstRow, u = i2.lastRow, a = {};
            for (var f = o2; f <= u; f++) {
              var l = this.cache[f];
              l == null && (l = r.getMatchOffsets(n2.getLine(f), this.regExp), l.length > this.MAX_RANGES && (l = l.slice(0, this.MAX_RANGES)), l = l.map(function(e3) {
                return new s(f, e3.offset, f, e3.offset + e3.length);
              }), this.cache[f] = l.length ? l : "");
              for (var c = l.length; c--; ) {
                var h = l[c].toScreenRange(n2), p = h.toString();
                if (a[p])
                  continue;
                a[p] = true, t2.drawSingleLineMarker(e2, h, this.clazz, i2);
              }
            }
          };
        }).call(o.prototype), t.SearchHighlight = o;
      }), ace.define("ace/edit_session/fold_line", ["require", "exports", "module", "ace/range"], function(e, t, n) {
        "use strict";
        function i(e2, t2) {
          this.foldData = e2, Array.isArray(t2) ? this.folds = t2 : t2 = this.folds = [t2];
          var n2 = t2[t2.length - 1];
          this.range = new r(t2[0].start.row, t2[0].start.column, n2.end.row, n2.end.column), this.start = this.range.start, this.end = this.range.end, this.folds.forEach(function(e3) {
            e3.setFoldLine(this);
          }, this);
        }
        var r = e("../range").Range;
        (function() {
          this.shiftRow = function(e2) {
            this.start.row += e2, this.end.row += e2, this.folds.forEach(function(t2) {
              t2.start.row += e2, t2.end.row += e2;
            });
          }, this.addFold = function(e2) {
            if (e2.sameRow) {
              if (e2.start.row < this.startRow || e2.endRow > this.endRow)
                throw new Error("Can't add a fold to this FoldLine as it has no connection");
              this.folds.push(e2), this.folds.sort(function(e3, t2) {
                return -e3.range.compareEnd(t2.start.row, t2.start.column);
              }), this.range.compareEnd(e2.start.row, e2.start.column) > 0 ? (this.end.row = e2.end.row, this.end.column = e2.end.column) : this.range.compareStart(e2.end.row, e2.end.column) < 0 && (this.start.row = e2.start.row, this.start.column = e2.start.column);
            } else if (e2.start.row == this.end.row)
              this.folds.push(e2), this.end.row = e2.end.row, this.end.column = e2.end.column;
            else {
              if (e2.end.row != this.start.row)
                throw new Error("Trying to add fold to FoldRow that doesn't have a matching row");
              this.folds.unshift(e2), this.start.row = e2.start.row, this.start.column = e2.start.column;
            }
            e2.foldLine = this;
          }, this.containsRow = function(e2) {
            return e2 >= this.start.row && e2 <= this.end.row;
          }, this.walk = function(e2, t2, n2) {
            var r2 = 0, i2 = this.folds, s, o, u, a = true;
            t2 == null && (t2 = this.end.row, n2 = this.end.column);
            for (var f = 0; f < i2.length; f++) {
              s = i2[f], o = s.range.compareStart(t2, n2);
              if (o == -1) {
                e2(null, t2, n2, r2, a);
                return;
              }
              u = e2(null, s.start.row, s.start.column, r2, a), u = !u && e2(s.placeholder, s.start.row, s.start.column, r2);
              if (u || o === 0)
                return;
              a = !s.sameRow, r2 = s.end.column;
            }
            e2(null, t2, n2, r2, a);
          }, this.getNextFoldTo = function(e2, t2) {
            var n2, r2;
            for (var i2 = 0; i2 < this.folds.length; i2++) {
              n2 = this.folds[i2], r2 = n2.range.compareEnd(e2, t2);
              if (r2 == -1)
                return { fold: n2, kind: "after" };
              if (r2 === 0)
                return { fold: n2, kind: "inside" };
            }
            return null;
          }, this.addRemoveChars = function(e2, t2, n2) {
            var r2 = this.getNextFoldTo(e2, t2), i2, s;
            if (r2) {
              i2 = r2.fold;
              if (r2.kind == "inside" && i2.start.column != t2 && i2.start.row != e2)
                window.console && window.console.log(e2, t2, i2);
              else if (i2.start.row == e2) {
                s = this.folds;
                var o = s.indexOf(i2);
                o === 0 && (this.start.column += n2);
                for (o; o < s.length; o++) {
                  i2 = s[o], i2.start.column += n2;
                  if (!i2.sameRow)
                    return;
                  i2.end.column += n2;
                }
                this.end.column += n2;
              }
            }
          }, this.split = function(e2, t2) {
            var n2 = this.getNextFoldTo(e2, t2);
            if (!n2 || n2.kind == "inside")
              return null;
            var r2 = n2.fold, s = this.folds, o = this.foldData, u = s.indexOf(r2), a = s[u - 1];
            this.end.row = a.end.row, this.end.column = a.end.column, s = s.splice(u, s.length - u);
            var f = new i(o, s);
            return o.splice(o.indexOf(this) + 1, 0, f), f;
          }, this.merge = function(e2) {
            var t2 = e2.folds;
            for (var n2 = 0; n2 < t2.length; n2++)
              this.addFold(t2[n2]);
            var r2 = this.foldData;
            r2.splice(r2.indexOf(e2), 1);
          }, this.toString = function() {
            var e2 = [this.range.toString() + ": ["];
            return this.folds.forEach(function(t2) {
              e2.push("  " + t2.toString());
            }), e2.push("]"), e2.join("\n");
          }, this.idxToPosition = function(e2) {
            var t2 = 0;
            for (var n2 = 0; n2 < this.folds.length; n2++) {
              var r2 = this.folds[n2];
              e2 -= r2.start.column - t2;
              if (e2 < 0)
                return { row: r2.start.row, column: r2.start.column + e2 };
              e2 -= r2.placeholder.length;
              if (e2 < 0)
                return r2.start;
              t2 = r2.end.column;
            }
            return { row: this.end.row, column: this.end.column + e2 };
          };
        }).call(i.prototype), t.FoldLine = i;
      }), ace.define("ace/range_list", ["require", "exports", "module", "ace/range"], function(e, t, n) {
        "use strict";
        var r = e("./range").Range, i = r.comparePoints, s = function() {
          this.ranges = [], this.$bias = 1;
        };
        (function() {
          this.comparePoints = i, this.pointIndex = function(e2, t2, n2) {
            var r2 = this.ranges;
            for (var s2 = n2 || 0; s2 < r2.length; s2++) {
              var o = r2[s2], u = i(e2, o.end);
              if (u > 0)
                continue;
              var a = i(e2, o.start);
              return u === 0 ? t2 && a !== 0 ? -s2 - 2 : s2 : a > 0 || a === 0 && !t2 ? s2 : -s2 - 1;
            }
            return -s2 - 1;
          }, this.add = function(e2) {
            var t2 = !e2.isEmpty(), n2 = this.pointIndex(e2.start, t2);
            n2 < 0 && (n2 = -n2 - 1);
            var r2 = this.pointIndex(e2.end, t2, n2);
            return r2 < 0 ? r2 = -r2 - 1 : r2++, this.ranges.splice(n2, r2 - n2, e2);
          }, this.addList = function(e2) {
            var t2 = [];
            for (var n2 = e2.length; n2--; )
              t2.push.apply(t2, this.add(e2[n2]));
            return t2;
          }, this.substractPoint = function(e2) {
            var t2 = this.pointIndex(e2);
            if (t2 >= 0)
              return this.ranges.splice(t2, 1);
          }, this.merge = function() {
            var e2 = [], t2 = this.ranges;
            t2 = t2.sort(function(e3, t3) {
              return i(e3.start, t3.start);
            });
            var n2 = t2[0], r2;
            for (var s2 = 1; s2 < t2.length; s2++) {
              r2 = n2, n2 = t2[s2];
              var o = i(r2.end, n2.start);
              if (o < 0)
                continue;
              if (o == 0 && !r2.isEmpty() && !n2.isEmpty())
                continue;
              i(r2.end, n2.end) < 0 && (r2.end.row = n2.end.row, r2.end.column = n2.end.column), t2.splice(s2, 1), e2.push(n2), n2 = r2, s2--;
            }
            return this.ranges = t2, e2;
          }, this.contains = function(e2, t2) {
            return this.pointIndex({ row: e2, column: t2 }) >= 0;
          }, this.containsPoint = function(e2) {
            return this.pointIndex(e2) >= 0;
          }, this.rangeAtPoint = function(e2) {
            var t2 = this.pointIndex(e2);
            if (t2 >= 0)
              return this.ranges[t2];
          }, this.clipRows = function(e2, t2) {
            var n2 = this.ranges;
            if (n2[0].start.row > t2 || n2[n2.length - 1].start.row < e2)
              return [];
            var r2 = this.pointIndex({ row: e2, column: 0 });
            r2 < 0 && (r2 = -r2 - 1);
            var i2 = this.pointIndex({ row: t2, column: 0 }, r2);
            i2 < 0 && (i2 = -i2 - 1);
            var s2 = [];
            for (var o = r2; o < i2; o++)
              s2.push(n2[o]);
            return s2;
          }, this.removeAll = function() {
            return this.ranges.splice(0, this.ranges.length);
          }, this.attach = function(e2) {
            this.session && this.detach(), this.session = e2, this.onChange = this.$onChange.bind(this), this.session.on("change", this.onChange);
          }, this.detach = function() {
            if (!this.session)
              return;
            this.session.removeListener("change", this.onChange), this.session = null;
          }, this.$onChange = function(e2) {
            var t2 = e2.start, n2 = e2.end, r2 = t2.row, i2 = n2.row, s2 = this.ranges;
            for (var o = 0, u = s2.length; o < u; o++) {
              var a = s2[o];
              if (a.end.row >= r2)
                break;
            }
            if (e2.action == "insert") {
              var f = i2 - r2, l = -t2.column + n2.column;
              for (; o < u; o++) {
                var a = s2[o];
                if (a.start.row > r2)
                  break;
                a.start.row == r2 && a.start.column >= t2.column && (a.start.column == t2.column && this.$bias <= 0 || (a.start.column += l, a.start.row += f));
                if (a.end.row == r2 && a.end.column >= t2.column) {
                  if (a.end.column == t2.column && this.$bias < 0)
                    continue;
                  a.end.column == t2.column && l > 0 && o < u - 1 && a.end.column > a.start.column && a.end.column == s2[o + 1].start.column && (a.end.column -= l), a.end.column += l, a.end.row += f;
                }
              }
            } else {
              var f = r2 - i2, l = t2.column - n2.column;
              for (; o < u; o++) {
                var a = s2[o];
                if (a.start.row > i2)
                  break;
                if (a.end.row < i2 && (r2 < a.end.row || r2 == a.end.row && t2.column < a.end.column))
                  a.end.row = r2, a.end.column = t2.column;
                else if (a.end.row == i2)
                  if (a.end.column <= n2.column) {
                    if (f || a.end.column > t2.column)
                      a.end.column = t2.column, a.end.row = t2.row;
                  } else
                    a.end.column += l, a.end.row += f;
                else
                  a.end.row > i2 && (a.end.row += f);
                if (a.start.row < i2 && (r2 < a.start.row || r2 == a.start.row && t2.column < a.start.column))
                  a.start.row = r2, a.start.column = t2.column;
                else if (a.start.row == i2)
                  if (a.start.column <= n2.column) {
                    if (f || a.start.column > t2.column)
                      a.start.column = t2.column, a.start.row = t2.row;
                  } else
                    a.start.column += l, a.start.row += f;
                else
                  a.start.row > i2 && (a.start.row += f);
              }
            }
            if (f != 0 && o < u)
              for (; o < u; o++) {
                var a = s2[o];
                a.start.row += f, a.end.row += f;
              }
          };
        }).call(s.prototype), t.RangeList = s;
      }), ace.define("ace/edit_session/fold", ["require", "exports", "module", "ace/range_list", "ace/lib/oop"], function(e, t, n) {
        "use strict";
        function o(e2, t2) {
          e2.row -= t2.row, e2.row == 0 && (e2.column -= t2.column);
        }
        function u(e2, t2) {
          o(e2.start, t2), o(e2.end, t2);
        }
        function a(e2, t2) {
          e2.row == 0 && (e2.column += t2.column), e2.row += t2.row;
        }
        function f(e2, t2) {
          a(e2.start, t2), a(e2.end, t2);
        }
        var r = e("../range_list").RangeList, i = e("../lib/oop"), s = t.Fold = function(e2, t2) {
          this.foldLine = null, this.placeholder = t2, this.range = e2, this.start = e2.start, this.end = e2.end, this.sameRow = e2.start.row == e2.end.row, this.subFolds = this.ranges = [];
        };
        i.inherits(s, r), function() {
          this.toString = function() {
            return '"' + this.placeholder + '" ' + this.range.toString();
          }, this.setFoldLine = function(e2) {
            this.foldLine = e2, this.subFolds.forEach(function(t2) {
              t2.setFoldLine(e2);
            });
          }, this.clone = function() {
            var e2 = this.range.clone(), t2 = new s(e2, this.placeholder);
            return this.subFolds.forEach(function(e3) {
              t2.subFolds.push(e3.clone());
            }), t2.collapseChildren = this.collapseChildren, t2;
          }, this.addSubFold = function(e2) {
            if (this.range.isEqual(e2))
              return;
            u(e2, this.start);
            var t2 = e2.start.row, n2 = e2.start.column;
            for (var r2 = 0, i2 = -1; r2 < this.subFolds.length; r2++) {
              i2 = this.subFolds[r2].range.compare(t2, n2);
              if (i2 != 1)
                break;
            }
            var s2 = this.subFolds[r2], o2 = 0;
            if (i2 == 0) {
              if (s2.range.containsRange(e2))
                return s2.addSubFold(e2);
              o2 = 1;
            }
            var t2 = e2.range.end.row, n2 = e2.range.end.column;
            for (var a2 = r2, i2 = -1; a2 < this.subFolds.length; a2++) {
              i2 = this.subFolds[a2].range.compare(t2, n2);
              if (i2 != 1)
                break;
            }
            i2 == 0 && a2++;
            var f2 = this.subFolds.splice(r2, a2 - r2, e2), l = i2 == 0 ? f2.length - 1 : f2.length;
            for (var c = o2; c < l; c++)
              e2.addSubFold(f2[c]);
            return e2.setFoldLine(this.foldLine), e2;
          }, this.restoreRange = function(e2) {
            return f(e2, this.start);
          };
        }.call(s.prototype);
      }), ace.define("ace/edit_session/folding", ["require", "exports", "module", "ace/range", "ace/edit_session/fold_line", "ace/edit_session/fold", "ace/token_iterator"], function(e, t, n) {
        "use strict";
        function u() {
          this.getFoldAt = function(e2, t2, n2) {
            var r2 = this.getFoldLine(e2);
            if (!r2)
              return null;
            var i2 = r2.folds;
            for (var s2 = 0; s2 < i2.length; s2++) {
              var o2 = i2[s2].range;
              if (o2.contains(e2, t2)) {
                if (n2 == 1 && o2.isEnd(e2, t2) && !o2.isEmpty())
                  continue;
                if (n2 == -1 && o2.isStart(e2, t2) && !o2.isEmpty())
                  continue;
                return i2[s2];
              }
            }
          }, this.getFoldsInRange = function(e2) {
            var t2 = e2.start, n2 = e2.end, r2 = this.$foldData, i2 = [];
            t2.column += 1, n2.column -= 1;
            for (var s2 = 0; s2 < r2.length; s2++) {
              var o2 = r2[s2].range.compareRange(e2);
              if (o2 == 2)
                continue;
              if (o2 == -2)
                break;
              var u2 = r2[s2].folds;
              for (var a = 0; a < u2.length; a++) {
                var f = u2[a];
                o2 = f.range.compareRange(e2);
                if (o2 == -2)
                  break;
                if (o2 == 2)
                  continue;
                if (o2 == 42)
                  break;
                i2.push(f);
              }
            }
            return t2.column -= 1, n2.column += 1, i2;
          }, this.getFoldsInRangeList = function(e2) {
            if (Array.isArray(e2)) {
              var t2 = [];
              e2.forEach(function(e3) {
                t2 = t2.concat(this.getFoldsInRange(e3));
              }, this);
            } else
              var t2 = this.getFoldsInRange(e2);
            return t2;
          }, this.getAllFolds = function() {
            var e2 = [], t2 = this.$foldData;
            for (var n2 = 0; n2 < t2.length; n2++)
              for (var r2 = 0; r2 < t2[n2].folds.length; r2++)
                e2.push(t2[n2].folds[r2]);
            return e2;
          }, this.getFoldStringAt = function(e2, t2, n2, r2) {
            r2 = r2 || this.getFoldLine(e2);
            if (!r2)
              return null;
            var i2 = { end: { column: 0 } }, s2, o2;
            for (var u2 = 0; u2 < r2.folds.length; u2++) {
              o2 = r2.folds[u2];
              var a = o2.range.compareEnd(e2, t2);
              if (a == -1) {
                s2 = this.getLine(o2.start.row).substring(i2.end.column, o2.start.column);
                break;
              }
              if (a === 0)
                return null;
              i2 = o2;
            }
            return s2 || (s2 = this.getLine(o2.start.row).substring(i2.end.column)), n2 == -1 ? s2.substring(0, t2 - i2.end.column) : n2 == 1 ? s2.substring(t2 - i2.end.column) : s2;
          }, this.getFoldLine = function(e2, t2) {
            var n2 = this.$foldData, r2 = 0;
            t2 && (r2 = n2.indexOf(t2)), r2 == -1 && (r2 = 0);
            for (r2; r2 < n2.length; r2++) {
              var i2 = n2[r2];
              if (i2.start.row <= e2 && i2.end.row >= e2)
                return i2;
              if (i2.end.row > e2)
                return null;
            }
            return null;
          }, this.getNextFoldLine = function(e2, t2) {
            var n2 = this.$foldData, r2 = 0;
            t2 && (r2 = n2.indexOf(t2)), r2 == -1 && (r2 = 0);
            for (r2; r2 < n2.length; r2++) {
              var i2 = n2[r2];
              if (i2.end.row >= e2)
                return i2;
            }
            return null;
          }, this.getFoldedRowCount = function(e2, t2) {
            var n2 = this.$foldData, r2 = t2 - e2 + 1;
            for (var i2 = 0; i2 < n2.length; i2++) {
              var s2 = n2[i2], o2 = s2.end.row, u2 = s2.start.row;
              if (o2 >= t2) {
                u2 < t2 && (u2 >= e2 ? r2 -= t2 - u2 : r2 = 0);
                break;
              }
              o2 >= e2 && (u2 >= e2 ? r2 -= o2 - u2 : r2 -= o2 - e2 + 1);
            }
            return r2;
          }, this.$addFoldLine = function(e2) {
            return this.$foldData.push(e2), this.$foldData.sort(function(e3, t2) {
              return e3.start.row - t2.start.row;
            }), e2;
          }, this.addFold = function(e2, t2) {
            var n2 = this.$foldData, r2 = false, o2;
            e2 instanceof s ? o2 = e2 : (o2 = new s(t2, e2), o2.collapseChildren = t2.collapseChildren), this.$clipRangeToDocument(o2.range);
            var u2 = o2.start.row, a = o2.start.column, f = o2.end.row, l = o2.end.column, c = this.getFoldAt(u2, a, 1), h = this.getFoldAt(f, l, -1);
            if (c && h == c)
              return c.addSubFold(o2);
            c && !c.range.isStart(u2, a) && this.removeFold(c), h && !h.range.isEnd(f, l) && this.removeFold(h);
            var p = this.getFoldsInRange(o2.range);
            p.length > 0 && (this.removeFolds(p), o2.collapseChildren || p.forEach(function(e3) {
              o2.addSubFold(e3);
            }));
            for (var d = 0; d < n2.length; d++) {
              var v = n2[d];
              if (f == v.start.row) {
                v.addFold(o2), r2 = true;
                break;
              }
              if (u2 == v.end.row) {
                v.addFold(o2), r2 = true;
                if (!o2.sameRow) {
                  var m = n2[d + 1];
                  if (m && m.start.row == f) {
                    v.merge(m);
                    break;
                  }
                }
                break;
              }
              if (f <= v.start.row)
                break;
            }
            return r2 || (v = this.$addFoldLine(new i(this.$foldData, o2))), this.$useWrapMode ? this.$updateWrapData(v.start.row, v.start.row) : this.$updateRowLengthCache(v.start.row, v.start.row), this.$modified = true, this._signal("changeFold", { data: o2, action: "add" }), o2;
          }, this.addFolds = function(e2) {
            e2.forEach(function(e3) {
              this.addFold(e3);
            }, this);
          }, this.removeFold = function(e2) {
            var t2 = e2.foldLine, n2 = t2.start.row, r2 = t2.end.row, i2 = this.$foldData, s2 = t2.folds;
            if (s2.length == 1)
              i2.splice(i2.indexOf(t2), 1);
            else if (t2.range.isEnd(e2.end.row, e2.end.column))
              s2.pop(), t2.end.row = s2[s2.length - 1].end.row, t2.end.column = s2[s2.length - 1].end.column;
            else if (t2.range.isStart(e2.start.row, e2.start.column))
              s2.shift(), t2.start.row = s2[0].start.row, t2.start.column = s2[0].start.column;
            else if (e2.sameRow)
              s2.splice(s2.indexOf(e2), 1);
            else {
              var o2 = t2.split(e2.start.row, e2.start.column);
              s2 = o2.folds, s2.shift(), o2.start.row = s2[0].start.row, o2.start.column = s2[0].start.column;
            }
            this.$updating || (this.$useWrapMode ? this.$updateWrapData(n2, r2) : this.$updateRowLengthCache(n2, r2)), this.$modified = true, this._signal("changeFold", { data: e2, action: "remove" });
          }, this.removeFolds = function(e2) {
            var t2 = [];
            for (var n2 = 0; n2 < e2.length; n2++)
              t2.push(e2[n2]);
            t2.forEach(function(e3) {
              this.removeFold(e3);
            }, this), this.$modified = true;
          }, this.expandFold = function(e2) {
            this.removeFold(e2), e2.subFolds.forEach(function(t2) {
              e2.restoreRange(t2), this.addFold(t2);
            }, this), e2.collapseChildren > 0 && this.foldAll(e2.start.row + 1, e2.end.row, e2.collapseChildren - 1), e2.subFolds = [];
          }, this.expandFolds = function(e2) {
            e2.forEach(function(e3) {
              this.expandFold(e3);
            }, this);
          }, this.unfold = function(e2, t2) {
            var n2, i2;
            if (e2 == null)
              n2 = new r(0, 0, this.getLength(), 0), t2 == null && (t2 = true);
            else if (typeof e2 == "number")
              n2 = new r(e2, 0, e2, this.getLine(e2).length);
            else if ("row" in e2)
              n2 = r.fromPoints(e2, e2);
            else {
              if (Array.isArray(e2))
                return i2 = [], e2.forEach(function(e3) {
                  i2 = i2.concat(this.unfold(e3));
                }, this), i2;
              n2 = e2;
            }
            i2 = this.getFoldsInRangeList(n2);
            var s2 = i2;
            while (i2.length == 1 && r.comparePoints(i2[0].start, n2.start) < 0 && r.comparePoints(i2[0].end, n2.end) > 0)
              this.expandFolds(i2), i2 = this.getFoldsInRangeList(n2);
            t2 != 0 ? this.removeFolds(i2) : this.expandFolds(i2);
            if (s2.length)
              return s2;
          }, this.isRowFolded = function(e2, t2) {
            return !!this.getFoldLine(e2, t2);
          }, this.getRowFoldEnd = function(e2, t2) {
            var n2 = this.getFoldLine(e2, t2);
            return n2 ? n2.end.row : e2;
          }, this.getRowFoldStart = function(e2, t2) {
            var n2 = this.getFoldLine(e2, t2);
            return n2 ? n2.start.row : e2;
          }, this.getFoldDisplayLine = function(e2, t2, n2, r2, i2) {
            r2 == null && (r2 = e2.start.row), i2 == null && (i2 = 0), t2 == null && (t2 = e2.end.row), n2 == null && (n2 = this.getLine(t2).length);
            var s2 = this.doc, o2 = "";
            return e2.walk(function(e3, t3, n3, u2) {
              if (t3 < r2)
                return;
              if (t3 == r2) {
                if (n3 < i2)
                  return;
                u2 = Math.max(i2, u2);
              }
              e3 != null ? o2 += e3 : o2 += s2.getLine(t3).substring(u2, n3);
            }, t2, n2), o2;
          }, this.getDisplayLine = function(e2, t2, n2, r2) {
            var i2 = this.getFoldLine(e2);
            if (!i2) {
              var s2;
              return s2 = this.doc.getLine(e2), s2.substring(r2 || 0, t2 || s2.length);
            }
            return this.getFoldDisplayLine(i2, e2, t2, n2, r2);
          }, this.$cloneFoldData = function() {
            var e2 = [];
            return e2 = this.$foldData.map(function(t2) {
              var n2 = t2.folds.map(function(e3) {
                return e3.clone();
              });
              return new i(e2, n2);
            }), e2;
          }, this.toggleFold = function(e2) {
            var t2 = this.selection, n2 = t2.getRange(), r2, i2;
            if (n2.isEmpty()) {
              var s2 = n2.start;
              r2 = this.getFoldAt(s2.row, s2.column);
              if (r2) {
                this.expandFold(r2);
                return;
              }
              (i2 = this.findMatchingBracket(s2)) ? n2.comparePoint(i2) == 1 ? n2.end = i2 : (n2.start = i2, n2.start.column++, n2.end.column--) : (i2 = this.findMatchingBracket({ row: s2.row, column: s2.column + 1 })) ? (n2.comparePoint(i2) == 1 ? n2.end = i2 : n2.start = i2, n2.start.column++) : n2 = this.getCommentFoldRange(s2.row, s2.column) || n2;
            } else {
              var o2 = this.getFoldsInRange(n2);
              if (e2 && o2.length) {
                this.expandFolds(o2);
                return;
              }
              o2.length == 1 && (r2 = o2[0]);
            }
            r2 || (r2 = this.getFoldAt(n2.start.row, n2.start.column));
            if (r2 && r2.range.toString() == n2.toString()) {
              this.expandFold(r2);
              return;
            }
            var u2 = "...";
            if (!n2.isMultiLine()) {
              u2 = this.getTextRange(n2);
              if (u2.length < 4)
                return;
              u2 = u2.trim().substring(0, 2) + "..";
            }
            this.addFold(u2, n2);
          }, this.getCommentFoldRange = function(e2, t2, n2) {
            var i2 = new o(this, e2, t2), s2 = i2.getCurrentToken(), u2 = s2 && s2.type;
            if (s2 && /^comment|string/.test(u2)) {
              u2 = u2.match(/comment|string/)[0], u2 == "comment" && (u2 += "|doc-start");
              var a = new RegExp(u2), f = new r();
              if (n2 != 1) {
                do
                  s2 = i2.stepBackward();
                while (s2 && a.test(s2.type));
                i2.stepForward();
              }
              f.start.row = i2.getCurrentTokenRow(), f.start.column = i2.getCurrentTokenColumn() + 2, i2 = new o(this, e2, t2);
              if (n2 != -1) {
                var l = -1;
                do {
                  s2 = i2.stepForward();
                  if (l == -1) {
                    var c = this.getState(i2.$row);
                    a.test(c) || (l = i2.$row);
                  } else if (i2.$row > l)
                    break;
                } while (s2 && a.test(s2.type));
                s2 = i2.stepBackward();
              } else
                s2 = i2.getCurrentToken();
              return f.end.row = i2.getCurrentTokenRow(), f.end.column = i2.getCurrentTokenColumn() + s2.value.length - 2, f;
            }
          }, this.foldAll = function(e2, t2, n2, r2) {
            n2 == void 0 && (n2 = 1e5);
            var i2 = this.foldWidgets;
            if (!i2)
              return;
            t2 = t2 || this.getLength(), e2 = e2 || 0;
            for (var s2 = e2; s2 < t2; s2++) {
              i2[s2] == null && (i2[s2] = this.getFoldWidget(s2));
              if (i2[s2] != "start")
                continue;
              if (r2 && !r2(s2))
                continue;
              var o2 = this.getFoldWidgetRange(s2);
              o2 && o2.isMultiLine() && o2.end.row <= t2 && o2.start.row >= e2 && (s2 = o2.end.row, o2.collapseChildren = n2, this.addFold("...", o2));
            }
          }, this.foldToLevel = function(e2) {
            this.foldAll();
            while (e2-- > 0)
              this.unfold(null, false);
          }, this.foldAllComments = function() {
            var e2 = this;
            this.foldAll(null, null, null, function(t2) {
              var n2 = e2.getTokens(t2);
              for (var r2 = 0; r2 < n2.length; r2++) {
                var i2 = n2[r2];
                if (i2.type == "text" && /^\s+$/.test(i2.value))
                  continue;
                return /comment/.test(i2.type) ? true : false;
              }
            });
          }, this.$foldStyles = { manual: 1, markbegin: 1, markbeginend: 1 }, this.$foldStyle = "markbegin", this.setFoldStyle = function(e2) {
            if (!this.$foldStyles[e2])
              throw new Error("invalid fold style: " + e2 + "[" + Object.keys(this.$foldStyles).join(", ") + "]");
            if (this.$foldStyle == e2)
              return;
            this.$foldStyle = e2, e2 == "manual" && this.unfold();
            var t2 = this.$foldMode;
            this.$setFolding(null), this.$setFolding(t2);
          }, this.$setFolding = function(e2) {
            if (this.$foldMode == e2)
              return;
            this.$foldMode = e2, this.off("change", this.$updateFoldWidgets), this.off("tokenizerUpdate", this.$tokenizerUpdateFoldWidgets), this._signal("changeAnnotation");
            if (!e2 || this.$foldStyle == "manual") {
              this.foldWidgets = null;
              return;
            }
            this.foldWidgets = [], this.getFoldWidget = e2.getFoldWidget.bind(e2, this, this.$foldStyle), this.getFoldWidgetRange = e2.getFoldWidgetRange.bind(e2, this, this.$foldStyle), this.$updateFoldWidgets = this.updateFoldWidgets.bind(this), this.$tokenizerUpdateFoldWidgets = this.tokenizerUpdateFoldWidgets.bind(this), this.on("change", this.$updateFoldWidgets), this.on("tokenizerUpdate", this.$tokenizerUpdateFoldWidgets);
          }, this.getParentFoldRangeData = function(e2, t2) {
            var n2 = this.foldWidgets;
            if (!n2 || t2 && n2[e2])
              return {};
            var r2 = e2 - 1, i2;
            while (r2 >= 0) {
              var s2 = n2[r2];
              s2 == null && (s2 = n2[r2] = this.getFoldWidget(r2));
              if (s2 == "start") {
                var o2 = this.getFoldWidgetRange(r2);
                i2 || (i2 = o2);
                if (o2 && o2.end.row >= e2)
                  break;
              }
              r2--;
            }
            return { range: r2 !== -1 && o2, firstRange: i2 };
          }, this.onFoldWidgetClick = function(e2, t2) {
            t2 = t2.domEvent;
            var n2 = { children: t2.shiftKey, all: t2.ctrlKey || t2.metaKey, siblings: t2.altKey }, r2 = this.$toggleFoldWidget(e2, n2);
            if (!r2) {
              var i2 = t2.target || t2.srcElement;
              i2 && /ace_fold-widget/.test(i2.className) && (i2.className += " ace_invalid");
            }
          }, this.$toggleFoldWidget = function(e2, t2) {
            if (!this.getFoldWidget)
              return;
            var n2 = this.getFoldWidget(e2), r2 = this.getLine(e2), i2 = n2 === "end" ? -1 : 1, s2 = this.getFoldAt(e2, i2 === -1 ? 0 : r2.length, i2);
            if (s2)
              return t2.children || t2.all ? this.removeFold(s2) : this.expandFold(s2), s2;
            var o2 = this.getFoldWidgetRange(e2, true);
            if (o2 && !o2.isMultiLine()) {
              s2 = this.getFoldAt(o2.start.row, o2.start.column, 1);
              if (s2 && o2.isEqual(s2.range))
                return this.removeFold(s2), s2;
            }
            if (t2.siblings) {
              var u2 = this.getParentFoldRangeData(e2);
              if (u2.range)
                var a = u2.range.start.row + 1, f = u2.range.end.row;
              this.foldAll(a, f, t2.all ? 1e4 : 0);
            } else
              t2.children ? (f = o2 ? o2.end.row : this.getLength(), this.foldAll(e2 + 1, f, t2.all ? 1e4 : 0)) : o2 && (t2.all && (o2.collapseChildren = 1e4), this.addFold("...", o2));
            return o2;
          }, this.toggleFoldWidget = function(e2) {
            var t2 = this.selection.getCursor().row;
            t2 = this.getRowFoldStart(t2);
            var n2 = this.$toggleFoldWidget(t2, {});
            if (n2)
              return;
            var r2 = this.getParentFoldRangeData(t2, true);
            n2 = r2.range || r2.firstRange;
            if (n2) {
              t2 = n2.start.row;
              var i2 = this.getFoldAt(t2, this.getLine(t2).length, 1);
              i2 ? this.removeFold(i2) : this.addFold("...", n2);
            }
          }, this.updateFoldWidgets = function(e2) {
            var t2 = e2.start.row, n2 = e2.end.row - t2;
            if (n2 === 0)
              this.foldWidgets[t2] = null;
            else if (e2.action == "remove")
              this.foldWidgets.splice(t2, n2 + 1, null);
            else {
              var r2 = Array(n2 + 1);
              r2.unshift(t2, 1), this.foldWidgets.splice.apply(this.foldWidgets, r2);
            }
          }, this.tokenizerUpdateFoldWidgets = function(e2) {
            var t2 = e2.data;
            t2.first != t2.last && this.foldWidgets.length > t2.first && this.foldWidgets.splice(t2.first, this.foldWidgets.length);
          };
        }
        var r = e("../range").Range, i = e("./fold_line").FoldLine, s = e("./fold").Fold, o = e("../token_iterator").TokenIterator;
        t.Folding = u;
      }), ace.define("ace/edit_session/bracket_match", ["require", "exports", "module", "ace/token_iterator", "ace/range"], function(e, t, n) {
        "use strict";
        function s() {
          this.findMatchingBracket = function(e2, t2) {
            if (e2.column == 0)
              return null;
            var n2 = t2 || this.getLine(e2.row).charAt(e2.column - 1);
            if (n2 == "")
              return null;
            var r2 = n2.match(/([\(\[\{])|([\)\]\}])/);
            return r2 ? r2[1] ? this.$findClosingBracket(r2[1], e2) : this.$findOpeningBracket(r2[2], e2) : null;
          }, this.getBracketRange = function(e2) {
            var t2 = this.getLine(e2.row), n2 = true, r2, s2 = t2.charAt(e2.column - 1), o = s2 && s2.match(/([\(\[\{])|([\)\]\}])/);
            o || (s2 = t2.charAt(e2.column), e2 = { row: e2.row, column: e2.column + 1 }, o = s2 && s2.match(/([\(\[\{])|([\)\]\}])/), n2 = false);
            if (!o)
              return null;
            if (o[1]) {
              var u = this.$findClosingBracket(o[1], e2);
              if (!u)
                return null;
              r2 = i.fromPoints(e2, u), n2 || (r2.end.column++, r2.start.column--), r2.cursor = r2.end;
            } else {
              var u = this.$findOpeningBracket(o[2], e2);
              if (!u)
                return null;
              r2 = i.fromPoints(u, e2), n2 || (r2.start.column++, r2.end.column--), r2.cursor = r2.start;
            }
            return r2;
          }, this.getMatchingBracketRanges = function(e2) {
            var t2 = this.getLine(e2.row), n2 = t2.charAt(e2.column - 1), r2 = n2 && n2.match(/([\(\[\{])|([\)\]\}])/);
            r2 || (n2 = t2.charAt(e2.column), e2 = { row: e2.row, column: e2.column + 1 }, r2 = n2 && n2.match(/([\(\[\{])|([\)\]\}])/));
            if (!r2)
              return null;
            var s2 = new i(e2.row, e2.column - 1, e2.row, e2.column), o = r2[1] ? this.$findClosingBracket(r2[1], e2) : this.$findOpeningBracket(r2[2], e2);
            if (!o)
              return [s2];
            var u = new i(o.row, o.column, o.row, o.column + 1);
            return [s2, u];
          }, this.$brackets = { ")": "(", "(": ")", "]": "[", "[": "]", "{": "}", "}": "{", "<": ">", ">": "<" }, this.$findOpeningBracket = function(e2, t2, n2) {
            var i2 = this.$brackets[e2], s2 = 1, o = new r(this, t2.row, t2.column), u = o.getCurrentToken();
            u || (u = o.stepForward());
            if (!u)
              return;
            n2 || (n2 = new RegExp("(\\.?" + u.type.replace(".", "\\.").replace("rparen", ".paren").replace(/\b(?:end)\b/, "(?:start|begin|end)") + ")+"));
            var a = t2.column - o.getCurrentTokenColumn() - 2, f = u.value;
            for (; ; ) {
              while (a >= 0) {
                var l = f.charAt(a);
                if (l == i2) {
                  s2 -= 1;
                  if (s2 == 0)
                    return { row: o.getCurrentTokenRow(), column: a + o.getCurrentTokenColumn() };
                } else
                  l == e2 && (s2 += 1);
                a -= 1;
              }
              do
                u = o.stepBackward();
              while (u && !n2.test(u.type));
              if (u == null)
                break;
              f = u.value, a = f.length - 1;
            }
            return null;
          }, this.$findClosingBracket = function(e2, t2, n2) {
            var i2 = this.$brackets[e2], s2 = 1, o = new r(this, t2.row, t2.column), u = o.getCurrentToken();
            u || (u = o.stepForward());
            if (!u)
              return;
            n2 || (n2 = new RegExp("(\\.?" + u.type.replace(".", "\\.").replace("lparen", ".paren").replace(/\b(?:start|begin)\b/, "(?:start|begin|end)") + ")+"));
            var a = t2.column - o.getCurrentTokenColumn();
            for (; ; ) {
              var f = u.value, l = f.length;
              while (a < l) {
                var c = f.charAt(a);
                if (c == i2) {
                  s2 -= 1;
                  if (s2 == 0)
                    return { row: o.getCurrentTokenRow(), column: a + o.getCurrentTokenColumn() };
                } else
                  c == e2 && (s2 += 1);
                a += 1;
              }
              do
                u = o.stepForward();
              while (u && !n2.test(u.type));
              if (u == null)
                break;
              a = 0;
            }
            return null;
          };
        }
        var r = e("../token_iterator").TokenIterator, i = e("../range").Range;
        t.BracketMatch = s;
      }), ace.define("ace/edit_session", ["require", "exports", "module", "ace/lib/oop", "ace/lib/lang", "ace/bidihandler", "ace/config", "ace/lib/event_emitter", "ace/selection", "ace/mode/text", "ace/range", "ace/document", "ace/background_tokenizer", "ace/search_highlight", "ace/edit_session/folding", "ace/edit_session/bracket_match"], function(e, t, n) {
        "use strict";
        var r = e("./lib/oop"), i = e("./lib/lang"), s = e("./bidihandler").BidiHandler, o = e("./config"), u = e("./lib/event_emitter").EventEmitter, a = e("./selection").Selection, f = e("./mode/text").Mode, l = e("./range").Range, c = e("./document").Document, h = e("./background_tokenizer").BackgroundTokenizer, p = e("./search_highlight").SearchHighlight, d = function(e2, t2) {
          this.$breakpoints = [], this.$decorations = [], this.$frontMarkers = {}, this.$backMarkers = {}, this.$markerId = 1, this.$undoSelect = true, this.$foldData = [], this.id = "session" + ++d.$uid, this.$foldData.toString = function() {
            return this.join("\n");
          }, this.bgTokenizer = new h(new f().getTokenizer(), this);
          var n2 = this;
          this.bgTokenizer.on("update", function(e3) {
            n2._signal("tokenizerUpdate", e3);
          }), this.on("changeFold", this.onChangeFold.bind(this)), this.$onChange = this.onChange.bind(this);
          if (typeof e2 != "object" || !e2.getLine)
            e2 = new c(e2);
          this.setDocument(e2), this.selection = new a(this), this.$bidiHandler = new s(this), o.resetOptions(this), this.setMode(t2), o._signal("session", this), this.destroyed = false;
        };
        d.$uid = 0, function() {
          function v(e3) {
            return e3 < 4352 ? false : e3 >= 4352 && e3 <= 4447 || e3 >= 4515 && e3 <= 4519 || e3 >= 4602 && e3 <= 4607 || e3 >= 9001 && e3 <= 9002 || e3 >= 11904 && e3 <= 11929 || e3 >= 11931 && e3 <= 12019 || e3 >= 12032 && e3 <= 12245 || e3 >= 12272 && e3 <= 12283 || e3 >= 12288 && e3 <= 12350 || e3 >= 12353 && e3 <= 12438 || e3 >= 12441 && e3 <= 12543 || e3 >= 12549 && e3 <= 12589 || e3 >= 12593 && e3 <= 12686 || e3 >= 12688 && e3 <= 12730 || e3 >= 12736 && e3 <= 12771 || e3 >= 12784 && e3 <= 12830 || e3 >= 12832 && e3 <= 12871 || e3 >= 12880 && e3 <= 13054 || e3 >= 13056 && e3 <= 19903 || e3 >= 19968 && e3 <= 42124 || e3 >= 42128 && e3 <= 42182 || e3 >= 43360 && e3 <= 43388 || e3 >= 44032 && e3 <= 55203 || e3 >= 55216 && e3 <= 55238 || e3 >= 55243 && e3 <= 55291 || e3 >= 63744 && e3 <= 64255 || e3 >= 65040 && e3 <= 65049 || e3 >= 65072 && e3 <= 65106 || e3 >= 65108 && e3 <= 65126 || e3 >= 65128 && e3 <= 65131 || e3 >= 65281 && e3 <= 65376 || e3 >= 65504 && e3 <= 65510;
          }
          r.implement(this, u), this.setDocument = function(e3) {
            this.doc && this.doc.off("change", this.$onChange), this.doc = e3, e3.on("change", this.$onChange), this.bgTokenizer.setDocument(this.getDocument()), this.resetCaches();
          }, this.getDocument = function() {
            return this.doc;
          }, this.$resetRowCache = function(e3) {
            if (!e3) {
              this.$docRowCache = [], this.$screenRowCache = [];
              return;
            }
            var t3 = this.$docRowCache.length, n3 = this.$getRowCacheIndex(this.$docRowCache, e3) + 1;
            t3 > n3 && (this.$docRowCache.splice(n3, t3), this.$screenRowCache.splice(n3, t3));
          }, this.$getRowCacheIndex = function(e3, t3) {
            var n3 = 0, r2 = e3.length - 1;
            while (n3 <= r2) {
              var i2 = n3 + r2 >> 1, s3 = e3[i2];
              if (t3 > s3)
                n3 = i2 + 1;
              else {
                if (!(t3 < s3))
                  return i2;
                r2 = i2 - 1;
              }
            }
            return n3 - 1;
          }, this.resetCaches = function() {
            this.$modified = true, this.$wrapData = [], this.$rowLengthCache = [], this.$resetRowCache(0), this.destroyed || this.bgTokenizer.start(0);
          }, this.onChangeFold = function(e3) {
            var t3 = e3.data;
            this.$resetRowCache(t3.start.row);
          }, this.onChange = function(e3) {
            this.$modified = true, this.$bidiHandler.onChange(e3), this.$resetRowCache(e3.start.row);
            var t3 = this.$updateInternalDataOnChange(e3);
            !this.$fromUndo && this.$undoManager && (t3 && t3.length && (this.$undoManager.add({ action: "removeFolds", folds: t3 }, this.mergeUndoDeltas), this.mergeUndoDeltas = true), this.$undoManager.add(e3, this.mergeUndoDeltas), this.mergeUndoDeltas = true, this.$informUndoManager.schedule()), this.bgTokenizer.$updateOnChange(e3), this._signal("change", e3);
          }, this.setValue = function(e3) {
            this.doc.setValue(e3), this.selection.moveTo(0, 0), this.$resetRowCache(0), this.setUndoManager(this.$undoManager), this.getUndoManager().reset();
          }, this.getValue = this.toString = function() {
            return this.doc.getValue();
          }, this.getSelection = function() {
            return this.selection;
          }, this.getState = function(e3) {
            return this.bgTokenizer.getState(e3);
          }, this.getTokens = function(e3) {
            return this.bgTokenizer.getTokens(e3);
          }, this.getTokenAt = function(e3, t3) {
            var n3 = this.bgTokenizer.getTokens(e3), r2, i2 = 0;
            if (t3 == null) {
              var s3 = n3.length - 1;
              i2 = this.getLine(e3).length;
            } else
              for (var s3 = 0; s3 < n3.length; s3++) {
                i2 += n3[s3].value.length;
                if (i2 >= t3)
                  break;
              }
            return r2 = n3[s3], r2 ? (r2.index = s3, r2.start = i2 - r2.value.length, r2) : null;
          }, this.setUndoManager = function(e3) {
            this.$undoManager = e3, this.$informUndoManager && this.$informUndoManager.cancel();
            if (e3) {
              var t3 = this;
              e3.addSession(this), this.$syncInformUndoManager = function() {
                t3.$informUndoManager.cancel(), t3.mergeUndoDeltas = false;
              }, this.$informUndoManager = i.delayedCall(this.$syncInformUndoManager);
            } else
              this.$syncInformUndoManager = function() {
              };
          }, this.markUndoGroup = function() {
            this.$syncInformUndoManager && this.$syncInformUndoManager();
          }, this.$defaultUndoManager = { undo: function() {
          }, redo: function() {
          }, hasUndo: function() {
          }, hasRedo: function() {
          }, reset: function() {
          }, add: function() {
          }, addSelection: function() {
          }, startNewGroup: function() {
          }, addSession: function() {
          } }, this.getUndoManager = function() {
            return this.$undoManager || this.$defaultUndoManager;
          }, this.getTabString = function() {
            return this.getUseSoftTabs() ? i.stringRepeat(" ", this.getTabSize()) : "	";
          }, this.setUseSoftTabs = function(e3) {
            this.setOption("useSoftTabs", e3);
          }, this.getUseSoftTabs = function() {
            return this.$useSoftTabs && !this.$mode.$indentWithTabs;
          }, this.setTabSize = function(e3) {
            this.setOption("tabSize", e3);
          }, this.getTabSize = function() {
            return this.$tabSize;
          }, this.isTabStop = function(e3) {
            return this.$useSoftTabs && e3.column % this.$tabSize === 0;
          }, this.setNavigateWithinSoftTabs = function(e3) {
            this.setOption("navigateWithinSoftTabs", e3);
          }, this.getNavigateWithinSoftTabs = function() {
            return this.$navigateWithinSoftTabs;
          }, this.$overwrite = false, this.setOverwrite = function(e3) {
            this.setOption("overwrite", e3);
          }, this.getOverwrite = function() {
            return this.$overwrite;
          }, this.toggleOverwrite = function() {
            this.setOverwrite(!this.$overwrite);
          }, this.addGutterDecoration = function(e3, t3) {
            this.$decorations[e3] || (this.$decorations[e3] = ""), this.$decorations[e3] += " " + t3, this._signal("changeBreakpoint", {});
          }, this.removeGutterDecoration = function(e3, t3) {
            this.$decorations[e3] = (this.$decorations[e3] || "").replace(" " + t3, ""), this._signal("changeBreakpoint", {});
          }, this.getBreakpoints = function() {
            return this.$breakpoints;
          }, this.setBreakpoints = function(e3) {
            this.$breakpoints = [];
            for (var t3 = 0; t3 < e3.length; t3++)
              this.$breakpoints[e3[t3]] = "ace_breakpoint";
            this._signal("changeBreakpoint", {});
          }, this.clearBreakpoints = function() {
            this.$breakpoints = [], this._signal("changeBreakpoint", {});
          }, this.setBreakpoint = function(e3, t3) {
            t3 === void 0 && (t3 = "ace_breakpoint"), t3 ? this.$breakpoints[e3] = t3 : delete this.$breakpoints[e3], this._signal("changeBreakpoint", {});
          }, this.clearBreakpoint = function(e3) {
            delete this.$breakpoints[e3], this._signal("changeBreakpoint", {});
          }, this.addMarker = function(e3, t3, n3, r2) {
            var i2 = this.$markerId++, s3 = { range: e3, type: n3 || "line", renderer: typeof n3 == "function" ? n3 : null, clazz: t3, inFront: !!r2, id: i2 };
            return r2 ? (this.$frontMarkers[i2] = s3, this._signal("changeFrontMarker")) : (this.$backMarkers[i2] = s3, this._signal("changeBackMarker")), i2;
          }, this.addDynamicMarker = function(e3, t3) {
            if (!e3.update)
              return;
            var n3 = this.$markerId++;
            return e3.id = n3, e3.inFront = !!t3, t3 ? (this.$frontMarkers[n3] = e3, this._signal("changeFrontMarker")) : (this.$backMarkers[n3] = e3, this._signal("changeBackMarker")), e3;
          }, this.removeMarker = function(e3) {
            var t3 = this.$frontMarkers[e3] || this.$backMarkers[e3];
            if (!t3)
              return;
            var n3 = t3.inFront ? this.$frontMarkers : this.$backMarkers;
            delete n3[e3], this._signal(t3.inFront ? "changeFrontMarker" : "changeBackMarker");
          }, this.getMarkers = function(e3) {
            return e3 ? this.$frontMarkers : this.$backMarkers;
          }, this.highlight = function(e3) {
            if (!this.$searchHighlight) {
              var t3 = new p(null, "ace_selected-word", "text");
              this.$searchHighlight = this.addDynamicMarker(t3);
            }
            this.$searchHighlight.setRegexp(e3);
          }, this.highlightLines = function(e3, t3, n3, r2) {
            typeof t3 != "number" && (n3 = t3, t3 = e3), n3 || (n3 = "ace_step");
            var i2 = new l(e3, 0, t3, Infinity);
            return i2.id = this.addMarker(i2, n3, "fullLine", r2), i2;
          }, this.setAnnotations = function(e3) {
            this.$annotations = e3, this._signal("changeAnnotation", {});
          }, this.getAnnotations = function() {
            return this.$annotations || [];
          }, this.clearAnnotations = function() {
            this.setAnnotations([]);
          }, this.$detectNewLine = function(e3) {
            var t3 = e3.match(/^.*?(\r?\n)/m);
            t3 ? this.$autoNewLine = t3[1] : this.$autoNewLine = "\n";
          }, this.getWordRange = function(e3, t3) {
            var n3 = this.getLine(e3), r2 = false;
            t3 > 0 && (r2 = !!n3.charAt(t3 - 1).match(this.tokenRe)), r2 || (r2 = !!n3.charAt(t3).match(this.tokenRe));
            if (r2)
              var i2 = this.tokenRe;
            else if (/^\s+$/.test(n3.slice(t3 - 1, t3 + 1)))
              var i2 = /\s/;
            else
              var i2 = this.nonTokenRe;
            var s3 = t3;
            if (s3 > 0) {
              do
                s3--;
              while (s3 >= 0 && n3.charAt(s3).match(i2));
              s3++;
            }
            var o2 = t3;
            while (o2 < n3.length && n3.charAt(o2).match(i2))
              o2++;
            return new l(e3, s3, e3, o2);
          }, this.getAWordRange = function(e3, t3) {
            var n3 = this.getWordRange(e3, t3), r2 = this.getLine(n3.end.row);
            while (r2.charAt(n3.end.column).match(/[ \t]/))
              n3.end.column += 1;
            return n3;
          }, this.setNewLineMode = function(e3) {
            this.doc.setNewLineMode(e3);
          }, this.getNewLineMode = function() {
            return this.doc.getNewLineMode();
          }, this.setUseWorker = function(e3) {
            this.setOption("useWorker", e3);
          }, this.getUseWorker = function() {
            return this.$useWorker;
          }, this.onReloadTokenizer = function(e3) {
            var t3 = e3.data;
            this.bgTokenizer.start(t3.first), this._signal("tokenizerUpdate", e3);
          }, this.$modes = o.$modes, this.$mode = null, this.$modeId = null, this.setMode = function(e3, t3) {
            if (e3 && typeof e3 == "object") {
              if (e3.getTokenizer)
                return this.$onChangeMode(e3);
              var n3 = e3, r2 = n3.path;
            } else
              r2 = e3 || "ace/mode/text";
            this.$modes["ace/mode/text"] || (this.$modes["ace/mode/text"] = new f());
            if (this.$modes[r2] && !n3) {
              this.$onChangeMode(this.$modes[r2]), t3 && t3();
              return;
            }
            this.$modeId = r2, o.loadModule(["mode", r2], function(e4) {
              if (this.$modeId !== r2)
                return t3 && t3();
              this.$modes[r2] && !n3 ? this.$onChangeMode(this.$modes[r2]) : e4 && e4.Mode && (e4 = new e4.Mode(n3), n3 || (this.$modes[r2] = e4, e4.$id = r2), this.$onChangeMode(e4)), t3 && t3();
            }.bind(this)), this.$mode || this.$onChangeMode(this.$modes["ace/mode/text"], true);
          }, this.$onChangeMode = function(e3, t3) {
            t3 || (this.$modeId = e3.$id);
            if (this.$mode === e3)
              return;
            var n3 = this.$mode;
            this.$mode = e3, this.$stopWorker(), this.$useWorker && this.$startWorker();
            var r2 = e3.getTokenizer();
            if (r2.on !== void 0) {
              var i2 = this.onReloadTokenizer.bind(this);
              r2.on("update", i2);
            }
            this.bgTokenizer.setTokenizer(r2), this.bgTokenizer.setDocument(this.getDocument()), this.tokenRe = e3.tokenRe, this.nonTokenRe = e3.nonTokenRe, t3 || (e3.attachToSession && e3.attachToSession(this), this.$options.wrapMethod.set.call(this, this.$wrapMethod), this.$setFolding(e3.foldingRules), this.bgTokenizer.start(0), this._emit("changeMode", { oldMode: n3, mode: e3 }));
          }, this.$stopWorker = function() {
            this.$worker && (this.$worker.terminate(), this.$worker = null);
          }, this.$startWorker = function() {
            try {
              this.$worker = this.$mode.createWorker(this);
            } catch (e3) {
              o.warn("Could not load worker", e3), this.$worker = null;
            }
          }, this.getMode = function() {
            return this.$mode;
          }, this.$scrollTop = 0, this.setScrollTop = function(e3) {
            if (this.$scrollTop === e3 || isNaN(e3))
              return;
            this.$scrollTop = e3, this._signal("changeScrollTop", e3);
          }, this.getScrollTop = function() {
            return this.$scrollTop;
          }, this.$scrollLeft = 0, this.setScrollLeft = function(e3) {
            if (this.$scrollLeft === e3 || isNaN(e3))
              return;
            this.$scrollLeft = e3, this._signal("changeScrollLeft", e3);
          }, this.getScrollLeft = function() {
            return this.$scrollLeft;
          }, this.getScreenWidth = function() {
            return this.$computeWidth(), this.lineWidgets ? Math.max(this.getLineWidgetMaxWidth(), this.screenWidth) : this.screenWidth;
          }, this.getLineWidgetMaxWidth = function() {
            if (this.lineWidgetsWidth != null)
              return this.lineWidgetsWidth;
            var e3 = 0;
            return this.lineWidgets.forEach(function(t3) {
              t3 && t3.screenWidth > e3 && (e3 = t3.screenWidth);
            }), this.lineWidgetWidth = e3;
          }, this.$computeWidth = function(e3) {
            if (this.$modified || e3) {
              this.$modified = false;
              if (this.$useWrapMode)
                return this.screenWidth = this.$wrapLimit;
              var t3 = this.doc.getAllLines(), n3 = this.$rowLengthCache, r2 = 0, i2 = 0, s3 = this.$foldData[i2], o2 = s3 ? s3.start.row : Infinity, u2 = t3.length;
              for (var a3 = 0; a3 < u2; a3++) {
                if (a3 > o2) {
                  a3 = s3.end.row + 1;
                  if (a3 >= u2)
                    break;
                  s3 = this.$foldData[i2++], o2 = s3 ? s3.start.row : Infinity;
                }
                n3[a3] == null && (n3[a3] = this.$getStringScreenWidth(t3[a3])[0]), n3[a3] > r2 && (r2 = n3[a3]);
              }
              this.screenWidth = r2;
            }
          }, this.getLine = function(e3) {
            return this.doc.getLine(e3);
          }, this.getLines = function(e3, t3) {
            return this.doc.getLines(e3, t3);
          }, this.getLength = function() {
            return this.doc.getLength();
          }, this.getTextRange = function(e3) {
            return this.doc.getTextRange(e3 || this.selection.getRange());
          }, this.insert = function(e3, t3) {
            return this.doc.insert(e3, t3);
          }, this.remove = function(e3) {
            return this.doc.remove(e3);
          }, this.removeFullLines = function(e3, t3) {
            return this.doc.removeFullLines(e3, t3);
          }, this.undoChanges = function(e3, t3) {
            if (!e3.length)
              return;
            this.$fromUndo = true;
            for (var n3 = e3.length - 1; n3 != -1; n3--) {
              var r2 = e3[n3];
              r2.action == "insert" || r2.action == "remove" ? this.doc.revertDelta(r2) : r2.folds && this.addFolds(r2.folds);
            }
            !t3 && this.$undoSelect && (e3.selectionBefore ? this.selection.fromJSON(e3.selectionBefore) : this.selection.setRange(this.$getUndoSelection(e3, true))), this.$fromUndo = false;
          }, this.redoChanges = function(e3, t3) {
            if (!e3.length)
              return;
            this.$fromUndo = true;
            for (var n3 = 0; n3 < e3.length; n3++) {
              var r2 = e3[n3];
              (r2.action == "insert" || r2.action == "remove") && this.doc.$safeApplyDelta(r2);
            }
            !t3 && this.$undoSelect && (e3.selectionAfter ? this.selection.fromJSON(e3.selectionAfter) : this.selection.setRange(this.$getUndoSelection(e3, false))), this.$fromUndo = false;
          }, this.setUndoSelect = function(e3) {
            this.$undoSelect = e3;
          }, this.$getUndoSelection = function(e3, t3) {
            function n3(e4) {
              return t3 ? e4.action !== "insert" : e4.action === "insert";
            }
            var r2, i2;
            for (var s3 = 0; s3 < e3.length; s3++) {
              var o2 = e3[s3];
              if (!o2.start)
                continue;
              if (!r2) {
                n3(o2) ? r2 = l.fromPoints(o2.start, o2.end) : r2 = l.fromPoints(o2.start, o2.start);
                continue;
              }
              n3(o2) ? (i2 = o2.start, r2.compare(i2.row, i2.column) == -1 && r2.setStart(i2), i2 = o2.end, r2.compare(i2.row, i2.column) == 1 && r2.setEnd(i2)) : (i2 = o2.start, r2.compare(i2.row, i2.column) == -1 && (r2 = l.fromPoints(o2.start, o2.start)));
            }
            return r2;
          }, this.replace = function(e3, t3) {
            return this.doc.replace(e3, t3);
          }, this.moveText = function(e3, t3, n3) {
            var r2 = this.getTextRange(e3), i2 = this.getFoldsInRange(e3), s3 = l.fromPoints(t3, t3);
            if (!n3) {
              this.remove(e3);
              var o2 = e3.start.row - e3.end.row, u2 = o2 ? -e3.end.column : e3.start.column - e3.end.column;
              u2 && (s3.start.row == e3.end.row && s3.start.column > e3.end.column && (s3.start.column += u2), s3.end.row == e3.end.row && s3.end.column > e3.end.column && (s3.end.column += u2)), o2 && s3.start.row >= e3.end.row && (s3.start.row += o2, s3.end.row += o2);
            }
            s3.end = this.insert(s3.start, r2);
            if (i2.length) {
              var a3 = e3.start, f2 = s3.start, o2 = f2.row - a3.row, u2 = f2.column - a3.column;
              this.addFolds(i2.map(function(e4) {
                return e4 = e4.clone(), e4.start.row == a3.row && (e4.start.column += u2), e4.end.row == a3.row && (e4.end.column += u2), e4.start.row += o2, e4.end.row += o2, e4;
              }));
            }
            return s3;
          }, this.indentRows = function(e3, t3, n3) {
            n3 = n3.replace(/\t/g, this.getTabString());
            for (var r2 = e3; r2 <= t3; r2++)
              this.doc.insertInLine({ row: r2, column: 0 }, n3);
          }, this.outdentRows = function(e3) {
            var t3 = e3.collapseRows(), n3 = new l(0, 0, 0, 0), r2 = this.getTabSize();
            for (var i2 = t3.start.row; i2 <= t3.end.row; ++i2) {
              var s3 = this.getLine(i2);
              n3.start.row = i2, n3.end.row = i2;
              for (var o2 = 0; o2 < r2; ++o2)
                if (s3.charAt(o2) != " ")
                  break;
              o2 < r2 && s3.charAt(o2) == "	" ? (n3.start.column = o2, n3.end.column = o2 + 1) : (n3.start.column = 0, n3.end.column = o2), this.remove(n3);
            }
          }, this.$moveLines = function(e3, t3, n3) {
            e3 = this.getRowFoldStart(e3), t3 = this.getRowFoldEnd(t3);
            if (n3 < 0) {
              var r2 = this.getRowFoldStart(e3 + n3);
              if (r2 < 0)
                return 0;
              var i2 = r2 - e3;
            } else if (n3 > 0) {
              var r2 = this.getRowFoldEnd(t3 + n3);
              if (r2 > this.doc.getLength() - 1)
                return 0;
              var i2 = r2 - t3;
            } else {
              e3 = this.$clipRowToDocument(e3), t3 = this.$clipRowToDocument(t3);
              var i2 = t3 - e3 + 1;
            }
            var s3 = new l(e3, 0, t3, Number.MAX_VALUE), o2 = this.getFoldsInRange(s3).map(function(e4) {
              return e4 = e4.clone(), e4.start.row += i2, e4.end.row += i2, e4;
            }), u2 = n3 == 0 ? this.doc.getLines(e3, t3) : this.doc.removeFullLines(e3, t3);
            return this.doc.insertFullLines(e3 + i2, u2), o2.length && this.addFolds(o2), i2;
          }, this.moveLinesUp = function(e3, t3) {
            return this.$moveLines(e3, t3, -1);
          }, this.moveLinesDown = function(e3, t3) {
            return this.$moveLines(e3, t3, 1);
          }, this.duplicateLines = function(e3, t3) {
            return this.$moveLines(e3, t3, 0);
          }, this.$clipRowToDocument = function(e3) {
            return Math.max(0, Math.min(e3, this.doc.getLength() - 1));
          }, this.$clipColumnToRow = function(e3, t3) {
            return t3 < 0 ? 0 : Math.min(this.doc.getLine(e3).length, t3);
          }, this.$clipPositionToDocument = function(e3, t3) {
            t3 = Math.max(0, t3);
            if (e3 < 0)
              e3 = 0, t3 = 0;
            else {
              var n3 = this.doc.getLength();
              e3 >= n3 ? (e3 = n3 - 1, t3 = this.doc.getLine(n3 - 1).length) : t3 = Math.min(this.doc.getLine(e3).length, t3);
            }
            return { row: e3, column: t3 };
          }, this.$clipRangeToDocument = function(e3) {
            e3.start.row < 0 ? (e3.start.row = 0, e3.start.column = 0) : e3.start.column = this.$clipColumnToRow(e3.start.row, e3.start.column);
            var t3 = this.doc.getLength() - 1;
            return e3.end.row > t3 ? (e3.end.row = t3, e3.end.column = this.doc.getLine(t3).length) : e3.end.column = this.$clipColumnToRow(e3.end.row, e3.end.column), e3;
          }, this.$wrapLimit = 80, this.$useWrapMode = false, this.$wrapLimitRange = { min: null, max: null }, this.setUseWrapMode = function(e3) {
            if (e3 != this.$useWrapMode) {
              this.$useWrapMode = e3, this.$modified = true, this.$resetRowCache(0);
              if (e3) {
                var t3 = this.getLength();
                this.$wrapData = Array(t3), this.$updateWrapData(0, t3 - 1);
              }
              this._signal("changeWrapMode");
            }
          }, this.getUseWrapMode = function() {
            return this.$useWrapMode;
          }, this.setWrapLimitRange = function(e3, t3) {
            if (this.$wrapLimitRange.min !== e3 || this.$wrapLimitRange.max !== t3)
              this.$wrapLimitRange = { min: e3, max: t3 }, this.$modified = true, this.$bidiHandler.markAsDirty(), this.$useWrapMode && this._signal("changeWrapMode");
          }, this.adjustWrapLimit = function(e3, t3) {
            var n3 = this.$wrapLimitRange;
            n3.max < 0 && (n3 = { min: t3, max: t3 });
            var r2 = this.$constrainWrapLimit(e3, n3.min, n3.max);
            return r2 != this.$wrapLimit && r2 > 1 ? (this.$wrapLimit = r2, this.$modified = true, this.$useWrapMode && (this.$updateWrapData(0, this.getLength() - 1), this.$resetRowCache(0), this._signal("changeWrapLimit")), true) : false;
          }, this.$constrainWrapLimit = function(e3, t3, n3) {
            return t3 && (e3 = Math.max(t3, e3)), n3 && (e3 = Math.min(n3, e3)), e3;
          }, this.getWrapLimit = function() {
            return this.$wrapLimit;
          }, this.setWrapLimit = function(e3) {
            this.setWrapLimitRange(e3, e3);
          }, this.getWrapLimitRange = function() {
            return { min: this.$wrapLimitRange.min, max: this.$wrapLimitRange.max };
          }, this.$updateInternalDataOnChange = function(e3) {
            var t3 = this.$useWrapMode, n3 = e3.action, r2 = e3.start, i2 = e3.end, s3 = r2.row, o2 = i2.row, u2 = o2 - s3, a3 = null;
            this.$updating = true;
            if (u2 != 0)
              if (n3 === "remove") {
                this[t3 ? "$wrapData" : "$rowLengthCache"].splice(s3, u2);
                var f2 = this.$foldData;
                a3 = this.getFoldsInRange(e3), this.removeFolds(a3);
                var l2 = this.getFoldLine(i2.row), c3 = 0;
                if (l2) {
                  l2.addRemoveChars(i2.row, i2.column, r2.column - i2.column), l2.shiftRow(-u2);
                  var h3 = this.getFoldLine(s3);
                  h3 && h3 !== l2 && (h3.merge(l2), l2 = h3), c3 = f2.indexOf(l2) + 1;
                }
                for (c3; c3 < f2.length; c3++) {
                  var l2 = f2[c3];
                  l2.start.row >= i2.row && l2.shiftRow(-u2);
                }
                o2 = s3;
              } else {
                var p2 = Array(u2);
                p2.unshift(s3, 0);
                var d3 = t3 ? this.$wrapData : this.$rowLengthCache;
                d3.splice.apply(d3, p2);
                var f2 = this.$foldData, l2 = this.getFoldLine(s3), c3 = 0;
                if (l2) {
                  var v2 = l2.range.compareInside(r2.row, r2.column);
                  v2 == 0 ? (l2 = l2.split(r2.row, r2.column), l2 && (l2.shiftRow(u2), l2.addRemoveChars(o2, 0, i2.column - r2.column))) : v2 == -1 && (l2.addRemoveChars(s3, 0, i2.column - r2.column), l2.shiftRow(u2)), c3 = f2.indexOf(l2) + 1;
                }
                for (c3; c3 < f2.length; c3++) {
                  var l2 = f2[c3];
                  l2.start.row >= s3 && l2.shiftRow(u2);
                }
              }
            else {
              u2 = Math.abs(e3.start.column - e3.end.column), n3 === "remove" && (a3 = this.getFoldsInRange(e3), this.removeFolds(a3), u2 = -u2);
              var l2 = this.getFoldLine(s3);
              l2 && l2.addRemoveChars(s3, r2.column, u2);
            }
            return t3 && this.$wrapData.length != this.doc.getLength() && console.error("doc.getLength() and $wrapData.length have to be the same!"), this.$updating = false, t3 ? this.$updateWrapData(s3, o2) : this.$updateRowLengthCache(s3, o2), a3;
          }, this.$updateRowLengthCache = function(e3, t3, n3) {
            this.$rowLengthCache[e3] = null, this.$rowLengthCache[t3] = null;
          }, this.$updateWrapData = function(e3, t3) {
            var r2 = this.doc.getAllLines(), i2 = this.getTabSize(), o2 = this.$wrapData, u2 = this.$wrapLimit, a3, f2, l2 = e3;
            t3 = Math.min(t3, r2.length - 1);
            while (l2 <= t3)
              f2 = this.getFoldLine(l2, f2), f2 ? (a3 = [], f2.walk(function(e4, t4, i3, o3) {
                var u3;
                if (e4 != null) {
                  u3 = this.$getDisplayTokens(e4, a3.length), u3[0] = n2;
                  for (var f3 = 1; f3 < u3.length; f3++)
                    u3[f3] = s2;
                } else
                  u3 = this.$getDisplayTokens(r2[t4].substring(o3, i3), a3.length);
                a3 = a3.concat(u3);
              }.bind(this), f2.end.row, r2[f2.end.row].length + 1), o2[f2.start.row] = this.$computeWrapSplits(a3, u2, i2), l2 = f2.end.row + 1) : (a3 = this.$getDisplayTokens(r2[l2]), o2[l2] = this.$computeWrapSplits(a3, u2, i2), l2++);
          };
          var e2 = 1, t2 = 2, n2 = 3, s2 = 4, a2 = 9, c2 = 10, h2 = 11, d2 = 12;
          this.$computeWrapSplits = function(e3, r2, i2) {
            function g() {
              var t3 = 0;
              if (m === 0)
                return t3;
              if (v2)
                for (var n3 = 0; n3 < e3.length; n3++) {
                  var r3 = e3[n3];
                  if (r3 == c2)
                    t3 += 1;
                  else {
                    if (r3 != h2) {
                      if (r3 == d2)
                        continue;
                      break;
                    }
                    t3 += i2;
                  }
                }
              return p2 && v2 !== false && (t3 += i2), Math.min(t3, m);
            }
            function y(t3) {
              var n3 = t3 - f2;
              for (var r3 = f2; r3 < t3; r3++) {
                var i3 = e3[r3];
                if (i3 === 12 || i3 === 2)
                  n3 -= 1;
              }
              o2.length || (b = g(), o2.indent = b), l2 += n3, o2.push(l2), f2 = t3;
            }
            if (e3.length == 0)
              return [];
            var o2 = [], u2 = e3.length, f2 = 0, l2 = 0, p2 = this.$wrapAsCode, v2 = this.$indentedSoftWrap, m = r2 <= Math.max(2 * i2, 8) || v2 === false ? 0 : Math.floor(r2 / 2), b = 0;
            while (u2 - f2 > r2 - b) {
              var w = f2 + r2 - b;
              if (e3[w - 1] >= c2 && e3[w] >= c2) {
                y(w);
                continue;
              }
              if (e3[w] == n2 || e3[w] == s2) {
                for (w; w != f2 - 1; w--)
                  if (e3[w] == n2)
                    break;
                if (w > f2) {
                  y(w);
                  continue;
                }
                w = f2 + r2;
                for (w; w < e3.length; w++)
                  if (e3[w] != s2)
                    break;
                if (w == e3.length)
                  break;
                y(w);
                continue;
              }
              var E = Math.max(w - (r2 - (r2 >> 2)), f2 - 1);
              while (w > E && e3[w] < n2)
                w--;
              if (p2) {
                while (w > E && e3[w] < n2)
                  w--;
                while (w > E && e3[w] == a2)
                  w--;
              } else
                while (w > E && e3[w] < c2)
                  w--;
              if (w > E) {
                y(++w);
                continue;
              }
              w = f2 + r2, e3[w] == t2 && w--, y(w - b);
            }
            return o2;
          }, this.$getDisplayTokens = function(n3, r2) {
            var i2 = [], s3;
            r2 = r2 || 0;
            for (var o2 = 0; o2 < n3.length; o2++) {
              var u2 = n3.charCodeAt(o2);
              if (u2 == 9) {
                s3 = this.getScreenTabSize(i2.length + r2), i2.push(h2);
                for (var f2 = 1; f2 < s3; f2++)
                  i2.push(d2);
              } else
                u2 == 32 ? i2.push(c2) : u2 > 39 && u2 < 48 || u2 > 57 && u2 < 64 ? i2.push(a2) : u2 >= 4352 && v(u2) ? i2.push(e2, t2) : i2.push(e2);
            }
            return i2;
          }, this.$getStringScreenWidth = function(e3, t3, n3) {
            if (t3 == 0)
              return [0, 0];
            t3 == null && (t3 = Infinity), n3 = n3 || 0;
            var r2, i2;
            for (i2 = 0; i2 < e3.length; i2++) {
              r2 = e3.charCodeAt(i2), r2 == 9 ? n3 += this.getScreenTabSize(n3) : r2 >= 4352 && v(r2) ? n3 += 2 : n3 += 1;
              if (n3 > t3)
                break;
            }
            return [n3, i2];
          }, this.lineWidgets = null, this.getRowLength = function(e3) {
            var t3 = 1;
            return this.lineWidgets && (t3 += this.lineWidgets[e3] && this.lineWidgets[e3].rowCount || 0), !this.$useWrapMode || !this.$wrapData[e3] ? t3 : this.$wrapData[e3].length + t3;
          }, this.getRowLineCount = function(e3) {
            return !this.$useWrapMode || !this.$wrapData[e3] ? 1 : this.$wrapData[e3].length + 1;
          }, this.getRowWrapIndent = function(e3) {
            if (this.$useWrapMode) {
              var t3 = this.screenToDocumentPosition(e3, Number.MAX_VALUE), n3 = this.$wrapData[t3.row];
              return n3.length && n3[0] < t3.column ? n3.indent : 0;
            }
            return 0;
          }, this.getScreenLastRowColumn = function(e3) {
            var t3 = this.screenToDocumentPosition(e3, Number.MAX_VALUE);
            return this.documentToScreenColumn(t3.row, t3.column);
          }, this.getDocumentLastRowColumn = function(e3, t3) {
            var n3 = this.documentToScreenRow(e3, t3);
            return this.getScreenLastRowColumn(n3);
          }, this.getDocumentLastRowColumnPosition = function(e3, t3) {
            var n3 = this.documentToScreenRow(e3, t3);
            return this.screenToDocumentPosition(n3, Number.MAX_VALUE / 10);
          }, this.getRowSplitData = function(e3) {
            return this.$useWrapMode ? this.$wrapData[e3] : void 0;
          }, this.getScreenTabSize = function(e3) {
            return this.$tabSize - (e3 % this.$tabSize | 0);
          }, this.screenToDocumentRow = function(e3, t3) {
            return this.screenToDocumentPosition(e3, t3).row;
          }, this.screenToDocumentColumn = function(e3, t3) {
            return this.screenToDocumentPosition(e3, t3).column;
          }, this.screenToDocumentPosition = function(e3, t3, n3) {
            if (e3 < 0)
              return { row: 0, column: 0 };
            var r2, i2 = 0, s3 = 0, o2, u2 = 0, a3 = 0, f2 = this.$screenRowCache, l2 = this.$getRowCacheIndex(f2, e3), c3 = f2.length;
            if (c3 && l2 >= 0)
              var u2 = f2[l2], i2 = this.$docRowCache[l2], h3 = e3 > f2[c3 - 1];
            else
              var h3 = !c3;
            var p2 = this.getLength() - 1, d3 = this.getNextFoldLine(i2), v2 = d3 ? d3.start.row : Infinity;
            while (u2 <= e3) {
              a3 = this.getRowLength(i2);
              if (u2 + a3 > e3 || i2 >= p2)
                break;
              u2 += a3, i2++, i2 > v2 && (i2 = d3.end.row + 1, d3 = this.getNextFoldLine(i2, d3), v2 = d3 ? d3.start.row : Infinity), h3 && (this.$docRowCache.push(i2), this.$screenRowCache.push(u2));
            }
            if (d3 && d3.start.row <= i2)
              r2 = this.getFoldDisplayLine(d3), i2 = d3.start.row;
            else {
              if (u2 + a3 <= e3 || i2 > p2)
                return { row: p2, column: this.getLine(p2).length };
              r2 = this.getLine(i2), d3 = null;
            }
            var m = 0, g = Math.floor(e3 - u2);
            if (this.$useWrapMode) {
              var y = this.$wrapData[i2];
              y && (o2 = y[g], g > 0 && y.length && (m = y.indent, s3 = y[g - 1] || y[y.length - 1], r2 = r2.substring(s3)));
            }
            return n3 !== void 0 && this.$bidiHandler.isBidiRow(u2 + g, i2, g) && (t3 = this.$bidiHandler.offsetToCol(n3)), s3 += this.$getStringScreenWidth(r2, t3 - m)[1], this.$useWrapMode && s3 >= o2 && (s3 = o2 - 1), d3 ? d3.idxToPosition(s3) : { row: i2, column: s3 };
          }, this.documentToScreenPosition = function(e3, t3) {
            if (typeof t3 == "undefined")
              var n3 = this.$clipPositionToDocument(e3.row, e3.column);
            else
              n3 = this.$clipPositionToDocument(e3, t3);
            e3 = n3.row, t3 = n3.column;
            var r2 = 0, i2 = null, s3 = null;
            s3 = this.getFoldAt(e3, t3, 1), s3 && (e3 = s3.start.row, t3 = s3.start.column);
            var o2, u2 = 0, a3 = this.$docRowCache, f2 = this.$getRowCacheIndex(a3, e3), l2 = a3.length;
            if (l2 && f2 >= 0)
              var u2 = a3[f2], r2 = this.$screenRowCache[f2], c3 = e3 > a3[l2 - 1];
            else
              var c3 = !l2;
            var h3 = this.getNextFoldLine(u2), p2 = h3 ? h3.start.row : Infinity;
            while (u2 < e3) {
              if (u2 >= p2) {
                o2 = h3.end.row + 1;
                if (o2 > e3)
                  break;
                h3 = this.getNextFoldLine(o2, h3), p2 = h3 ? h3.start.row : Infinity;
              } else
                o2 = u2 + 1;
              r2 += this.getRowLength(u2), u2 = o2, c3 && (this.$docRowCache.push(u2), this.$screenRowCache.push(r2));
            }
            var d3 = "";
            h3 && u2 >= p2 ? (d3 = this.getFoldDisplayLine(h3, e3, t3), i2 = h3.start.row) : (d3 = this.getLine(e3).substring(0, t3), i2 = e3);
            var v2 = 0;
            if (this.$useWrapMode) {
              var m = this.$wrapData[i2];
              if (m) {
                var g = 0;
                while (d3.length >= m[g])
                  r2++, g++;
                d3 = d3.substring(m[g - 1] || 0, d3.length), v2 = g > 0 ? m.indent : 0;
              }
            }
            return this.lineWidgets && this.lineWidgets[u2] && this.lineWidgets[u2].rowsAbove && (r2 += this.lineWidgets[u2].rowsAbove), { row: r2, column: v2 + this.$getStringScreenWidth(d3)[0] };
          }, this.documentToScreenColumn = function(e3, t3) {
            return this.documentToScreenPosition(e3, t3).column;
          }, this.documentToScreenRow = function(e3, t3) {
            return this.documentToScreenPosition(e3, t3).row;
          }, this.getScreenLength = function() {
            var e3 = 0, t3 = null;
            if (!this.$useWrapMode) {
              e3 = this.getLength();
              var n3 = this.$foldData;
              for (var r2 = 0; r2 < n3.length; r2++)
                t3 = n3[r2], e3 -= t3.end.row - t3.start.row;
            } else {
              var i2 = this.$wrapData.length, s3 = 0, r2 = 0, t3 = this.$foldData[r2++], o2 = t3 ? t3.start.row : Infinity;
              while (s3 < i2) {
                var u2 = this.$wrapData[s3];
                e3 += u2 ? u2.length + 1 : 1, s3++, s3 > o2 && (s3 = t3.end.row + 1, t3 = this.$foldData[r2++], o2 = t3 ? t3.start.row : Infinity);
              }
            }
            return this.lineWidgets && (e3 += this.$getWidgetScreenLength()), e3;
          }, this.$setFontMetrics = function(e3) {
            if (!this.$enableVarChar)
              return;
            this.$getStringScreenWidth = function(t3, n3, r2) {
              if (n3 === 0)
                return [0, 0];
              n3 || (n3 = Infinity), r2 = r2 || 0;
              var i2, s3;
              for (s3 = 0; s3 < t3.length; s3++) {
                i2 = t3.charAt(s3), i2 === "	" ? r2 += this.getScreenTabSize(r2) : r2 += e3.getCharacterWidth(i2);
                if (r2 > n3)
                  break;
              }
              return [r2, s3];
            };
          }, this.destroy = function() {
            this.destroyed || (this.bgTokenizer.setDocument(null), this.bgTokenizer.cleanup(), this.destroyed = true), this.$stopWorker(), this.removeAllListeners(), this.doc && this.doc.off("change", this.$onChange), this.selection.detach();
          }, this.isFullWidth = v;
        }.call(d.prototype), e("./edit_session/folding").Folding.call(d.prototype), e("./edit_session/bracket_match").BracketMatch.call(d.prototype), o.defineOptions(d.prototype, "session", { wrap: { set: function(e2) {
          !e2 || e2 == "off" ? e2 = false : e2 == "free" ? e2 = true : e2 == "printMargin" ? e2 = -1 : typeof e2 == "string" && (e2 = parseInt(e2, 10) || false);
          if (this.$wrap == e2)
            return;
          this.$wrap = e2;
          if (!e2)
            this.setUseWrapMode(false);
          else {
            var t2 = typeof e2 == "number" ? e2 : null;
            this.setWrapLimitRange(t2, t2), this.setUseWrapMode(true);
          }
        }, get: function() {
          return this.getUseWrapMode() ? this.$wrap == -1 ? "printMargin" : this.getWrapLimitRange().min ? this.$wrap : "free" : "off";
        }, handlesSet: true }, wrapMethod: { set: function(e2) {
          e2 = e2 == "auto" ? this.$mode.type != "text" : e2 != "text", e2 != this.$wrapAsCode && (this.$wrapAsCode = e2, this.$useWrapMode && (this.$useWrapMode = false, this.setUseWrapMode(true)));
        }, initialValue: "auto" }, indentedSoftWrap: { set: function() {
          this.$useWrapMode && (this.$useWrapMode = false, this.setUseWrapMode(true));
        }, initialValue: true }, firstLineNumber: { set: function() {
          this._signal("changeBreakpoint");
        }, initialValue: 1 }, useWorker: { set: function(e2) {
          this.$useWorker = e2, this.$stopWorker(), e2 && this.$startWorker();
        }, initialValue: true }, useSoftTabs: { initialValue: true }, tabSize: { set: function(e2) {
          e2 = parseInt(e2), e2 > 0 && this.$tabSize !== e2 && (this.$modified = true, this.$rowLengthCache = [], this.$tabSize = e2, this._signal("changeTabSize"));
        }, initialValue: 4, handlesSet: true }, navigateWithinSoftTabs: { initialValue: false }, foldStyle: { set: function(e2) {
          this.setFoldStyle(e2);
        }, handlesSet: true }, overwrite: { set: function(e2) {
          this._signal("changeOverwrite");
        }, initialValue: false }, newLineMode: { set: function(e2) {
          this.doc.setNewLineMode(e2);
        }, get: function() {
          return this.doc.getNewLineMode();
        }, handlesSet: true }, mode: { set: function(e2) {
          this.setMode(e2);
        }, get: function() {
          return this.$modeId;
        }, handlesSet: true } }), t.EditSession = d;
      }), ace.define("ace/search", ["require", "exports", "module", "ace/lib/lang", "ace/lib/oop", "ace/range"], function(e, t, n) {
        "use strict";
        function u(e2, t2) {
          function n2(e3) {
            return /\w/.test(e3) || t2.regExp ? "\\b" : "";
          }
          return n2(e2[0]) + e2 + n2(e2[e2.length - 1]);
        }
        var r = e("./lib/lang"), i = e("./lib/oop"), s = e("./range").Range, o = function() {
          this.$options = {};
        };
        (function() {
          this.set = function(e2) {
            return i.mixin(this.$options, e2), this;
          }, this.getOptions = function() {
            return r.copyObject(this.$options);
          }, this.setOptions = function(e2) {
            this.$options = e2;
          }, this.find = function(e2) {
            var t2 = this.$options, n2 = this.$matchIterator(e2, t2);
            if (!n2)
              return false;
            var r2 = null;
            return n2.forEach(function(e3, n3, i2, o2) {
              return r2 = new s(e3, n3, i2, o2), n3 == o2 && t2.start && t2.start.start && t2.skipCurrent != 0 && r2.isEqual(t2.start) ? (r2 = null, false) : true;
            }), r2;
          }, this.findAll = function(e2) {
            var t2 = this.$options;
            if (!t2.needle)
              return [];
            this.$assembleRegExp(t2);
            var n2 = t2.range, i2 = n2 ? e2.getLines(n2.start.row, n2.end.row) : e2.doc.getAllLines(), o2 = [], u2 = t2.re;
            if (t2.$isMultiLine) {
              var a = u2.length, f = i2.length - a, l;
              e:
                for (var c = u2.offset || 0; c <= f; c++) {
                  for (var h = 0; h < a; h++)
                    if (i2[c + h].search(u2[h]) == -1)
                      continue e;
                  var p = i2[c], d = i2[c + a - 1], v = p.length - p.match(u2[0])[0].length, m = d.match(u2[a - 1])[0].length;
                  if (l && l.end.row === c && l.end.column > v)
                    continue;
                  o2.push(l = new s(c, v, c + a - 1, m)), a > 2 && (c = c + a - 2);
                }
            } else
              for (var g = 0; g < i2.length; g++) {
                var y = r.getMatchOffsets(i2[g], u2);
                for (var h = 0; h < y.length; h++) {
                  var b = y[h];
                  o2.push(new s(g, b.offset, g, b.offset + b.length));
                }
              }
            if (n2) {
              var w = n2.start.column, E = n2.start.column, g = 0, h = o2.length - 1;
              while (g < h && o2[g].start.column < w && o2[g].start.row == n2.start.row)
                g++;
              while (g < h && o2[h].end.column > E && o2[h].end.row == n2.end.row)
                h--;
              o2 = o2.slice(g, h + 1);
              for (g = 0, h = o2.length; g < h; g++)
                o2[g].start.row += n2.start.row, o2[g].end.row += n2.start.row;
            }
            return o2;
          }, this.replace = function(e2, t2) {
            var n2 = this.$options, r2 = this.$assembleRegExp(n2);
            if (n2.$isMultiLine)
              return t2;
            if (!r2)
              return;
            var i2 = r2.exec(e2);
            if (!i2 || i2[0].length != e2.length)
              return null;
            t2 = e2.replace(r2, t2);
            if (n2.preserveCase) {
              t2 = t2.split("");
              for (var s2 = Math.min(e2.length, e2.length); s2--; ) {
                var o2 = e2[s2];
                o2 && o2.toLowerCase() != o2 ? t2[s2] = t2[s2].toUpperCase() : t2[s2] = t2[s2].toLowerCase();
              }
              t2 = t2.join("");
            }
            return t2;
          }, this.$assembleRegExp = function(e2, t2) {
            if (e2.needle instanceof RegExp)
              return e2.re = e2.needle;
            var n2 = e2.needle;
            if (!e2.needle)
              return e2.re = false;
            e2.regExp || (n2 = r.escapeRegExp(n2)), e2.wholeWord && (n2 = u(n2, e2));
            var i2 = e2.caseSensitive ? "gm" : "gmi";
            e2.$isMultiLine = !t2 && /[\n\r]/.test(n2);
            if (e2.$isMultiLine)
              return e2.re = this.$assembleMultilineRegExp(n2, i2);
            try {
              var s2 = new RegExp(n2, i2);
            } catch (o2) {
              s2 = false;
            }
            return e2.re = s2;
          }, this.$assembleMultilineRegExp = function(e2, t2) {
            var n2 = e2.replace(/\r\n|\r|\n/g, "$\n^").split("\n"), r2 = [];
            for (var i2 = 0; i2 < n2.length; i2++)
              try {
                r2.push(new RegExp(n2[i2], t2));
              } catch (s2) {
                return false;
              }
            return r2;
          }, this.$matchIterator = function(e2, t2) {
            var n2 = this.$assembleRegExp(t2);
            if (!n2)
              return false;
            var r2 = t2.backwards == 1, i2 = t2.skipCurrent != 0, s2 = t2.range, o2 = t2.start;
            o2 || (o2 = s2 ? s2[r2 ? "end" : "start"] : e2.selection.getRange()), o2.start && (o2 = o2[i2 != r2 ? "end" : "start"]);
            var u2 = s2 ? s2.start.row : 0, a = s2 ? s2.end.row : e2.getLength() - 1;
            if (r2)
              var f = function(e3) {
                var n3 = o2.row;
                if (c(n3, o2.column, e3))
                  return;
                for (n3--; n3 >= u2; n3--)
                  if (c(n3, Number.MAX_VALUE, e3))
                    return;
                if (t2.wrap == 0)
                  return;
                for (n3 = a, u2 = o2.row; n3 >= u2; n3--)
                  if (c(n3, Number.MAX_VALUE, e3))
                    return;
              };
            else
              var f = function(e3) {
                var n3 = o2.row;
                if (c(n3, o2.column, e3))
                  return;
                for (n3 += 1; n3 <= a; n3++)
                  if (c(n3, 0, e3))
                    return;
                if (t2.wrap == 0)
                  return;
                for (n3 = u2, a = o2.row; n3 <= a; n3++)
                  if (c(n3, 0, e3))
                    return;
              };
            if (t2.$isMultiLine)
              var l = n2.length, c = function(t3, i3, s3) {
                var o3 = r2 ? t3 - l + 1 : t3;
                if (o3 < 0 || o3 + l > e2.getLength())
                  return;
                var u3 = e2.getLine(o3), a2 = u3.search(n2[0]);
                if (!r2 && a2 < i3 || a2 === -1)
                  return;
                for (var f2 = 1; f2 < l; f2++) {
                  u3 = e2.getLine(o3 + f2);
                  if (u3.search(n2[f2]) == -1)
                    return;
                }
                var c2 = u3.match(n2[l - 1])[0].length;
                if (r2 && c2 > i3)
                  return;
                if (s3(o3, a2, o3 + l - 1, c2))
                  return true;
              };
            else if (r2)
              var c = function(t3, r3, i3) {
                var s3 = e2.getLine(t3), o3 = [], u3, a2 = 0;
                n2.lastIndex = 0;
                while (u3 = n2.exec(s3)) {
                  var f2 = u3[0].length;
                  a2 = u3.index;
                  if (!f2) {
                    if (a2 >= s3.length)
                      break;
                    n2.lastIndex = a2 += 1;
                  }
                  if (u3.index + f2 > r3)
                    break;
                  o3.push(u3.index, f2);
                }
                for (var l2 = o3.length - 1; l2 >= 0; l2 -= 2) {
                  var c2 = o3[l2 - 1], f2 = o3[l2];
                  if (i3(t3, c2, t3, c2 + f2))
                    return true;
                }
              };
            else
              var c = function(t3, r3, i3) {
                var s3 = e2.getLine(t3), o3, u3;
                n2.lastIndex = r3;
                while (u3 = n2.exec(s3)) {
                  var a2 = u3[0].length;
                  o3 = u3.index;
                  if (i3(t3, o3, t3, o3 + a2))
                    return true;
                  if (!a2) {
                    n2.lastIndex = o3 += 1;
                    if (o3 >= s3.length)
                      return false;
                  }
                }
              };
            return { forEach: f };
          };
        }).call(o.prototype), t.Search = o;
      }), ace.define("ace/keyboard/hash_handler", ["require", "exports", "module", "ace/lib/keys", "ace/lib/useragent"], function(e, t, n) {
        "use strict";
        function o(e2, t2) {
          this.platform = t2 || (i.isMac ? "mac" : "win"), this.commands = {}, this.commandKeyBinding = {}, this.addCommands(e2), this.$singleCommand = true;
        }
        function u(e2, t2) {
          o.call(this, e2, t2), this.$singleCommand = false;
        }
        var r = e("../lib/keys"), i = e("../lib/useragent"), s = r.KEY_MODS;
        u.prototype = o.prototype, function() {
          function e2(e3) {
            return typeof e3 == "object" && e3.bindKey && e3.bindKey.position || (e3.isDefault ? -100 : 0);
          }
          this.addCommand = function(e3) {
            this.commands[e3.name] && this.removeCommand(e3), this.commands[e3.name] = e3, e3.bindKey && this._buildKeyHash(e3);
          }, this.removeCommand = function(e3, t2) {
            var n2 = e3 && (typeof e3 == "string" ? e3 : e3.name);
            e3 = this.commands[n2], t2 || delete this.commands[n2];
            var r2 = this.commandKeyBinding;
            for (var i2 in r2) {
              var s2 = r2[i2];
              if (s2 == e3)
                delete r2[i2];
              else if (Array.isArray(s2)) {
                var o2 = s2.indexOf(e3);
                o2 != -1 && (s2.splice(o2, 1), s2.length == 1 && (r2[i2] = s2[0]));
              }
            }
          }, this.bindKey = function(e3, t2, n2) {
            typeof e3 == "object" && e3 && (n2 == void 0 && (n2 = e3.position), e3 = e3[this.platform]);
            if (!e3)
              return;
            if (typeof t2 == "function")
              return this.addCommand({ exec: t2, bindKey: e3, name: t2.name || e3 });
            e3.split("|").forEach(function(e4) {
              var r2 = "";
              if (e4.indexOf(" ") != -1) {
                var i2 = e4.split(/\s+/);
                e4 = i2.pop(), i2.forEach(function(e5) {
                  var t3 = this.parseKeys(e5), n3 = s[t3.hashId] + t3.key;
                  r2 += (r2 ? " " : "") + n3, this._addCommandToBinding(r2, "chainKeys");
                }, this), r2 += " ";
              }
              var o2 = this.parseKeys(e4), u2 = s[o2.hashId] + o2.key;
              this._addCommandToBinding(r2 + u2, t2, n2);
            }, this);
          }, this._addCommandToBinding = function(t2, n2, r2) {
            var i2 = this.commandKeyBinding, s2;
            if (!n2)
              delete i2[t2];
            else if (!i2[t2] || this.$singleCommand)
              i2[t2] = n2;
            else {
              Array.isArray(i2[t2]) ? (s2 = i2[t2].indexOf(n2)) != -1 && i2[t2].splice(s2, 1) : i2[t2] = [i2[t2]], typeof r2 != "number" && (r2 = e2(n2));
              var o2 = i2[t2];
              for (s2 = 0; s2 < o2.length; s2++) {
                var u2 = o2[s2], a = e2(u2);
                if (a > r2)
                  break;
              }
              o2.splice(s2, 0, n2);
            }
          }, this.addCommands = function(e3) {
            e3 && Object.keys(e3).forEach(function(t2) {
              var n2 = e3[t2];
              if (!n2)
                return;
              if (typeof n2 == "string")
                return this.bindKey(n2, t2);
              typeof n2 == "function" && (n2 = { exec: n2 });
              if (typeof n2 != "object")
                return;
              n2.name || (n2.name = t2), this.addCommand(n2);
            }, this);
          }, this.removeCommands = function(e3) {
            Object.keys(e3).forEach(function(t2) {
              this.removeCommand(e3[t2]);
            }, this);
          }, this.bindKeys = function(e3) {
            Object.keys(e3).forEach(function(t2) {
              this.bindKey(t2, e3[t2]);
            }, this);
          }, this._buildKeyHash = function(e3) {
            this.bindKey(e3.bindKey, e3);
          }, this.parseKeys = function(e3) {
            var t2 = e3.toLowerCase().split(/[\-\+]([\-\+])?/).filter(function(e4) {
              return e4;
            }), n2 = t2.pop(), i2 = r[n2];
            if (r.FUNCTION_KEYS[i2])
              n2 = r.FUNCTION_KEYS[i2].toLowerCase();
            else {
              if (!t2.length)
                return { key: n2, hashId: -1 };
              if (t2.length == 1 && t2[0] == "shift")
                return { key: n2.toUpperCase(), hashId: -1 };
            }
            var s2 = 0;
            for (var o2 = t2.length; o2--; ) {
              var u2 = r.KEY_MODS[t2[o2]];
              if (u2 == null)
                return typeof console != "undefined" && console.error("invalid modifier " + t2[o2] + " in " + e3), false;
              s2 |= u2;
            }
            return { key: n2, hashId: s2 };
          }, this.findKeyCommand = function(t2, n2) {
            var r2 = s[t2] + n2;
            return this.commandKeyBinding[r2];
          }, this.handleKeyboard = function(e3, t2, n2, r2) {
            if (r2 < 0)
              return;
            var i2 = s[t2] + n2, o2 = this.commandKeyBinding[i2];
            e3.$keyChain && (e3.$keyChain += " " + i2, o2 = this.commandKeyBinding[e3.$keyChain] || o2);
            if (o2) {
              if (o2 == "chainKeys" || o2[o2.length - 1] == "chainKeys")
                return e3.$keyChain = e3.$keyChain || i2, { command: "null" };
            }
            if (e3.$keyChain)
              if (!!t2 && t2 != 4 || n2.length != 1) {
                if (t2 == -1 || r2 > 0)
                  e3.$keyChain = "";
              } else
                e3.$keyChain = e3.$keyChain.slice(0, -i2.length - 1);
            return { command: o2 };
          }, this.getStatusText = function(e3, t2) {
            return t2.$keyChain || "";
          };
        }.call(o.prototype), t.HashHandler = o, t.MultiHashHandler = u;
      }), ace.define("ace/commands/command_manager", ["require", "exports", "module", "ace/lib/oop", "ace/keyboard/hash_handler", "ace/lib/event_emitter"], function(e, t, n) {
        "use strict";
        var r = e("../lib/oop"), i = e("../keyboard/hash_handler").MultiHashHandler, s = e("../lib/event_emitter").EventEmitter, o = function(e2, t2) {
          i.call(this, t2, e2), this.byName = this.commands, this.setDefaultHandler("exec", function(e3) {
            return e3.args ? e3.command.exec(e3.editor, e3.args, e3.event, false) : e3.command.exec(e3.editor, {}, e3.event, true);
          });
        };
        r.inherits(o, i), function() {
          r.implement(this, s), this.exec = function(e2, t2, n2) {
            if (Array.isArray(e2)) {
              for (var r2 = e2.length; r2--; )
                if (this.exec(e2[r2], t2, n2))
                  return true;
              return false;
            }
            typeof e2 == "string" && (e2 = this.commands[e2]);
            if (!e2)
              return false;
            if (t2 && t2.$readOnly && !e2.readOnly)
              return false;
            if (this.$checkCommandState != 0 && e2.isAvailable && !e2.isAvailable(t2))
              return false;
            var i2 = { editor: t2, command: e2, args: n2 };
            return i2.returnValue = this._emit("exec", i2), this._signal("afterExec", i2), i2.returnValue === false ? false : true;
          }, this.toggleRecording = function(e2) {
            if (this.$inReplay)
              return;
            return e2 && e2._emit("changeStatus"), this.recording ? (this.macro.pop(), this.off("exec", this.$addCommandToMacro), this.macro.length || (this.macro = this.oldMacro), this.recording = false) : (this.$addCommandToMacro || (this.$addCommandToMacro = function(e3) {
              this.macro.push([e3.command, e3.args]);
            }.bind(this)), this.oldMacro = this.macro, this.macro = [], this.on("exec", this.$addCommandToMacro), this.recording = true);
          }, this.replay = function(e2) {
            if (this.$inReplay || !this.macro)
              return;
            if (this.recording)
              return this.toggleRecording(e2);
            try {
              this.$inReplay = true, this.macro.forEach(function(t2) {
                typeof t2 == "string" ? this.exec(t2, e2) : this.exec(t2[0], e2, t2[1]);
              }, this);
            } finally {
              this.$inReplay = false;
            }
          }, this.trimMacro = function(e2) {
            return e2.map(function(e3) {
              return typeof e3[0] != "string" && (e3[0] = e3[0].name), e3[1] || (e3 = e3[0]), e3;
            });
          };
        }.call(o.prototype), t.CommandManager = o;
      }), ace.define("ace/commands/default_commands", ["require", "exports", "module", "ace/lib/lang", "ace/config", "ace/range"], function(e, t, n) {
        "use strict";
        function o(e2, t2) {
          return { win: e2, mac: t2 };
        }
        var r = e("../lib/lang"), i = e("../config"), s = e("../range").Range;
        t.commands = [{ name: "showSettingsMenu", description: "Show settings menu", bindKey: o("Ctrl-,", "Command-,"), exec: function(e2) {
          i.loadModule("ace/ext/settings_menu", function(t2) {
            t2.init(e2), e2.showSettingsMenu();
          });
        }, readOnly: true }, { name: "goToNextError", description: "Go to next error", bindKey: o("Alt-E", "F4"), exec: function(e2) {
          i.loadModule("./ext/error_marker", function(t2) {
            t2.showErrorMarker(e2, 1);
          });
        }, scrollIntoView: "animate", readOnly: true }, { name: "goToPreviousError", description: "Go to previous error", bindKey: o("Alt-Shift-E", "Shift-F4"), exec: function(e2) {
          i.loadModule("./ext/error_marker", function(t2) {
            t2.showErrorMarker(e2, -1);
          });
        }, scrollIntoView: "animate", readOnly: true }, { name: "selectall", description: "Select all", bindKey: o("Ctrl-A", "Command-A"), exec: function(e2) {
          e2.selectAll();
        }, readOnly: true }, { name: "centerselection", description: "Center selection", bindKey: o(null, "Ctrl-L"), exec: function(e2) {
          e2.centerSelection();
        }, readOnly: true }, { name: "gotoline", description: "Go to line...", bindKey: o("Ctrl-L", "Command-L"), exec: function(e2, t2) {
          typeof t2 == "number" && !isNaN(t2) && e2.gotoLine(t2), e2.prompt({ $type: "gotoLine" });
        }, readOnly: true }, { name: "fold", bindKey: o("Alt-L|Ctrl-F1", "Command-Alt-L|Command-F1"), exec: function(e2) {
          e2.session.toggleFold(false);
        }, multiSelectAction: "forEach", scrollIntoView: "center", readOnly: true }, { name: "unfold", bindKey: o("Alt-Shift-L|Ctrl-Shift-F1", "Command-Alt-Shift-L|Command-Shift-F1"), exec: function(e2) {
          e2.session.toggleFold(true);
        }, multiSelectAction: "forEach", scrollIntoView: "center", readOnly: true }, { name: "toggleFoldWidget", description: "Toggle fold widget", bindKey: o("F2", "F2"), exec: function(e2) {
          e2.session.toggleFoldWidget();
        }, multiSelectAction: "forEach", scrollIntoView: "center", readOnly: true }, { name: "toggleParentFoldWidget", description: "Toggle parent fold widget", bindKey: o("Alt-F2", "Alt-F2"), exec: function(e2) {
          e2.session.toggleFoldWidget(true);
        }, multiSelectAction: "forEach", scrollIntoView: "center", readOnly: true }, { name: "foldall", description: "Fold all", bindKey: o(null, "Ctrl-Command-Option-0"), exec: function(e2) {
          e2.session.foldAll();
        }, scrollIntoView: "center", readOnly: true }, { name: "foldAllComments", description: "Fold all comments", bindKey: o(null, "Ctrl-Command-Option-0"), exec: function(e2) {
          e2.session.foldAllComments();
        }, scrollIntoView: "center", readOnly: true }, { name: "foldOther", description: "Fold other", bindKey: o("Alt-0", "Command-Option-0"), exec: function(e2) {
          e2.session.foldAll(), e2.session.unfold(e2.selection.getAllRanges());
        }, scrollIntoView: "center", readOnly: true }, { name: "unfoldall", description: "Unfold all", bindKey: o("Alt-Shift-0", "Command-Option-Shift-0"), exec: function(e2) {
          e2.session.unfold();
        }, scrollIntoView: "center", readOnly: true }, { name: "findnext", description: "Find next", bindKey: o("Ctrl-K", "Command-G"), exec: function(e2) {
          e2.findNext();
        }, multiSelectAction: "forEach", scrollIntoView: "center", readOnly: true }, { name: "findprevious", description: "Find previous", bindKey: o("Ctrl-Shift-K", "Command-Shift-G"), exec: function(e2) {
          e2.findPrevious();
        }, multiSelectAction: "forEach", scrollIntoView: "center", readOnly: true }, { name: "selectOrFindNext", description: "Select or find next", bindKey: o("Alt-K", "Ctrl-G"), exec: function(e2) {
          e2.selection.isEmpty() ? e2.selection.selectWord() : e2.findNext();
        }, readOnly: true }, { name: "selectOrFindPrevious", description: "Select or find previous", bindKey: o("Alt-Shift-K", "Ctrl-Shift-G"), exec: function(e2) {
          e2.selection.isEmpty() ? e2.selection.selectWord() : e2.findPrevious();
        }, readOnly: true }, { name: "find", description: "Find", bindKey: o("Ctrl-F", "Command-F"), exec: function(e2) {
          i.loadModule("ace/ext/searchbox", function(t2) {
            t2.Search(e2);
          });
        }, readOnly: true }, { name: "overwrite", description: "Overwrite", bindKey: "Insert", exec: function(e2) {
          e2.toggleOverwrite();
        }, readOnly: true }, { name: "selecttostart", description: "Select to start", bindKey: o("Ctrl-Shift-Home", "Command-Shift-Home|Command-Shift-Up"), exec: function(e2) {
          e2.getSelection().selectFileStart();
        }, multiSelectAction: "forEach", readOnly: true, scrollIntoView: "animate", aceCommandGroup: "fileJump" }, { name: "gotostart", description: "Go to start", bindKey: o("Ctrl-Home", "Command-Home|Command-Up"), exec: function(e2) {
          e2.navigateFileStart();
        }, multiSelectAction: "forEach", readOnly: true, scrollIntoView: "animate", aceCommandGroup: "fileJump" }, { name: "selectup", description: "Select up", bindKey: o("Shift-Up", "Shift-Up|Ctrl-Shift-P"), exec: function(e2) {
          e2.getSelection().selectUp();
        }, multiSelectAction: "forEach", scrollIntoView: "cursor", readOnly: true }, { name: "golineup", description: "Go line up", bindKey: o("Up", "Up|Ctrl-P"), exec: function(e2, t2) {
          e2.navigateUp(t2.times);
        }, multiSelectAction: "forEach", scrollIntoView: "cursor", readOnly: true }, { name: "selecttoend", description: "Select to end", bindKey: o("Ctrl-Shift-End", "Command-Shift-End|Command-Shift-Down"), exec: function(e2) {
          e2.getSelection().selectFileEnd();
        }, multiSelectAction: "forEach", readOnly: true, scrollIntoView: "animate", aceCommandGroup: "fileJump" }, { name: "gotoend", description: "Go to end", bindKey: o("Ctrl-End", "Command-End|Command-Down"), exec: function(e2) {
          e2.navigateFileEnd();
        }, multiSelectAction: "forEach", readOnly: true, scrollIntoView: "animate", aceCommandGroup: "fileJump" }, { name: "selectdown", description: "Select down", bindKey: o("Shift-Down", "Shift-Down|Ctrl-Shift-N"), exec: function(e2) {
          e2.getSelection().selectDown();
        }, multiSelectAction: "forEach", scrollIntoView: "cursor", readOnly: true }, { name: "golinedown", description: "Go line down", bindKey: o("Down", "Down|Ctrl-N"), exec: function(e2, t2) {
          e2.navigateDown(t2.times);
        }, multiSelectAction: "forEach", scrollIntoView: "cursor", readOnly: true }, { name: "selectwordleft", description: "Select word left", bindKey: o("Ctrl-Shift-Left", "Option-Shift-Left"), exec: function(e2) {
          e2.getSelection().selectWordLeft();
        }, multiSelectAction: "forEach", scrollIntoView: "cursor", readOnly: true }, { name: "gotowordleft", description: "Go to word left", bindKey: o("Ctrl-Left", "Option-Left"), exec: function(e2) {
          e2.navigateWordLeft();
        }, multiSelectAction: "forEach", scrollIntoView: "cursor", readOnly: true }, { name: "selecttolinestart", description: "Select to line start", bindKey: o("Alt-Shift-Left", "Command-Shift-Left|Ctrl-Shift-A"), exec: function(e2) {
          e2.getSelection().selectLineStart();
        }, multiSelectAction: "forEach", scrollIntoView: "cursor", readOnly: true }, { name: "gotolinestart", description: "Go to line start", bindKey: o("Alt-Left|Home", "Command-Left|Home|Ctrl-A"), exec: function(e2) {
          e2.navigateLineStart();
        }, multiSelectAction: "forEach", scrollIntoView: "cursor", readOnly: true }, { name: "selectleft", description: "Select left", bindKey: o("Shift-Left", "Shift-Left|Ctrl-Shift-B"), exec: function(e2) {
          e2.getSelection().selectLeft();
        }, multiSelectAction: "forEach", scrollIntoView: "cursor", readOnly: true }, { name: "gotoleft", description: "Go to left", bindKey: o("Left", "Left|Ctrl-B"), exec: function(e2, t2) {
          e2.navigateLeft(t2.times);
        }, multiSelectAction: "forEach", scrollIntoView: "cursor", readOnly: true }, { name: "selectwordright", description: "Select word right", bindKey: o("Ctrl-Shift-Right", "Option-Shift-Right"), exec: function(e2) {
          e2.getSelection().selectWordRight();
        }, multiSelectAction: "forEach", scrollIntoView: "cursor", readOnly: true }, { name: "gotowordright", description: "Go to word right", bindKey: o("Ctrl-Right", "Option-Right"), exec: function(e2) {
          e2.navigateWordRight();
        }, multiSelectAction: "forEach", scrollIntoView: "cursor", readOnly: true }, { name: "selecttolineend", description: "Select to line end", bindKey: o("Alt-Shift-Right", "Command-Shift-Right|Shift-End|Ctrl-Shift-E"), exec: function(e2) {
          e2.getSelection().selectLineEnd();
        }, multiSelectAction: "forEach", scrollIntoView: "cursor", readOnly: true }, { name: "gotolineend", description: "Go to line end", bindKey: o("Alt-Right|End", "Command-Right|End|Ctrl-E"), exec: function(e2) {
          e2.navigateLineEnd();
        }, multiSelectAction: "forEach", scrollIntoView: "cursor", readOnly: true }, { name: "selectright", description: "Select right", bindKey: o("Shift-Right", "Shift-Right"), exec: function(e2) {
          e2.getSelection().selectRight();
        }, multiSelectAction: "forEach", scrollIntoView: "cursor", readOnly: true }, { name: "gotoright", description: "Go to right", bindKey: o("Right", "Right|Ctrl-F"), exec: function(e2, t2) {
          e2.navigateRight(t2.times);
        }, multiSelectAction: "forEach", scrollIntoView: "cursor", readOnly: true }, { name: "selectpagedown", description: "Select page down", bindKey: "Shift-PageDown", exec: function(e2) {
          e2.selectPageDown();
        }, readOnly: true }, { name: "pagedown", description: "Page down", bindKey: o(null, "Option-PageDown"), exec: function(e2) {
          e2.scrollPageDown();
        }, readOnly: true }, { name: "gotopagedown", description: "Go to page down", bindKey: o("PageDown", "PageDown|Ctrl-V"), exec: function(e2) {
          e2.gotoPageDown();
        }, readOnly: true }, { name: "selectpageup", description: "Select page up", bindKey: "Shift-PageUp", exec: function(e2) {
          e2.selectPageUp();
        }, readOnly: true }, { name: "pageup", description: "Page up", bindKey: o(null, "Option-PageUp"), exec: function(e2) {
          e2.scrollPageUp();
        }, readOnly: true }, { name: "gotopageup", description: "Go to page up", bindKey: "PageUp", exec: function(e2) {
          e2.gotoPageUp();
        }, readOnly: true }, { name: "scrollup", description: "Scroll up", bindKey: o("Ctrl-Up", null), exec: function(e2) {
          e2.renderer.scrollBy(0, -2 * e2.renderer.layerConfig.lineHeight);
        }, readOnly: true }, { name: "scrolldown", description: "Scroll down", bindKey: o("Ctrl-Down", null), exec: function(e2) {
          e2.renderer.scrollBy(0, 2 * e2.renderer.layerConfig.lineHeight);
        }, readOnly: true }, { name: "selectlinestart", description: "Select line start", bindKey: "Shift-Home", exec: function(e2) {
          e2.getSelection().selectLineStart();
        }, multiSelectAction: "forEach", scrollIntoView: "cursor", readOnly: true }, { name: "selectlineend", description: "Select line end", bindKey: "Shift-End", exec: function(e2) {
          e2.getSelection().selectLineEnd();
        }, multiSelectAction: "forEach", scrollIntoView: "cursor", readOnly: true }, { name: "togglerecording", description: "Toggle recording", bindKey: o("Ctrl-Alt-E", "Command-Option-E"), exec: function(e2) {
          e2.commands.toggleRecording(e2);
        }, readOnly: true }, { name: "replaymacro", description: "Replay macro", bindKey: o("Ctrl-Shift-E", "Command-Shift-E"), exec: function(e2) {
          e2.commands.replay(e2);
        }, readOnly: true }, { name: "jumptomatching", description: "Jump to matching", bindKey: o("Ctrl-\\|Ctrl-P", "Command-\\"), exec: function(e2) {
          e2.jumpToMatching();
        }, multiSelectAction: "forEach", scrollIntoView: "animate", readOnly: true }, { name: "selecttomatching", description: "Select to matching", bindKey: o("Ctrl-Shift-\\|Ctrl-Shift-P", "Command-Shift-\\"), exec: function(e2) {
          e2.jumpToMatching(true);
        }, multiSelectAction: "forEach", scrollIntoView: "animate", readOnly: true }, { name: "expandToMatching", description: "Expand to matching", bindKey: o("Ctrl-Shift-M", "Ctrl-Shift-M"), exec: function(e2) {
          e2.jumpToMatching(true, true);
        }, multiSelectAction: "forEach", scrollIntoView: "animate", readOnly: true }, { name: "passKeysToBrowser", description: "Pass keys to browser", bindKey: o(null, null), exec: function() {
        }, passEvent: true, readOnly: true }, { name: "copy", description: "Copy", exec: function(e2) {
        }, readOnly: true }, { name: "cut", description: "Cut", exec: function(e2) {
          var t2 = e2.$copyWithEmptySelection && e2.selection.isEmpty(), n2 = t2 ? e2.selection.getLineRange() : e2.selection.getRange();
          e2._emit("cut", n2), n2.isEmpty() || e2.session.remove(n2), e2.clearSelection();
        }, scrollIntoView: "cursor", multiSelectAction: "forEach" }, { name: "paste", description: "Paste", exec: function(e2, t2) {
          e2.$handlePaste(t2);
        }, scrollIntoView: "cursor" }, { name: "removeline", description: "Remove line", bindKey: o("Ctrl-D", "Command-D"), exec: function(e2) {
          e2.removeLines();
        }, scrollIntoView: "cursor", multiSelectAction: "forEachLine" }, { name: "duplicateSelection", description: "Duplicate selection", bindKey: o("Ctrl-Shift-D", "Command-Shift-D"), exec: function(e2) {
          e2.duplicateSelection();
        }, scrollIntoView: "cursor", multiSelectAction: "forEach" }, { name: "sortlines", description: "Sort lines", bindKey: o("Ctrl-Alt-S", "Command-Alt-S"), exec: function(e2) {
          e2.sortLines();
        }, scrollIntoView: "selection", multiSelectAction: "forEachLine" }, { name: "togglecomment", description: "Toggle comment", bindKey: o("Ctrl-/", "Command-/"), exec: function(e2) {
          e2.toggleCommentLines();
        }, multiSelectAction: "forEachLine", scrollIntoView: "selectionPart" }, { name: "toggleBlockComment", description: "Toggle block comment", bindKey: o("Ctrl-Shift-/", "Command-Shift-/"), exec: function(e2) {
          e2.toggleBlockComment();
        }, multiSelectAction: "forEach", scrollIntoView: "selectionPart" }, { name: "modifyNumberUp", description: "Modify number up", bindKey: o("Ctrl-Shift-Up", "Alt-Shift-Up"), exec: function(e2) {
          e2.modifyNumber(1);
        }, scrollIntoView: "cursor", multiSelectAction: "forEach" }, { name: "modifyNumberDown", description: "Modify number down", bindKey: o("Ctrl-Shift-Down", "Alt-Shift-Down"), exec: function(e2) {
          e2.modifyNumber(-1);
        }, scrollIntoView: "cursor", multiSelectAction: "forEach" }, { name: "replace", description: "Replace", bindKey: o("Ctrl-H", "Command-Option-F"), exec: function(e2) {
          i.loadModule("ace/ext/searchbox", function(t2) {
            t2.Search(e2, true);
          });
        } }, { name: "undo", description: "Undo", bindKey: o("Ctrl-Z", "Command-Z"), exec: function(e2) {
          e2.undo();
        } }, { name: "redo", description: "Redo", bindKey: o("Ctrl-Shift-Z|Ctrl-Y", "Command-Shift-Z|Command-Y"), exec: function(e2) {
          e2.redo();
        } }, { name: "copylinesup", description: "Copy lines up", bindKey: o("Alt-Shift-Up", "Command-Option-Up"), exec: function(e2) {
          e2.copyLinesUp();
        }, scrollIntoView: "cursor" }, { name: "movelinesup", description: "Move lines up", bindKey: o("Alt-Up", "Option-Up"), exec: function(e2) {
          e2.moveLinesUp();
        }, scrollIntoView: "cursor" }, { name: "copylinesdown", description: "Copy lines down", bindKey: o("Alt-Shift-Down", "Command-Option-Down"), exec: function(e2) {
          e2.copyLinesDown();
        }, scrollIntoView: "cursor" }, { name: "movelinesdown", description: "Move lines down", bindKey: o("Alt-Down", "Option-Down"), exec: function(e2) {
          e2.moveLinesDown();
        }, scrollIntoView: "cursor" }, { name: "del", description: "Delete", bindKey: o("Delete", "Delete|Ctrl-D|Shift-Delete"), exec: function(e2) {
          e2.remove("right");
        }, multiSelectAction: "forEach", scrollIntoView: "cursor" }, { name: "backspace", description: "Backspace", bindKey: o("Shift-Backspace|Backspace", "Ctrl-Backspace|Shift-Backspace|Backspace|Ctrl-H"), exec: function(e2) {
          e2.remove("left");
        }, multiSelectAction: "forEach", scrollIntoView: "cursor" }, { name: "cut_or_delete", description: "Cut or delete", bindKey: o("Shift-Delete", null), exec: function(e2) {
          if (!e2.selection.isEmpty())
            return false;
          e2.remove("left");
        }, multiSelectAction: "forEach", scrollIntoView: "cursor" }, { name: "removetolinestart", description: "Remove to line start", bindKey: o("Alt-Backspace", "Command-Backspace"), exec: function(e2) {
          e2.removeToLineStart();
        }, multiSelectAction: "forEach", scrollIntoView: "cursor" }, { name: "removetolineend", description: "Remove to line end", bindKey: o("Alt-Delete", "Ctrl-K|Command-Delete"), exec: function(e2) {
          e2.removeToLineEnd();
        }, multiSelectAction: "forEach", scrollIntoView: "cursor" }, { name: "removetolinestarthard", description: "Remove to line start hard", bindKey: o("Ctrl-Shift-Backspace", null), exec: function(e2) {
          var t2 = e2.selection.getRange();
          t2.start.column = 0, e2.session.remove(t2);
        }, multiSelectAction: "forEach", scrollIntoView: "cursor" }, { name: "removetolineendhard", description: "Remove to line end hard", bindKey: o("Ctrl-Shift-Delete", null), exec: function(e2) {
          var t2 = e2.selection.getRange();
          t2.end.column = Number.MAX_VALUE, e2.session.remove(t2);
        }, multiSelectAction: "forEach", scrollIntoView: "cursor" }, { name: "removewordleft", description: "Remove word left", bindKey: o("Ctrl-Backspace", "Alt-Backspace|Ctrl-Alt-Backspace"), exec: function(e2) {
          e2.removeWordLeft();
        }, multiSelectAction: "forEach", scrollIntoView: "cursor" }, { name: "removewordright", description: "Remove word right", bindKey: o("Ctrl-Delete", "Alt-Delete"), exec: function(e2) {
          e2.removeWordRight();
        }, multiSelectAction: "forEach", scrollIntoView: "cursor" }, { name: "outdent", description: "Outdent", bindKey: o("Shift-Tab", "Shift-Tab"), exec: function(e2) {
          e2.blockOutdent();
        }, multiSelectAction: "forEach", scrollIntoView: "selectionPart" }, { name: "indent", description: "Indent", bindKey: o("Tab", "Tab"), exec: function(e2) {
          e2.indent();
        }, multiSelectAction: "forEach", scrollIntoView: "selectionPart" }, { name: "blockoutdent", description: "Block outdent", bindKey: o("Ctrl-[", "Ctrl-["), exec: function(e2) {
          e2.blockOutdent();
        }, multiSelectAction: "forEachLine", scrollIntoView: "selectionPart" }, { name: "blockindent", description: "Block indent", bindKey: o("Ctrl-]", "Ctrl-]"), exec: function(e2) {
          e2.blockIndent();
        }, multiSelectAction: "forEachLine", scrollIntoView: "selectionPart" }, { name: "insertstring", description: "Insert string", exec: function(e2, t2) {
          e2.insert(t2);
        }, multiSelectAction: "forEach", scrollIntoView: "cursor" }, { name: "inserttext", description: "Insert text", exec: function(e2, t2) {
          e2.insert(r.stringRepeat(t2.text || "", t2.times || 1));
        }, multiSelectAction: "forEach", scrollIntoView: "cursor" }, { name: "splitline", description: "Split line", bindKey: o(null, "Ctrl-O"), exec: function(e2) {
          e2.splitLine();
        }, multiSelectAction: "forEach", scrollIntoView: "cursor" }, { name: "transposeletters", description: "Transpose letters", bindKey: o("Alt-Shift-X", "Ctrl-T"), exec: function(e2) {
          e2.transposeLetters();
        }, multiSelectAction: function(e2) {
          e2.transposeSelections(1);
        }, scrollIntoView: "cursor" }, { name: "touppercase", description: "To uppercase", bindKey: o("Ctrl-U", "Ctrl-U"), exec: function(e2) {
          e2.toUpperCase();
        }, multiSelectAction: "forEach", scrollIntoView: "cursor" }, { name: "tolowercase", description: "To lowercase", bindKey: o("Ctrl-Shift-U", "Ctrl-Shift-U"), exec: function(e2) {
          e2.toLowerCase();
        }, multiSelectAction: "forEach", scrollIntoView: "cursor" }, { name: "autoindent", description: "Auto Indent", bindKey: o(null, null), exec: function(e2) {
          e2.autoIndent();
        }, multiSelectAction: "forEachLine", scrollIntoView: "animate" }, { name: "expandtoline", description: "Expand to line", bindKey: o("Ctrl-Shift-L", "Command-Shift-L"), exec: function(e2) {
          var t2 = e2.selection.getRange();
          t2.start.column = t2.end.column = 0, t2.end.row++, e2.selection.setRange(t2, false);
        }, multiSelectAction: "forEach", scrollIntoView: "cursor", readOnly: true }, { name: "joinlines", description: "Join lines", bindKey: o(null, null), exec: function(e2) {
          var t2 = e2.selection.isBackwards(), n2 = t2 ? e2.selection.getSelectionLead() : e2.selection.getSelectionAnchor(), i2 = t2 ? e2.selection.getSelectionAnchor() : e2.selection.getSelectionLead(), o2 = e2.session.doc.getLine(n2.row).length, u2 = e2.session.doc.getTextRange(e2.selection.getRange()), a = u2.replace(/\n\s*/, " ").length, f = e2.session.doc.getLine(n2.row);
          for (var l = n2.row + 1; l <= i2.row + 1; l++) {
            var c = r.stringTrimLeft(r.stringTrimRight(e2.session.doc.getLine(l)));
            c.length !== 0 && (c = " " + c), f += c;
          }
          i2.row + 1 < e2.session.doc.getLength() - 1 && (f += e2.session.doc.getNewLineCharacter()), e2.clearSelection(), e2.session.doc.replace(new s(n2.row, 0, i2.row + 2, 0), f), a > 0 ? (e2.selection.moveCursorTo(n2.row, n2.column), e2.selection.selectTo(n2.row, n2.column + a)) : (o2 = e2.session.doc.getLine(n2.row).length > o2 ? o2 + 1 : o2, e2.selection.moveCursorTo(n2.row, o2));
        }, multiSelectAction: "forEach", readOnly: true }, { name: "invertSelection", description: "Invert selection", bindKey: o(null, null), exec: function(e2) {
          var t2 = e2.session.doc.getLength() - 1, n2 = e2.session.doc.getLine(t2).length, r2 = e2.selection.rangeList.ranges, i2 = [];
          r2.length < 1 && (r2 = [e2.selection.getRange()]);
          for (var o2 = 0; o2 < r2.length; o2++)
            o2 == r2.length - 1 && (r2[o2].end.row !== t2 || r2[o2].end.column !== n2) && i2.push(new s(r2[o2].end.row, r2[o2].end.column, t2, n2)), o2 === 0 ? (r2[o2].start.row !== 0 || r2[o2].start.column !== 0) && i2.push(new s(0, 0, r2[o2].start.row, r2[o2].start.column)) : i2.push(new s(r2[o2 - 1].end.row, r2[o2 - 1].end.column, r2[o2].start.row, r2[o2].start.column));
          e2.exitMultiSelectMode(), e2.clearSelection();
          for (var o2 = 0; o2 < i2.length; o2++)
            e2.selection.addRange(i2[o2], false);
        }, readOnly: true, scrollIntoView: "none" }, { name: "addLineAfter", description: "Add new line after the current line", exec: function(e2) {
          e2.selection.clearSelection(), e2.navigateLineEnd(), e2.insert("\n");
        }, multiSelectAction: "forEach", scrollIntoView: "cursor" }, { name: "addLineBefore", description: "Add new line before the current line", exec: function(e2) {
          e2.selection.clearSelection();
          var t2 = e2.getCursorPosition();
          e2.selection.moveTo(t2.row - 1, Number.MAX_VALUE), e2.insert("\n"), t2.row === 0 && e2.navigateUp();
        }, multiSelectAction: "forEach", scrollIntoView: "cursor" }, { name: "openCommandPallete", description: "Open command pallete", bindKey: o("F1", "F1"), exec: function(e2) {
          e2.prompt({ $type: "commands" });
        }, readOnly: true }, { name: "modeSelect", description: "Change language mode...", bindKey: o(null, null), exec: function(e2) {
          e2.prompt({ $type: "modes" });
        }, readOnly: true }];
        for (var u = 1; u < 9; u++)
          t.commands.push({ name: "foldToLevel" + u, description: "Fold To Level " + u, level: u, exec: function(e2) {
            e2.session.foldToLevel(this.level);
          }, scrollIntoView: "center", readOnly: true });
      }), ace.define("ace/editor", ["require", "exports", "module", "ace/lib/fixoldbrowsers", "ace/lib/oop", "ace/lib/dom", "ace/lib/lang", "ace/lib/useragent", "ace/keyboard/textinput", "ace/mouse/mouse_handler", "ace/mouse/fold_handler", "ace/keyboard/keybinding", "ace/edit_session", "ace/search", "ace/range", "ace/lib/event_emitter", "ace/commands/command_manager", "ace/commands/default_commands", "ace/config", "ace/token_iterator", "ace/clipboard"], function(e, t, n) {
        "use strict";
        e("./lib/fixoldbrowsers");
        var r = e("./lib/oop"), i = e("./lib/dom"), s = e("./lib/lang"), o = e("./lib/useragent"), u = e("./keyboard/textinput").TextInput, a = e("./mouse/mouse_handler").MouseHandler, f = e("./mouse/fold_handler").FoldHandler, l = e("./keyboard/keybinding").KeyBinding, c = e("./edit_session").EditSession, h = e("./search").Search, p = e("./range").Range, d = e("./lib/event_emitter").EventEmitter, v = e("./commands/command_manager").CommandManager, m = e("./commands/default_commands").commands, g = e("./config"), y = e("./token_iterator").TokenIterator, b = e("./clipboard"), w = function(e2, t2, n2) {
          this.$toDestroy = [];
          var r2 = e2.getContainerElement();
          this.container = r2, this.renderer = e2, this.id = "editor" + ++w.$uid, this.commands = new v(o.isMac ? "mac" : "win", m), typeof document == "object" && (this.textInput = new u(e2.getTextAreaContainer(), this), this.renderer.textarea = this.textInput.getElement(), this.$mouseHandler = new a(this), new f(this)), this.keyBinding = new l(this), this.$search = new h().set({ wrap: true }), this.$historyTracker = this.$historyTracker.bind(this), this.commands.on("exec", this.$historyTracker), this.$initOperationListeners(), this._$emitInputEvent = s.delayedCall(function() {
            this._signal("input", {}), this.session && !this.session.destroyed && this.session.bgTokenizer.scheduleStart();
          }.bind(this)), this.on("change", function(e3, t3) {
            t3._$emitInputEvent.schedule(31);
          }), this.setSession(t2 || n2 && n2.session || new c("")), g.resetOptions(this), n2 && this.setOptions(n2), g._signal("editor", this);
        };
        w.$uid = 0, function() {
          r.implement(this, d), this.$initOperationListeners = function() {
            this.commands.on("exec", this.startOperation.bind(this), true), this.commands.on("afterExec", this.endOperation.bind(this), true), this.$opResetTimer = s.delayedCall(this.endOperation.bind(this, true)), this.on("change", function() {
              this.curOp || (this.startOperation(), this.curOp.selectionBefore = this.$lastSel), this.curOp.docChanged = true;
            }.bind(this), true), this.on("changeSelection", function() {
              this.curOp || (this.startOperation(), this.curOp.selectionBefore = this.$lastSel), this.curOp.selectionChanged = true;
            }.bind(this), true);
          }, this.curOp = null, this.prevOp = {}, this.startOperation = function(e2) {
            if (this.curOp) {
              if (!e2 || this.curOp.command)
                return;
              this.prevOp = this.curOp;
            }
            e2 || (this.previousCommand = null, e2 = {}), this.$opResetTimer.schedule(), this.curOp = this.session.curOp = { command: e2.command || {}, args: e2.args, scrollTop: this.renderer.scrollTop }, this.curOp.selectionBefore = this.selection.toJSON();
          }, this.endOperation = function(e2) {
            if (this.curOp && this.session) {
              if (e2 && e2.returnValue === false || !this.session)
                return this.curOp = null;
              if (e2 == 1 && this.curOp.command && this.curOp.command.name == "mouse")
                return;
              this._signal("beforeEndOperation");
              if (!this.curOp)
                return;
              var t2 = this.curOp.command, n2 = t2 && t2.scrollIntoView;
              if (n2) {
                switch (n2) {
                  case "center-animate":
                    n2 = "animate";
                  case "center":
                    this.renderer.scrollCursorIntoView(null, 0.5);
                    break;
                  case "animate":
                  case "cursor":
                    this.renderer.scrollCursorIntoView();
                    break;
                  case "selectionPart":
                    var r2 = this.selection.getRange(), i2 = this.renderer.layerConfig;
                    (r2.start.row >= i2.lastRow || r2.end.row <= i2.firstRow) && this.renderer.scrollSelectionIntoView(this.selection.anchor, this.selection.lead);
                    break;
                  default:
                }
                n2 == "animate" && this.renderer.animateScrolling(this.curOp.scrollTop);
              }
              var s2 = this.selection.toJSON();
              this.curOp.selectionAfter = s2, this.$lastSel = this.selection.toJSON(), this.session.getUndoManager().addSelection(s2), this.prevOp = this.curOp, this.curOp = null;
            }
          }, this.$mergeableCommands = ["backspace", "del", "insertstring"], this.$historyTracker = function(e2) {
            if (!this.$mergeUndoDeltas)
              return;
            var t2 = this.prevOp, n2 = this.$mergeableCommands, r2 = t2.command && e2.command.name == t2.command.name;
            if (e2.command.name == "insertstring") {
              var i2 = e2.args;
              this.mergeNextCommand === void 0 && (this.mergeNextCommand = true), r2 = r2 && this.mergeNextCommand && (!/\s/.test(i2) || /\s/.test(t2.args)), this.mergeNextCommand = true;
            } else
              r2 = r2 && n2.indexOf(e2.command.name) !== -1;
            this.$mergeUndoDeltas != "always" && Date.now() - this.sequenceStartTime > 2e3 && (r2 = false), r2 ? this.session.mergeUndoDeltas = true : n2.indexOf(e2.command.name) !== -1 && (this.sequenceStartTime = Date.now());
          }, this.setKeyboardHandler = function(e2, t2) {
            if (e2 && typeof e2 == "string" && e2 != "ace") {
              this.$keybindingId = e2;
              var n2 = this;
              g.loadModule(["keybinding", e2], function(r2) {
                n2.$keybindingId == e2 && n2.keyBinding.setKeyboardHandler(r2 && r2.handler), t2 && t2();
              });
            } else
              this.$keybindingId = null, this.keyBinding.setKeyboardHandler(e2), t2 && t2();
          }, this.getKeyboardHandler = function() {
            return this.keyBinding.getKeyboardHandler();
          }, this.setSession = function(e2) {
            if (this.session == e2)
              return;
            this.curOp && this.endOperation(), this.curOp = {};
            var t2 = this.session;
            if (t2) {
              this.session.off("change", this.$onDocumentChange), this.session.off("changeMode", this.$onChangeMode), this.session.off("tokenizerUpdate", this.$onTokenizerUpdate), this.session.off("changeTabSize", this.$onChangeTabSize), this.session.off("changeWrapLimit", this.$onChangeWrapLimit), this.session.off("changeWrapMode", this.$onChangeWrapMode), this.session.off("changeFold", this.$onChangeFold), this.session.off("changeFrontMarker", this.$onChangeFrontMarker), this.session.off("changeBackMarker", this.$onChangeBackMarker), this.session.off("changeBreakpoint", this.$onChangeBreakpoint), this.session.off("changeAnnotation", this.$onChangeAnnotation), this.session.off("changeOverwrite", this.$onCursorChange), this.session.off("changeScrollTop", this.$onScrollTopChange), this.session.off("changeScrollLeft", this.$onScrollLeftChange);
              var n2 = this.session.getSelection();
              n2.off("changeCursor", this.$onCursorChange), n2.off("changeSelection", this.$onSelectionChange);
            }
            this.session = e2, e2 ? (this.$onDocumentChange = this.onDocumentChange.bind(this), e2.on("change", this.$onDocumentChange), this.renderer.setSession(e2), this.$onChangeMode = this.onChangeMode.bind(this), e2.on("changeMode", this.$onChangeMode), this.$onTokenizerUpdate = this.onTokenizerUpdate.bind(this), e2.on("tokenizerUpdate", this.$onTokenizerUpdate), this.$onChangeTabSize = this.renderer.onChangeTabSize.bind(this.renderer), e2.on("changeTabSize", this.$onChangeTabSize), this.$onChangeWrapLimit = this.onChangeWrapLimit.bind(this), e2.on("changeWrapLimit", this.$onChangeWrapLimit), this.$onChangeWrapMode = this.onChangeWrapMode.bind(this), e2.on("changeWrapMode", this.$onChangeWrapMode), this.$onChangeFold = this.onChangeFold.bind(this), e2.on("changeFold", this.$onChangeFold), this.$onChangeFrontMarker = this.onChangeFrontMarker.bind(this), this.session.on("changeFrontMarker", this.$onChangeFrontMarker), this.$onChangeBackMarker = this.onChangeBackMarker.bind(this), this.session.on("changeBackMarker", this.$onChangeBackMarker), this.$onChangeBreakpoint = this.onChangeBreakpoint.bind(this), this.session.on("changeBreakpoint", this.$onChangeBreakpoint), this.$onChangeAnnotation = this.onChangeAnnotation.bind(this), this.session.on("changeAnnotation", this.$onChangeAnnotation), this.$onCursorChange = this.onCursorChange.bind(this), this.session.on("changeOverwrite", this.$onCursorChange), this.$onScrollTopChange = this.onScrollTopChange.bind(this), this.session.on("changeScrollTop", this.$onScrollTopChange), this.$onScrollLeftChange = this.onScrollLeftChange.bind(this), this.session.on("changeScrollLeft", this.$onScrollLeftChange), this.selection = e2.getSelection(), this.selection.on("changeCursor", this.$onCursorChange), this.$onSelectionChange = this.onSelectionChange.bind(this), this.selection.on("changeSelection", this.$onSelectionChange), this.onChangeMode(), this.onCursorChange(), this.onScrollTopChange(), this.onScrollLeftChange(), this.onSelectionChange(), this.onChangeFrontMarker(), this.onChangeBackMarker(), this.onChangeBreakpoint(), this.onChangeAnnotation(), this.session.getUseWrapMode() && this.renderer.adjustWrapLimit(), this.renderer.updateFull()) : (this.selection = null, this.renderer.setSession(e2)), this._signal("changeSession", { session: e2, oldSession: t2 }), this.curOp = null, t2 && t2._signal("changeEditor", { oldEditor: this }), e2 && e2._signal("changeEditor", { editor: this }), e2 && !e2.destroyed && e2.bgTokenizer.scheduleStart();
          }, this.getSession = function() {
            return this.session;
          }, this.setValue = function(e2, t2) {
            return this.session.doc.setValue(e2), t2 ? t2 == 1 ? this.navigateFileEnd() : t2 == -1 && this.navigateFileStart() : this.selectAll(), e2;
          }, this.getValue = function() {
            return this.session.getValue();
          }, this.getSelection = function() {
            return this.selection;
          }, this.resize = function(e2) {
            this.renderer.onResize(e2);
          }, this.setTheme = function(e2, t2) {
            this.renderer.setTheme(e2, t2);
          }, this.getTheme = function() {
            return this.renderer.getTheme();
          }, this.setStyle = function(e2) {
            this.renderer.setStyle(e2);
          }, this.unsetStyle = function(e2) {
            this.renderer.unsetStyle(e2);
          }, this.getFontSize = function() {
            return this.getOption("fontSize") || i.computedStyle(this.container).fontSize;
          }, this.setFontSize = function(e2) {
            this.setOption("fontSize", e2);
          }, this.$highlightBrackets = function() {
            if (this.$highlightPending)
              return;
            var e2 = this;
            this.$highlightPending = true, setTimeout(function() {
              e2.$highlightPending = false;
              var t2 = e2.session;
              if (!t2 || t2.destroyed)
                return;
              t2.$bracketHighlight && (t2.$bracketHighlight.markerIds.forEach(function(e3) {
                t2.removeMarker(e3);
              }), t2.$bracketHighlight = null);
              var n2 = t2.getMatchingBracketRanges(e2.getCursorPosition());
              !n2 && t2.$mode.getMatching && (n2 = t2.$mode.getMatching(e2.session));
              if (!n2)
                return;
              var r2 = "ace_bracket";
              Array.isArray(n2) ? n2.length == 1 && (r2 = "ace_error_bracket") : n2 = [n2], n2.length == 2 && (p.comparePoints(n2[0].end, n2[1].start) == 0 ? n2 = [p.fromPoints(n2[0].start, n2[1].end)] : p.comparePoints(n2[0].start, n2[1].end) == 0 && (n2 = [p.fromPoints(n2[1].start, n2[0].end)])), t2.$bracketHighlight = { ranges: n2, markerIds: n2.map(function(e3) {
                return t2.addMarker(e3, r2, "text");
              }) };
            }, 50);
          }, this.$highlightTags = function() {
            if (this.$highlightTagPending)
              return;
            var e2 = this;
            this.$highlightTagPending = true, setTimeout(function() {
              e2.$highlightTagPending = false;
              var t2 = e2.session;
              if (!t2 || t2.destroyed)
                return;
              var n2 = e2.getCursorPosition(), r2 = new y(e2.session, n2.row, n2.column), i2 = r2.getCurrentToken();
              if (!i2 || !/\b(?:tag-open|tag-name)/.test(i2.type)) {
                t2.removeMarker(t2.$tagHighlight), t2.$tagHighlight = null;
                return;
              }
              if (i2.type.indexOf("tag-open") !== -1) {
                i2 = r2.stepForward();
                if (!i2)
                  return;
              }
              var s2 = i2.value, o2 = i2.value, u2 = 0, a2 = r2.stepBackward();
              if (a2.value === "<") {
                do
                  a2 = i2, i2 = r2.stepForward(), i2 && (i2.type.indexOf("tag-name") !== -1 ? (o2 = i2.value, s2 === o2 && (a2.value === "<" ? u2++ : a2.value === "</" && u2--)) : s2 === o2 && i2.value === "/>" && u2--);
                while (i2 && u2 >= 0);
              } else {
                do {
                  i2 = a2, a2 = r2.stepBackward();
                  if (i2) {
                    if (i2.type.indexOf("tag-name") !== -1)
                      s2 === i2.value && (a2.value === "<" ? u2++ : a2.value === "</" && u2--);
                    else if (i2.value === "/>") {
                      var f2 = 0, l2 = a2;
                      while (l2) {
                        if (l2.type.indexOf("tag-name") !== -1 && l2.value === s2) {
                          u2--;
                          break;
                        }
                        if (l2.value === "<")
                          break;
                        l2 = r2.stepBackward(), f2++;
                      }
                      for (var c2 = 0; c2 < f2; c2++)
                        r2.stepForward();
                    }
                  }
                } while (a2 && u2 <= 0);
                r2.stepForward();
              }
              if (!i2) {
                t2.removeMarker(t2.$tagHighlight), t2.$tagHighlight = null;
                return;
              }
              var h2 = r2.getCurrentTokenRow(), d2 = r2.getCurrentTokenColumn(), v2 = new p(h2, d2, h2, d2 + i2.value.length), m2 = t2.$backMarkers[t2.$tagHighlight];
              t2.$tagHighlight && m2 != void 0 && v2.compareRange(m2.range) !== 0 && (t2.removeMarker(t2.$tagHighlight), t2.$tagHighlight = null), t2.$tagHighlight || (t2.$tagHighlight = t2.addMarker(v2, "ace_bracket", "text"));
            }, 50);
          }, this.focus = function() {
            this.textInput.focus();
          }, this.isFocused = function() {
            return this.textInput.isFocused();
          }, this.blur = function() {
            this.textInput.blur();
          }, this.onFocus = function(e2) {
            if (this.$isFocused)
              return;
            this.$isFocused = true, this.renderer.showCursor(), this.renderer.visualizeFocus(), this._emit("focus", e2);
          }, this.onBlur = function(e2) {
            if (!this.$isFocused)
              return;
            this.$isFocused = false, this.renderer.hideCursor(), this.renderer.visualizeBlur(), this._emit("blur", e2);
          }, this.$cursorChange = function() {
            this.renderer.updateCursor(), this.$highlightBrackets(), this.$highlightTags(), this.$updateHighlightActiveLine();
          }, this.onDocumentChange = function(e2) {
            var t2 = this.session.$useWrapMode, n2 = e2.start.row == e2.end.row ? e2.end.row : Infinity;
            this.renderer.updateLines(e2.start.row, n2, t2), this._signal("change", e2), this.$cursorChange();
          }, this.onTokenizerUpdate = function(e2) {
            var t2 = e2.data;
            this.renderer.updateLines(t2.first, t2.last);
          }, this.onScrollTopChange = function() {
            this.renderer.scrollToY(this.session.getScrollTop());
          }, this.onScrollLeftChange = function() {
            this.renderer.scrollToX(this.session.getScrollLeft());
          }, this.onCursorChange = function() {
            this.$cursorChange(), this._signal("changeSelection");
          }, this.$updateHighlightActiveLine = function() {
            var e2 = this.getSession(), t2;
            if (this.$highlightActiveLine) {
              if (this.$selectionStyle != "line" || !this.selection.isMultiLine())
                t2 = this.getCursorPosition();
              this.renderer.theme && this.renderer.theme.$selectionColorConflict && !this.selection.isEmpty() && (t2 = false), this.renderer.$maxLines && this.session.getLength() === 1 && !(this.renderer.$minLines > 1) && (t2 = false);
            }
            if (e2.$highlightLineMarker && !t2)
              e2.removeMarker(e2.$highlightLineMarker.id), e2.$highlightLineMarker = null;
            else if (!e2.$highlightLineMarker && t2) {
              var n2 = new p(t2.row, t2.column, t2.row, Infinity);
              n2.id = e2.addMarker(n2, "ace_active-line", "screenLine"), e2.$highlightLineMarker = n2;
            } else
              t2 && (e2.$highlightLineMarker.start.row = t2.row, e2.$highlightLineMarker.end.row = t2.row, e2.$highlightLineMarker.start.column = t2.column, e2._signal("changeBackMarker"));
          }, this.onSelectionChange = function(e2) {
            var t2 = this.session;
            t2.$selectionMarker && t2.removeMarker(t2.$selectionMarker), t2.$selectionMarker = null;
            if (!this.selection.isEmpty()) {
              var n2 = this.selection.getRange(), r2 = this.getSelectionStyle();
              t2.$selectionMarker = t2.addMarker(n2, "ace_selection", r2);
            } else
              this.$updateHighlightActiveLine();
            var i2 = this.$highlightSelectedWord && this.$getSelectionHighLightRegexp();
            this.session.highlight(i2), this._signal("changeSelection");
          }, this.$getSelectionHighLightRegexp = function() {
            var e2 = this.session, t2 = this.getSelectionRange();
            if (t2.isEmpty() || t2.isMultiLine())
              return;
            var n2 = t2.start.column, r2 = t2.end.column, i2 = e2.getLine(t2.start.row), s2 = i2.substring(n2, r2);
            if (s2.length > 5e3 || !/[\w\d]/.test(s2))
              return;
            var o2 = this.$search.$assembleRegExp({ wholeWord: true, caseSensitive: true, needle: s2 }), u2 = i2.substring(n2 - 1, r2 + 1);
            if (!o2.test(u2))
              return;
            return o2;
          }, this.onChangeFrontMarker = function() {
            this.renderer.updateFrontMarkers();
          }, this.onChangeBackMarker = function() {
            this.renderer.updateBackMarkers();
          }, this.onChangeBreakpoint = function() {
            this.renderer.updateBreakpoints();
          }, this.onChangeAnnotation = function() {
            this.renderer.setAnnotations(this.session.getAnnotations());
          }, this.onChangeMode = function(e2) {
            this.renderer.updateText(), this._emit("changeMode", e2);
          }, this.onChangeWrapLimit = function() {
            this.renderer.updateFull();
          }, this.onChangeWrapMode = function() {
            this.renderer.onResize(true);
          }, this.onChangeFold = function() {
            this.$updateHighlightActiveLine(), this.renderer.updateFull();
          }, this.getSelectedText = function() {
            return this.session.getTextRange(this.getSelectionRange());
          }, this.getCopyText = function() {
            var e2 = this.getSelectedText(), t2 = this.session.doc.getNewLineCharacter(), n2 = false;
            if (!e2 && this.$copyWithEmptySelection) {
              n2 = true;
              var r2 = this.selection.getAllRanges();
              for (var i2 = 0; i2 < r2.length; i2++) {
                var s2 = r2[i2];
                if (i2 && r2[i2 - 1].start.row == s2.start.row)
                  continue;
                e2 += this.session.getLine(s2.start.row) + t2;
              }
            }
            var o2 = { text: e2 };
            return this._signal("copy", o2), b.lineMode = n2 ? o2.text : false, o2.text;
          }, this.onCopy = function() {
            this.commands.exec("copy", this);
          }, this.onCut = function() {
            this.commands.exec("cut", this);
          }, this.onPaste = function(e2, t2) {
            var n2 = { text: e2, event: t2 };
            this.commands.exec("paste", this, n2);
          }, this.$handlePaste = function(e2) {
            typeof e2 == "string" && (e2 = { text: e2 }), this._signal("paste", e2);
            var t2 = e2.text, n2 = t2 === b.lineMode, r2 = this.session;
            if (!this.inMultiSelectMode || this.inVirtualSelectionMode)
              n2 ? r2.insert({ row: this.selection.lead.row, column: 0 }, t2) : this.insert(t2);
            else if (n2)
              this.selection.rangeList.ranges.forEach(function(e3) {
                r2.insert({ row: e3.start.row, column: 0 }, t2);
              });
            else {
              var i2 = t2.split(/\r\n|\r|\n/), s2 = this.selection.rangeList.ranges, o2 = i2.length == 2 && (!i2[0] || !i2[1]);
              if (i2.length != s2.length || o2)
                return this.commands.exec("insertstring", this, t2);
              for (var u2 = s2.length; u2--; ) {
                var a2 = s2[u2];
                a2.isEmpty() || r2.remove(a2), r2.insert(a2.start, i2[u2]);
              }
            }
          }, this.execCommand = function(e2, t2) {
            return this.commands.exec(e2, this, t2);
          }, this.insert = function(e2, t2) {
            var n2 = this.session, r2 = n2.getMode(), i2 = this.getCursorPosition();
            if (this.getBehavioursEnabled() && !t2) {
              var s2 = r2.transformAction(n2.getState(i2.row), "insertion", this, n2, e2);
              s2 && (e2 !== s2.text && (this.inVirtualSelectionMode || (this.session.mergeUndoDeltas = false, this.mergeNextCommand = false)), e2 = s2.text);
            }
            e2 == "	" && (e2 = this.session.getTabString());
            if (!this.selection.isEmpty()) {
              var o2 = this.getSelectionRange();
              i2 = this.session.remove(o2), this.clearSelection();
            } else if (this.session.getOverwrite() && e2.indexOf("\n") == -1) {
              var o2 = new p.fromPoints(i2, i2);
              o2.end.column += e2.length, this.session.remove(o2);
            }
            if (e2 == "\n" || e2 == "\r\n") {
              var u2 = n2.getLine(i2.row);
              if (i2.column > u2.search(/\S|$/)) {
                var a2 = u2.substr(i2.column).search(/\S|$/);
                n2.doc.removeInLine(i2.row, i2.column, i2.column + a2);
              }
            }
            this.clearSelection();
            var f2 = i2.column, l2 = n2.getState(i2.row), u2 = n2.getLine(i2.row), c2 = r2.checkOutdent(l2, u2, e2);
            n2.insert(i2, e2), s2 && s2.selection && (s2.selection.length == 2 ? this.selection.setSelectionRange(new p(i2.row, f2 + s2.selection[0], i2.row, f2 + s2.selection[1])) : this.selection.setSelectionRange(new p(i2.row + s2.selection[0], s2.selection[1], i2.row + s2.selection[2], s2.selection[3])));
            if (this.$enableAutoIndent) {
              if (n2.getDocument().isNewLine(e2)) {
                var h2 = r2.getNextLineIndent(l2, u2.slice(0, i2.column), n2.getTabString());
                n2.insert({ row: i2.row + 1, column: 0 }, h2);
              }
              c2 && r2.autoOutdent(l2, n2, i2.row);
            }
          }, this.autoIndent = function() {
            var e2 = this.session, t2 = e2.getMode(), n2, r2;
            if (this.selection.isEmpty())
              n2 = 0, r2 = e2.doc.getLength() - 1;
            else {
              var i2 = this.getSelectionRange();
              n2 = i2.start.row, r2 = i2.end.row;
            }
            var s2 = "", o2 = "", u2 = "", a2, f2, l2, c2 = e2.getTabString();
            for (var h2 = n2; h2 <= r2; h2++)
              h2 > 0 && (s2 = e2.getState(h2 - 1), o2 = e2.getLine(h2 - 1), u2 = t2.getNextLineIndent(s2, o2, c2)), a2 = e2.getLine(h2), f2 = t2.$getIndent(a2), u2 !== f2 && (f2.length > 0 && (l2 = new p(h2, 0, h2, f2.length), e2.remove(l2)), u2.length > 0 && e2.insert({ row: h2, column: 0 }, u2)), t2.autoOutdent(s2, e2, h2);
          }, this.onTextInput = function(e2, t2) {
            if (!t2)
              return this.keyBinding.onTextInput(e2);
            this.startOperation({ command: { name: "insertstring" } });
            var n2 = this.applyComposition.bind(this, e2, t2);
            this.selection.rangeCount ? this.forEachSelection(n2) : n2(), this.endOperation();
          }, this.applyComposition = function(e2, t2) {
            if (t2.extendLeft || t2.extendRight) {
              var n2 = this.selection.getRange();
              n2.start.column -= t2.extendLeft, n2.end.column += t2.extendRight, n2.start.column < 0 && (n2.start.row--, n2.start.column += this.session.getLine(n2.start.row).length + 1), this.selection.setRange(n2), !e2 && !n2.isEmpty() && this.remove();
            }
            (e2 || !this.selection.isEmpty()) && this.insert(e2, true);
            if (t2.restoreStart || t2.restoreEnd) {
              var n2 = this.selection.getRange();
              n2.start.column -= t2.restoreStart, n2.end.column -= t2.restoreEnd, this.selection.setRange(n2);
            }
          }, this.onCommandKey = function(e2, t2, n2) {
            return this.keyBinding.onCommandKey(e2, t2, n2);
          }, this.setOverwrite = function(e2) {
            this.session.setOverwrite(e2);
          }, this.getOverwrite = function() {
            return this.session.getOverwrite();
          }, this.toggleOverwrite = function() {
            this.session.toggleOverwrite();
          }, this.setScrollSpeed = function(e2) {
            this.setOption("scrollSpeed", e2);
          }, this.getScrollSpeed = function() {
            return this.getOption("scrollSpeed");
          }, this.setDragDelay = function(e2) {
            this.setOption("dragDelay", e2);
          }, this.getDragDelay = function() {
            return this.getOption("dragDelay");
          }, this.setSelectionStyle = function(e2) {
            this.setOption("selectionStyle", e2);
          }, this.getSelectionStyle = function() {
            return this.getOption("selectionStyle");
          }, this.setHighlightActiveLine = function(e2) {
            this.setOption("highlightActiveLine", e2);
          }, this.getHighlightActiveLine = function() {
            return this.getOption("highlightActiveLine");
          }, this.setHighlightGutterLine = function(e2) {
            this.setOption("highlightGutterLine", e2);
          }, this.getHighlightGutterLine = function() {
            return this.getOption("highlightGutterLine");
          }, this.setHighlightSelectedWord = function(e2) {
            this.setOption("highlightSelectedWord", e2);
          }, this.getHighlightSelectedWord = function() {
            return this.$highlightSelectedWord;
          }, this.setAnimatedScroll = function(e2) {
            this.renderer.setAnimatedScroll(e2);
          }, this.getAnimatedScroll = function() {
            return this.renderer.getAnimatedScroll();
          }, this.setShowInvisibles = function(e2) {
            this.renderer.setShowInvisibles(e2);
          }, this.getShowInvisibles = function() {
            return this.renderer.getShowInvisibles();
          }, this.setDisplayIndentGuides = function(e2) {
            this.renderer.setDisplayIndentGuides(e2);
          }, this.getDisplayIndentGuides = function() {
            return this.renderer.getDisplayIndentGuides();
          }, this.setShowPrintMargin = function(e2) {
            this.renderer.setShowPrintMargin(e2);
          }, this.getShowPrintMargin = function() {
            return this.renderer.getShowPrintMargin();
          }, this.setPrintMarginColumn = function(e2) {
            this.renderer.setPrintMarginColumn(e2);
          }, this.getPrintMarginColumn = function() {
            return this.renderer.getPrintMarginColumn();
          }, this.setReadOnly = function(e2) {
            this.setOption("readOnly", e2);
          }, this.getReadOnly = function() {
            return this.getOption("readOnly");
          }, this.setBehavioursEnabled = function(e2) {
            this.setOption("behavioursEnabled", e2);
          }, this.getBehavioursEnabled = function() {
            return this.getOption("behavioursEnabled");
          }, this.setWrapBehavioursEnabled = function(e2) {
            this.setOption("wrapBehavioursEnabled", e2);
          }, this.getWrapBehavioursEnabled = function() {
            return this.getOption("wrapBehavioursEnabled");
          }, this.setShowFoldWidgets = function(e2) {
            this.setOption("showFoldWidgets", e2);
          }, this.getShowFoldWidgets = function() {
            return this.getOption("showFoldWidgets");
          }, this.setFadeFoldWidgets = function(e2) {
            this.setOption("fadeFoldWidgets", e2);
          }, this.getFadeFoldWidgets = function() {
            return this.getOption("fadeFoldWidgets");
          }, this.remove = function(e2) {
            this.selection.isEmpty() && (e2 == "left" ? this.selection.selectLeft() : this.selection.selectRight());
            var t2 = this.getSelectionRange();
            if (this.getBehavioursEnabled()) {
              var n2 = this.session, r2 = n2.getState(t2.start.row), i2 = n2.getMode().transformAction(r2, "deletion", this, n2, t2);
              if (t2.end.column === 0) {
                var s2 = n2.getTextRange(t2);
                if (s2[s2.length - 1] == "\n") {
                  var o2 = n2.getLine(t2.end.row);
                  /^\s+$/.test(o2) && (t2.end.column = o2.length);
                }
              }
              i2 && (t2 = i2);
            }
            this.session.remove(t2), this.clearSelection();
          }, this.removeWordRight = function() {
            this.selection.isEmpty() && this.selection.selectWordRight(), this.session.remove(this.getSelectionRange()), this.clearSelection();
          }, this.removeWordLeft = function() {
            this.selection.isEmpty() && this.selection.selectWordLeft(), this.session.remove(this.getSelectionRange()), this.clearSelection();
          }, this.removeToLineStart = function() {
            this.selection.isEmpty() && this.selection.selectLineStart(), this.selection.isEmpty() && this.selection.selectLeft(), this.session.remove(this.getSelectionRange()), this.clearSelection();
          }, this.removeToLineEnd = function() {
            this.selection.isEmpty() && this.selection.selectLineEnd();
            var e2 = this.getSelectionRange();
            e2.start.column == e2.end.column && e2.start.row == e2.end.row && (e2.end.column = 0, e2.end.row++), this.session.remove(e2), this.clearSelection();
          }, this.splitLine = function() {
            this.selection.isEmpty() || (this.session.remove(this.getSelectionRange()), this.clearSelection());
            var e2 = this.getCursorPosition();
            this.insert("\n"), this.moveCursorToPosition(e2);
          }, this.transposeLetters = function() {
            if (!this.selection.isEmpty())
              return;
            var e2 = this.getCursorPosition(), t2 = e2.column;
            if (t2 === 0)
              return;
            var n2 = this.session.getLine(e2.row), r2, i2;
            t2 < n2.length ? (r2 = n2.charAt(t2) + n2.charAt(t2 - 1), i2 = new p(e2.row, t2 - 1, e2.row, t2 + 1)) : (r2 = n2.charAt(t2 - 1) + n2.charAt(t2 - 2), i2 = new p(e2.row, t2 - 2, e2.row, t2)), this.session.replace(i2, r2), this.session.selection.moveToPosition(i2.end);
          }, this.toLowerCase = function() {
            var e2 = this.getSelectionRange();
            this.selection.isEmpty() && this.selection.selectWord();
            var t2 = this.getSelectionRange(), n2 = this.session.getTextRange(t2);
            this.session.replace(t2, n2.toLowerCase()), this.selection.setSelectionRange(e2);
          }, this.toUpperCase = function() {
            var e2 = this.getSelectionRange();
            this.selection.isEmpty() && this.selection.selectWord();
            var t2 = this.getSelectionRange(), n2 = this.session.getTextRange(t2);
            this.session.replace(t2, n2.toUpperCase()), this.selection.setSelectionRange(e2);
          }, this.indent = function() {
            var e2 = this.session, t2 = this.getSelectionRange();
            if (t2.start.row < t2.end.row) {
              var n2 = this.$getSelectedRows();
              e2.indentRows(n2.first, n2.last, "	");
              return;
            }
            if (t2.start.column < t2.end.column) {
              var r2 = e2.getTextRange(t2);
              if (!/^\s+$/.test(r2)) {
                var n2 = this.$getSelectedRows();
                e2.indentRows(n2.first, n2.last, "	");
                return;
              }
            }
            var i2 = e2.getLine(t2.start.row), o2 = t2.start, u2 = e2.getTabSize(), a2 = e2.documentToScreenColumn(o2.row, o2.column);
            if (this.session.getUseSoftTabs())
              var f2 = u2 - a2 % u2, l2 = s.stringRepeat(" ", f2);
            else {
              var f2 = a2 % u2;
              while (i2[t2.start.column - 1] == " " && f2)
                t2.start.column--, f2--;
              this.selection.setSelectionRange(t2), l2 = "	";
            }
            return this.insert(l2);
          }, this.blockIndent = function() {
            var e2 = this.$getSelectedRows();
            this.session.indentRows(e2.first, e2.last, "	");
          }, this.blockOutdent = function() {
            var e2 = this.session.getSelection();
            this.session.outdentRows(e2.getRange());
          }, this.sortLines = function() {
            var e2 = this.$getSelectedRows(), t2 = this.session, n2 = [];
            for (var r2 = e2.first; r2 <= e2.last; r2++)
              n2.push(t2.getLine(r2));
            n2.sort(function(e3, t3) {
              return e3.toLowerCase() < t3.toLowerCase() ? -1 : e3.toLowerCase() > t3.toLowerCase() ? 1 : 0;
            });
            var i2 = new p(0, 0, 0, 0);
            for (var r2 = e2.first; r2 <= e2.last; r2++) {
              var s2 = t2.getLine(r2);
              i2.start.row = r2, i2.end.row = r2, i2.end.column = s2.length, t2.replace(i2, n2[r2 - e2.first]);
            }
          }, this.toggleCommentLines = function() {
            var e2 = this.session.getState(this.getCursorPosition().row), t2 = this.$getSelectedRows();
            this.session.getMode().toggleCommentLines(e2, this.session, t2.first, t2.last);
          }, this.toggleBlockComment = function() {
            var e2 = this.getCursorPosition(), t2 = this.session.getState(e2.row), n2 = this.getSelectionRange();
            this.session.getMode().toggleBlockComment(t2, this.session, n2, e2);
          }, this.getNumberAt = function(e2, t2) {
            var n2 = /[\-]?[0-9]+(?:\.[0-9]+)?/g;
            n2.lastIndex = 0;
            var r2 = this.session.getLine(e2);
            while (n2.lastIndex < t2) {
              var i2 = n2.exec(r2);
              if (i2.index <= t2 && i2.index + i2[0].length >= t2) {
                var s2 = { value: i2[0], start: i2.index, end: i2.index + i2[0].length };
                return s2;
              }
            }
            return null;
          }, this.modifyNumber = function(e2) {
            var t2 = this.selection.getCursor().row, n2 = this.selection.getCursor().column, r2 = new p(t2, n2 - 1, t2, n2), i2 = this.session.getTextRange(r2);
            if (!isNaN(parseFloat(i2)) && isFinite(i2)) {
              var s2 = this.getNumberAt(t2, n2);
              if (s2) {
                var o2 = s2.value.indexOf(".") >= 0 ? s2.start + s2.value.indexOf(".") + 1 : s2.end, u2 = s2.start + s2.value.length - o2, a2 = parseFloat(s2.value);
                a2 *= Math.pow(10, u2), o2 !== s2.end && n2 < o2 ? e2 *= Math.pow(10, s2.end - n2 - 1) : e2 *= Math.pow(10, s2.end - n2), a2 += e2, a2 /= Math.pow(10, u2);
                var f2 = a2.toFixed(u2), l2 = new p(t2, s2.start, t2, s2.end);
                this.session.replace(l2, f2), this.moveCursorTo(t2, Math.max(s2.start + 1, n2 + f2.length - s2.value.length));
              }
            } else
              this.toggleWord();
          }, this.$toggleWordPairs = [["first", "last"], ["true", "false"], ["yes", "no"], ["width", "height"], ["top", "bottom"], ["right", "left"], ["on", "off"], ["x", "y"], ["get", "set"], ["max", "min"], ["horizontal", "vertical"], ["show", "hide"], ["add", "remove"], ["up", "down"], ["before", "after"], ["even", "odd"], ["in", "out"], ["inside", "outside"], ["next", "previous"], ["increase", "decrease"], ["attach", "detach"], ["&&", "||"], ["==", "!="]], this.toggleWord = function() {
            var e2 = this.selection.getCursor().row, t2 = this.selection.getCursor().column;
            this.selection.selectWord();
            var n2 = this.getSelectedText(), r2 = this.selection.getWordRange().start.column, i2 = n2.replace(/([a-z]+|[A-Z]+)(?=[A-Z_]|$)/g, "$1 ").split(/\s/), o2 = t2 - r2 - 1;
            o2 < 0 && (o2 = 0);
            var u2 = 0, a2 = 0, f2 = this;
            n2.match(/[A-Za-z0-9_]+/) && i2.forEach(function(t3, i3) {
              a2 = u2 + t3.length, o2 >= u2 && o2 <= a2 && (n2 = t3, f2.selection.clearSelection(), f2.moveCursorTo(e2, u2 + r2), f2.selection.selectTo(e2, a2 + r2)), u2 = a2;
            });
            var l2 = this.$toggleWordPairs, c2;
            for (var h2 = 0; h2 < l2.length; h2++) {
              var p2 = l2[h2];
              for (var d2 = 0; d2 <= 1; d2++) {
                var v2 = +!d2, m2 = n2.match(new RegExp("^\\s?_?(" + s.escapeRegExp(p2[d2]) + ")\\s?$", "i"));
                if (m2) {
                  var g2 = n2.match(new RegExp("([_]|^|\\s)(" + s.escapeRegExp(m2[1]) + ")($|\\s)", "g"));
                  g2 && (c2 = n2.replace(new RegExp(s.escapeRegExp(p2[d2]), "i"), function(e3) {
                    var t3 = p2[v2];
                    return e3.toUpperCase() == e3 ? t3 = t3.toUpperCase() : e3.charAt(0).toUpperCase() == e3.charAt(0) && (t3 = t3.substr(0, 0) + p2[v2].charAt(0).toUpperCase() + t3.substr(1)), t3;
                  }), this.insert(c2), c2 = "");
                }
              }
            }
          }, this.removeLines = function() {
            var e2 = this.$getSelectedRows();
            this.session.removeFullLines(e2.first, e2.last), this.clearSelection();
          }, this.duplicateSelection = function() {
            var e2 = this.selection, t2 = this.session, n2 = e2.getRange(), r2 = e2.isBackwards();
            if (n2.isEmpty()) {
              var i2 = n2.start.row;
              t2.duplicateLines(i2, i2);
            } else {
              var s2 = r2 ? n2.start : n2.end, o2 = t2.insert(s2, t2.getTextRange(n2), false);
              n2.start = s2, n2.end = o2, e2.setSelectionRange(n2, r2);
            }
          }, this.moveLinesDown = function() {
            this.$moveLines(1, false);
          }, this.moveLinesUp = function() {
            this.$moveLines(-1, false);
          }, this.moveText = function(e2, t2, n2) {
            return this.session.moveText(e2, t2, n2);
          }, this.copyLinesUp = function() {
            this.$moveLines(-1, true);
          }, this.copyLinesDown = function() {
            this.$moveLines(1, true);
          }, this.$moveLines = function(e2, t2) {
            var n2, r2, i2 = this.selection;
            if (!i2.inMultiSelectMode || this.inVirtualSelectionMode) {
              var s2 = i2.toOrientedRange();
              n2 = this.$getSelectedRows(s2), r2 = this.session.$moveLines(n2.first, n2.last, t2 ? 0 : e2), t2 && e2 == -1 && (r2 = 0), s2.moveBy(r2, 0), i2.fromOrientedRange(s2);
            } else {
              var o2 = i2.rangeList.ranges;
              i2.rangeList.detach(this.session), this.inVirtualSelectionMode = true;
              var u2 = 0, a2 = 0, f2 = o2.length;
              for (var l2 = 0; l2 < f2; l2++) {
                var c2 = l2;
                o2[l2].moveBy(u2, 0), n2 = this.$getSelectedRows(o2[l2]);
                var h2 = n2.first, p2 = n2.last;
                while (++l2 < f2) {
                  a2 && o2[l2].moveBy(a2, 0);
                  var d2 = this.$getSelectedRows(o2[l2]);
                  if (t2 && d2.first != p2)
                    break;
                  if (!t2 && d2.first > p2 + 1)
                    break;
                  p2 = d2.last;
                }
                l2--, u2 = this.session.$moveLines(h2, p2, t2 ? 0 : e2), t2 && e2 == -1 && (c2 = l2 + 1);
                while (c2 <= l2)
                  o2[c2].moveBy(u2, 0), c2++;
                t2 || (u2 = 0), a2 += u2;
              }
              i2.fromOrientedRange(i2.ranges[0]), i2.rangeList.attach(this.session), this.inVirtualSelectionMode = false;
            }
          }, this.$getSelectedRows = function(e2) {
            return e2 = (e2 || this.getSelectionRange()).collapseRows(), { first: this.session.getRowFoldStart(e2.start.row), last: this.session.getRowFoldEnd(e2.end.row) };
          }, this.onCompositionStart = function(e2) {
            this.renderer.showComposition(e2);
          }, this.onCompositionUpdate = function(e2) {
            this.renderer.setCompositionText(e2);
          }, this.onCompositionEnd = function() {
            this.renderer.hideComposition();
          }, this.getFirstVisibleRow = function() {
            return this.renderer.getFirstVisibleRow();
          }, this.getLastVisibleRow = function() {
            return this.renderer.getLastVisibleRow();
          }, this.isRowVisible = function(e2) {
            return e2 >= this.getFirstVisibleRow() && e2 <= this.getLastVisibleRow();
          }, this.isRowFullyVisible = function(e2) {
            return e2 >= this.renderer.getFirstFullyVisibleRow() && e2 <= this.renderer.getLastFullyVisibleRow();
          }, this.$getVisibleRowCount = function() {
            return this.renderer.getScrollBottomRow() - this.renderer.getScrollTopRow() + 1;
          }, this.$moveByPage = function(e2, t2) {
            var n2 = this.renderer, r2 = this.renderer.layerConfig, i2 = e2 * Math.floor(r2.height / r2.lineHeight);
            t2 === true ? this.selection.$moveSelection(function() {
              this.moveCursorBy(i2, 0);
            }) : t2 === false && (this.selection.moveCursorBy(i2, 0), this.selection.clearSelection());
            var s2 = n2.scrollTop;
            n2.scrollBy(0, i2 * r2.lineHeight), t2 != null && n2.scrollCursorIntoView(null, 0.5), n2.animateScrolling(s2);
          }, this.selectPageDown = function() {
            this.$moveByPage(1, true);
          }, this.selectPageUp = function() {
            this.$moveByPage(-1, true);
          }, this.gotoPageDown = function() {
            this.$moveByPage(1, false);
          }, this.gotoPageUp = function() {
            this.$moveByPage(-1, false);
          }, this.scrollPageDown = function() {
            this.$moveByPage(1);
          }, this.scrollPageUp = function() {
            this.$moveByPage(-1);
          }, this.scrollToRow = function(e2) {
            this.renderer.scrollToRow(e2);
          }, this.scrollToLine = function(e2, t2, n2, r2) {
            this.renderer.scrollToLine(e2, t2, n2, r2);
          }, this.centerSelection = function() {
            var e2 = this.getSelectionRange(), t2 = { row: Math.floor(e2.start.row + (e2.end.row - e2.start.row) / 2), column: Math.floor(e2.start.column + (e2.end.column - e2.start.column) / 2) };
            this.renderer.alignCursor(t2, 0.5);
          }, this.getCursorPosition = function() {
            return this.selection.getCursor();
          }, this.getCursorPositionScreen = function() {
            return this.session.documentToScreenPosition(this.getCursorPosition());
          }, this.getSelectionRange = function() {
            return this.selection.getRange();
          }, this.selectAll = function() {
            this.selection.selectAll();
          }, this.clearSelection = function() {
            this.selection.clearSelection();
          }, this.moveCursorTo = function(e2, t2) {
            this.selection.moveCursorTo(e2, t2);
          }, this.moveCursorToPosition = function(e2) {
            this.selection.moveCursorToPosition(e2);
          }, this.jumpToMatching = function(e2, t2) {
            var n2 = this.getCursorPosition(), r2 = new y(this.session, n2.row, n2.column), i2 = r2.getCurrentToken(), s2 = i2 || r2.stepForward();
            if (!s2)
              return;
            var o2, u2 = false, a2 = {}, f2 = n2.column - s2.start, l2, c2 = { ")": "(", "(": "(", "]": "[", "[": "[", "{": "{", "}": "{" };
            do {
              if (s2.value.match(/[{}()\[\]]/g))
                for (; f2 < s2.value.length && !u2; f2++) {
                  if (!c2[s2.value[f2]])
                    continue;
                  l2 = c2[s2.value[f2]] + "." + s2.type.replace("rparen", "lparen"), isNaN(a2[l2]) && (a2[l2] = 0);
                  switch (s2.value[f2]) {
                    case "(":
                    case "[":
                    case "{":
                      a2[l2]++;
                      break;
                    case ")":
                    case "]":
                    case "}":
                      a2[l2]--, a2[l2] === -1 && (o2 = "bracket", u2 = true);
                  }
                }
              else
                s2.type.indexOf("tag-name") !== -1 && (isNaN(a2[s2.value]) && (a2[s2.value] = 0), i2.value === "<" ? a2[s2.value]++ : i2.value === "</" && a2[s2.value]--, a2[s2.value] === -1 && (o2 = "tag", u2 = true));
              u2 || (i2 = s2, s2 = r2.stepForward(), f2 = 0);
            } while (s2 && !u2);
            if (!o2)
              return;
            var h2, d2;
            if (o2 === "bracket") {
              h2 = this.session.getBracketRange(n2);
              if (!h2) {
                h2 = new p(r2.getCurrentTokenRow(), r2.getCurrentTokenColumn() + f2 - 1, r2.getCurrentTokenRow(), r2.getCurrentTokenColumn() + f2 - 1), d2 = h2.start;
                if (t2 || d2.row === n2.row && Math.abs(d2.column - n2.column) < 2)
                  h2 = this.session.getBracketRange(d2);
              }
            } else if (o2 === "tag") {
              if (!s2 || s2.type.indexOf("tag-name") === -1)
                return;
              var v2 = s2.value;
              h2 = new p(r2.getCurrentTokenRow(), r2.getCurrentTokenColumn() - 2, r2.getCurrentTokenRow(), r2.getCurrentTokenColumn() - 2);
              if (h2.compare(n2.row, n2.column) === 0) {
                u2 = false;
                do
                  s2 = i2, i2 = r2.stepBackward(), i2 && (i2.type.indexOf("tag-close") !== -1 && h2.setEnd(r2.getCurrentTokenRow(), r2.getCurrentTokenColumn() + 1), s2.value === v2 && s2.type.indexOf("tag-name") !== -1 && (i2.value === "<" ? a2[v2]++ : i2.value === "</" && a2[v2]--, a2[v2] === 0 && (u2 = true)));
                while (i2 && !u2);
              }
              s2 && s2.type.indexOf("tag-name") && (d2 = h2.start, d2.row == n2.row && Math.abs(d2.column - n2.column) < 2 && (d2 = h2.end));
            }
            d2 = h2 && h2.cursor || d2, d2 && (e2 ? h2 && t2 ? this.selection.setRange(h2) : h2 && h2.isEqual(this.getSelectionRange()) ? this.clearSelection() : this.selection.selectTo(d2.row, d2.column) : this.selection.moveTo(d2.row, d2.column));
          }, this.gotoLine = function(e2, t2, n2) {
            this.selection.clearSelection(), this.session.unfold({ row: e2 - 1, column: t2 || 0 }), this.exitMultiSelectMode && this.exitMultiSelectMode(), this.moveCursorTo(e2 - 1, t2 || 0), this.isRowFullyVisible(e2 - 1) || this.scrollToLine(e2 - 1, true, n2);
          }, this.navigateTo = function(e2, t2) {
            this.selection.moveTo(e2, t2);
          }, this.navigateUp = function(e2) {
            if (this.selection.isMultiLine() && !this.selection.isBackwards()) {
              var t2 = this.selection.anchor.getPosition();
              return this.moveCursorToPosition(t2);
            }
            this.selection.clearSelection(), this.selection.moveCursorBy(-e2 || -1, 0);
          }, this.navigateDown = function(e2) {
            if (this.selection.isMultiLine() && this.selection.isBackwards()) {
              var t2 = this.selection.anchor.getPosition();
              return this.moveCursorToPosition(t2);
            }
            this.selection.clearSelection(), this.selection.moveCursorBy(e2 || 1, 0);
          }, this.navigateLeft = function(e2) {
            if (!this.selection.isEmpty()) {
              var t2 = this.getSelectionRange().start;
              this.moveCursorToPosition(t2);
            } else {
              e2 = e2 || 1;
              while (e2--)
                this.selection.moveCursorLeft();
            }
            this.clearSelection();
          }, this.navigateRight = function(e2) {
            if (!this.selection.isEmpty()) {
              var t2 = this.getSelectionRange().end;
              this.moveCursorToPosition(t2);
            } else {
              e2 = e2 || 1;
              while (e2--)
                this.selection.moveCursorRight();
            }
            this.clearSelection();
          }, this.navigateLineStart = function() {
            this.selection.moveCursorLineStart(), this.clearSelection();
          }, this.navigateLineEnd = function() {
            this.selection.moveCursorLineEnd(), this.clearSelection();
          }, this.navigateFileEnd = function() {
            this.selection.moveCursorFileEnd(), this.clearSelection();
          }, this.navigateFileStart = function() {
            this.selection.moveCursorFileStart(), this.clearSelection();
          }, this.navigateWordRight = function() {
            this.selection.moveCursorWordRight(), this.clearSelection();
          }, this.navigateWordLeft = function() {
            this.selection.moveCursorWordLeft(), this.clearSelection();
          }, this.replace = function(e2, t2) {
            t2 && this.$search.set(t2);
            var n2 = this.$search.find(this.session), r2 = 0;
            return n2 ? (this.$tryReplace(n2, e2) && (r2 = 1), this.selection.setSelectionRange(n2), this.renderer.scrollSelectionIntoView(n2.start, n2.end), r2) : r2;
          }, this.replaceAll = function(e2, t2) {
            t2 && this.$search.set(t2);
            var n2 = this.$search.findAll(this.session), r2 = 0;
            if (!n2.length)
              return r2;
            var i2 = this.getSelectionRange();
            this.selection.moveTo(0, 0);
            for (var s2 = n2.length - 1; s2 >= 0; --s2)
              this.$tryReplace(n2[s2], e2) && r2++;
            return this.selection.setSelectionRange(i2), r2;
          }, this.$tryReplace = function(e2, t2) {
            var n2 = this.session.getTextRange(e2);
            return t2 = this.$search.replace(n2, t2), t2 !== null ? (e2.end = this.session.replace(e2, t2), e2) : null;
          }, this.getLastSearchOptions = function() {
            return this.$search.getOptions();
          }, this.find = function(e2, t2, n2) {
            t2 || (t2 = {}), typeof e2 == "string" || e2 instanceof RegExp ? t2.needle = e2 : typeof e2 == "object" && r.mixin(t2, e2);
            var i2 = this.selection.getRange();
            t2.needle == null && (e2 = this.session.getTextRange(i2) || this.$search.$options.needle, e2 || (i2 = this.session.getWordRange(i2.start.row, i2.start.column), e2 = this.session.getTextRange(i2)), this.$search.set({ needle: e2 })), this.$search.set(t2), t2.start || this.$search.set({ start: i2 });
            var s2 = this.$search.find(this.session);
            if (t2.preventScroll)
              return s2;
            if (s2)
              return this.revealRange(s2, n2), s2;
            t2.backwards ? i2.start = i2.end : i2.end = i2.start, this.selection.setRange(i2);
          }, this.findNext = function(e2, t2) {
            this.find({ skipCurrent: true, backwards: false }, e2, t2);
          }, this.findPrevious = function(e2, t2) {
            this.find(e2, { skipCurrent: true, backwards: true }, t2);
          }, this.revealRange = function(e2, t2) {
            this.session.unfold(e2), this.selection.setSelectionRange(e2);
            var n2 = this.renderer.scrollTop;
            this.renderer.scrollSelectionIntoView(e2.start, e2.end, 0.5), t2 !== false && this.renderer.animateScrolling(n2);
          }, this.undo = function() {
            this.session.getUndoManager().undo(this.session), this.renderer.scrollCursorIntoView(null, 0.5);
          }, this.redo = function() {
            this.session.getUndoManager().redo(this.session), this.renderer.scrollCursorIntoView(null, 0.5);
          }, this.destroy = function() {
            this.$toDestroy && (this.$toDestroy.forEach(function(e2) {
              e2.destroy();
            }), this.$toDestroy = null), this.$mouseHandler && this.$mouseHandler.destroy(), this.renderer.destroy(), this._signal("destroy", this), this.session && this.session.destroy(), this._$emitInputEvent && this._$emitInputEvent.cancel(), this.removeAllListeners();
          }, this.setAutoScrollEditorIntoView = function(e2) {
            if (!e2)
              return;
            var t2, n2 = this, r2 = false;
            this.$scrollAnchor || (this.$scrollAnchor = document.createElement("div"));
            var i2 = this.$scrollAnchor;
            i2.style.cssText = "position:absolute", this.container.insertBefore(i2, this.container.firstChild);
            var s2 = this.on("changeSelection", function() {
              r2 = true;
            }), o2 = this.renderer.on("beforeRender", function() {
              r2 && (t2 = n2.renderer.container.getBoundingClientRect());
            }), u2 = this.renderer.on("afterRender", function() {
              if (r2 && t2 && (n2.isFocused() || n2.searchBox && n2.searchBox.isFocused())) {
                var e3 = n2.renderer, s3 = e3.$cursorLayer.$pixelPos, o3 = e3.layerConfig, u3 = s3.top - o3.offset;
                s3.top >= 0 && u3 + t2.top < 0 ? r2 = true : s3.top < o3.height && s3.top + t2.top + o3.lineHeight > window.innerHeight ? r2 = false : r2 = null, r2 != null && (i2.style.top = u3 + "px", i2.style.left = s3.left + "px", i2.style.height = o3.lineHeight + "px", i2.scrollIntoView(r2)), r2 = t2 = null;
              }
            });
            this.setAutoScrollEditorIntoView = function(e3) {
              if (e3)
                return;
              delete this.setAutoScrollEditorIntoView, this.off("changeSelection", s2), this.renderer.off("afterRender", u2), this.renderer.off("beforeRender", o2);
            };
          }, this.$resetCursorStyle = function() {
            var e2 = this.$cursorStyle || "ace", t2 = this.renderer.$cursorLayer;
            if (!t2)
              return;
            t2.setSmoothBlinking(/smooth/.test(e2)), t2.isBlinking = !this.$readOnly && e2 != "wide", i.setCssClass(t2.element, "ace_slim-cursors", /slim/.test(e2));
          }, this.prompt = function(e2, t2, n2) {
            var r2 = this;
            g.loadModule("./ext/prompt", function(i2) {
              i2.prompt(r2, e2, t2, n2);
            });
          };
        }.call(w.prototype), g.defineOptions(w.prototype, "editor", { selectionStyle: { set: function(e2) {
          this.onSelectionChange(), this._signal("changeSelectionStyle", { data: e2 });
        }, initialValue: "line" }, highlightActiveLine: { set: function() {
          this.$updateHighlightActiveLine();
        }, initialValue: true }, highlightSelectedWord: { set: function(e2) {
          this.$onSelectionChange();
        }, initialValue: true }, readOnly: { set: function(e2) {
          this.textInput.setReadOnly(e2), this.$resetCursorStyle();
        }, initialValue: false }, copyWithEmptySelection: { set: function(e2) {
          this.textInput.setCopyWithEmptySelection(e2);
        }, initialValue: false }, cursorStyle: { set: function(e2) {
          this.$resetCursorStyle();
        }, values: ["ace", "slim", "smooth", "wide"], initialValue: "ace" }, mergeUndoDeltas: { values: [false, true, "always"], initialValue: true }, behavioursEnabled: { initialValue: true }, wrapBehavioursEnabled: { initialValue: true }, enableAutoIndent: { initialValue: true }, autoScrollEditorIntoView: { set: function(e2) {
          this.setAutoScrollEditorIntoView(e2);
        } }, keyboardHandler: { set: function(e2) {
          this.setKeyboardHandler(e2);
        }, get: function() {
          return this.$keybindingId;
        }, handlesSet: true }, value: { set: function(e2) {
          this.session.setValue(e2);
        }, get: function() {
          return this.getValue();
        }, handlesSet: true, hidden: true }, session: { set: function(e2) {
          this.setSession(e2);
        }, get: function() {
          return this.session;
        }, handlesSet: true, hidden: true }, showLineNumbers: { set: function(e2) {
          this.renderer.$gutterLayer.setShowLineNumbers(e2), this.renderer.$loop.schedule(this.renderer.CHANGE_GUTTER), e2 && this.$relativeLineNumbers ? E.attach(this) : E.detach(this);
        }, initialValue: true }, relativeLineNumbers: { set: function(e2) {
          this.$showLineNumbers && e2 ? E.attach(this) : E.detach(this);
        } }, placeholder: { set: function(e2) {
          this.$updatePlaceholder || (this.$updatePlaceholder = function() {
            var e3 = this.session && (this.renderer.$composition || this.getValue());
            if (e3 && this.renderer.placeholderNode)
              this.renderer.off("afterRender", this.$updatePlaceholder), i.removeCssClass(this.container, "ace_hasPlaceholder"), this.renderer.placeholderNode.remove(), this.renderer.placeholderNode = null;
            else if (!e3 && !this.renderer.placeholderNode) {
              this.renderer.on("afterRender", this.$updatePlaceholder), i.addCssClass(this.container, "ace_hasPlaceholder");
              var t2 = i.createElement("div");
              t2.className = "ace_placeholder", t2.textContent = this.$placeholder || "", this.renderer.placeholderNode = t2, this.renderer.content.appendChild(this.renderer.placeholderNode);
            } else
              !e3 && this.renderer.placeholderNode && (this.renderer.placeholderNode.textContent = this.$placeholder || "");
          }.bind(this), this.on("input", this.$updatePlaceholder)), this.$updatePlaceholder();
        } }, hScrollBarAlwaysVisible: "renderer", vScrollBarAlwaysVisible: "renderer", highlightGutterLine: "renderer", animatedScroll: "renderer", showInvisibles: "renderer", showPrintMargin: "renderer", printMarginColumn: "renderer", printMargin: "renderer", fadeFoldWidgets: "renderer", showFoldWidgets: "renderer", displayIndentGuides: "renderer", showGutter: "renderer", fontSize: "renderer", fontFamily: "renderer", maxLines: "renderer", minLines: "renderer", scrollPastEnd: "renderer", fixedWidthGutter: "renderer", theme: "renderer", hasCssTransforms: "renderer", maxPixelHeight: "renderer", useTextareaForIME: "renderer", scrollSpeed: "$mouseHandler", dragDelay: "$mouseHandler", dragEnabled: "$mouseHandler", focusTimeout: "$mouseHandler", tooltipFollowsMouse: "$mouseHandler", firstLineNumber: "session", overwrite: "session", newLineMode: "session", useWorker: "session", useSoftTabs: "session", navigateWithinSoftTabs: "session", tabSize: "session", wrap: "session", indentedSoftWrap: "session", foldStyle: "session", mode: "session" });
        var E = { getText: function(e2, t2) {
          return (Math.abs(e2.selection.lead.row - t2) || t2 + 1 + (t2 < 9 ? "\xB7" : "")) + "";
        }, getWidth: function(e2, t2, n2) {
          return Math.max(t2.toString().length, (n2.lastRow + 1).toString().length, 2) * n2.characterWidth;
        }, update: function(e2, t2) {
          t2.renderer.$loop.schedule(t2.renderer.CHANGE_GUTTER);
        }, attach: function(e2) {
          e2.renderer.$gutterLayer.$renderer = this, e2.on("changeSelection", this.update), this.update(null, e2);
        }, detach: function(e2) {
          e2.renderer.$gutterLayer.$renderer == this && (e2.renderer.$gutterLayer.$renderer = null), e2.off("changeSelection", this.update), this.update(null, e2);
        } };
        t.Editor = w;
      }), ace.define("ace/undomanager", ["require", "exports", "module", "ace/range"], function(e, t, n) {
        "use strict";
        function i(e2, t2) {
          for (var n2 = t2; n2--; ) {
            var r2 = e2[n2];
            if (r2 && !r2[0].ignore) {
              while (n2 < t2 - 1) {
                var i2 = d(e2[n2], e2[n2 + 1]);
                e2[n2] = i2[0], e2[n2 + 1] = i2[1], n2++;
              }
              return true;
            }
          }
        }
        function a(e2) {
          var t2 = e2.action == "insert", n2 = e2.start, r2 = e2.end, i2 = (r2.row - n2.row) * (t2 ? 1 : -1), s2 = (r2.column - n2.column) * (t2 ? 1 : -1);
          t2 && (r2 = n2);
          for (var o2 in this.marks) {
            var a2 = this.marks[o2], f2 = u(a2, n2);
            if (f2 < 0)
              continue;
            if (f2 === 0 && t2) {
              if (a2.bias != 1) {
                a2.bias == -1;
                continue;
              }
              f2 = 1;
            }
            var l2 = t2 ? f2 : u(a2, r2);
            if (l2 > 0) {
              a2.row += i2, a2.column += a2.row == r2.row ? s2 : 0;
              continue;
            }
            !t2 && l2 <= 0 && (a2.row = n2.row, a2.column = n2.column, l2 === 0 && (a2.bias = 1));
          }
        }
        function f(e2) {
          return { row: e2.row, column: e2.column };
        }
        function l(e2) {
          return { start: f(e2.start), end: f(e2.end), action: e2.action, lines: e2.lines.slice() };
        }
        function c(e2) {
          e2 = e2 || this;
          if (Array.isArray(e2))
            return e2.map(c).join("\n");
          var t2 = "";
          e2.action ? (t2 = e2.action == "insert" ? "+" : "-", t2 += "[" + e2.lines + "]") : e2.value && (Array.isArray(e2.value) ? t2 = e2.value.map(h).join("\n") : t2 = h(e2.value)), e2.start && (t2 += h(e2));
          if (e2.id || e2.rev)
            t2 += "	(" + (e2.id || e2.rev) + ")";
          return t2;
        }
        function h(e2) {
          return e2.start.row + ":" + e2.start.column + "=>" + e2.end.row + ":" + e2.end.column;
        }
        function p(e2, t2) {
          var n2 = e2.action == "insert", r2 = t2.action == "insert";
          if (n2 && r2)
            if (o(t2.start, e2.end) >= 0)
              m(t2, e2, -1);
            else {
              if (!(o(t2.start, e2.start) <= 0))
                return null;
              m(e2, t2, 1);
            }
          else if (n2 && !r2)
            if (o(t2.start, e2.end) >= 0)
              m(t2, e2, -1);
            else {
              if (!(o(t2.end, e2.start) <= 0))
                return null;
              m(e2, t2, -1);
            }
          else if (!n2 && r2)
            if (o(t2.start, e2.start) >= 0)
              m(t2, e2, 1);
            else {
              if (!(o(t2.start, e2.start) <= 0))
                return null;
              m(e2, t2, 1);
            }
          else if (!n2 && !r2)
            if (o(t2.start, e2.start) >= 0)
              m(t2, e2, 1);
            else {
              if (!(o(t2.end, e2.start) <= 0))
                return null;
              m(e2, t2, -1);
            }
          return [t2, e2];
        }
        function d(e2, t2) {
          for (var n2 = e2.length; n2--; )
            for (var r2 = 0; r2 < t2.length; r2++)
              if (!p(e2[n2], t2[r2])) {
                while (n2 < e2.length) {
                  while (r2--)
                    p(t2[r2], e2[n2]);
                  r2 = t2.length, n2++;
                }
                return [e2, t2];
              }
          return e2.selectionBefore = t2.selectionBefore = e2.selectionAfter = t2.selectionAfter = null, [t2, e2];
        }
        function v(e2, t2) {
          var n2 = e2.action == "insert", r2 = t2.action == "insert";
          if (n2 && r2)
            o(e2.start, t2.start) < 0 ? m(t2, e2, 1) : m(e2, t2, 1);
          else if (n2 && !r2)
            o(e2.start, t2.end) >= 0 ? m(e2, t2, -1) : o(e2.start, t2.start) <= 0 ? m(t2, e2, 1) : (m(e2, s.fromPoints(t2.start, e2.start), -1), m(t2, e2, 1));
          else if (!n2 && r2)
            o(t2.start, e2.end) >= 0 ? m(t2, e2, -1) : o(t2.start, e2.start) <= 0 ? m(e2, t2, 1) : (m(t2, s.fromPoints(e2.start, t2.start), -1), m(e2, t2, 1));
          else if (!n2 && !r2)
            if (o(t2.start, e2.end) >= 0)
              m(t2, e2, -1);
            else {
              if (!(o(t2.end, e2.start) <= 0)) {
                var i2, u2;
                return o(e2.start, t2.start) < 0 && (i2 = e2, e2 = y(e2, t2.start)), o(e2.end, t2.end) > 0 && (u2 = y(e2, t2.end)), g(t2.end, e2.start, e2.end, -1), u2 && !i2 && (e2.lines = u2.lines, e2.start = u2.start, e2.end = u2.end, u2 = e2), [t2, i2, u2].filter(Boolean);
              }
              m(e2, t2, -1);
            }
          return [t2, e2];
        }
        function m(e2, t2, n2) {
          g(e2.start, t2.start, t2.end, n2), g(e2.end, t2.start, t2.end, n2);
        }
        function g(e2, t2, n2, r2) {
          e2.row == (r2 == 1 ? t2 : n2).row && (e2.column += r2 * (n2.column - t2.column)), e2.row += r2 * (n2.row - t2.row);
        }
        function y(e2, t2) {
          var n2 = e2.lines, r2 = e2.end;
          e2.end = f(t2);
          var i2 = e2.end.row - e2.start.row, s2 = n2.splice(i2, n2.length), o2 = i2 ? t2.column : t2.column - e2.start.column;
          n2.push(s2[0].substring(0, o2)), s2[0] = s2[0].substr(o2);
          var u2 = { start: f(t2), end: r2, lines: s2, action: e2.action };
          return u2;
        }
        function b(e2, t2) {
          t2 = l(t2);
          for (var n2 = e2.length; n2--; ) {
            var r2 = e2[n2];
            for (var i2 = 0; i2 < r2.length; i2++) {
              var s2 = r2[i2], o2 = v(s2, t2);
              t2 = o2[0], o2.length != 2 && (o2[2] ? (r2.splice(i2 + 1, 1, o2[1], o2[2]), i2++) : o2[1] || (r2.splice(i2, 1), i2--));
            }
            r2.length || e2.splice(n2, 1);
          }
          return e2;
        }
        function w(e2, t2) {
          for (var n2 = 0; n2 < t2.length; n2++) {
            var r2 = t2[n2];
            for (var i2 = 0; i2 < r2.length; i2++)
              b(e2, r2[i2]);
          }
        }
        var r = function() {
          this.$maxRev = 0, this.$fromUndo = false, this.reset();
        };
        (function() {
          this.addSession = function(e2) {
            this.$session = e2;
          }, this.add = function(e2, t2, n2) {
            if (this.$fromUndo)
              return;
            if (e2 == this.$lastDelta)
              return;
            this.$keepRedoStack || (this.$redoStack.length = 0);
            if (t2 === false || !this.lastDeltas)
              this.lastDeltas = [], this.$undoStack.push(this.lastDeltas), e2.id = this.$rev = ++this.$maxRev;
            if (e2.action == "remove" || e2.action == "insert")
              this.$lastDelta = e2;
            this.lastDeltas.push(e2);
          }, this.addSelection = function(e2, t2) {
            this.selections.push({ value: e2, rev: t2 || this.$rev });
          }, this.startNewGroup = function() {
            return this.lastDeltas = null, this.$rev;
          }, this.markIgnored = function(e2, t2) {
            t2 == null && (t2 = this.$rev + 1);
            var n2 = this.$undoStack;
            for (var r2 = n2.length; r2--; ) {
              var i2 = n2[r2][0];
              if (i2.id <= e2)
                break;
              i2.id < t2 && (i2.ignore = true);
            }
            this.lastDeltas = null;
          }, this.getSelection = function(e2, t2) {
            var n2 = this.selections;
            for (var r2 = n2.length; r2--; ) {
              var i2 = n2[r2];
              if (i2.rev < e2)
                return t2 && (i2 = n2[r2 + 1]), i2;
            }
          }, this.getRevision = function() {
            return this.$rev;
          }, this.getDeltas = function(e2, t2) {
            t2 == null && (t2 = this.$rev + 1);
            var n2 = this.$undoStack, r2 = null, i2 = 0;
            for (var s2 = n2.length; s2--; ) {
              var o2 = n2[s2][0];
              o2.id < t2 && !r2 && (r2 = s2 + 1);
              if (o2.id <= e2) {
                i2 = s2 + 1;
                break;
              }
            }
            return n2.slice(i2, r2);
          }, this.getChangedRanges = function(e2, t2) {
            t2 == null && (t2 = this.$rev + 1);
          }, this.getChangedLines = function(e2, t2) {
            t2 == null && (t2 = this.$rev + 1);
          }, this.undo = function(e2, t2) {
            this.lastDeltas = null;
            var n2 = this.$undoStack;
            if (!i(n2, n2.length))
              return;
            e2 || (e2 = this.$session), this.$redoStackBaseRev !== this.$rev && this.$redoStack.length && (this.$redoStack = []), this.$fromUndo = true;
            var r2 = n2.pop(), s2 = null;
            return r2 && (s2 = e2.undoChanges(r2, t2), this.$redoStack.push(r2), this.$syncRev()), this.$fromUndo = false, s2;
          }, this.redo = function(e2, t2) {
            this.lastDeltas = null, e2 || (e2 = this.$session), this.$fromUndo = true;
            if (this.$redoStackBaseRev != this.$rev) {
              var n2 = this.getDeltas(this.$redoStackBaseRev, this.$rev + 1);
              w(this.$redoStack, n2), this.$redoStackBaseRev = this.$rev, this.$redoStack.forEach(function(e3) {
                e3[0].id = ++this.$maxRev;
              }, this);
            }
            var r2 = this.$redoStack.pop(), i2 = null;
            return r2 && (i2 = e2.redoChanges(r2, t2), this.$undoStack.push(r2), this.$syncRev()), this.$fromUndo = false, i2;
          }, this.$syncRev = function() {
            var e2 = this.$undoStack, t2 = e2[e2.length - 1], n2 = t2 && t2[0].id || 0;
            this.$redoStackBaseRev = n2, this.$rev = n2;
          }, this.reset = function() {
            this.lastDeltas = null, this.$lastDelta = null, this.$undoStack = [], this.$redoStack = [], this.$rev = 0, this.mark = 0, this.$redoStackBaseRev = this.$rev, this.selections = [];
          }, this.canUndo = function() {
            return this.$undoStack.length > 0;
          }, this.canRedo = function() {
            return this.$redoStack.length > 0;
          }, this.bookmark = function(e2) {
            e2 == void 0 && (e2 = this.$rev), this.mark = e2;
          }, this.isAtBookmark = function() {
            return this.$rev === this.mark;
          }, this.toJSON = function() {
          }, this.fromJSON = function() {
          }, this.hasUndo = this.canUndo, this.hasRedo = this.canRedo, this.isClean = this.isAtBookmark, this.markClean = this.bookmark, this.$prettyPrint = function(e2) {
            return e2 ? c(e2) : c(this.$undoStack) + "\n---\n" + c(this.$redoStack);
          };
        }).call(r.prototype);
        var s = e("./range").Range, o = s.comparePoints, u = s.comparePoints;
        t.UndoManager = r;
      }), ace.define("ace/layer/lines", ["require", "exports", "module", "ace/lib/dom"], function(e, t, n) {
        "use strict";
        var r = e("../lib/dom"), i = function(e2, t2) {
          this.element = e2, this.canvasHeight = t2 || 5e5, this.element.style.height = this.canvasHeight * 2 + "px", this.cells = [], this.cellCache = [], this.$offsetCoefficient = 0;
        };
        (function() {
          this.moveContainer = function(e2) {
            r.translate(this.element, 0, -(e2.firstRowScreen * e2.lineHeight % this.canvasHeight) - e2.offset * this.$offsetCoefficient);
          }, this.pageChanged = function(e2, t2) {
            return Math.floor(e2.firstRowScreen * e2.lineHeight / this.canvasHeight) !== Math.floor(t2.firstRowScreen * t2.lineHeight / this.canvasHeight);
          }, this.computeLineTop = function(e2, t2, n2) {
            var r2 = t2.firstRowScreen * t2.lineHeight, i2 = Math.floor(r2 / this.canvasHeight), s = n2.documentToScreenRow(e2, 0) * t2.lineHeight;
            return s - i2 * this.canvasHeight;
          }, this.computeLineHeight = function(e2, t2, n2) {
            return t2.lineHeight * n2.getRowLineCount(e2);
          }, this.getLength = function() {
            return this.cells.length;
          }, this.get = function(e2) {
            return this.cells[e2];
          }, this.shift = function() {
            this.$cacheCell(this.cells.shift());
          }, this.pop = function() {
            this.$cacheCell(this.cells.pop());
          }, this.push = function(e2) {
            if (Array.isArray(e2)) {
              this.cells.push.apply(this.cells, e2);
              var t2 = r.createFragment(this.element);
              for (var n2 = 0; n2 < e2.length; n2++)
                t2.appendChild(e2[n2].element);
              this.element.appendChild(t2);
            } else
              this.cells.push(e2), this.element.appendChild(e2.element);
          }, this.unshift = function(e2) {
            if (Array.isArray(e2)) {
              this.cells.unshift.apply(this.cells, e2);
              var t2 = r.createFragment(this.element);
              for (var n2 = 0; n2 < e2.length; n2++)
                t2.appendChild(e2[n2].element);
              this.element.firstChild ? this.element.insertBefore(t2, this.element.firstChild) : this.element.appendChild(t2);
            } else
              this.cells.unshift(e2), this.element.insertAdjacentElement("afterbegin", e2.element);
          }, this.last = function() {
            return this.cells.length ? this.cells[this.cells.length - 1] : null;
          }, this.$cacheCell = function(e2) {
            if (!e2)
              return;
            e2.element.remove(), this.cellCache.push(e2);
          }, this.createCell = function(e2, t2, n2, i2) {
            var s = this.cellCache.pop();
            if (!s) {
              var o = r.createElement("div");
              i2 && i2(o), this.element.appendChild(o), s = { element: o, text: "", row: e2 };
            }
            return s.row = e2, s;
          };
        }).call(i.prototype), t.Lines = i;
      }), ace.define("ace/layer/gutter", ["require", "exports", "module", "ace/lib/dom", "ace/lib/oop", "ace/lib/lang", "ace/lib/event_emitter", "ace/layer/lines"], function(e, t, n) {
        "use strict";
        function f(e2) {
          var t2 = document.createTextNode("");
          e2.appendChild(t2);
          var n2 = r.createElement("span");
          return e2.appendChild(n2), e2;
        }
        var r = e("../lib/dom"), i = e("../lib/oop"), s = e("../lib/lang"), o = e("../lib/event_emitter").EventEmitter, u = e("./lines").Lines, a = function(e2) {
          this.element = r.createElement("div"), this.element.className = "ace_layer ace_gutter-layer", e2.appendChild(this.element), this.setShowFoldWidgets(this.$showFoldWidgets), this.gutterWidth = 0, this.$annotations = [], this.$updateAnnotations = this.$updateAnnotations.bind(this), this.$lines = new u(this.element), this.$lines.$offsetCoefficient = 1;
        };
        (function() {
          i.implement(this, o), this.setSession = function(e2) {
            this.session && this.session.off("change", this.$updateAnnotations), this.session = e2, e2 && e2.on("change", this.$updateAnnotations);
          }, this.addGutterDecoration = function(e2, t2) {
            window.console && console.warn && console.warn("deprecated use session.addGutterDecoration"), this.session.addGutterDecoration(e2, t2);
          }, this.removeGutterDecoration = function(e2, t2) {
            window.console && console.warn && console.warn("deprecated use session.removeGutterDecoration"), this.session.removeGutterDecoration(e2, t2);
          }, this.setAnnotations = function(e2) {
            this.$annotations = [];
            for (var t2 = 0; t2 < e2.length; t2++) {
              var n2 = e2[t2], r2 = n2.row, i2 = this.$annotations[r2];
              i2 || (i2 = this.$annotations[r2] = { text: [] });
              var o2 = n2.text;
              o2 = o2 ? s.escapeHTML(o2) : n2.html || "", i2.text.indexOf(o2) === -1 && i2.text.push(o2);
              var u2 = n2.type;
              u2 == "error" ? i2.className = " ace_error" : u2 == "warning" && i2.className != " ace_error" ? i2.className = " ace_warning" : u2 == "info" && !i2.className && (i2.className = " ace_info");
            }
          }, this.$updateAnnotations = function(e2) {
            if (!this.$annotations.length)
              return;
            var t2 = e2.start.row, n2 = e2.end.row - t2;
            if (n2 !== 0)
              if (e2.action == "remove")
                this.$annotations.splice(t2, n2 + 1, null);
              else {
                var r2 = new Array(n2 + 1);
                r2.unshift(t2, 1), this.$annotations.splice.apply(this.$annotations, r2);
              }
          }, this.update = function(e2) {
            this.config = e2;
            var t2 = this.session, n2 = e2.firstRow, r2 = Math.min(e2.lastRow + e2.gutterOffset, t2.getLength() - 1);
            this.oldLastRow = r2, this.config = e2, this.$lines.moveContainer(e2), this.$updateCursorRow();
            var i2 = t2.getNextFoldLine(n2), s2 = i2 ? i2.start.row : Infinity, o2 = null, u2 = -1, a2 = n2;
            for (; ; ) {
              a2 > s2 && (a2 = i2.end.row + 1, i2 = t2.getNextFoldLine(a2, i2), s2 = i2 ? i2.start.row : Infinity);
              if (a2 > r2) {
                while (this.$lines.getLength() > u2 + 1)
                  this.$lines.pop();
                break;
              }
              o2 = this.$lines.get(++u2), o2 ? o2.row = a2 : (o2 = this.$lines.createCell(a2, e2, this.session, f), this.$lines.push(o2)), this.$renderCell(o2, e2, i2, a2), a2++;
            }
            this._signal("afterRender"), this.$updateGutterWidth(e2);
          }, this.$updateGutterWidth = function(e2) {
            var t2 = this.session, n2 = t2.gutterRenderer || this.$renderer, r2 = t2.$firstLineNumber, i2 = this.$lines.last() ? this.$lines.last().text : "";
            if (this.$fixedWidth || t2.$useWrapMode)
              i2 = t2.getLength() + r2 - 1;
            var s2 = n2 ? n2.getWidth(t2, i2, e2) : i2.toString().length * e2.characterWidth, o2 = this.$padding || this.$computePadding();
            s2 += o2.left + o2.right, s2 !== this.gutterWidth && !isNaN(s2) && (this.gutterWidth = s2, this.element.parentNode.style.width = this.element.style.width = Math.ceil(this.gutterWidth) + "px", this._signal("changeGutterWidth", s2));
          }, this.$updateCursorRow = function() {
            if (!this.$highlightGutterLine)
              return;
            var e2 = this.session.selection.getCursor();
            if (this.$cursorRow === e2.row)
              return;
            this.$cursorRow = e2.row;
          }, this.updateLineHighlight = function() {
            if (!this.$highlightGutterLine)
              return;
            var e2 = this.session.selection.cursor.row;
            this.$cursorRow = e2;
            if (this.$cursorCell && this.$cursorCell.row == e2)
              return;
            this.$cursorCell && (this.$cursorCell.element.className = this.$cursorCell.element.className.replace("ace_gutter-active-line ", ""));
            var t2 = this.$lines.cells;
            this.$cursorCell = null;
            for (var n2 = 0; n2 < t2.length; n2++) {
              var r2 = t2[n2];
              if (r2.row >= this.$cursorRow) {
                if (r2.row > this.$cursorRow) {
                  var i2 = this.session.getFoldLine(this.$cursorRow);
                  if (!(n2 > 0 && i2 && i2.start.row == t2[n2 - 1].row))
                    break;
                  r2 = t2[n2 - 1];
                }
                r2.element.className = "ace_gutter-active-line " + r2.element.className, this.$cursorCell = r2;
                break;
              }
            }
          }, this.scrollLines = function(e2) {
            var t2 = this.config;
            this.config = e2, this.$updateCursorRow();
            if (this.$lines.pageChanged(t2, e2))
              return this.update(e2);
            this.$lines.moveContainer(e2);
            var n2 = Math.min(e2.lastRow + e2.gutterOffset, this.session.getLength() - 1), r2 = this.oldLastRow;
            this.oldLastRow = n2;
            if (!t2 || r2 < e2.firstRow)
              return this.update(e2);
            if (n2 < t2.firstRow)
              return this.update(e2);
            if (t2.firstRow < e2.firstRow)
              for (var i2 = this.session.getFoldedRowCount(t2.firstRow, e2.firstRow - 1); i2 > 0; i2--)
                this.$lines.shift();
            if (r2 > n2)
              for (var i2 = this.session.getFoldedRowCount(n2 + 1, r2); i2 > 0; i2--)
                this.$lines.pop();
            e2.firstRow < t2.firstRow && this.$lines.unshift(this.$renderLines(e2, e2.firstRow, t2.firstRow - 1)), n2 > r2 && this.$lines.push(this.$renderLines(e2, r2 + 1, n2)), this.updateLineHighlight(), this._signal("afterRender"), this.$updateGutterWidth(e2);
          }, this.$renderLines = function(e2, t2, n2) {
            var r2 = [], i2 = t2, s2 = this.session.getNextFoldLine(i2), o2 = s2 ? s2.start.row : Infinity;
            for (; ; ) {
              i2 > o2 && (i2 = s2.end.row + 1, s2 = this.session.getNextFoldLine(i2, s2), o2 = s2 ? s2.start.row : Infinity);
              if (i2 > n2)
                break;
              var u2 = this.$lines.createCell(i2, e2, this.session, f);
              this.$renderCell(u2, e2, s2, i2), r2.push(u2), i2++;
            }
            return r2;
          }, this.$renderCell = function(e2, t2, n2, i2) {
            var s2 = e2.element, o2 = this.session, u2 = s2.childNodes[0], a2 = s2.childNodes[1], f2 = o2.$firstLineNumber, l = o2.$breakpoints, c = o2.$decorations, h = o2.gutterRenderer || this.$renderer, p = this.$showFoldWidgets && o2.foldWidgets, d = n2 ? n2.start.row : Number.MAX_VALUE, v = "ace_gutter-cell ";
            this.$highlightGutterLine && (i2 == this.$cursorRow || n2 && i2 < this.$cursorRow && i2 >= d && this.$cursorRow <= n2.end.row) && (v += "ace_gutter-active-line ", this.$cursorCell != e2 && (this.$cursorCell && (this.$cursorCell.element.className = this.$cursorCell.element.className.replace("ace_gutter-active-line ", "")), this.$cursorCell = e2)), l[i2] && (v += l[i2]), c[i2] && (v += c[i2]), this.$annotations[i2] && (v += this.$annotations[i2].className), s2.className != v && (s2.className = v);
            if (p) {
              var m = p[i2];
              m == null && (m = p[i2] = o2.getFoldWidget(i2));
            }
            if (m) {
              var v = "ace_fold-widget ace_" + m;
              m == "start" && i2 == d && i2 < n2.end.row ? v += " ace_closed" : v += " ace_open", a2.className != v && (a2.className = v);
              var g = t2.lineHeight + "px";
              r.setStyle(a2.style, "height", g), r.setStyle(a2.style, "display", "inline-block");
            } else
              a2 && r.setStyle(a2.style, "display", "none");
            var y = (h ? h.getText(o2, i2) : i2 + f2).toString();
            return y !== u2.data && (u2.data = y), r.setStyle(e2.element.style, "height", this.$lines.computeLineHeight(i2, t2, o2) + "px"), r.setStyle(e2.element.style, "top", this.$lines.computeLineTop(i2, t2, o2) + "px"), e2.text = y, e2;
          }, this.$fixedWidth = false, this.$highlightGutterLine = true, this.$renderer = "", this.setHighlightGutterLine = function(e2) {
            this.$highlightGutterLine = e2;
          }, this.$showLineNumbers = true, this.$renderer = "", this.setShowLineNumbers = function(e2) {
            this.$renderer = !e2 && { getWidth: function() {
              return 0;
            }, getText: function() {
              return "";
            } };
          }, this.getShowLineNumbers = function() {
            return this.$showLineNumbers;
          }, this.$showFoldWidgets = true, this.setShowFoldWidgets = function(e2) {
            e2 ? r.addCssClass(this.element, "ace_folding-enabled") : r.removeCssClass(this.element, "ace_folding-enabled"), this.$showFoldWidgets = e2, this.$padding = null;
          }, this.getShowFoldWidgets = function() {
            return this.$showFoldWidgets;
          }, this.$computePadding = function() {
            if (!this.element.firstChild)
              return { left: 0, right: 0 };
            var e2 = r.computedStyle(this.element.firstChild);
            return this.$padding = {}, this.$padding.left = (parseInt(e2.borderLeftWidth) || 0) + (parseInt(e2.paddingLeft) || 0) + 1, this.$padding.right = (parseInt(e2.borderRightWidth) || 0) + (parseInt(e2.paddingRight) || 0), this.$padding;
          }, this.getRegion = function(e2) {
            var t2 = this.$padding || this.$computePadding(), n2 = this.element.getBoundingClientRect();
            if (e2.x < t2.left + n2.left)
              return "markers";
            if (this.$showFoldWidgets && e2.x > n2.right - t2.right)
              return "foldWidgets";
          };
        }).call(a.prototype), t.Gutter = a;
      }), ace.define("ace/layer/marker", ["require", "exports", "module", "ace/range", "ace/lib/dom"], function(e, t, n) {
        "use strict";
        var r = e("../range").Range, i = e("../lib/dom"), s = function(e2) {
          this.element = i.createElement("div"), this.element.className = "ace_layer ace_marker-layer", e2.appendChild(this.element);
        };
        (function() {
          function e2(e3, t2, n2, r2) {
            return (e3 ? 1 : 0) | (t2 ? 2 : 0) | (n2 ? 4 : 0) | (r2 ? 8 : 0);
          }
          this.$padding = 0, this.setPadding = function(e3) {
            this.$padding = e3;
          }, this.setSession = function(e3) {
            this.session = e3;
          }, this.setMarkers = function(e3) {
            this.markers = e3;
          }, this.elt = function(e3, t2) {
            var n2 = this.i != -1 && this.element.childNodes[this.i];
            n2 ? this.i++ : (n2 = document.createElement("div"), this.element.appendChild(n2), this.i = -1), n2.style.cssText = t2, n2.className = e3;
          }, this.update = function(e3) {
            if (!e3)
              return;
            this.config = e3, this.i = 0;
            var t2;
            for (var n2 in this.markers) {
              var r2 = this.markers[n2];
              if (!r2.range) {
                r2.update(t2, this, this.session, e3);
                continue;
              }
              var i2 = r2.range.clipRows(e3.firstRow, e3.lastRow);
              if (i2.isEmpty())
                continue;
              i2 = i2.toScreenRange(this.session);
              if (r2.renderer) {
                var s2 = this.$getTop(i2.start.row, e3), o = this.$padding + i2.start.column * e3.characterWidth;
                r2.renderer(t2, i2, o, s2, e3);
              } else
                r2.type == "fullLine" ? this.drawFullLineMarker(t2, i2, r2.clazz, e3) : r2.type == "screenLine" ? this.drawScreenLineMarker(t2, i2, r2.clazz, e3) : i2.isMultiLine() ? r2.type == "text" ? this.drawTextMarker(t2, i2, r2.clazz, e3) : this.drawMultiLineMarker(t2, i2, r2.clazz, e3) : this.drawSingleLineMarker(t2, i2, r2.clazz + " ace_start ace_br15", e3);
            }
            if (this.i != -1)
              while (this.i < this.element.childElementCount)
                this.element.removeChild(this.element.lastChild);
          }, this.$getTop = function(e3, t2) {
            return (e3 - t2.firstRowScreen) * t2.lineHeight;
          }, this.drawTextMarker = function(t2, n2, i2, s2, o) {
            var u = this.session, a = n2.start.row, f = n2.end.row, l = a, c = 0, h = 0, p = u.getScreenLastRowColumn(l), d = new r(l, n2.start.column, l, h);
            for (; l <= f; l++)
              d.start.row = d.end.row = l, d.start.column = l == a ? n2.start.column : u.getRowWrapIndent(l), d.end.column = p, c = h, h = p, p = l + 1 < f ? u.getScreenLastRowColumn(l + 1) : l == f ? 0 : n2.end.column, this.drawSingleLineMarker(t2, d, i2 + (l == a ? " ace_start" : "") + " ace_br" + e2(l == a || l == a + 1 && n2.start.column, c < h, h > p, l == f), s2, l == f ? 0 : 1, o);
          }, this.drawMultiLineMarker = function(e3, t2, n2, r2, i2) {
            var s2 = this.$padding, o = r2.lineHeight, u = this.$getTop(t2.start.row, r2), a = s2 + t2.start.column * r2.characterWidth;
            i2 = i2 || "";
            if (this.session.$bidiHandler.isBidiRow(t2.start.row)) {
              var f = t2.clone();
              f.end.row = f.start.row, f.end.column = this.session.getLine(f.start.row).length, this.drawBidiSingleLineMarker(e3, f, n2 + " ace_br1 ace_start", r2, null, i2);
            } else
              this.elt(n2 + " ace_br1 ace_start", "height:" + o + "px;right:0;top:" + u + "px;left:" + a + "px;" + (i2 || ""));
            if (this.session.$bidiHandler.isBidiRow(t2.end.row)) {
              var f = t2.clone();
              f.start.row = f.end.row, f.start.column = 0, this.drawBidiSingleLineMarker(e3, f, n2 + " ace_br12", r2, null, i2);
            } else {
              u = this.$getTop(t2.end.row, r2);
              var l = t2.end.column * r2.characterWidth;
              this.elt(n2 + " ace_br12", "height:" + o + "px;width:" + l + "px;top:" + u + "px;left:" + s2 + "px;" + (i2 || ""));
            }
            o = (t2.end.row - t2.start.row - 1) * r2.lineHeight;
            if (o <= 0)
              return;
            u = this.$getTop(t2.start.row + 1, r2);
            var c = (t2.start.column ? 1 : 0) | (t2.end.column ? 0 : 8);
            this.elt(n2 + (c ? " ace_br" + c : ""), "height:" + o + "px;right:0;top:" + u + "px;left:" + s2 + "px;" + (i2 || ""));
          }, this.drawSingleLineMarker = function(e3, t2, n2, r2, i2, s2) {
            if (this.session.$bidiHandler.isBidiRow(t2.start.row))
              return this.drawBidiSingleLineMarker(e3, t2, n2, r2, i2, s2);
            var o = r2.lineHeight, u = (t2.end.column + (i2 || 0) - t2.start.column) * r2.characterWidth, a = this.$getTop(t2.start.row, r2), f = this.$padding + t2.start.column * r2.characterWidth;
            this.elt(n2, "height:" + o + "px;width:" + u + "px;top:" + a + "px;left:" + f + "px;" + (s2 || ""));
          }, this.drawBidiSingleLineMarker = function(e3, t2, n2, r2, i2, s2) {
            var o = r2.lineHeight, u = this.$getTop(t2.start.row, r2), a = this.$padding, f = this.session.$bidiHandler.getSelections(t2.start.column, t2.end.column);
            f.forEach(function(e4) {
              this.elt(n2, "height:" + o + "px;width:" + e4.width + (i2 || 0) + "px;top:" + u + "px;left:" + (a + e4.left) + "px;" + (s2 || ""));
            }, this);
          }, this.drawFullLineMarker = function(e3, t2, n2, r2, i2) {
            var s2 = this.$getTop(t2.start.row, r2), o = r2.lineHeight;
            t2.start.row != t2.end.row && (o += this.$getTop(t2.end.row, r2) - s2), this.elt(n2, "height:" + o + "px;top:" + s2 + "px;left:0;right:0;" + (i2 || ""));
          }, this.drawScreenLineMarker = function(e3, t2, n2, r2, i2) {
            var s2 = this.$getTop(t2.start.row, r2), o = r2.lineHeight;
            this.elt(n2, "height:" + o + "px;top:" + s2 + "px;left:0;right:0;" + (i2 || ""));
          };
        }).call(s.prototype), t.Marker = s;
      }), ace.define("ace/layer/text", ["require", "exports", "module", "ace/lib/oop", "ace/lib/dom", "ace/lib/lang", "ace/layer/lines", "ace/lib/event_emitter"], function(e, t, n) {
        "use strict";
        var r = e("../lib/oop"), i = e("../lib/dom"), s = e("../lib/lang"), o = e("./lines").Lines, u = e("../lib/event_emitter").EventEmitter, a = function(e2) {
          this.dom = i, this.element = this.dom.createElement("div"), this.element.className = "ace_layer ace_text-layer", e2.appendChild(this.element), this.$updateEolChar = this.$updateEolChar.bind(this), this.$lines = new o(this.element);
        };
        (function() {
          r.implement(this, u), this.EOF_CHAR = "\xB6", this.EOL_CHAR_LF = "\xAC", this.EOL_CHAR_CRLF = "\xA4", this.EOL_CHAR = this.EOL_CHAR_LF, this.TAB_CHAR = "\u2014", this.SPACE_CHAR = "\xB7", this.$padding = 0, this.MAX_LINE_LENGTH = 1e4, this.$updateEolChar = function() {
            var e2 = this.session.doc, t2 = e2.getNewLineCharacter() == "\n" && e2.getNewLineMode() != "windows", n2 = t2 ? this.EOL_CHAR_LF : this.EOL_CHAR_CRLF;
            if (this.EOL_CHAR != n2)
              return this.EOL_CHAR = n2, true;
          }, this.setPadding = function(e2) {
            this.$padding = e2, this.element.style.margin = "0 " + e2 + "px";
          }, this.getLineHeight = function() {
            return this.$fontMetrics.$characterSize.height || 0;
          }, this.getCharacterWidth = function() {
            return this.$fontMetrics.$characterSize.width || 0;
          }, this.$setFontMetrics = function(e2) {
            this.$fontMetrics = e2, this.$fontMetrics.on("changeCharacterSize", function(e3) {
              this._signal("changeCharacterSize", e3);
            }.bind(this)), this.$pollSizeChanges();
          }, this.checkForSizeChanges = function() {
            this.$fontMetrics.checkForSizeChanges();
          }, this.$pollSizeChanges = function() {
            return this.$pollSizeChangesTimer = this.$fontMetrics.$pollSizeChanges();
          }, this.setSession = function(e2) {
            this.session = e2, e2 && this.$computeTabString();
          }, this.showInvisibles = false, this.showSpaces = false, this.showTabs = false, this.showEOL = false, this.setShowInvisibles = function(e2) {
            return this.showInvisibles == e2 ? false : (this.showInvisibles = e2, typeof e2 == "string" ? (this.showSpaces = /tab/i.test(e2), this.showTabs = /space/i.test(e2), this.showEOL = /eol/i.test(e2)) : this.showSpaces = this.showTabs = this.showEOL = e2, this.$computeTabString(), true);
          }, this.displayIndentGuides = true, this.setDisplayIndentGuides = function(e2) {
            return this.displayIndentGuides == e2 ? false : (this.displayIndentGuides = e2, this.$computeTabString(), true);
          }, this.$tabStrings = [], this.onChangeTabSize = this.$computeTabString = function() {
            var e2 = this.session.getTabSize();
            this.tabSize = e2;
            var t2 = this.$tabStrings = [0];
            for (var n2 = 1; n2 < e2 + 1; n2++)
              if (this.showTabs) {
                var r2 = this.dom.createElement("span");
                r2.className = "ace_invisible ace_invisible_tab", r2.textContent = s.stringRepeat(this.TAB_CHAR, n2), t2.push(r2);
              } else
                t2.push(this.dom.createTextNode(s.stringRepeat(" ", n2), this.element));
            if (this.displayIndentGuides) {
              this.$indentGuideRe = /\s\S| \t|\t |\s$/;
              var i2 = "ace_indent-guide", o2 = this.showSpaces ? " ace_invisible ace_invisible_space" : "", u2 = this.showSpaces ? s.stringRepeat(this.SPACE_CHAR, this.tabSize) : s.stringRepeat(" ", this.tabSize), a2 = this.showTabs ? " ace_invisible ace_invisible_tab" : "", f = this.showTabs ? s.stringRepeat(this.TAB_CHAR, this.tabSize) : u2, r2 = this.dom.createElement("span");
              r2.className = i2 + o2, r2.textContent = u2, this.$tabStrings[" "] = r2;
              var r2 = this.dom.createElement("span");
              r2.className = i2 + a2, r2.textContent = f, this.$tabStrings["	"] = r2;
            }
          }, this.updateLines = function(e2, t2, n2) {
            if (this.config.lastRow != e2.lastRow || this.config.firstRow != e2.firstRow)
              return this.update(e2);
            this.config = e2;
            var r2 = Math.max(t2, e2.firstRow), i2 = Math.min(n2, e2.lastRow), s2 = this.element.childNodes, o2 = 0;
            for (var u2 = e2.firstRow; u2 < r2; u2++) {
              var a2 = this.session.getFoldLine(u2);
              if (a2) {
                if (a2.containsRow(r2)) {
                  r2 = a2.start.row;
                  break;
                }
                u2 = a2.end.row;
              }
              o2++;
            }
            var f = false, u2 = r2, a2 = this.session.getNextFoldLine(u2), l = a2 ? a2.start.row : Infinity;
            for (; ; ) {
              u2 > l && (u2 = a2.end.row + 1, a2 = this.session.getNextFoldLine(u2, a2), l = a2 ? a2.start.row : Infinity);
              if (u2 > i2)
                break;
              var c = s2[o2++];
              if (c) {
                this.dom.removeChildren(c), this.$renderLine(c, u2, u2 == l ? a2 : false), f && (c.style.top = this.$lines.computeLineTop(u2, e2, this.session) + "px");
                var h = e2.lineHeight * this.session.getRowLength(u2) + "px";
                c.style.height != h && (f = true, c.style.height = h);
              }
              u2++;
            }
            if (f)
              while (o2 < this.$lines.cells.length) {
                var p = this.$lines.cells[o2++];
                p.element.style.top = this.$lines.computeLineTop(p.row, e2, this.session) + "px";
              }
          }, this.scrollLines = function(e2) {
            var t2 = this.config;
            this.config = e2;
            if (this.$lines.pageChanged(t2, e2))
              return this.update(e2);
            this.$lines.moveContainer(e2);
            var n2 = e2.lastRow, r2 = t2 ? t2.lastRow : -1;
            if (!t2 || r2 < e2.firstRow)
              return this.update(e2);
            if (n2 < t2.firstRow)
              return this.update(e2);
            if (!t2 || t2.lastRow < e2.firstRow)
              return this.update(e2);
            if (e2.lastRow < t2.firstRow)
              return this.update(e2);
            if (t2.firstRow < e2.firstRow)
              for (var i2 = this.session.getFoldedRowCount(t2.firstRow, e2.firstRow - 1); i2 > 0; i2--)
                this.$lines.shift();
            if (t2.lastRow > e2.lastRow)
              for (var i2 = this.session.getFoldedRowCount(e2.lastRow + 1, t2.lastRow); i2 > 0; i2--)
                this.$lines.pop();
            e2.firstRow < t2.firstRow && this.$lines.unshift(this.$renderLinesFragment(e2, e2.firstRow, t2.firstRow - 1)), e2.lastRow > t2.lastRow && this.$lines.push(this.$renderLinesFragment(e2, t2.lastRow + 1, e2.lastRow));
          }, this.$renderLinesFragment = function(e2, t2, n2) {
            var r2 = [], s2 = t2, o2 = this.session.getNextFoldLine(s2), u2 = o2 ? o2.start.row : Infinity;
            for (; ; ) {
              s2 > u2 && (s2 = o2.end.row + 1, o2 = this.session.getNextFoldLine(s2, o2), u2 = o2 ? o2.start.row : Infinity);
              if (s2 > n2)
                break;
              var a2 = this.$lines.createCell(s2, e2, this.session), f = a2.element;
              this.dom.removeChildren(f), i.setStyle(f.style, "height", this.$lines.computeLineHeight(s2, e2, this.session) + "px"), i.setStyle(f.style, "top", this.$lines.computeLineTop(s2, e2, this.session) + "px"), this.$renderLine(f, s2, s2 == u2 ? o2 : false), this.$useLineGroups() ? f.className = "ace_line_group" : f.className = "ace_line", r2.push(a2), s2++;
            }
            return r2;
          }, this.update = function(e2) {
            this.$lines.moveContainer(e2), this.config = e2;
            var t2 = e2.firstRow, n2 = e2.lastRow, r2 = this.$lines;
            while (r2.getLength())
              r2.pop();
            r2.push(this.$renderLinesFragment(e2, t2, n2));
          }, this.$textToken = { text: true, rparen: true, lparen: true }, this.$renderToken = function(e2, t2, n2, r2) {
            var i2 = this, o2 = /(\t)|( +)|([\x00-\x1f\x80-\xa0\xad\u1680\u180E\u2000-\u200f\u2028\u2029\u202F\u205F\uFEFF\uFFF9-\uFFFC\u2066\u2067\u2068\u202A\u202B\u202D\u202E\u202C\u2069]+)|(\u3000)|([\u1100-\u115F\u11A3-\u11A7\u11FA-\u11FF\u2329-\u232A\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFB\u3001-\u303E\u3041-\u3096\u3099-\u30FF\u3105-\u312D\u3131-\u318E\u3190-\u31BA\u31C0-\u31E3\u31F0-\u321E\u3220-\u3247\u3250-\u32FE\u3300-\u4DBF\u4E00-\uA48C\uA490-\uA4C6\uA960-\uA97C\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFAFF\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE66\uFE68-\uFE6B\uFF01-\uFF60\uFFE0-\uFFE6]|[\uD800-\uDBFF][\uDC00-\uDFFF])/g, u2 = this.dom.createFragment(this.element), a2, f = 0;
            while (a2 = o2.exec(r2)) {
              var l = a2[1], c = a2[2], h = a2[3], p = a2[4], d = a2[5];
              if (!i2.showSpaces && c)
                continue;
              var v = f != a2.index ? r2.slice(f, a2.index) : "";
              f = a2.index + a2[0].length, v && u2.appendChild(this.dom.createTextNode(v, this.element));
              if (l) {
                var m = i2.session.getScreenTabSize(t2 + a2.index);
                u2.appendChild(i2.$tabStrings[m].cloneNode(true)), t2 += m - 1;
              } else if (c)
                if (i2.showSpaces) {
                  var g = this.dom.createElement("span");
                  g.className = "ace_invisible ace_invisible_space", g.textContent = s.stringRepeat(i2.SPACE_CHAR, c.length), u2.appendChild(g);
                } else
                  u2.appendChild(this.com.createTextNode(c, this.element));
              else if (h) {
                var g = this.dom.createElement("span");
                g.className = "ace_invisible ace_invisible_space ace_invalid", g.textContent = s.stringRepeat(i2.SPACE_CHAR, h.length), u2.appendChild(g);
              } else if (p) {
                t2 += 1;
                var g = this.dom.createElement("span");
                g.style.width = i2.config.characterWidth * 2 + "px", g.className = i2.showSpaces ? "ace_cjk ace_invisible ace_invisible_space" : "ace_cjk", g.textContent = i2.showSpaces ? i2.SPACE_CHAR : p, u2.appendChild(g);
              } else if (d) {
                t2 += 1;
                var g = this.dom.createElement("span");
                g.style.width = i2.config.characterWidth * 2 + "px", g.className = "ace_cjk", g.textContent = d, u2.appendChild(g);
              }
            }
            u2.appendChild(this.dom.createTextNode(f ? r2.slice(f) : r2, this.element));
            if (!this.$textToken[n2.type]) {
              var y = "ace_" + n2.type.replace(/\./g, " ace_"), g = this.dom.createElement("span");
              n2.type == "fold" && (g.style.width = n2.value.length * this.config.characterWidth + "px"), g.className = y, g.appendChild(u2), e2.appendChild(g);
            } else
              e2.appendChild(u2);
            return t2 + r2.length;
          }, this.renderIndentGuide = function(e2, t2, n2) {
            var r2 = t2.search(this.$indentGuideRe);
            if (r2 <= 0 || r2 >= n2)
              return t2;
            if (t2[0] == " ") {
              r2 -= r2 % this.tabSize;
              var i2 = r2 / this.tabSize;
              for (var s2 = 0; s2 < i2; s2++)
                e2.appendChild(this.$tabStrings[" "].cloneNode(true));
              return t2.substr(r2);
            }
            if (t2[0] == "	") {
              for (var s2 = 0; s2 < r2; s2++)
                e2.appendChild(this.$tabStrings["	"].cloneNode(true));
              return t2.substr(r2);
            }
            return t2;
          }, this.$createLineElement = function(e2) {
            var t2 = this.dom.createElement("div");
            return t2.className = "ace_line", t2.style.height = this.config.lineHeight + "px", t2;
          }, this.$renderWrappedLine = function(e2, t2, n2) {
            var r2 = 0, i2 = 0, o2 = n2[0], u2 = 0, a2 = this.$createLineElement();
            e2.appendChild(a2);
            for (var f = 0; f < t2.length; f++) {
              var l = t2[f], c = l.value;
              if (f == 0 && this.displayIndentGuides) {
                r2 = c.length, c = this.renderIndentGuide(a2, c, o2);
                if (!c)
                  continue;
                r2 -= c.length;
              }
              if (r2 + c.length < o2)
                u2 = this.$renderToken(a2, u2, l, c), r2 += c.length;
              else {
                while (r2 + c.length >= o2)
                  u2 = this.$renderToken(a2, u2, l, c.substring(0, o2 - r2)), c = c.substring(o2 - r2), r2 = o2, a2 = this.$createLineElement(), e2.appendChild(a2), a2.appendChild(this.dom.createTextNode(s.stringRepeat("\xA0", n2.indent), this.element)), i2++, u2 = 0, o2 = n2[i2] || Number.MAX_VALUE;
                c.length != 0 && (r2 += c.length, u2 = this.$renderToken(a2, u2, l, c));
              }
            }
            n2[n2.length - 1] > this.MAX_LINE_LENGTH && this.$renderOverflowMessage(a2, u2, null, "", true);
          }, this.$renderSimpleLine = function(e2, t2) {
            var n2 = 0;
            for (var r2 = 0; r2 < t2.length; r2++) {
              var i2 = t2[r2], s2 = i2.value;
              if (r2 == 0 && this.displayIndentGuides) {
                s2 = this.renderIndentGuide(e2, s2);
                if (!s2)
                  continue;
              }
              if (n2 + s2.length > this.MAX_LINE_LENGTH)
                return this.$renderOverflowMessage(e2, n2, i2, s2);
              n2 = this.$renderToken(e2, n2, i2, s2);
            }
          }, this.$renderOverflowMessage = function(e2, t2, n2, r2, i2) {
            n2 && this.$renderToken(e2, t2, n2, r2.slice(0, this.MAX_LINE_LENGTH - t2));
            var s2 = this.dom.createElement("span");
            s2.className = "ace_inline_button ace_keyword ace_toggle_wrap", s2.textContent = i2 ? "<hide>" : "<click to see more...>", e2.appendChild(s2);
          }, this.$renderLine = function(e2, t2, n2) {
            !n2 && n2 != 0 && (n2 = this.session.getFoldLine(t2));
            if (n2)
              var r2 = this.$getFoldLineTokens(t2, n2);
            else
              var r2 = this.session.getTokens(t2);
            var i2 = e2;
            if (r2.length) {
              var s2 = this.session.getRowSplitData(t2);
              if (s2 && s2.length) {
                this.$renderWrappedLine(e2, r2, s2);
                var i2 = e2.lastChild;
              } else {
                var i2 = e2;
                this.$useLineGroups() && (i2 = this.$createLineElement(), e2.appendChild(i2)), this.$renderSimpleLine(i2, r2);
              }
            } else
              this.$useLineGroups() && (i2 = this.$createLineElement(), e2.appendChild(i2));
            if (this.showEOL && i2) {
              n2 && (t2 = n2.end.row);
              var o2 = this.dom.createElement("span");
              o2.className = "ace_invisible ace_invisible_eol", o2.textContent = t2 == this.session.getLength() - 1 ? this.EOF_CHAR : this.EOL_CHAR, i2.appendChild(o2);
            }
          }, this.$getFoldLineTokens = function(e2, t2) {
            function i2(e3, t3, n3) {
              var i3 = 0, s3 = 0;
              while (s3 + e3[i3].value.length < t3) {
                s3 += e3[i3].value.length, i3++;
                if (i3 == e3.length)
                  return;
              }
              if (s3 != t3) {
                var o2 = e3[i3].value.substring(t3 - s3);
                o2.length > n3 - t3 && (o2 = o2.substring(0, n3 - t3)), r2.push({ type: e3[i3].type, value: o2 }), s3 = t3 + o2.length, i3 += 1;
              }
              while (s3 < n3 && i3 < e3.length) {
                var o2 = e3[i3].value;
                o2.length + s3 > n3 ? r2.push({ type: e3[i3].type, value: o2.substring(0, n3 - s3) }) : r2.push(e3[i3]), s3 += o2.length, i3 += 1;
              }
            }
            var n2 = this.session, r2 = [], s2 = n2.getTokens(e2);
            return t2.walk(function(e3, t3, o2, u2, a2) {
              e3 != null ? r2.push({ type: "fold", value: e3 }) : (a2 && (s2 = n2.getTokens(t3)), s2.length && i2(s2, u2, o2));
            }, t2.end.row, this.session.getLine(t2.end.row).length), r2;
          }, this.$useLineGroups = function() {
            return this.session.getUseWrapMode();
          }, this.destroy = function() {
          };
        }).call(a.prototype), t.Text = a;
      }), ace.define("ace/layer/cursor", ["require", "exports", "module", "ace/lib/dom"], function(e, t, n) {
        "use strict";
        var r = e("../lib/dom"), i = function(e2) {
          this.element = r.createElement("div"), this.element.className = "ace_layer ace_cursor-layer", e2.appendChild(this.element), this.isVisible = false, this.isBlinking = true, this.blinkInterval = 1e3, this.smoothBlinking = false, this.cursors = [], this.cursor = this.addCursor(), r.addCssClass(this.element, "ace_hidden-cursors"), this.$updateCursors = this.$updateOpacity.bind(this);
        };
        (function() {
          this.$updateOpacity = function(e2) {
            var t2 = this.cursors;
            for (var n2 = t2.length; n2--; )
              r.setStyle(t2[n2].style, "opacity", e2 ? "" : "0");
          }, this.$startCssAnimation = function() {
            var e2 = this.cursors;
            for (var t2 = e2.length; t2--; )
              e2[t2].style.animationDuration = this.blinkInterval + "ms";
            this.$isAnimating = true, setTimeout(function() {
              this.$isAnimating && r.addCssClass(this.element, "ace_animate-blinking");
            }.bind(this));
          }, this.$stopCssAnimation = function() {
            this.$isAnimating = false, r.removeCssClass(this.element, "ace_animate-blinking");
          }, this.$padding = 0, this.setPadding = function(e2) {
            this.$padding = e2;
          }, this.setSession = function(e2) {
            this.session = e2;
          }, this.setBlinking = function(e2) {
            e2 != this.isBlinking && (this.isBlinking = e2, this.restartTimer());
          }, this.setBlinkInterval = function(e2) {
            e2 != this.blinkInterval && (this.blinkInterval = e2, this.restartTimer());
          }, this.setSmoothBlinking = function(e2) {
            e2 != this.smoothBlinking && (this.smoothBlinking = e2, r.setCssClass(this.element, "ace_smooth-blinking", e2), this.$updateCursors(true), this.restartTimer());
          }, this.addCursor = function() {
            var e2 = r.createElement("div");
            return e2.className = "ace_cursor", this.element.appendChild(e2), this.cursors.push(e2), e2;
          }, this.removeCursor = function() {
            if (this.cursors.length > 1) {
              var e2 = this.cursors.pop();
              return e2.parentNode.removeChild(e2), e2;
            }
          }, this.hideCursor = function() {
            this.isVisible = false, r.addCssClass(this.element, "ace_hidden-cursors"), this.restartTimer();
          }, this.showCursor = function() {
            this.isVisible = true, r.removeCssClass(this.element, "ace_hidden-cursors"), this.restartTimer();
          }, this.restartTimer = function() {
            var e2 = this.$updateCursors;
            clearInterval(this.intervalId), clearTimeout(this.timeoutId), this.$stopCssAnimation(), this.smoothBlinking && (this.$isSmoothBlinking = false, r.removeCssClass(this.element, "ace_smooth-blinking")), e2(true);
            if (!this.isBlinking || !this.blinkInterval || !this.isVisible) {
              this.$stopCssAnimation();
              return;
            }
            this.smoothBlinking && (this.$isSmoothBlinking = true, setTimeout(function() {
              this.$isSmoothBlinking && r.addCssClass(this.element, "ace_smooth-blinking");
            }.bind(this)));
            if (r.HAS_CSS_ANIMATION)
              this.$startCssAnimation();
            else {
              var t2 = function() {
                this.timeoutId = setTimeout(function() {
                  e2(false);
                }, 0.6 * this.blinkInterval);
              }.bind(this);
              this.intervalId = setInterval(function() {
                e2(true), t2();
              }, this.blinkInterval), t2();
            }
          }, this.getPixelPosition = function(e2, t2) {
            if (!this.config || !this.session)
              return { left: 0, top: 0 };
            e2 || (e2 = this.session.selection.getCursor());
            var n2 = this.session.documentToScreenPosition(e2), r2 = this.$padding + (this.session.$bidiHandler.isBidiRow(n2.row, e2.row) ? this.session.$bidiHandler.getPosLeft(n2.column) : n2.column * this.config.characterWidth), i2 = (n2.row - (t2 ? this.config.firstRowScreen : 0)) * this.config.lineHeight;
            return { left: r2, top: i2 };
          }, this.isCursorInView = function(e2, t2) {
            return e2.top >= 0 && e2.top < t2.maxHeight;
          }, this.update = function(e2) {
            this.config = e2;
            var t2 = this.session.$selectionMarkers, n2 = 0, i2 = 0;
            if (t2 === void 0 || t2.length === 0)
              t2 = [{ cursor: null }];
            for (var n2 = 0, s = t2.length; n2 < s; n2++) {
              var o = this.getPixelPosition(t2[n2].cursor, true);
              if ((o.top > e2.height + e2.offset || o.top < 0) && n2 > 1)
                continue;
              var u = this.cursors[i2++] || this.addCursor(), a = u.style;
              this.drawCursor ? this.drawCursor(u, o, e2, t2[n2], this.session) : this.isCursorInView(o, e2) ? (r.setStyle(a, "display", "block"), r.translate(u, o.left, o.top), r.setStyle(a, "width", Math.round(e2.characterWidth) + "px"), r.setStyle(a, "height", e2.lineHeight + "px")) : r.setStyle(a, "display", "none");
            }
            while (this.cursors.length > i2)
              this.removeCursor();
            var f = this.session.getOverwrite();
            this.$setOverwrite(f), this.$pixelPos = o, this.restartTimer();
          }, this.drawCursor = null, this.$setOverwrite = function(e2) {
            e2 != this.overwrite && (this.overwrite = e2, e2 ? r.addCssClass(this.element, "ace_overwrite-cursors") : r.removeCssClass(this.element, "ace_overwrite-cursors"));
          }, this.destroy = function() {
            clearInterval(this.intervalId), clearTimeout(this.timeoutId);
          };
        }).call(i.prototype), t.Cursor = i;
      }), ace.define("ace/scrollbar", ["require", "exports", "module", "ace/lib/oop", "ace/lib/dom", "ace/lib/event", "ace/lib/event_emitter"], function(e, t, n) {
        "use strict";
        var r = e("./lib/oop"), i = e("./lib/dom"), s = e("./lib/event"), o = e("./lib/event_emitter").EventEmitter, u = 32768, a = function(e2) {
          this.element = i.createElement("div"), this.element.className = "ace_scrollbar ace_scrollbar" + this.classSuffix, this.inner = i.createElement("div"), this.inner.className = "ace_scrollbar-inner", this.inner.textContent = "\xA0", this.element.appendChild(this.inner), e2.appendChild(this.element), this.setVisible(false), this.skipEvent = false, s.addListener(this.element, "scroll", this.onScroll.bind(this)), s.addListener(this.element, "mousedown", s.preventDefault);
        };
        (function() {
          r.implement(this, o), this.setVisible = function(e2) {
            this.element.style.display = e2 ? "" : "none", this.isVisible = e2, this.coeff = 1;
          };
        }).call(a.prototype);
        var f = function(e2, t2) {
          a.call(this, e2), this.scrollTop = 0, this.scrollHeight = 0, t2.$scrollbarWidth = this.width = i.scrollbarWidth(e2.ownerDocument), this.inner.style.width = this.element.style.width = (this.width || 15) + 5 + "px", this.$minWidth = 0;
        };
        r.inherits(f, a), function() {
          this.classSuffix = "-v", this.onScroll = function() {
            if (!this.skipEvent) {
              this.scrollTop = this.element.scrollTop;
              if (this.coeff != 1) {
                var e2 = this.element.clientHeight / this.scrollHeight;
                this.scrollTop = this.scrollTop * (1 - e2) / (this.coeff - e2);
              }
              this._emit("scroll", { data: this.scrollTop });
            }
            this.skipEvent = false;
          }, this.getWidth = function() {
            return Math.max(this.isVisible ? this.width : 0, this.$minWidth || 0);
          }, this.setHeight = function(e2) {
            this.element.style.height = e2 + "px";
          }, this.setInnerHeight = this.setScrollHeight = function(e2) {
            this.scrollHeight = e2, e2 > u ? (this.coeff = u / e2, e2 = u) : this.coeff != 1 && (this.coeff = 1), this.inner.style.height = e2 + "px";
          }, this.setScrollTop = function(e2) {
            this.scrollTop != e2 && (this.skipEvent = true, this.scrollTop = e2, this.element.scrollTop = e2 * this.coeff);
          };
        }.call(f.prototype);
        var l = function(e2, t2) {
          a.call(this, e2), this.scrollLeft = 0, this.height = t2.$scrollbarWidth, this.inner.style.height = this.element.style.height = (this.height || 15) + 5 + "px";
        };
        r.inherits(l, a), function() {
          this.classSuffix = "-h", this.onScroll = function() {
            this.skipEvent || (this.scrollLeft = this.element.scrollLeft, this._emit("scroll", { data: this.scrollLeft })), this.skipEvent = false;
          }, this.getHeight = function() {
            return this.isVisible ? this.height : 0;
          }, this.setWidth = function(e2) {
            this.element.style.width = e2 + "px";
          }, this.setInnerWidth = function(e2) {
            this.inner.style.width = e2 + "px";
          }, this.setScrollWidth = function(e2) {
            this.inner.style.width = e2 + "px";
          }, this.setScrollLeft = function(e2) {
            this.scrollLeft != e2 && (this.skipEvent = true, this.scrollLeft = this.element.scrollLeft = e2);
          };
        }.call(l.prototype), t.ScrollBar = f, t.ScrollBarV = f, t.ScrollBarH = l, t.VScrollBar = f, t.HScrollBar = l;
      }), ace.define("ace/renderloop", ["require", "exports", "module", "ace/lib/event"], function(e, t, n) {
        "use strict";
        var r = e("./lib/event"), i = function(e2, t2) {
          this.onRender = e2, this.pending = false, this.changes = 0, this.$recursionLimit = 2, this.window = t2 || window;
          var n2 = this;
          this._flush = function(e3) {
            n2.pending = false;
            var t3 = n2.changes;
            t3 && (r.blockIdle(100), n2.changes = 0, n2.onRender(t3));
            if (n2.changes) {
              if (n2.$recursionLimit-- < 0)
                return;
              n2.schedule();
            } else
              n2.$recursionLimit = 2;
          };
        };
        (function() {
          this.schedule = function(e2) {
            this.changes = this.changes | e2, this.changes && !this.pending && (r.nextFrame(this._flush), this.pending = true);
          }, this.clear = function(e2) {
            var t2 = this.changes;
            return this.changes = 0, t2;
          };
        }).call(i.prototype), t.RenderLoop = i;
      }), ace.define("ace/layer/font_metrics", ["require", "exports", "module", "ace/lib/oop", "ace/lib/dom", "ace/lib/lang", "ace/lib/event", "ace/lib/useragent", "ace/lib/event_emitter"], function(e, t, n) {
        var r = e("../lib/oop"), i = e("../lib/dom"), s = e("../lib/lang"), o = e("../lib/event"), u = e("../lib/useragent"), a = e("../lib/event_emitter").EventEmitter, f = 256, l = typeof ResizeObserver == "function", c = 200, h = t.FontMetrics = function(e2) {
          this.el = i.createElement("div"), this.$setMeasureNodeStyles(this.el.style, true), this.$main = i.createElement("div"), this.$setMeasureNodeStyles(this.$main.style), this.$measureNode = i.createElement("div"), this.$setMeasureNodeStyles(this.$measureNode.style), this.el.appendChild(this.$main), this.el.appendChild(this.$measureNode), e2.appendChild(this.el), this.$measureNode.textContent = s.stringRepeat("X", f), this.$characterSize = { width: 0, height: 0 }, l ? this.$addObserver() : this.checkForSizeChanges();
        };
        (function() {
          r.implement(this, a), this.$characterSize = { width: 0, height: 0 }, this.$setMeasureNodeStyles = function(e2, t2) {
            e2.width = e2.height = "auto", e2.left = e2.top = "0px", e2.visibility = "hidden", e2.position = "absolute", e2.whiteSpace = "pre", u.isIE < 8 ? e2["font-family"] = "inherit" : e2.font = "inherit", e2.overflow = t2 ? "hidden" : "visible";
          }, this.checkForSizeChanges = function(e2) {
            e2 === void 0 && (e2 = this.$measureSizes());
            if (e2 && (this.$characterSize.width !== e2.width || this.$characterSize.height !== e2.height)) {
              this.$measureNode.style.fontWeight = "bold";
              var t2 = this.$measureSizes();
              this.$measureNode.style.fontWeight = "", this.$characterSize = e2, this.charSizes = /* @__PURE__ */ Object.create(null), this.allowBoldFonts = t2 && t2.width === e2.width && t2.height === e2.height, this._emit("changeCharacterSize", { data: e2 });
            }
          }, this.$addObserver = function() {
            var e2 = this;
            this.$observer = new window.ResizeObserver(function(t2) {
              e2.checkForSizeChanges();
            }), this.$observer.observe(this.$measureNode);
          }, this.$pollSizeChanges = function() {
            if (this.$pollSizeChangesTimer || this.$observer)
              return this.$pollSizeChangesTimer;
            var e2 = this;
            return this.$pollSizeChangesTimer = o.onIdle(function t2() {
              e2.checkForSizeChanges(), o.onIdle(t2, 500);
            }, 500);
          }, this.setPolling = function(e2) {
            e2 ? this.$pollSizeChanges() : this.$pollSizeChangesTimer && (clearInterval(this.$pollSizeChangesTimer), this.$pollSizeChangesTimer = 0);
          }, this.$measureSizes = function(e2) {
            var t2 = { height: (e2 || this.$measureNode).clientHeight, width: (e2 || this.$measureNode).clientWidth / f };
            return t2.width === 0 || t2.height === 0 ? null : t2;
          }, this.$measureCharWidth = function(e2) {
            this.$main.textContent = s.stringRepeat(e2, f);
            var t2 = this.$main.getBoundingClientRect();
            return t2.width / f;
          }, this.getCharacterWidth = function(e2) {
            var t2 = this.charSizes[e2];
            return t2 === void 0 && (t2 = this.charSizes[e2] = this.$measureCharWidth(e2) / this.$characterSize.width), t2;
          }, this.destroy = function() {
            clearInterval(this.$pollSizeChangesTimer), this.$observer && this.$observer.disconnect(), this.el && this.el.parentNode && this.el.parentNode.removeChild(this.el);
          }, this.$getZoom = function e2(t2) {
            return !t2 || !t2.parentElement ? 1 : (window.getComputedStyle(t2).zoom || 1) * e2(t2.parentElement);
          }, this.$initTransformMeasureNodes = function() {
            var e2 = function(e3, t2) {
              return ["div", { style: "position: absolute;top:" + e3 + "px;left:" + t2 + "px;" }];
            };
            this.els = i.buildDom([e2(0, 0), e2(c, 0), e2(0, c), e2(c, c)], this.el);
          }, this.transformCoordinates = function(e2, t2) {
            function r2(e3, t3, n3) {
              var r3 = e3[1] * t3[0] - e3[0] * t3[1];
              return [(-t3[1] * n3[0] + t3[0] * n3[1]) / r3, (+e3[1] * n3[0] - e3[0] * n3[1]) / r3];
            }
            function i2(e3, t3) {
              return [e3[0] - t3[0], e3[1] - t3[1]];
            }
            function s2(e3, t3) {
              return [e3[0] + t3[0], e3[1] + t3[1]];
            }
            function o2(e3, t3) {
              return [e3 * t3[0], e3 * t3[1]];
            }
            function u2(e3) {
              var t3 = e3.getBoundingClientRect();
              return [t3.left, t3.top];
            }
            if (e2) {
              var n2 = this.$getZoom(this.el);
              e2 = o2(1 / n2, e2);
            }
            this.els || this.$initTransformMeasureNodes();
            var a2 = u2(this.els[0]), f2 = u2(this.els[1]), l2 = u2(this.els[2]), h2 = u2(this.els[3]), p = r2(i2(h2, f2), i2(h2, l2), i2(s2(f2, l2), s2(h2, a2))), d = o2(1 + p[0], i2(f2, a2)), v = o2(1 + p[1], i2(l2, a2));
            if (t2) {
              var m = t2, g = p[0] * m[0] / c + p[1] * m[1] / c + 1, y = s2(o2(m[0], d), o2(m[1], v));
              return s2(o2(1 / g / c, y), a2);
            }
            var b = i2(e2, a2), w = r2(i2(d, o2(p[0], b)), i2(v, o2(p[1], b)), b);
            return o2(c, w);
          };
        }).call(h.prototype);
      }), ace.define("ace/virtual_renderer", ["require", "exports", "module", "ace/lib/oop", "ace/lib/dom", "ace/config", "ace/layer/gutter", "ace/layer/marker", "ace/layer/text", "ace/layer/cursor", "ace/scrollbar", "ace/scrollbar", "ace/renderloop", "ace/layer/font_metrics", "ace/lib/event_emitter", "ace/lib/useragent"], function(e, t, n) {
        "use strict";
        var r = e("./lib/oop"), i = e("./lib/dom"), s = e("./config"), o = e("./layer/gutter").Gutter, u = e("./layer/marker").Marker, a = e("./layer/text").Text, f = e("./layer/cursor").Cursor, l = e("./scrollbar").HScrollBar, c = e("./scrollbar").VScrollBar, h = e("./renderloop").RenderLoop, p = e("./layer/font_metrics").FontMetrics, d = e("./lib/event_emitter").EventEmitter, v = `.ace_br1 {border-top-left-radius    : 3px;}.ace_br2 {border-top-right-radius   : 3px;}.ace_br3 {border-top-left-radius    : 3px; border-top-right-radius:    3px;}.ace_br4 {border-bottom-right-radius: 3px;}.ace_br5 {border-top-left-radius    : 3px; border-bottom-right-radius: 3px;}.ace_br6 {border-top-right-radius   : 3px; border-bottom-right-radius: 3px;}.ace_br7 {border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-right-radius: 3px;}.ace_br8 {border-bottom-left-radius : 3px;}.ace_br9 {border-top-left-radius    : 3px; border-bottom-left-radius:  3px;}.ace_br10{border-top-right-radius   : 3px; border-bottom-left-radius:  3px;}.ace_br11{border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-left-radius:  3px;}.ace_br12{border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}.ace_br13{border-top-left-radius    : 3px; border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}.ace_br14{border-top-right-radius   : 3px; border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}.ace_br15{border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-right-radius: 3px; border-bottom-left-radius: 3px;}.ace_editor {position: relative;overflow: hidden;padding: 0;font: 12px/normal 'Monaco', 'Menlo', 'Ubuntu Mono', 'Consolas', 'source-code-pro', monospace;direction: ltr;text-align: left;-webkit-tap-highlight-color: rgba(0, 0, 0, 0);}.ace_scroller {position: absolute;overflow: hidden;top: 0;bottom: 0;background-color: inherit;-ms-user-select: none;-moz-user-select: none;-webkit-user-select: none;user-select: none;cursor: text;}.ace_content {position: absolute;box-sizing: border-box;min-width: 100%;contain: style size layout;font-variant-ligatures: no-common-ligatures;}.ace_dragging .ace_scroller:before{position: absolute;top: 0;left: 0;right: 0;bottom: 0;content: '';background: rgba(250, 250, 250, 0.01);z-index: 1000;}.ace_dragging.ace_dark .ace_scroller:before{background: rgba(0, 0, 0, 0.01);}.ace_gutter {position: absolute;overflow : hidden;width: auto;top: 0;bottom: 0;left: 0;cursor: default;z-index: 4;-ms-user-select: none;-moz-user-select: none;-webkit-user-select: none;user-select: none;contain: style size layout;}.ace_gutter-active-line {position: absolute;left: 0;right: 0;}.ace_scroller.ace_scroll-left {box-shadow: 17px 0 16px -16px rgba(0, 0, 0, 0.4) inset;}.ace_gutter-cell {position: absolute;top: 0;left: 0;right: 0;padding-left: 19px;padding-right: 6px;background-repeat: no-repeat;}.ace_gutter-cell.ace_error {background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAABOFBMVEX/////////QRswFAb/Ui4wFAYwFAYwFAaWGAfDRymzOSH/PxswFAb/SiUwFAYwFAbUPRvjQiDllog5HhHdRybsTi3/Tyv9Tir+Syj/UC3////XurebMBIwFAb/RSHbPx/gUzfdwL3kzMivKBAwFAbbvbnhPx66NhowFAYwFAaZJg8wFAaxKBDZurf/RB6mMxb/SCMwFAYwFAbxQB3+RB4wFAb/Qhy4Oh+4QifbNRcwFAYwFAYwFAb/QRzdNhgwFAYwFAbav7v/Uy7oaE68MBK5LxLewr/r2NXewLswFAaxJw4wFAbkPRy2PyYwFAaxKhLm1tMwFAazPiQwFAaUGAb/QBrfOx3bvrv/VC/maE4wFAbRPBq6MRO8Qynew8Dp2tjfwb0wFAbx6eju5+by6uns4uH9/f36+vr/GkHjAAAAYnRSTlMAGt+64rnWu/bo8eAA4InH3+DwoN7j4eLi4xP99Nfg4+b+/u9B/eDs1MD1mO7+4PHg2MXa347g7vDizMLN4eG+Pv7i5evs/v79yu7S3/DV7/498Yv24eH+4ufQ3Ozu/v7+y13sRqwAAADLSURBVHjaZc/XDsFgGIBhtDrshlitmk2IrbHFqL2pvXf/+78DPokj7+Fz9qpU/9UXJIlhmPaTaQ6QPaz0mm+5gwkgovcV6GZzd5JtCQwgsxoHOvJO15kleRLAnMgHFIESUEPmawB9ngmelTtipwwfASilxOLyiV5UVUyVAfbG0cCPHig+GBkzAENHS0AstVF6bacZIOzgLmxsHbt2OecNgJC83JERmePUYq8ARGkJx6XtFsdddBQgZE2nPR6CICZhawjA4Fb/chv+399kfR+MMMDGOQAAAABJRU5ErkJggg==");background-repeat: no-repeat;background-position: 2px center;}.ace_gutter-cell.ace_warning {background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAmVBMVEX///8AAAD///8AAAAAAABPSzb/5sAAAAB/blH/73z/ulkAAAAAAAD85pkAAAAAAAACAgP/vGz/rkDerGbGrV7/pkQICAf////e0IsAAAD/oED/qTvhrnUAAAD/yHD/njcAAADuv2r/nz//oTj/p064oGf/zHAAAAA9Nir/tFIAAAD/tlTiuWf/tkIAAACynXEAAAAAAAAtIRW7zBpBAAAAM3RSTlMAABR1m7RXO8Ln31Z36zT+neXe5OzooRDfn+TZ4p3h2hTf4t3k3ucyrN1K5+Xaks52Sfs9CXgrAAAAjklEQVR42o3PbQ+CIBQFYEwboPhSYgoYunIqqLn6/z8uYdH8Vmdnu9vz4WwXgN/xTPRD2+sgOcZjsge/whXZgUaYYvT8QnuJaUrjrHUQreGczuEafQCO/SJTufTbroWsPgsllVhq3wJEk2jUSzX3CUEDJC84707djRc5MTAQxoLgupWRwW6UB5fS++NV8AbOZgnsC7BpEAAAAABJRU5ErkJggg==");background-position: 2px center;}.ace_gutter-cell.ace_info {background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAAAAAA6mKC9AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAAJ0Uk5TAAB2k804AAAAPklEQVQY02NgIB68QuO3tiLznjAwpKTgNyDbMegwisCHZUETUZV0ZqOquBpXj2rtnpSJT1AEnnRmL2OgGgAAIKkRQap2htgAAAAASUVORK5CYII=");background-position: 2px center;}.ace_dark .ace_gutter-cell.ace_info {background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQBAMAAADt3eJSAAAAJFBMVEUAAAChoaGAgIAqKiq+vr6tra1ZWVmUlJSbm5s8PDxubm56enrdgzg3AAAAAXRSTlMAQObYZgAAAClJREFUeNpjYMAPdsMYHegyJZFQBlsUlMFVCWUYKkAZMxZAGdxlDMQBAG+TBP4B6RyJAAAAAElFTkSuQmCC");}.ace_scrollbar {contain: strict;position: absolute;right: 0;bottom: 0;z-index: 6;}.ace_scrollbar-inner {position: absolute;cursor: text;left: 0;top: 0;}.ace_scrollbar-v{overflow-x: hidden;overflow-y: scroll;top: 0;}.ace_scrollbar-h {overflow-x: scroll;overflow-y: hidden;left: 0;}.ace_print-margin {position: absolute;height: 100%;}.ace_text-input {position: absolute;z-index: 0;width: 0.5em;height: 1em;opacity: 0;background: transparent;-moz-appearance: none;appearance: none;border: none;resize: none;outline: none;overflow: hidden;font: inherit;padding: 0 1px;margin: 0 -1px;contain: strict;-ms-user-select: text;-moz-user-select: text;-webkit-user-select: text;user-select: text;white-space: pre!important;}.ace_text-input.ace_composition {background: transparent;color: inherit;z-index: 1000;opacity: 1;}.ace_composition_placeholder { color: transparent }.ace_composition_marker { border-bottom: 1px solid;position: absolute;border-radius: 0;margin-top: 1px;}[ace_nocontext=true] {transform: none!important;filter: none!important;clip-path: none!important;mask : none!important;contain: none!important;perspective: none!important;mix-blend-mode: initial!important;z-index: auto;}.ace_layer {z-index: 1;position: absolute;overflow: hidden;word-wrap: normal;white-space: pre;height: 100%;width: 100%;box-sizing: border-box;pointer-events: none;}.ace_gutter-layer {position: relative;width: auto;text-align: right;pointer-events: auto;height: 1000000px;contain: style size layout;}.ace_text-layer {font: inherit !important;position: absolute;height: 1000000px;width: 1000000px;contain: style size layout;}.ace_text-layer > .ace_line, .ace_text-layer > .ace_line_group {contain: style size layout;position: absolute;top: 0;left: 0;right: 0;}.ace_hidpi .ace_text-layer,.ace_hidpi .ace_gutter-layer,.ace_hidpi .ace_content,.ace_hidpi .ace_gutter {contain: strict;will-change: transform;}.ace_hidpi .ace_text-layer > .ace_line, .ace_hidpi .ace_text-layer > .ace_line_group {contain: strict;}.ace_cjk {display: inline-block;text-align: center;}.ace_cursor-layer {z-index: 4;}.ace_cursor {z-index: 4;position: absolute;box-sizing: border-box;border-left: 2px solid;transform: translatez(0);}.ace_multiselect .ace_cursor {border-left-width: 1px;}.ace_slim-cursors .ace_cursor {border-left-width: 1px;}.ace_overwrite-cursors .ace_cursor {border-left-width: 0;border-bottom: 1px solid;}.ace_hidden-cursors .ace_cursor {opacity: 0.2;}.ace_hasPlaceholder .ace_hidden-cursors .ace_cursor {opacity: 0;}.ace_smooth-blinking .ace_cursor {transition: opacity 0.18s;}.ace_animate-blinking .ace_cursor {animation-duration: 1000ms;animation-timing-function: step-end;animation-name: blink-ace-animate;animation-iteration-count: infinite;}.ace_animate-blinking.ace_smooth-blinking .ace_cursor {animation-duration: 1000ms;animation-timing-function: ease-in-out;animation-name: blink-ace-animate-smooth;}@keyframes blink-ace-animate {from, to { opacity: 1; }60% { opacity: 0; }}@keyframes blink-ace-animate-smooth {from, to { opacity: 1; }45% { opacity: 1; }60% { opacity: 0; }85% { opacity: 0; }}.ace_marker-layer .ace_step, .ace_marker-layer .ace_stack {position: absolute;z-index: 3;}.ace_marker-layer .ace_selection {position: absolute;z-index: 5;}.ace_marker-layer .ace_bracket {position: absolute;z-index: 6;}.ace_marker-layer .ace_error_bracket {position: absolute;border-bottom: 1px solid #DE5555;border-radius: 0;}.ace_marker-layer .ace_active-line {position: absolute;z-index: 2;}.ace_marker-layer .ace_selected-word {position: absolute;z-index: 4;box-sizing: border-box;}.ace_line .ace_fold {box-sizing: border-box;display: inline-block;height: 11px;margin-top: -2px;vertical-align: middle;background-image:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAJCAYAAADU6McMAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJpJREFUeNpi/P//PwOlgAXGYGRklAVSokD8GmjwY1wasKljQpYACtpCFeADcHVQfQyMQAwzwAZI3wJKvCLkfKBaMSClBlR7BOQikCFGQEErIH0VqkabiGCAqwUadAzZJRxQr/0gwiXIal8zQQPnNVTgJ1TdawL0T5gBIP1MUJNhBv2HKoQHHjqNrA4WO4zY0glyNKLT2KIfIMAAQsdgGiXvgnYAAAAASUVORK5CYII="),url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAA3CAYAAADNNiA5AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAACJJREFUeNpi+P//fxgTAwPDBxDxD078RSX+YeEyDFMCIMAAI3INmXiwf2YAAAAASUVORK5CYII=");background-repeat: no-repeat, repeat-x;background-position: center center, top left;color: transparent;border: 1px solid black;border-radius: 2px;cursor: pointer;pointer-events: auto;}.ace_dark .ace_fold {}.ace_fold:hover{background-image:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAJCAYAAADU6McMAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJpJREFUeNpi/P//PwOlgAXGYGRklAVSokD8GmjwY1wasKljQpYACtpCFeADcHVQfQyMQAwzwAZI3wJKvCLkfKBaMSClBlR7BOQikCFGQEErIH0VqkabiGCAqwUadAzZJRxQr/0gwiXIal8zQQPnNVTgJ1TdawL0T5gBIP1MUJNhBv2HKoQHHjqNrA4WO4zY0glyNKLT2KIfIMAAQsdgGiXvgnYAAAAASUVORK5CYII="),url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAA3CAYAAADNNiA5AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAACBJREFUeNpi+P//fz4TAwPDZxDxD5X4i5fLMEwJgAADAEPVDbjNw87ZAAAAAElFTkSuQmCC");}.ace_tooltip {background-color: #FFF;background-image: linear-gradient(to bottom, transparent, rgba(0, 0, 0, 0.1));border: 1px solid gray;border-radius: 1px;box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);color: black;max-width: 100%;padding: 3px 4px;position: fixed;z-index: 999999;box-sizing: border-box;cursor: default;white-space: pre;word-wrap: break-word;line-height: normal;font-style: normal;font-weight: normal;letter-spacing: normal;pointer-events: none;}.ace_folding-enabled > .ace_gutter-cell {padding-right: 13px;}.ace_fold-widget {box-sizing: border-box;margin: 0 -12px 0 1px;display: none;width: 11px;vertical-align: top;background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAANElEQVR42mWKsQ0AMAzC8ixLlrzQjzmBiEjp0A6WwBCSPgKAXoLkqSot7nN3yMwR7pZ32NzpKkVoDBUxKAAAAABJRU5ErkJggg==");background-repeat: no-repeat;background-position: center;border-radius: 3px;border: 1px solid transparent;cursor: pointer;}.ace_folding-enabled .ace_fold-widget {display: inline-block;   }.ace_fold-widget.ace_end {background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAANElEQVR42m3HwQkAMAhD0YzsRchFKI7sAikeWkrxwScEB0nh5e7KTPWimZki4tYfVbX+MNl4pyZXejUO1QAAAABJRU5ErkJggg==");}.ace_fold-widget.ace_closed {background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAGCAYAAAAG5SQMAAAAOUlEQVR42jXKwQkAMAgDwKwqKD4EwQ26sSOkVWjgIIHAzPiCgaqiqnJHZnKICBERHN194O5b9vbLuAVRL+l0YWnZAAAAAElFTkSuQmCCXA==");}.ace_fold-widget:hover {border: 1px solid rgba(0, 0, 0, 0.3);background-color: rgba(255, 255, 255, 0.2);box-shadow: 0 1px 1px rgba(255, 255, 255, 0.7);}.ace_fold-widget:active {border: 1px solid rgba(0, 0, 0, 0.4);background-color: rgba(0, 0, 0, 0.05);box-shadow: 0 1px 1px rgba(255, 255, 255, 0.8);}.ace_dark .ace_fold-widget {background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHklEQVQIW2P4//8/AzoGEQ7oGCaLLAhWiSwB146BAQCSTPYocqT0AAAAAElFTkSuQmCC");}.ace_dark .ace_fold-widget.ace_end {background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAH0lEQVQIW2P4//8/AxQ7wNjIAjDMgC4AxjCVKBirIAAF0kz2rlhxpAAAAABJRU5ErkJggg==");}.ace_dark .ace_fold-widget.ace_closed {background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAFCAYAAACAcVaiAAAAHElEQVQIW2P4//+/AxAzgDADlOOAznHAKgPWAwARji8UIDTfQQAAAABJRU5ErkJggg==");}.ace_dark .ace_fold-widget:hover {box-shadow: 0 1px 1px rgba(255, 255, 255, 0.2);background-color: rgba(255, 255, 255, 0.1);}.ace_dark .ace_fold-widget:active {box-shadow: 0 1px 1px rgba(255, 255, 255, 0.2);}.ace_inline_button {border: 1px solid lightgray;display: inline-block;margin: -1px 8px;padding: 0 5px;pointer-events: auto;cursor: pointer;}.ace_inline_button:hover {border-color: gray;background: rgba(200,200,200,0.2);display: inline-block;pointer-events: auto;}.ace_fold-widget.ace_invalid {background-color: #FFB4B4;border-color: #DE5555;}.ace_fade-fold-widgets .ace_fold-widget {transition: opacity 0.4s ease 0.05s;opacity: 0;}.ace_fade-fold-widgets:hover .ace_fold-widget {transition: opacity 0.05s ease 0.05s;opacity:1;}.ace_underline {text-decoration: underline;}.ace_bold {font-weight: bold;}.ace_nobold .ace_bold {font-weight: normal;}.ace_italic {font-style: italic;}.ace_error-marker {background-color: rgba(255, 0, 0,0.2);position: absolute;z-index: 9;}.ace_highlight-marker {background-color: rgba(255, 255, 0,0.2);position: absolute;z-index: 8;}.ace_mobile-menu {position: absolute;line-height: 1.5;border-radius: 4px;-ms-user-select: none;-moz-user-select: none;-webkit-user-select: none;user-select: none;background: white;box-shadow: 1px 3px 2px grey;border: 1px solid #dcdcdc;color: black;}.ace_dark > .ace_mobile-menu {background: #333;color: #ccc;box-shadow: 1px 3px 2px grey;border: 1px solid #444;}.ace_mobile-button {padding: 2px;cursor: pointer;overflow: hidden;}.ace_mobile-button:hover {background-color: #eee;opacity:1;}.ace_mobile-button:active {background-color: #ddd;}.ace_placeholder {font-family: arial;transform: scale(0.9);transform-origin: left;white-space: pre;opacity: 0.7;margin: 0 10px;}`, m = e("./lib/useragent"), g = m.isIE;
        i.importCssString(v, "ace_editor.css", false);
        var y = function(e2, t2) {
          var n2 = this;
          this.container = e2 || i.createElement("div"), i.addCssClass(this.container, "ace_editor"), i.HI_DPI && i.addCssClass(this.container, "ace_hidpi"), this.setTheme(t2), s.get("useStrictCSP") == null && s.set("useStrictCSP", false), this.$gutter = i.createElement("div"), this.$gutter.className = "ace_gutter", this.container.appendChild(this.$gutter), this.$gutter.setAttribute("aria-hidden", true), this.scroller = i.createElement("div"), this.scroller.className = "ace_scroller", this.container.appendChild(this.scroller), this.content = i.createElement("div"), this.content.className = "ace_content", this.scroller.appendChild(this.content), this.$gutterLayer = new o(this.$gutter), this.$gutterLayer.on("changeGutterWidth", this.onGutterResize.bind(this)), this.$markerBack = new u(this.content);
          var r2 = this.$textLayer = new a(this.content);
          this.canvas = r2.element, this.$markerFront = new u(this.content), this.$cursorLayer = new f(this.content), this.$horizScroll = false, this.$vScroll = false, this.scrollBar = this.scrollBarV = new c(this.container, this), this.scrollBarH = new l(this.container, this), this.scrollBarV.on("scroll", function(e3) {
            n2.$scrollAnimation || n2.session.setScrollTop(e3.data - n2.scrollMargin.top);
          }), this.scrollBarH.on("scroll", function(e3) {
            n2.$scrollAnimation || n2.session.setScrollLeft(e3.data - n2.scrollMargin.left);
          }), this.scrollTop = 0, this.scrollLeft = 0, this.cursorPos = { row: 0, column: 0 }, this.$fontMetrics = new p(this.container), this.$textLayer.$setFontMetrics(this.$fontMetrics), this.$textLayer.on("changeCharacterSize", function(e3) {
            n2.updateCharacterSize(), n2.onResize(true, n2.gutterWidth, n2.$size.width, n2.$size.height), n2._signal("changeCharacterSize", e3);
          }), this.$size = { width: 0, height: 0, scrollerHeight: 0, scrollerWidth: 0, $dirty: true }, this.layerConfig = { width: 1, padding: 0, firstRow: 0, firstRowScreen: 0, lastRow: 0, lineHeight: 0, characterWidth: 0, minHeight: 1, maxHeight: 1, offset: 0, height: 1, gutterOffset: 1 }, this.scrollMargin = { left: 0, right: 0, top: 0, bottom: 0, v: 0, h: 0 }, this.margin = { left: 0, right: 0, top: 0, bottom: 0, v: 0, h: 0 }, this.$keepTextAreaAtCursor = !m.isIOS, this.$loop = new h(this.$renderChanges.bind(this), this.container.ownerDocument.defaultView), this.$loop.schedule(this.CHANGE_FULL), this.updateCharacterSize(), this.setPadding(4), s.resetOptions(this), s._signal("renderer", this);
        };
        (function() {
          this.CHANGE_CURSOR = 1, this.CHANGE_MARKER = 2, this.CHANGE_GUTTER = 4, this.CHANGE_SCROLL = 8, this.CHANGE_LINES = 16, this.CHANGE_TEXT = 32, this.CHANGE_SIZE = 64, this.CHANGE_MARKER_BACK = 128, this.CHANGE_MARKER_FRONT = 256, this.CHANGE_FULL = 512, this.CHANGE_H_SCROLL = 1024, r.implement(this, d), this.updateCharacterSize = function() {
            this.$textLayer.allowBoldFonts != this.$allowBoldFonts && (this.$allowBoldFonts = this.$textLayer.allowBoldFonts, this.setStyle("ace_nobold", !this.$allowBoldFonts)), this.layerConfig.characterWidth = this.characterWidth = this.$textLayer.getCharacterWidth(), this.layerConfig.lineHeight = this.lineHeight = this.$textLayer.getLineHeight(), this.$updatePrintMargin(), i.setStyle(this.scroller.style, "line-height", this.lineHeight + "px");
          }, this.setSession = function(e2) {
            this.session && this.session.doc.off("changeNewLineMode", this.onChangeNewLineMode), this.session = e2, e2 && this.scrollMargin.top && e2.getScrollTop() <= 0 && e2.setScrollTop(-this.scrollMargin.top), this.$cursorLayer.setSession(e2), this.$markerBack.setSession(e2), this.$markerFront.setSession(e2), this.$gutterLayer.setSession(e2), this.$textLayer.setSession(e2);
            if (!e2)
              return;
            this.$loop.schedule(this.CHANGE_FULL), this.session.$setFontMetrics(this.$fontMetrics), this.scrollBarH.scrollLeft = this.scrollBarV.scrollTop = null, this.onChangeNewLineMode = this.onChangeNewLineMode.bind(this), this.onChangeNewLineMode(), this.session.doc.on("changeNewLineMode", this.onChangeNewLineMode);
          }, this.updateLines = function(e2, t2, n2) {
            t2 === void 0 && (t2 = Infinity), this.$changedLines ? (this.$changedLines.firstRow > e2 && (this.$changedLines.firstRow = e2), this.$changedLines.lastRow < t2 && (this.$changedLines.lastRow = t2)) : this.$changedLines = { firstRow: e2, lastRow: t2 };
            if (this.$changedLines.lastRow < this.layerConfig.firstRow) {
              if (!n2)
                return;
              this.$changedLines.lastRow = this.layerConfig.lastRow;
            }
            if (this.$changedLines.firstRow > this.layerConfig.lastRow)
              return;
            this.$loop.schedule(this.CHANGE_LINES);
          }, this.onChangeNewLineMode = function() {
            this.$loop.schedule(this.CHANGE_TEXT), this.$textLayer.$updateEolChar(), this.session.$bidiHandler.setEolChar(this.$textLayer.EOL_CHAR);
          }, this.onChangeTabSize = function() {
            this.$loop.schedule(this.CHANGE_TEXT | this.CHANGE_MARKER), this.$textLayer.onChangeTabSize();
          }, this.updateText = function() {
            this.$loop.schedule(this.CHANGE_TEXT);
          }, this.updateFull = function(e2) {
            e2 ? this.$renderChanges(this.CHANGE_FULL, true) : this.$loop.schedule(this.CHANGE_FULL);
          }, this.updateFontSize = function() {
            this.$textLayer.checkForSizeChanges();
          }, this.$changes = 0, this.$updateSizeAsync = function() {
            this.$loop.pending ? this.$size.$dirty = true : this.onResize();
          }, this.onResize = function(e2, t2, n2, r2) {
            if (this.resizing > 2)
              return;
            this.resizing > 0 ? this.resizing++ : this.resizing = e2 ? 1 : 0;
            var i2 = this.container;
            r2 || (r2 = i2.clientHeight || i2.scrollHeight), n2 || (n2 = i2.clientWidth || i2.scrollWidth);
            var s2 = this.$updateCachedSize(e2, t2, n2, r2);
            if (!this.$size.scrollerHeight || !n2 && !r2)
              return this.resizing = 0;
            e2 && (this.$gutterLayer.$padding = null), e2 ? this.$renderChanges(s2 | this.$changes, true) : this.$loop.schedule(s2 | this.$changes), this.resizing && (this.resizing = 0), this.scrollBarH.scrollLeft = this.scrollBarV.scrollTop = null;
          }, this.$updateCachedSize = function(e2, t2, n2, r2) {
            r2 -= this.$extraHeight || 0;
            var s2 = 0, o2 = this.$size, u2 = { width: o2.width, height: o2.height, scrollerHeight: o2.scrollerHeight, scrollerWidth: o2.scrollerWidth };
            r2 && (e2 || o2.height != r2) && (o2.height = r2, s2 |= this.CHANGE_SIZE, o2.scrollerHeight = o2.height, this.$horizScroll && (o2.scrollerHeight -= this.scrollBarH.getHeight()), this.scrollBarV.element.style.bottom = this.scrollBarH.getHeight() + "px", s2 |= this.CHANGE_SCROLL);
            if (n2 && (e2 || o2.width != n2)) {
              s2 |= this.CHANGE_SIZE, o2.width = n2, t2 == null && (t2 = this.$showGutter ? this.$gutter.offsetWidth : 0), this.gutterWidth = t2, i.setStyle(this.scrollBarH.element.style, "left", t2 + "px"), i.setStyle(this.scroller.style, "left", t2 + this.margin.left + "px"), o2.scrollerWidth = Math.max(0, n2 - t2 - this.scrollBarV.getWidth() - this.margin.h), i.setStyle(this.$gutter.style, "left", this.margin.left + "px");
              var a2 = this.scrollBarV.getWidth() + "px";
              i.setStyle(this.scrollBarH.element.style, "right", a2), i.setStyle(this.scroller.style, "right", a2), i.setStyle(this.scroller.style, "bottom", this.scrollBarH.getHeight());
              if (this.session && this.session.getUseWrapMode() && this.adjustWrapLimit() || e2)
                s2 |= this.CHANGE_FULL;
            }
            return o2.$dirty = !n2 || !r2, s2 && this._signal("resize", u2), s2;
          }, this.onGutterResize = function(e2) {
            var t2 = this.$showGutter ? e2 : 0;
            t2 != this.gutterWidth && (this.$changes |= this.$updateCachedSize(true, t2, this.$size.width, this.$size.height)), this.session.getUseWrapMode() && this.adjustWrapLimit() ? this.$loop.schedule(this.CHANGE_FULL) : this.$size.$dirty ? this.$loop.schedule(this.CHANGE_FULL) : this.$computeLayerConfig();
          }, this.adjustWrapLimit = function() {
            var e2 = this.$size.scrollerWidth - this.$padding * 2, t2 = Math.floor(e2 / this.characterWidth);
            return this.session.adjustWrapLimit(t2, this.$showPrintMargin && this.$printMarginColumn);
          }, this.setAnimatedScroll = function(e2) {
            this.setOption("animatedScroll", e2);
          }, this.getAnimatedScroll = function() {
            return this.$animatedScroll;
          }, this.setShowInvisibles = function(e2) {
            this.setOption("showInvisibles", e2), this.session.$bidiHandler.setShowInvisibles(e2);
          }, this.getShowInvisibles = function() {
            return this.getOption("showInvisibles");
          }, this.getDisplayIndentGuides = function() {
            return this.getOption("displayIndentGuides");
          }, this.setDisplayIndentGuides = function(e2) {
            this.setOption("displayIndentGuides", e2);
          }, this.setShowPrintMargin = function(e2) {
            this.setOption("showPrintMargin", e2);
          }, this.getShowPrintMargin = function() {
            return this.getOption("showPrintMargin");
          }, this.setPrintMarginColumn = function(e2) {
            this.setOption("printMarginColumn", e2);
          }, this.getPrintMarginColumn = function() {
            return this.getOption("printMarginColumn");
          }, this.getShowGutter = function() {
            return this.getOption("showGutter");
          }, this.setShowGutter = function(e2) {
            return this.setOption("showGutter", e2);
          }, this.getFadeFoldWidgets = function() {
            return this.getOption("fadeFoldWidgets");
          }, this.setFadeFoldWidgets = function(e2) {
            this.setOption("fadeFoldWidgets", e2);
          }, this.setHighlightGutterLine = function(e2) {
            this.setOption("highlightGutterLine", e2);
          }, this.getHighlightGutterLine = function() {
            return this.getOption("highlightGutterLine");
          }, this.$updatePrintMargin = function() {
            if (!this.$showPrintMargin && !this.$printMarginEl)
              return;
            if (!this.$printMarginEl) {
              var e2 = i.createElement("div");
              e2.className = "ace_layer ace_print-margin-layer", this.$printMarginEl = i.createElement("div"), this.$printMarginEl.className = "ace_print-margin", e2.appendChild(this.$printMarginEl), this.content.insertBefore(e2, this.content.firstChild);
            }
            var t2 = this.$printMarginEl.style;
            t2.left = Math.round(this.characterWidth * this.$printMarginColumn + this.$padding) + "px", t2.visibility = this.$showPrintMargin ? "visible" : "hidden", this.session && this.session.$wrap == -1 && this.adjustWrapLimit();
          }, this.getContainerElement = function() {
            return this.container;
          }, this.getMouseEventTarget = function() {
            return this.scroller;
          }, this.getTextAreaContainer = function() {
            return this.container;
          }, this.$moveTextAreaToCursor = function() {
            if (this.$isMousePressed)
              return;
            var e2 = this.textarea.style, t2 = this.$composition;
            if (!this.$keepTextAreaAtCursor && !t2) {
              i.translate(this.textarea, -100, 0);
              return;
            }
            var n2 = this.$cursorLayer.$pixelPos;
            if (!n2)
              return;
            t2 && t2.markerRange && (n2 = this.$cursorLayer.getPixelPosition(t2.markerRange.start, true));
            var r2 = this.layerConfig, s2 = n2.top, o2 = n2.left;
            s2 -= r2.offset;
            var u2 = t2 && t2.useTextareaForIME ? this.lineHeight : g ? 0 : 1;
            if (s2 < 0 || s2 > r2.height - u2) {
              i.translate(this.textarea, 0, 0);
              return;
            }
            var a2 = 1, f2 = this.$size.height - u2;
            if (!t2)
              s2 += this.lineHeight;
            else if (t2.useTextareaForIME) {
              var l2 = this.textarea.value;
              a2 = this.characterWidth * this.session.$getStringScreenWidth(l2)[0];
            } else
              s2 += this.lineHeight + 2;
            o2 -= this.scrollLeft, o2 > this.$size.scrollerWidth - a2 && (o2 = this.$size.scrollerWidth - a2), o2 += this.gutterWidth + this.margin.left, i.setStyle(e2, "height", u2 + "px"), i.setStyle(e2, "width", a2 + "px"), i.translate(this.textarea, Math.min(o2, this.$size.scrollerWidth - a2), Math.min(s2, f2));
          }, this.getFirstVisibleRow = function() {
            return this.layerConfig.firstRow;
          }, this.getFirstFullyVisibleRow = function() {
            return this.layerConfig.firstRow + (this.layerConfig.offset === 0 ? 0 : 1);
          }, this.getLastFullyVisibleRow = function() {
            var e2 = this.layerConfig, t2 = e2.lastRow, n2 = this.session.documentToScreenRow(t2, 0) * e2.lineHeight;
            return n2 - this.session.getScrollTop() > e2.height - e2.lineHeight ? t2 - 1 : t2;
          }, this.getLastVisibleRow = function() {
            return this.layerConfig.lastRow;
          }, this.$padding = null, this.setPadding = function(e2) {
            this.$padding = e2, this.$textLayer.setPadding(e2), this.$cursorLayer.setPadding(e2), this.$markerFront.setPadding(e2), this.$markerBack.setPadding(e2), this.$loop.schedule(this.CHANGE_FULL), this.$updatePrintMargin();
          }, this.setScrollMargin = function(e2, t2, n2, r2) {
            var i2 = this.scrollMargin;
            i2.top = e2 | 0, i2.bottom = t2 | 0, i2.right = r2 | 0, i2.left = n2 | 0, i2.v = i2.top + i2.bottom, i2.h = i2.left + i2.right, i2.top && this.scrollTop <= 0 && this.session && this.session.setScrollTop(-i2.top), this.updateFull();
          }, this.setMargin = function(e2, t2, n2, r2) {
            var i2 = this.margin;
            i2.top = e2 | 0, i2.bottom = t2 | 0, i2.right = r2 | 0, i2.left = n2 | 0, i2.v = i2.top + i2.bottom, i2.h = i2.left + i2.right, this.$updateCachedSize(true, this.gutterWidth, this.$size.width, this.$size.height), this.updateFull();
          }, this.getHScrollBarAlwaysVisible = function() {
            return this.$hScrollBarAlwaysVisible;
          }, this.setHScrollBarAlwaysVisible = function(e2) {
            this.setOption("hScrollBarAlwaysVisible", e2);
          }, this.getVScrollBarAlwaysVisible = function() {
            return this.$vScrollBarAlwaysVisible;
          }, this.setVScrollBarAlwaysVisible = function(e2) {
            this.setOption("vScrollBarAlwaysVisible", e2);
          }, this.$updateScrollBarV = function() {
            var e2 = this.layerConfig.maxHeight, t2 = this.$size.scrollerHeight;
            !this.$maxLines && this.$scrollPastEnd && (e2 -= (t2 - this.lineHeight) * this.$scrollPastEnd, this.scrollTop > e2 - t2 && (e2 = this.scrollTop + t2, this.scrollBarV.scrollTop = null)), this.scrollBarV.setScrollHeight(e2 + this.scrollMargin.v), this.scrollBarV.setScrollTop(this.scrollTop + this.scrollMargin.top);
          }, this.$updateScrollBarH = function() {
            this.scrollBarH.setScrollWidth(this.layerConfig.width + 2 * this.$padding + this.scrollMargin.h), this.scrollBarH.setScrollLeft(this.scrollLeft + this.scrollMargin.left);
          }, this.$frozen = false, this.freeze = function() {
            this.$frozen = true;
          }, this.unfreeze = function() {
            this.$frozen = false;
          }, this.$renderChanges = function(e2, t2) {
            this.$changes && (e2 |= this.$changes, this.$changes = 0);
            if (!this.session || !this.container.offsetWidth || this.$frozen || !e2 && !t2) {
              this.$changes |= e2;
              return;
            }
            if (this.$size.$dirty)
              return this.$changes |= e2, this.onResize(true);
            this.lineHeight || this.$textLayer.checkForSizeChanges(), this._signal("beforeRender", e2), this.session && this.session.$bidiHandler && this.session.$bidiHandler.updateCharacterWidths(this.$fontMetrics);
            var n2 = this.layerConfig;
            if (e2 & this.CHANGE_FULL || e2 & this.CHANGE_SIZE || e2 & this.CHANGE_TEXT || e2 & this.CHANGE_LINES || e2 & this.CHANGE_SCROLL || e2 & this.CHANGE_H_SCROLL) {
              e2 |= this.$computeLayerConfig() | this.$loop.clear();
              if (n2.firstRow != this.layerConfig.firstRow && n2.firstRowScreen == this.layerConfig.firstRowScreen) {
                var r2 = this.scrollTop + (n2.firstRow - this.layerConfig.firstRow) * this.lineHeight;
                r2 > 0 && (this.scrollTop = r2, e2 |= this.CHANGE_SCROLL, e2 |= this.$computeLayerConfig() | this.$loop.clear());
              }
              n2 = this.layerConfig, this.$updateScrollBarV(), e2 & this.CHANGE_H_SCROLL && this.$updateScrollBarH(), i.translate(this.content, -this.scrollLeft, -n2.offset);
              var s2 = n2.width + 2 * this.$padding + "px", o2 = n2.minHeight + "px";
              i.setStyle(this.content.style, "width", s2), i.setStyle(this.content.style, "height", o2);
            }
            e2 & this.CHANGE_H_SCROLL && (i.translate(this.content, -this.scrollLeft, -n2.offset), this.scroller.className = this.scrollLeft <= 0 ? "ace_scroller" : "ace_scroller ace_scroll-left");
            if (e2 & this.CHANGE_FULL) {
              this.$changedLines = null, this.$textLayer.update(n2), this.$showGutter && this.$gutterLayer.update(n2), this.$markerBack.update(n2), this.$markerFront.update(n2), this.$cursorLayer.update(n2), this.$moveTextAreaToCursor(), this._signal("afterRender", e2);
              return;
            }
            if (e2 & this.CHANGE_SCROLL) {
              this.$changedLines = null, e2 & this.CHANGE_TEXT || e2 & this.CHANGE_LINES ? this.$textLayer.update(n2) : this.$textLayer.scrollLines(n2), this.$showGutter && (e2 & this.CHANGE_GUTTER || e2 & this.CHANGE_LINES ? this.$gutterLayer.update(n2) : this.$gutterLayer.scrollLines(n2)), this.$markerBack.update(n2), this.$markerFront.update(n2), this.$cursorLayer.update(n2), this.$moveTextAreaToCursor(), this._signal("afterRender", e2);
              return;
            }
            e2 & this.CHANGE_TEXT ? (this.$changedLines = null, this.$textLayer.update(n2), this.$showGutter && this.$gutterLayer.update(n2)) : e2 & this.CHANGE_LINES ? (this.$updateLines() || e2 & this.CHANGE_GUTTER && this.$showGutter) && this.$gutterLayer.update(n2) : e2 & this.CHANGE_TEXT || e2 & this.CHANGE_GUTTER ? this.$showGutter && this.$gutterLayer.update(n2) : e2 & this.CHANGE_CURSOR && this.$highlightGutterLine && this.$gutterLayer.updateLineHighlight(n2), e2 & this.CHANGE_CURSOR && (this.$cursorLayer.update(n2), this.$moveTextAreaToCursor()), e2 & (this.CHANGE_MARKER | this.CHANGE_MARKER_FRONT) && this.$markerFront.update(n2), e2 & (this.CHANGE_MARKER | this.CHANGE_MARKER_BACK) && this.$markerBack.update(n2), this._signal("afterRender", e2);
          }, this.$autosize = function() {
            var e2 = this.session.getScreenLength() * this.lineHeight, t2 = this.$maxLines * this.lineHeight, n2 = Math.min(t2, Math.max((this.$minLines || 1) * this.lineHeight, e2)) + this.scrollMargin.v + (this.$extraHeight || 0);
            this.$horizScroll && (n2 += this.scrollBarH.getHeight()), this.$maxPixelHeight && n2 > this.$maxPixelHeight && (n2 = this.$maxPixelHeight);
            var r2 = n2 <= 2 * this.lineHeight, i2 = !r2 && e2 > t2;
            if (n2 != this.desiredHeight || this.$size.height != this.desiredHeight || i2 != this.$vScroll) {
              i2 != this.$vScroll && (this.$vScroll = i2, this.scrollBarV.setVisible(i2));
              var s2 = this.container.clientWidth;
              this.container.style.height = n2 + "px", this.$updateCachedSize(true, this.$gutterWidth, s2, n2), this.desiredHeight = n2, this._signal("autosize");
            }
          }, this.$computeLayerConfig = function() {
            var e2 = this.session, t2 = this.$size, n2 = t2.height <= 2 * this.lineHeight, r2 = this.session.getScreenLength(), i2 = r2 * this.lineHeight, s2 = this.$getLongestLine(), o2 = !n2 && (this.$hScrollBarAlwaysVisible || t2.scrollerWidth - s2 - 2 * this.$padding < 0), u2 = this.$horizScroll !== o2;
            u2 && (this.$horizScroll = o2, this.scrollBarH.setVisible(o2));
            var a2 = this.$vScroll;
            this.$maxLines && this.lineHeight > 1 && this.$autosize();
            var f2 = t2.scrollerHeight + this.lineHeight, l2 = !this.$maxLines && this.$scrollPastEnd ? (t2.scrollerHeight - this.lineHeight) * this.$scrollPastEnd : 0;
            i2 += l2;
            var c2 = this.scrollMargin;
            this.session.setScrollTop(Math.max(-c2.top, Math.min(this.scrollTop, i2 - t2.scrollerHeight + c2.bottom))), this.session.setScrollLeft(Math.max(-c2.left, Math.min(this.scrollLeft, s2 + 2 * this.$padding - t2.scrollerWidth + c2.right)));
            var h2 = !n2 && (this.$vScrollBarAlwaysVisible || t2.scrollerHeight - i2 + l2 < 0 || this.scrollTop > c2.top), p2 = a2 !== h2;
            p2 && (this.$vScroll = h2, this.scrollBarV.setVisible(h2));
            var d2 = this.scrollTop % this.lineHeight, v2 = Math.ceil(f2 / this.lineHeight) - 1, m2 = Math.max(0, Math.round((this.scrollTop - d2) / this.lineHeight)), g2 = m2 + v2, y2, b, w = this.lineHeight;
            m2 = e2.screenToDocumentRow(m2, 0);
            var E = e2.getFoldLine(m2);
            E && (m2 = E.start.row), y2 = e2.documentToScreenRow(m2, 0), b = e2.getRowLength(m2) * w, g2 = Math.min(e2.screenToDocumentRow(g2, 0), e2.getLength() - 1), f2 = t2.scrollerHeight + e2.getRowLength(g2) * w + b, d2 = this.scrollTop - y2 * w;
            var S = 0;
            if (this.layerConfig.width != s2 || u2)
              S = this.CHANGE_H_SCROLL;
            if (u2 || p2)
              S |= this.$updateCachedSize(true, this.gutterWidth, t2.width, t2.height), this._signal("scrollbarVisibilityChanged"), p2 && (s2 = this.$getLongestLine());
            return this.layerConfig = { width: s2, padding: this.$padding, firstRow: m2, firstRowScreen: y2, lastRow: g2, lineHeight: w, characterWidth: this.characterWidth, minHeight: f2, maxHeight: i2, offset: d2, gutterOffset: w ? Math.max(0, Math.ceil((d2 + t2.height - t2.scrollerHeight) / w)) : 0, height: this.$size.scrollerHeight }, this.session.$bidiHandler && this.session.$bidiHandler.setContentWidth(s2 - this.$padding), S;
          }, this.$updateLines = function() {
            if (!this.$changedLines)
              return;
            var e2 = this.$changedLines.firstRow, t2 = this.$changedLines.lastRow;
            this.$changedLines = null;
            var n2 = this.layerConfig;
            if (e2 > n2.lastRow + 1)
              return;
            if (t2 < n2.firstRow)
              return;
            if (t2 === Infinity) {
              this.$showGutter && this.$gutterLayer.update(n2), this.$textLayer.update(n2);
              return;
            }
            return this.$textLayer.updateLines(n2, e2, t2), true;
          }, this.$getLongestLine = function() {
            var e2 = this.session.getScreenWidth();
            return this.showInvisibles && !this.session.$useWrapMode && (e2 += 1), this.$textLayer && e2 > this.$textLayer.MAX_LINE_LENGTH && (e2 = this.$textLayer.MAX_LINE_LENGTH + 30), Math.max(this.$size.scrollerWidth - 2 * this.$padding, Math.round(e2 * this.characterWidth));
          }, this.updateFrontMarkers = function() {
            this.$markerFront.setMarkers(this.session.getMarkers(true)), this.$loop.schedule(this.CHANGE_MARKER_FRONT);
          }, this.updateBackMarkers = function() {
            this.$markerBack.setMarkers(this.session.getMarkers()), this.$loop.schedule(this.CHANGE_MARKER_BACK);
          }, this.addGutterDecoration = function(e2, t2) {
            this.$gutterLayer.addGutterDecoration(e2, t2);
          }, this.removeGutterDecoration = function(e2, t2) {
            this.$gutterLayer.removeGutterDecoration(e2, t2);
          }, this.updateBreakpoints = function(e2) {
            this.$loop.schedule(this.CHANGE_GUTTER);
          }, this.setAnnotations = function(e2) {
            this.$gutterLayer.setAnnotations(e2), this.$loop.schedule(this.CHANGE_GUTTER);
          }, this.updateCursor = function() {
            this.$loop.schedule(this.CHANGE_CURSOR);
          }, this.hideCursor = function() {
            this.$cursorLayer.hideCursor();
          }, this.showCursor = function() {
            this.$cursorLayer.showCursor();
          }, this.scrollSelectionIntoView = function(e2, t2, n2) {
            this.scrollCursorIntoView(e2, n2), this.scrollCursorIntoView(t2, n2);
          }, this.scrollCursorIntoView = function(e2, t2, n2) {
            if (this.$size.scrollerHeight === 0)
              return;
            var r2 = this.$cursorLayer.getPixelPosition(e2), i2 = r2.left, s2 = r2.top, o2 = n2 && n2.top || 0, u2 = n2 && n2.bottom || 0, a2 = this.$scrollAnimation ? this.session.getScrollTop() : this.scrollTop;
            a2 + o2 > s2 ? (t2 && a2 + o2 > s2 + this.lineHeight && (s2 -= t2 * this.$size.scrollerHeight), s2 === 0 && (s2 = -this.scrollMargin.top), this.session.setScrollTop(s2)) : a2 + this.$size.scrollerHeight - u2 < s2 + this.lineHeight && (t2 && a2 + this.$size.scrollerHeight - u2 < s2 - this.lineHeight && (s2 += t2 * this.$size.scrollerHeight), this.session.setScrollTop(s2 + this.lineHeight + u2 - this.$size.scrollerHeight));
            var f2 = this.scrollLeft;
            f2 > i2 ? (i2 < this.$padding + 2 * this.layerConfig.characterWidth && (i2 = -this.scrollMargin.left), this.session.setScrollLeft(i2)) : f2 + this.$size.scrollerWidth < i2 + this.characterWidth ? this.session.setScrollLeft(Math.round(i2 + this.characterWidth - this.$size.scrollerWidth)) : f2 <= this.$padding && i2 - f2 < this.characterWidth && this.session.setScrollLeft(0);
          }, this.getScrollTop = function() {
            return this.session.getScrollTop();
          }, this.getScrollLeft = function() {
            return this.session.getScrollLeft();
          }, this.getScrollTopRow = function() {
            return this.scrollTop / this.lineHeight;
          }, this.getScrollBottomRow = function() {
            return Math.max(0, Math.floor((this.scrollTop + this.$size.scrollerHeight) / this.lineHeight) - 1);
          }, this.scrollToRow = function(e2) {
            this.session.setScrollTop(e2 * this.lineHeight);
          }, this.alignCursor = function(e2, t2) {
            typeof e2 == "number" && (e2 = { row: e2, column: 0 });
            var n2 = this.$cursorLayer.getPixelPosition(e2), r2 = this.$size.scrollerHeight - this.lineHeight, i2 = n2.top - r2 * (t2 || 0);
            return this.session.setScrollTop(i2), i2;
          }, this.STEPS = 8, this.$calcSteps = function(e2, t2) {
            var n2 = 0, r2 = this.STEPS, i2 = [], s2 = function(e3, t3, n3) {
              return n3 * (Math.pow(e3 - 1, 3) + 1) + t3;
            };
            for (n2 = 0; n2 < r2; ++n2)
              i2.push(s2(n2 / this.STEPS, e2, t2 - e2));
            return i2;
          }, this.scrollToLine = function(e2, t2, n2, r2) {
            var i2 = this.$cursorLayer.getPixelPosition({ row: e2, column: 0 }), s2 = i2.top;
            t2 && (s2 -= this.$size.scrollerHeight / 2);
            var o2 = this.scrollTop;
            this.session.setScrollTop(s2), n2 !== false && this.animateScrolling(o2, r2);
          }, this.animateScrolling = function(e2, t2) {
            var n2 = this.scrollTop;
            if (!this.$animatedScroll)
              return;
            var r2 = this;
            if (e2 == n2)
              return;
            if (this.$scrollAnimation) {
              var i2 = this.$scrollAnimation.steps;
              if (i2.length) {
                e2 = i2[0];
                if (e2 == n2)
                  return;
              }
            }
            var s2 = r2.$calcSteps(e2, n2);
            this.$scrollAnimation = { from: e2, to: n2, steps: s2 }, clearInterval(this.$timer), r2.session.setScrollTop(s2.shift()), r2.session.$scrollTop = n2, this.$timer = setInterval(function() {
              if (!r2.session)
                return clearInterval(r2.$timer);
              s2.length ? (r2.session.setScrollTop(s2.shift()), r2.session.$scrollTop = n2) : n2 != null ? (r2.session.$scrollTop = -1, r2.session.setScrollTop(n2), n2 = null) : (r2.$timer = clearInterval(r2.$timer), r2.$scrollAnimation = null, t2 && t2());
            }, 10);
          }, this.scrollToY = function(e2) {
            this.scrollTop !== e2 && (this.$loop.schedule(this.CHANGE_SCROLL), this.scrollTop = e2);
          }, this.scrollToX = function(e2) {
            this.scrollLeft !== e2 && (this.scrollLeft = e2), this.$loop.schedule(this.CHANGE_H_SCROLL);
          }, this.scrollTo = function(e2, t2) {
            this.session.setScrollTop(t2), this.session.setScrollLeft(e2);
          }, this.scrollBy = function(e2, t2) {
            t2 && this.session.setScrollTop(this.session.getScrollTop() + t2), e2 && this.session.setScrollLeft(this.session.getScrollLeft() + e2);
          }, this.isScrollableBy = function(e2, t2) {
            if (t2 < 0 && this.session.getScrollTop() >= 1 - this.scrollMargin.top)
              return true;
            if (t2 > 0 && this.session.getScrollTop() + this.$size.scrollerHeight - this.layerConfig.maxHeight < -1 + this.scrollMargin.bottom)
              return true;
            if (e2 < 0 && this.session.getScrollLeft() >= 1 - this.scrollMargin.left)
              return true;
            if (e2 > 0 && this.session.getScrollLeft() + this.$size.scrollerWidth - this.layerConfig.width < -1 + this.scrollMargin.right)
              return true;
          }, this.pixelToScreenCoordinates = function(e2, t2) {
            var n2;
            if (this.$hasCssTransforms) {
              n2 = { top: 0, left: 0 };
              var r2 = this.$fontMetrics.transformCoordinates([e2, t2]);
              e2 = r2[1] - this.gutterWidth - this.margin.left, t2 = r2[0];
            } else
              n2 = this.scroller.getBoundingClientRect();
            var i2 = e2 + this.scrollLeft - n2.left - this.$padding, s2 = i2 / this.characterWidth, o2 = Math.floor((t2 + this.scrollTop - n2.top) / this.lineHeight), u2 = this.$blockCursor ? Math.floor(s2) : Math.round(s2);
            return { row: o2, column: u2, side: s2 - u2 > 0 ? 1 : -1, offsetX: i2 };
          }, this.screenToTextCoordinates = function(e2, t2) {
            var n2;
            if (this.$hasCssTransforms) {
              n2 = { top: 0, left: 0 };
              var r2 = this.$fontMetrics.transformCoordinates([e2, t2]);
              e2 = r2[1] - this.gutterWidth - this.margin.left, t2 = r2[0];
            } else
              n2 = this.scroller.getBoundingClientRect();
            var i2 = e2 + this.scrollLeft - n2.left - this.$padding, s2 = i2 / this.characterWidth, o2 = this.$blockCursor ? Math.floor(s2) : Math.round(s2), u2 = Math.floor((t2 + this.scrollTop - n2.top) / this.lineHeight);
            return this.session.screenToDocumentPosition(u2, Math.max(o2, 0), i2);
          }, this.textToScreenCoordinates = function(e2, t2) {
            var n2 = this.scroller.getBoundingClientRect(), r2 = this.session.documentToScreenPosition(e2, t2), i2 = this.$padding + (this.session.$bidiHandler.isBidiRow(r2.row, e2) ? this.session.$bidiHandler.getPosLeft(r2.column) : Math.round(r2.column * this.characterWidth)), s2 = r2.row * this.lineHeight;
            return { pageX: n2.left + i2 - this.scrollLeft, pageY: n2.top + s2 - this.scrollTop };
          }, this.visualizeFocus = function() {
            i.addCssClass(this.container, "ace_focus");
          }, this.visualizeBlur = function() {
            i.removeCssClass(this.container, "ace_focus");
          }, this.showComposition = function(e2) {
            this.$composition = e2, e2.cssText || (e2.cssText = this.textarea.style.cssText), e2.useTextareaForIME == void 0 && (e2.useTextareaForIME = this.$useTextareaForIME), this.$useTextareaForIME ? (i.addCssClass(this.textarea, "ace_composition"), this.textarea.style.cssText = "", this.$moveTextAreaToCursor(), this.$cursorLayer.element.style.display = "none") : e2.markerId = this.session.addMarker(e2.markerRange, "ace_composition_marker", "text");
          }, this.setCompositionText = function(e2) {
            var t2 = this.session.selection.cursor;
            this.addToken(e2, "composition_placeholder", t2.row, t2.column), this.$moveTextAreaToCursor();
          }, this.hideComposition = function() {
            if (!this.$composition)
              return;
            this.$composition.markerId && this.session.removeMarker(this.$composition.markerId), i.removeCssClass(this.textarea, "ace_composition"), this.textarea.style.cssText = this.$composition.cssText;
            var e2 = this.session.selection.cursor;
            this.removeExtraToken(e2.row, e2.column), this.$composition = null, this.$cursorLayer.element.style.display = "";
          }, this.addToken = function(e2, t2, n2, r2) {
            var i2 = this.session;
            i2.bgTokenizer.lines[n2] = null;
            var s2 = { type: t2, value: e2 }, o2 = i2.getTokens(n2);
            if (r2 == null)
              o2.push(s2);
            else {
              var u2 = 0;
              for (var a2 = 0; a2 < o2.length; a2++) {
                var f2 = o2[a2];
                u2 += f2.value.length;
                if (r2 <= u2) {
                  var l2 = f2.value.length - (u2 - r2), c2 = f2.value.slice(0, l2), h2 = f2.value.slice(l2);
                  o2.splice(a2, 1, { type: f2.type, value: c2 }, s2, { type: f2.type, value: h2 });
                  break;
                }
              }
            }
            this.updateLines(n2, n2);
          }, this.removeExtraToken = function(e2, t2) {
            this.updateLines(e2, e2);
          }, this.setTheme = function(e2, t2) {
            function o2(r3) {
              if (n2.$themeId != e2)
                return t2 && t2();
              if (!r3 || !r3.cssClass)
                throw new Error("couldn't load module " + e2 + " or it didn't call define");
              r3.$id && (n2.$themeId = r3.$id), i.importCssString(r3.cssText, r3.cssClass, n2.container), n2.theme && i.removeCssClass(n2.container, n2.theme.cssClass);
              var s2 = "padding" in r3 ? r3.padding : "padding" in (n2.theme || {}) ? 4 : n2.$padding;
              n2.$padding && s2 != n2.$padding && n2.setPadding(s2), n2.$theme = r3.cssClass, n2.theme = r3, i.addCssClass(n2.container, r3.cssClass), i.setCssClass(n2.container, "ace_dark", r3.isDark), n2.$size && (n2.$size.width = 0, n2.$updateSizeAsync()), n2._dispatchEvent("themeLoaded", { theme: r3 }), t2 && t2();
            }
            var n2 = this;
            this.$themeId = e2, n2._dispatchEvent("themeChange", { theme: e2 });
            if (!e2 || typeof e2 == "string") {
              var r2 = e2 || this.$options.theme.initialValue;
              s.loadModule(["theme", r2], o2);
            } else
              o2(e2);
          }, this.getTheme = function() {
            return this.$themeId;
          }, this.setStyle = function(e2, t2) {
            i.setCssClass(this.container, e2, t2 !== false);
          }, this.unsetStyle = function(e2) {
            i.removeCssClass(this.container, e2);
          }, this.setCursorStyle = function(e2) {
            i.setStyle(this.scroller.style, "cursor", e2);
          }, this.setMouseCursor = function(e2) {
            i.setStyle(this.scroller.style, "cursor", e2);
          }, this.attachToShadowRoot = function() {
            i.importCssString(v, "ace_editor.css", this.container);
          }, this.destroy = function() {
            this.freeze(), this.$fontMetrics.destroy(), this.$cursorLayer.destroy(), this.removeAllListeners(), this.container.textContent = "";
          };
        }).call(y.prototype), s.defineOptions(y.prototype, "renderer", { animatedScroll: { initialValue: false }, showInvisibles: { set: function(e2) {
          this.$textLayer.setShowInvisibles(e2) && this.$loop.schedule(this.CHANGE_TEXT);
        }, initialValue: false }, showPrintMargin: { set: function() {
          this.$updatePrintMargin();
        }, initialValue: true }, printMarginColumn: { set: function() {
          this.$updatePrintMargin();
        }, initialValue: 80 }, printMargin: { set: function(e2) {
          typeof e2 == "number" && (this.$printMarginColumn = e2), this.$showPrintMargin = !!e2, this.$updatePrintMargin();
        }, get: function() {
          return this.$showPrintMargin && this.$printMarginColumn;
        } }, showGutter: { set: function(e2) {
          this.$gutter.style.display = e2 ? "block" : "none", this.$loop.schedule(this.CHANGE_FULL), this.onGutterResize();
        }, initialValue: true }, fadeFoldWidgets: { set: function(e2) {
          i.setCssClass(this.$gutter, "ace_fade-fold-widgets", e2);
        }, initialValue: false }, showFoldWidgets: { set: function(e2) {
          this.$gutterLayer.setShowFoldWidgets(e2), this.$loop.schedule(this.CHANGE_GUTTER);
        }, initialValue: true }, displayIndentGuides: { set: function(e2) {
          this.$textLayer.setDisplayIndentGuides(e2) && this.$loop.schedule(this.CHANGE_TEXT);
        }, initialValue: true }, highlightGutterLine: { set: function(e2) {
          this.$gutterLayer.setHighlightGutterLine(e2), this.$loop.schedule(this.CHANGE_GUTTER);
        }, initialValue: true }, hScrollBarAlwaysVisible: { set: function(e2) {
          (!this.$hScrollBarAlwaysVisible || !this.$horizScroll) && this.$loop.schedule(this.CHANGE_SCROLL);
        }, initialValue: false }, vScrollBarAlwaysVisible: { set: function(e2) {
          (!this.$vScrollBarAlwaysVisible || !this.$vScroll) && this.$loop.schedule(this.CHANGE_SCROLL);
        }, initialValue: false }, fontSize: { set: function(e2) {
          typeof e2 == "number" && (e2 += "px"), this.container.style.fontSize = e2, this.updateFontSize();
        }, initialValue: 12 }, fontFamily: { set: function(e2) {
          this.container.style.fontFamily = e2, this.updateFontSize();
        } }, maxLines: { set: function(e2) {
          this.updateFull();
        } }, minLines: { set: function(e2) {
          this.$minLines < 562949953421311 || (this.$minLines = 0), this.updateFull();
        } }, maxPixelHeight: { set: function(e2) {
          this.updateFull();
        }, initialValue: 0 }, scrollPastEnd: { set: function(e2) {
          e2 = +e2 || 0;
          if (this.$scrollPastEnd == e2)
            return;
          this.$scrollPastEnd = e2, this.$loop.schedule(this.CHANGE_SCROLL);
        }, initialValue: 0, handlesSet: true }, fixedWidthGutter: { set: function(e2) {
          this.$gutterLayer.$fixedWidth = !!e2, this.$loop.schedule(this.CHANGE_GUTTER);
        } }, theme: { set: function(e2) {
          this.setTheme(e2);
        }, get: function() {
          return this.$themeId || this.theme;
        }, initialValue: "./theme/textmate", handlesSet: true }, hasCssTransforms: {}, useTextareaForIME: { initialValue: !m.isMobile && !m.isIE } }), t.VirtualRenderer = y;
      }), ace.define("ace/worker/worker_client", ["require", "exports", "module", "ace/lib/oop", "ace/lib/net", "ace/lib/event_emitter", "ace/config"], function(e, t, n) {
        "use strict";
        function u(e2) {
          var t2 = "importScripts('" + i.qualifyURL(e2) + "');";
          try {
            return new Blob([t2], { type: "application/javascript" });
          } catch (n2) {
            var r2 = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder, s2 = new r2();
            return s2.append(t2), s2.getBlob("application/javascript");
          }
        }
        function a(e2) {
          if (typeof Worker == "undefined")
            return { postMessage: function() {
            }, terminate: function() {
            } };
          if (o.get("loadWorkerFromBlob")) {
            var t2 = u(e2), n2 = window.URL || window.webkitURL, r2 = n2.createObjectURL(t2);
            return new Worker(r2);
          }
          return new Worker(e2);
        }
        var r = e("../lib/oop"), i = e("../lib/net"), s = e("../lib/event_emitter").EventEmitter, o = e("../config"), f = function(e2) {
          e2.postMessage || (e2 = this.$createWorkerFromOldConfig.apply(this, arguments)), this.$worker = e2, this.$sendDeltaQueue = this.$sendDeltaQueue.bind(this), this.changeListener = this.changeListener.bind(this), this.onMessage = this.onMessage.bind(this), this.callbackId = 1, this.callbacks = {}, this.$worker.onmessage = this.onMessage;
        };
        (function() {
          r.implement(this, s), this.$createWorkerFromOldConfig = function(t2, n2, r2, i2, s2) {
            e.nameToUrl && !e.toUrl && (e.toUrl = e.nameToUrl);
            if (o.get("packaged") || !e.toUrl)
              i2 = i2 || o.moduleUrl(n2, "worker");
            else {
              var u2 = this.$normalizePath;
              i2 = i2 || u2(e.toUrl("ace/worker/worker.js", null, "_"));
              var f2 = {};
              t2.forEach(function(t3) {
                f2[t3] = u2(e.toUrl(t3, null, "_").replace(/(\.js)?(\?.*)?$/, ""));
              });
            }
            return this.$worker = a(i2), s2 && this.send("importScripts", s2), this.$worker.postMessage({ init: true, tlns: f2, module: n2, classname: r2 }), this.$worker;
          }, this.onMessage = function(e2) {
            var t2 = e2.data;
            switch (t2.type) {
              case "event":
                this._signal(t2.name, { data: t2.data });
                break;
              case "call":
                var n2 = this.callbacks[t2.id];
                n2 && (n2(t2.data), delete this.callbacks[t2.id]);
                break;
              case "error":
                this.reportError(t2.data);
                break;
              case "log":
                window.console && console.log && console.log.apply(console, t2.data);
            }
          }, this.reportError = function(e2) {
            window.console && console.error && console.error(e2);
          }, this.$normalizePath = function(e2) {
            return i.qualifyURL(e2);
          }, this.terminate = function() {
            this._signal("terminate", {}), this.deltaQueue = null, this.$worker.terminate(), this.$worker = null, this.$doc && this.$doc.off("change", this.changeListener), this.$doc = null;
          }, this.send = function(e2, t2) {
            this.$worker.postMessage({ command: e2, args: t2 });
          }, this.call = function(e2, t2, n2) {
            if (n2) {
              var r2 = this.callbackId++;
              this.callbacks[r2] = n2, t2.push(r2);
            }
            this.send(e2, t2);
          }, this.emit = function(e2, t2) {
            try {
              t2.data && t2.data.err && (t2.data.err = { message: t2.data.err.message, stack: t2.data.err.stack, code: t2.data.err.code }), this.$worker && this.$worker.postMessage({ event: e2, data: { data: t2.data } });
            } catch (n2) {
              console.error(n2.stack);
            }
          }, this.attachToDocument = function(e2) {
            this.$doc && this.terminate(), this.$doc = e2, this.call("setValue", [e2.getValue()]), e2.on("change", this.changeListener);
          }, this.changeListener = function(e2) {
            this.deltaQueue || (this.deltaQueue = [], setTimeout(this.$sendDeltaQueue, 0)), e2.action == "insert" ? this.deltaQueue.push(e2.start, e2.lines) : this.deltaQueue.push(e2.start, e2.end);
          }, this.$sendDeltaQueue = function() {
            var e2 = this.deltaQueue;
            if (!e2)
              return;
            this.deltaQueue = null, e2.length > 50 && e2.length > this.$doc.getLength() >> 1 ? this.call("setValue", [this.$doc.getValue()]) : this.emit("change", { data: e2 });
          };
        }).call(f.prototype);
        var l = function(e2, t2, n2) {
          var r2 = null, i2 = false, u2 = Object.create(s), a2 = [], l2 = new f({ messageBuffer: a2, terminate: function() {
          }, postMessage: function(e3) {
            a2.push(e3);
            if (!r2)
              return;
            i2 ? setTimeout(c) : c();
          } });
          l2.setEmitSync = function(e3) {
            i2 = e3;
          };
          var c = function() {
            var e3 = a2.shift();
            e3.command ? r2[e3.command].apply(r2, e3.args) : e3.event && u2._signal(e3.event, e3.data);
          };
          return u2.postMessage = function(e3) {
            l2.onMessage({ data: e3 });
          }, u2.callback = function(e3, t3) {
            this.postMessage({ type: "call", id: t3, data: e3 });
          }, u2.emit = function(e3, t3) {
            this.postMessage({ type: "event", name: e3, data: t3 });
          }, o.loadModule(["worker", t2], function(e3) {
            r2 = new e3[n2](u2);
            while (a2.length)
              c();
          }), l2;
        };
        t.UIWorkerClient = l, t.WorkerClient = f, t.createWorker = a;
      }), ace.define("ace/placeholder", ["require", "exports", "module", "ace/range", "ace/lib/event_emitter", "ace/lib/oop"], function(e, t, n) {
        "use strict";
        var r = e("./range").Range, i = e("./lib/event_emitter").EventEmitter, s = e("./lib/oop"), o = function(e2, t2, n2, r2, i2, s2) {
          var o2 = this;
          this.length = t2, this.session = e2, this.doc = e2.getDocument(), this.mainClass = i2, this.othersClass = s2, this.$onUpdate = this.onUpdate.bind(this), this.doc.on("change", this.$onUpdate), this.$others = r2, this.$onCursorChange = function() {
            setTimeout(function() {
              o2.onCursorChange();
            });
          }, this.$pos = n2;
          var u = e2.getUndoManager().$undoStack || e2.getUndoManager().$undostack || { length: -1 };
          this.$undoStackDepth = u.length, this.setup(), e2.selection.on("changeCursor", this.$onCursorChange);
        };
        (function() {
          s.implement(this, i), this.setup = function() {
            var e2 = this, t2 = this.doc, n2 = this.session;
            this.selectionBefore = n2.selection.toJSON(), n2.selection.inMultiSelectMode && n2.selection.toSingleRange(), this.pos = t2.createAnchor(this.$pos.row, this.$pos.column);
            var i2 = this.pos;
            i2.$insertRight = true, i2.detach(), i2.markerId = n2.addMarker(new r(i2.row, i2.column, i2.row, i2.column + this.length), this.mainClass, null, false), this.others = [], this.$others.forEach(function(n3) {
              var r2 = t2.createAnchor(n3.row, n3.column);
              r2.$insertRight = true, r2.detach(), e2.others.push(r2);
            }), n2.setUndoSelect(false);
          }, this.showOtherMarkers = function() {
            if (this.othersActive)
              return;
            var e2 = this.session, t2 = this;
            this.othersActive = true, this.others.forEach(function(n2) {
              n2.markerId = e2.addMarker(new r(n2.row, n2.column, n2.row, n2.column + t2.length), t2.othersClass, null, false);
            });
          }, this.hideOtherMarkers = function() {
            if (!this.othersActive)
              return;
            this.othersActive = false;
            for (var e2 = 0; e2 < this.others.length; e2++)
              this.session.removeMarker(this.others[e2].markerId);
          }, this.onUpdate = function(e2) {
            if (this.$updating)
              return this.updateAnchors(e2);
            var t2 = e2;
            if (t2.start.row !== t2.end.row)
              return;
            if (t2.start.row !== this.pos.row)
              return;
            this.$updating = true;
            var n2 = e2.action === "insert" ? t2.end.column - t2.start.column : t2.start.column - t2.end.column, i2 = t2.start.column >= this.pos.column && t2.start.column <= this.pos.column + this.length + 1, s2 = t2.start.column - this.pos.column;
            this.updateAnchors(e2), i2 && (this.length += n2);
            if (i2 && !this.session.$fromUndo) {
              if (e2.action === "insert")
                for (var o2 = this.others.length - 1; o2 >= 0; o2--) {
                  var u = this.others[o2], a = { row: u.row, column: u.column + s2 };
                  this.doc.insertMergedLines(a, e2.lines);
                }
              else if (e2.action === "remove")
                for (var o2 = this.others.length - 1; o2 >= 0; o2--) {
                  var u = this.others[o2], a = { row: u.row, column: u.column + s2 };
                  this.doc.remove(new r(a.row, a.column, a.row, a.column - n2));
                }
            }
            this.$updating = false, this.updateMarkers();
          }, this.updateAnchors = function(e2) {
            this.pos.onChange(e2);
            for (var t2 = this.others.length; t2--; )
              this.others[t2].onChange(e2);
            this.updateMarkers();
          }, this.updateMarkers = function() {
            if (this.$updating)
              return;
            var e2 = this, t2 = this.session, n2 = function(n3, i3) {
              t2.removeMarker(n3.markerId), n3.markerId = t2.addMarker(new r(n3.row, n3.column, n3.row, n3.column + e2.length), i3, null, false);
            };
            n2(this.pos, this.mainClass);
            for (var i2 = this.others.length; i2--; )
              n2(this.others[i2], this.othersClass);
          }, this.onCursorChange = function(e2) {
            if (this.$updating || !this.session)
              return;
            var t2 = this.session.selection.getCursor();
            t2.row === this.pos.row && t2.column >= this.pos.column && t2.column <= this.pos.column + this.length ? (this.showOtherMarkers(), this._emit("cursorEnter", e2)) : (this.hideOtherMarkers(), this._emit("cursorLeave", e2));
          }, this.detach = function() {
            this.session.removeMarker(this.pos && this.pos.markerId), this.hideOtherMarkers(), this.doc.off("change", this.$onUpdate), this.session.selection.off("changeCursor", this.$onCursorChange), this.session.setUndoSelect(true), this.session = null;
          }, this.cancel = function() {
            if (this.$undoStackDepth === -1)
              return;
            var e2 = this.session.getUndoManager(), t2 = (e2.$undoStack || e2.$undostack).length - this.$undoStackDepth;
            for (var n2 = 0; n2 < t2; n2++)
              e2.undo(this.session, true);
            this.selectionBefore && this.session.selection.fromJSON(this.selectionBefore);
          };
        }).call(o.prototype), t.PlaceHolder = o;
      }), ace.define("ace/mouse/multi_select_handler", ["require", "exports", "module", "ace/lib/event", "ace/lib/useragent"], function(e, t, n) {
        function s(e2, t2) {
          return e2.row == t2.row && e2.column == t2.column;
        }
        function o(e2) {
          var t2 = e2.domEvent, n2 = t2.altKey, o2 = t2.shiftKey, u = t2.ctrlKey, a = e2.getAccelKey(), f = e2.getButton();
          u && i.isMac && (f = t2.button);
          if (e2.editor.inMultiSelectMode && f == 2) {
            e2.editor.textInput.onContextMenu(e2.domEvent);
            return;
          }
          if (!u && !n2 && !a) {
            f === 0 && e2.editor.inMultiSelectMode && e2.editor.exitMultiSelectMode();
            return;
          }
          if (f !== 0)
            return;
          var l = e2.editor, c = l.selection, h = l.inMultiSelectMode, p = e2.getDocumentPosition(), d = c.getCursor(), v = e2.inSelection() || c.isEmpty() && s(p, d), m = e2.x, g = e2.y, y = function(e3) {
            m = e3.clientX, g = e3.clientY;
          }, b = l.session, w = l.renderer.pixelToScreenCoordinates(m, g), E = w, S;
          if (l.$mouseHandler.$enableJumpToDef)
            u && n2 || a && n2 ? S = o2 ? "block" : "add" : n2 && l.$blockSelectEnabled && (S = "block");
          else if (a && !n2) {
            S = "add";
            if (!h && o2)
              return;
          } else
            n2 && l.$blockSelectEnabled && (S = "block");
          S && i.isMac && t2.ctrlKey && l.$mouseHandler.cancelContextMenu();
          if (S == "add") {
            if (!h && v)
              return;
            if (!h) {
              var x = c.toOrientedRange();
              l.addSelectionMarker(x);
            }
            var T = c.rangeList.rangeAtPoint(p);
            l.inVirtualSelectionMode = true, o2 && (T = null, x = c.ranges[0] || x, l.removeSelectionMarker(x)), l.once("mouseup", function() {
              var e3 = c.toOrientedRange();
              T && e3.isEmpty() && s(T.cursor, e3.cursor) ? c.substractPoint(e3.cursor) : (o2 ? c.substractPoint(x.cursor) : x && (l.removeSelectionMarker(x), c.addRange(x)), c.addRange(e3)), l.inVirtualSelectionMode = false;
            });
          } else if (S == "block") {
            e2.stop(), l.inVirtualSelectionMode = true;
            var N, C = [], k = function() {
              var e3 = l.renderer.pixelToScreenCoordinates(m, g), t3 = b.screenToDocumentPosition(e3.row, e3.column, e3.offsetX);
              if (s(E, e3) && s(t3, c.lead))
                return;
              E = e3, l.selection.moveToPosition(t3), l.renderer.scrollCursorIntoView(), l.removeSelectionMarkers(C), C = c.rectangularRangeBlock(E, w), l.$mouseHandler.$clickSelection && C.length == 1 && C[0].isEmpty() && (C[0] = l.$mouseHandler.$clickSelection.clone()), C.forEach(l.addSelectionMarker, l), l.updateSelectionMarkers();
            };
            h && !a ? c.toSingleRange() : !h && a && (N = c.toOrientedRange(), l.addSelectionMarker(N)), o2 ? w = b.documentToScreenPosition(c.lead) : c.moveToPosition(p), E = { row: -1, column: -1 };
            var L = function(e3) {
              k(), clearInterval(O), l.removeSelectionMarkers(C), C.length || (C = [c.toOrientedRange()]), N && (l.removeSelectionMarker(N), c.toSingleRange(N));
              for (var t3 = 0; t3 < C.length; t3++)
                c.addRange(C[t3]);
              l.inVirtualSelectionMode = false, l.$mouseHandler.$clickSelection = null;
            }, A = k;
            r.capture(l.container, y, L);
            var O = setInterval(function() {
              A();
            }, 20);
            return e2.preventDefault();
          }
        }
        var r = e("../lib/event"), i = e("../lib/useragent");
        t.onMouseDown = o;
      }), ace.define("ace/commands/multi_select_commands", ["require", "exports", "module", "ace/keyboard/hash_handler"], function(e, t, n) {
        t.defaultCommands = [{ name: "addCursorAbove", description: "Add cursor above", exec: function(e2) {
          e2.selectMoreLines(-1);
        }, bindKey: { win: "Ctrl-Alt-Up", mac: "Ctrl-Alt-Up" }, scrollIntoView: "cursor", readOnly: true }, { name: "addCursorBelow", description: "Add cursor below", exec: function(e2) {
          e2.selectMoreLines(1);
        }, bindKey: { win: "Ctrl-Alt-Down", mac: "Ctrl-Alt-Down" }, scrollIntoView: "cursor", readOnly: true }, { name: "addCursorAboveSkipCurrent", description: "Add cursor above (skip current)", exec: function(e2) {
          e2.selectMoreLines(-1, true);
        }, bindKey: { win: "Ctrl-Alt-Shift-Up", mac: "Ctrl-Alt-Shift-Up" }, scrollIntoView: "cursor", readOnly: true }, { name: "addCursorBelowSkipCurrent", description: "Add cursor below (skip current)", exec: function(e2) {
          e2.selectMoreLines(1, true);
        }, bindKey: { win: "Ctrl-Alt-Shift-Down", mac: "Ctrl-Alt-Shift-Down" }, scrollIntoView: "cursor", readOnly: true }, { name: "selectMoreBefore", description: "Select more before", exec: function(e2) {
          e2.selectMore(-1);
        }, bindKey: { win: "Ctrl-Alt-Left", mac: "Ctrl-Alt-Left" }, scrollIntoView: "cursor", readOnly: true }, { name: "selectMoreAfter", description: "Select more after", exec: function(e2) {
          e2.selectMore(1);
        }, bindKey: { win: "Ctrl-Alt-Right", mac: "Ctrl-Alt-Right" }, scrollIntoView: "cursor", readOnly: true }, { name: "selectNextBefore", description: "Select next before", exec: function(e2) {
          e2.selectMore(-1, true);
        }, bindKey: { win: "Ctrl-Alt-Shift-Left", mac: "Ctrl-Alt-Shift-Left" }, scrollIntoView: "cursor", readOnly: true }, { name: "selectNextAfter", description: "Select next after", exec: function(e2) {
          e2.selectMore(1, true);
        }, bindKey: { win: "Ctrl-Alt-Shift-Right", mac: "Ctrl-Alt-Shift-Right" }, scrollIntoView: "cursor", readOnly: true }, { name: "toggleSplitSelectionIntoLines", description: "Split into lines", exec: function(e2) {
          e2.multiSelect.rangeCount > 1 ? e2.multiSelect.joinSelections() : e2.multiSelect.splitIntoLines();
        }, bindKey: { win: "Ctrl-Alt-L", mac: "Ctrl-Alt-L" }, readOnly: true }, { name: "splitSelectionIntoLines", description: "Split into lines", exec: function(e2) {
          e2.multiSelect.splitIntoLines();
        }, readOnly: true }, { name: "alignCursors", description: "Align cursors", exec: function(e2) {
          e2.alignCursors();
        }, bindKey: { win: "Ctrl-Alt-A", mac: "Ctrl-Alt-A" }, scrollIntoView: "cursor" }, { name: "findAll", description: "Find all", exec: function(e2) {
          e2.findAll();
        }, bindKey: { win: "Ctrl-Alt-K", mac: "Ctrl-Alt-G" }, scrollIntoView: "cursor", readOnly: true }], t.multiSelectCommands = [{ name: "singleSelection", description: "Single selection", bindKey: "esc", exec: function(e2) {
          e2.exitMultiSelectMode();
        }, scrollIntoView: "cursor", readOnly: true, isAvailable: function(e2) {
          return e2 && e2.inMultiSelectMode;
        } }];
        var r = e("../keyboard/hash_handler").HashHandler;
        t.keyboardHandler = new r(t.multiSelectCommands);
      }), ace.define("ace/multi_select", ["require", "exports", "module", "ace/range_list", "ace/range", "ace/selection", "ace/mouse/multi_select_handler", "ace/lib/event", "ace/lib/lang", "ace/commands/multi_select_commands", "ace/search", "ace/edit_session", "ace/editor", "ace/config"], function(e, t, n) {
        function h(e2, t2, n2) {
          return c.$options.wrap = true, c.$options.needle = t2, c.$options.backwards = n2 == -1, c.find(e2);
        }
        function v(e2, t2) {
          return e2.row == t2.row && e2.column == t2.column;
        }
        function m(e2) {
          if (e2.$multiselectOnSessionChange)
            return;
          e2.$onAddRange = e2.$onAddRange.bind(e2), e2.$onRemoveRange = e2.$onRemoveRange.bind(e2), e2.$onMultiSelect = e2.$onMultiSelect.bind(e2), e2.$onSingleSelect = e2.$onSingleSelect.bind(e2), e2.$multiselectOnSessionChange = t.onSessionChange.bind(e2), e2.$checkMultiselectChange = e2.$checkMultiselectChange.bind(e2), e2.$multiselectOnSessionChange(e2), e2.on("changeSession", e2.$multiselectOnSessionChange), e2.on("mousedown", o), e2.commands.addCommands(f.defaultCommands), g(e2);
        }
        function g(e2) {
          function r2(t3) {
            n2 && (e2.renderer.setMouseCursor(""), n2 = false);
          }
          if (!e2.textInput)
            return;
          var t2 = e2.textInput.getElement(), n2 = false;
          u.addListener(t2, "keydown", function(t3) {
            var i2 = t3.keyCode == 18 && !(t3.ctrlKey || t3.shiftKey || t3.metaKey);
            e2.$blockSelectEnabled && i2 ? n2 || (e2.renderer.setMouseCursor("crosshair"), n2 = true) : n2 && r2();
          }, e2), u.addListener(t2, "keyup", r2, e2), u.addListener(t2, "blur", r2, e2);
        }
        var r = e("./range_list").RangeList, i = e("./range").Range, s = e("./selection").Selection, o = e("./mouse/multi_select_handler").onMouseDown, u = e("./lib/event"), a = e("./lib/lang"), f = e("./commands/multi_select_commands");
        t.commands = f.defaultCommands.concat(f.multiSelectCommands);
        var l = e("./search").Search, c = new l(), p = e("./edit_session").EditSession;
        (function() {
          this.getSelectionMarkers = function() {
            return this.$selectionMarkers;
          };
        }).call(p.prototype), function() {
          this.ranges = null, this.rangeList = null, this.addRange = function(e2, t2) {
            if (!e2)
              return;
            if (!this.inMultiSelectMode && this.rangeCount === 0) {
              var n2 = this.toOrientedRange();
              this.rangeList.add(n2), this.rangeList.add(e2);
              if (this.rangeList.ranges.length != 2)
                return this.rangeList.removeAll(), t2 || this.fromOrientedRange(e2);
              this.rangeList.removeAll(), this.rangeList.add(n2), this.$onAddRange(n2);
            }
            e2.cursor || (e2.cursor = e2.end);
            var r2 = this.rangeList.add(e2);
            return this.$onAddRange(e2), r2.length && this.$onRemoveRange(r2), this.rangeCount > 1 && !this.inMultiSelectMode && (this._signal("multiSelect"), this.inMultiSelectMode = true, this.session.$undoSelect = false, this.rangeList.attach(this.session)), t2 || this.fromOrientedRange(e2);
          }, this.toSingleRange = function(e2) {
            e2 = e2 || this.ranges[0];
            var t2 = this.rangeList.removeAll();
            t2.length && this.$onRemoveRange(t2), e2 && this.fromOrientedRange(e2);
          }, this.substractPoint = function(e2) {
            var t2 = this.rangeList.substractPoint(e2);
            if (t2)
              return this.$onRemoveRange(t2), t2[0];
          }, this.mergeOverlappingRanges = function() {
            var e2 = this.rangeList.merge();
            e2.length && this.$onRemoveRange(e2);
          }, this.$onAddRange = function(e2) {
            this.rangeCount = this.rangeList.ranges.length, this.ranges.unshift(e2), this._signal("addRange", { range: e2 });
          }, this.$onRemoveRange = function(e2) {
            this.rangeCount = this.rangeList.ranges.length;
            if (this.rangeCount == 1 && this.inMultiSelectMode) {
              var t2 = this.rangeList.ranges.pop();
              e2.push(t2), this.rangeCount = 0;
            }
            for (var n2 = e2.length; n2--; ) {
              var r2 = this.ranges.indexOf(e2[n2]);
              this.ranges.splice(r2, 1);
            }
            this._signal("removeRange", { ranges: e2 }), this.rangeCount === 0 && this.inMultiSelectMode && (this.inMultiSelectMode = false, this._signal("singleSelect"), this.session.$undoSelect = true, this.rangeList.detach(this.session)), t2 = t2 || this.ranges[0], t2 && !t2.isEqual(this.getRange()) && this.fromOrientedRange(t2);
          }, this.$initRangeList = function() {
            if (this.rangeList)
              return;
            this.rangeList = new r(), this.ranges = [], this.rangeCount = 0;
          }, this.getAllRanges = function() {
            return this.rangeCount ? this.rangeList.ranges.concat() : [this.getRange()];
          }, this.splitIntoLines = function() {
            var e2 = this.ranges.length ? this.ranges : [this.getRange()], t2 = [];
            for (var n2 = 0; n2 < e2.length; n2++) {
              var r2 = e2[n2], s2 = r2.start.row, o2 = r2.end.row;
              if (s2 === o2)
                t2.push(r2.clone());
              else {
                t2.push(new i(s2, r2.start.column, s2, this.session.getLine(s2).length));
                while (++s2 < o2)
                  t2.push(this.getLineRange(s2, true));
                t2.push(new i(o2, 0, o2, r2.end.column));
              }
              n2 == 0 && !this.isBackwards() && (t2 = t2.reverse());
            }
            this.toSingleRange();
            for (var n2 = t2.length; n2--; )
              this.addRange(t2[n2]);
          }, this.joinSelections = function() {
            var e2 = this.rangeList.ranges, t2 = e2[e2.length - 1], n2 = i.fromPoints(e2[0].start, t2.end);
            this.toSingleRange(), this.setSelectionRange(n2, t2.cursor == t2.start);
          }, this.toggleBlockSelection = function() {
            if (this.rangeCount > 1) {
              var e2 = this.rangeList.ranges, t2 = e2[e2.length - 1], n2 = i.fromPoints(e2[0].start, t2.end);
              this.toSingleRange(), this.setSelectionRange(n2, t2.cursor == t2.start);
            } else {
              var r2 = this.session.documentToScreenPosition(this.cursor), s2 = this.session.documentToScreenPosition(this.anchor), o2 = this.rectangularRangeBlock(r2, s2);
              o2.forEach(this.addRange, this);
            }
          }, this.rectangularRangeBlock = function(e2, t2, n2) {
            var r2 = [], s2 = e2.column < t2.column;
            if (s2)
              var o2 = e2.column, u2 = t2.column, a2 = e2.offsetX, f2 = t2.offsetX;
            else
              var o2 = t2.column, u2 = e2.column, a2 = t2.offsetX, f2 = e2.offsetX;
            var l2 = e2.row < t2.row;
            if (l2)
              var c2 = e2.row, h2 = t2.row;
            else
              var c2 = t2.row, h2 = e2.row;
            o2 < 0 && (o2 = 0), c2 < 0 && (c2 = 0), c2 == h2 && (n2 = true);
            var p2;
            for (var d2 = c2; d2 <= h2; d2++) {
              var m2 = i.fromPoints(this.session.screenToDocumentPosition(d2, o2, a2), this.session.screenToDocumentPosition(d2, u2, f2));
              if (m2.isEmpty()) {
                if (p2 && v(m2.end, p2))
                  break;
                p2 = m2.end;
              }
              m2.cursor = s2 ? m2.start : m2.end, r2.push(m2);
            }
            l2 && r2.reverse();
            if (!n2) {
              var g2 = r2.length - 1;
              while (r2[g2].isEmpty() && g2 > 0)
                g2--;
              if (g2 > 0) {
                var y = 0;
                while (r2[y].isEmpty())
                  y++;
              }
              for (var b = g2; b >= y; b--)
                r2[b].isEmpty() && r2.splice(b, 1);
            }
            return r2;
          };
        }.call(s.prototype);
        var d = e("./editor").Editor;
        (function() {
          this.updateSelectionMarkers = function() {
            this.renderer.updateCursor(), this.renderer.updateBackMarkers();
          }, this.addSelectionMarker = function(e2) {
            e2.cursor || (e2.cursor = e2.end);
            var t2 = this.getSelectionStyle();
            return e2.marker = this.session.addMarker(e2, "ace_selection", t2), this.session.$selectionMarkers.push(e2), this.session.selectionMarkerCount = this.session.$selectionMarkers.length, e2;
          }, this.removeSelectionMarker = function(e2) {
            if (!e2.marker)
              return;
            this.session.removeMarker(e2.marker);
            var t2 = this.session.$selectionMarkers.indexOf(e2);
            t2 != -1 && this.session.$selectionMarkers.splice(t2, 1), this.session.selectionMarkerCount = this.session.$selectionMarkers.length;
          }, this.removeSelectionMarkers = function(e2) {
            var t2 = this.session.$selectionMarkers;
            for (var n2 = e2.length; n2--; ) {
              var r2 = e2[n2];
              if (!r2.marker)
                continue;
              this.session.removeMarker(r2.marker);
              var i2 = t2.indexOf(r2);
              i2 != -1 && t2.splice(i2, 1);
            }
            this.session.selectionMarkerCount = t2.length;
          }, this.$onAddRange = function(e2) {
            this.addSelectionMarker(e2.range), this.renderer.updateCursor(), this.renderer.updateBackMarkers();
          }, this.$onRemoveRange = function(e2) {
            this.removeSelectionMarkers(e2.ranges), this.renderer.updateCursor(), this.renderer.updateBackMarkers();
          }, this.$onMultiSelect = function(e2) {
            if (this.inMultiSelectMode)
              return;
            this.inMultiSelectMode = true, this.setStyle("ace_multiselect"), this.keyBinding.addKeyboardHandler(f.keyboardHandler), this.commands.setDefaultHandler("exec", this.$onMultiSelectExec), this.renderer.updateCursor(), this.renderer.updateBackMarkers();
          }, this.$onSingleSelect = function(e2) {
            if (this.session.multiSelect.inVirtualMode)
              return;
            this.inMultiSelectMode = false, this.unsetStyle("ace_multiselect"), this.keyBinding.removeKeyboardHandler(f.keyboardHandler), this.commands.removeDefaultHandler("exec", this.$onMultiSelectExec), this.renderer.updateCursor(), this.renderer.updateBackMarkers(), this._emit("changeSelection");
          }, this.$onMultiSelectExec = function(e2) {
            var t2 = e2.command, n2 = e2.editor;
            if (!n2.multiSelect)
              return;
            if (!t2.multiSelectAction) {
              var r2 = t2.exec(n2, e2.args || {});
              n2.multiSelect.addRange(n2.multiSelect.toOrientedRange()), n2.multiSelect.mergeOverlappingRanges();
            } else
              t2.multiSelectAction == "forEach" ? r2 = n2.forEachSelection(t2, e2.args) : t2.multiSelectAction == "forEachLine" ? r2 = n2.forEachSelection(t2, e2.args, true) : t2.multiSelectAction == "single" ? (n2.exitMultiSelectMode(), r2 = t2.exec(n2, e2.args || {})) : r2 = t2.multiSelectAction(n2, e2.args || {});
            return r2;
          }, this.forEachSelection = function(e2, t2, n2) {
            if (this.inVirtualSelectionMode)
              return;
            var r2 = n2 && n2.keepOrder, i2 = n2 == 1 || n2 && n2.$byLines, o2 = this.session, u2 = this.selection, a2 = u2.rangeList, f2 = (r2 ? u2 : a2).ranges, l2;
            if (!f2.length)
              return e2.exec ? e2.exec(this, t2 || {}) : e2(this, t2 || {});
            var c2 = u2._eventRegistry;
            u2._eventRegistry = {};
            var h2 = new s(o2);
            this.inVirtualSelectionMode = true;
            for (var p2 = f2.length; p2--; ) {
              if (i2)
                while (p2 > 0 && f2[p2].start.row == f2[p2 - 1].end.row)
                  p2--;
              h2.fromOrientedRange(f2[p2]), h2.index = p2, this.selection = o2.selection = h2;
              var d2 = e2.exec ? e2.exec(this, t2 || {}) : e2(this, t2 || {});
              !l2 && d2 !== void 0 && (l2 = d2), h2.toOrientedRange(f2[p2]);
            }
            h2.detach(), this.selection = o2.selection = u2, this.inVirtualSelectionMode = false, u2._eventRegistry = c2, u2.mergeOverlappingRanges(), u2.ranges[0] && u2.fromOrientedRange(u2.ranges[0]);
            var v2 = this.renderer.$scrollAnimation;
            return this.onCursorChange(), this.onSelectionChange(), v2 && v2.from == v2.to && this.renderer.animateScrolling(v2.from), l2;
          }, this.exitMultiSelectMode = function() {
            if (!this.inMultiSelectMode || this.inVirtualSelectionMode)
              return;
            this.multiSelect.toSingleRange();
          }, this.getSelectedText = function() {
            var e2 = "";
            if (this.inMultiSelectMode && !this.inVirtualSelectionMode) {
              var t2 = this.multiSelect.rangeList.ranges, n2 = [];
              for (var r2 = 0; r2 < t2.length; r2++)
                n2.push(this.session.getTextRange(t2[r2]));
              var i2 = this.session.getDocument().getNewLineCharacter();
              e2 = n2.join(i2), e2.length == (n2.length - 1) * i2.length && (e2 = "");
            } else
              this.selection.isEmpty() || (e2 = this.session.getTextRange(this.getSelectionRange()));
            return e2;
          }, this.$checkMultiselectChange = function(e2, t2) {
            if (this.inMultiSelectMode && !this.inVirtualSelectionMode) {
              var n2 = this.multiSelect.ranges[0];
              if (this.multiSelect.isEmpty() && t2 == this.multiSelect.anchor)
                return;
              var r2 = t2 == this.multiSelect.anchor ? n2.cursor == n2.start ? n2.end : n2.start : n2.cursor;
              r2.row != t2.row || this.session.$clipPositionToDocument(r2.row, r2.column).column != t2.column ? this.multiSelect.toSingleRange(this.multiSelect.toOrientedRange()) : this.multiSelect.mergeOverlappingRanges();
            }
          }, this.findAll = function(e2, t2, n2) {
            t2 = t2 || {}, t2.needle = e2 || t2.needle;
            if (t2.needle == void 0) {
              var r2 = this.selection.isEmpty() ? this.selection.getWordRange() : this.selection.getRange();
              t2.needle = this.session.getTextRange(r2);
            }
            this.$search.set(t2);
            var i2 = this.$search.findAll(this.session);
            if (!i2.length)
              return 0;
            var s2 = this.multiSelect;
            n2 || s2.toSingleRange(i2[0]);
            for (var o2 = i2.length; o2--; )
              s2.addRange(i2[o2], true);
            return r2 && s2.rangeList.rangeAtPoint(r2.start) && s2.addRange(r2, true), i2.length;
          }, this.selectMoreLines = function(e2, t2) {
            var n2 = this.selection.toOrientedRange(), r2 = n2.cursor == n2.end, s2 = this.session.documentToScreenPosition(n2.cursor);
            this.selection.$desiredColumn && (s2.column = this.selection.$desiredColumn);
            var o2 = this.session.screenToDocumentPosition(s2.row + e2, s2.column);
            if (!n2.isEmpty())
              var u2 = this.session.documentToScreenPosition(r2 ? n2.end : n2.start), a2 = this.session.screenToDocumentPosition(u2.row + e2, u2.column);
            else
              var a2 = o2;
            if (r2) {
              var f2 = i.fromPoints(o2, a2);
              f2.cursor = f2.start;
            } else {
              var f2 = i.fromPoints(a2, o2);
              f2.cursor = f2.end;
            }
            f2.desiredColumn = s2.column;
            if (!this.selection.inMultiSelectMode)
              this.selection.addRange(n2);
            else if (t2)
              var l2 = n2.cursor;
            this.selection.addRange(f2), l2 && this.selection.substractPoint(l2);
          }, this.transposeSelections = function(e2) {
            var t2 = this.session, n2 = t2.multiSelect, r2 = n2.ranges;
            for (var i2 = r2.length; i2--; ) {
              var s2 = r2[i2];
              if (s2.isEmpty()) {
                var o2 = t2.getWordRange(s2.start.row, s2.start.column);
                s2.start.row = o2.start.row, s2.start.column = o2.start.column, s2.end.row = o2.end.row, s2.end.column = o2.end.column;
              }
            }
            n2.mergeOverlappingRanges();
            var u2 = [];
            for (var i2 = r2.length; i2--; ) {
              var s2 = r2[i2];
              u2.unshift(t2.getTextRange(s2));
            }
            e2 < 0 ? u2.unshift(u2.pop()) : u2.push(u2.shift());
            for (var i2 = r2.length; i2--; ) {
              var s2 = r2[i2], o2 = s2.clone();
              t2.replace(s2, u2[i2]), s2.start.row = o2.start.row, s2.start.column = o2.start.column;
            }
            n2.fromOrientedRange(n2.ranges[0]);
          }, this.selectMore = function(e2, t2, n2) {
            var r2 = this.session, i2 = r2.multiSelect, s2 = i2.toOrientedRange();
            if (s2.isEmpty()) {
              s2 = r2.getWordRange(s2.start.row, s2.start.column), s2.cursor = e2 == -1 ? s2.start : s2.end, this.multiSelect.addRange(s2);
              if (n2)
                return;
            }
            var o2 = r2.getTextRange(s2), u2 = h(r2, o2, e2);
            u2 && (u2.cursor = e2 == -1 ? u2.start : u2.end, this.session.unfold(u2), this.multiSelect.addRange(u2), this.renderer.scrollCursorIntoView(null, 0.5)), t2 && this.multiSelect.substractPoint(s2.cursor);
          }, this.alignCursors = function() {
            var e2 = this.session, t2 = e2.multiSelect, n2 = t2.ranges, r2 = -1, s2 = n2.filter(function(e3) {
              if (e3.cursor.row == r2)
                return true;
              r2 = e3.cursor.row;
            });
            if (!n2.length || s2.length == n2.length - 1) {
              var o2 = this.selection.getRange(), u2 = o2.start.row, f2 = o2.end.row, l2 = u2 == f2;
              if (l2) {
                var c2 = this.session.getLength(), h2;
                do
                  h2 = this.session.getLine(f2);
                while (/[=:]/.test(h2) && ++f2 < c2);
                do
                  h2 = this.session.getLine(u2);
                while (/[=:]/.test(h2) && --u2 > 0);
                u2 < 0 && (u2 = 0), f2 >= c2 && (f2 = c2 - 1);
              }
              var p2 = this.session.removeFullLines(u2, f2);
              p2 = this.$reAlignText(p2, l2), this.session.insert({ row: u2, column: 0 }, p2.join("\n") + "\n"), l2 || (o2.start.column = 0, o2.end.column = p2[p2.length - 1].length), this.selection.setRange(o2);
            } else {
              s2.forEach(function(e3) {
                t2.substractPoint(e3.cursor);
              });
              var d2 = 0, v2 = Infinity, m2 = n2.map(function(t3) {
                var n3 = t3.cursor, r3 = e2.getLine(n3.row), i2 = r3.substr(n3.column).search(/\S/g);
                return i2 == -1 && (i2 = 0), n3.column > d2 && (d2 = n3.column), i2 < v2 && (v2 = i2), i2;
              });
              n2.forEach(function(t3, n3) {
                var r3 = t3.cursor, s3 = d2 - r3.column, o3 = m2[n3] - v2;
                s3 > o3 ? e2.insert(r3, a.stringRepeat(" ", s3 - o3)) : e2.remove(new i(r3.row, r3.column, r3.row, r3.column - s3 + o3)), t3.start.column = t3.end.column = d2, t3.start.row = t3.end.row = r3.row, t3.cursor = t3.end;
              }), t2.fromOrientedRange(n2[0]), this.renderer.updateCursor(), this.renderer.updateBackMarkers();
            }
          }, this.$reAlignText = function(e2, t2) {
            function u2(e3) {
              return a.stringRepeat(" ", e3);
            }
            function f2(e3) {
              return e3[2] ? u2(i2) + e3[2] + u2(s2 - e3[2].length + o2) + e3[4].replace(/^([=:])\s+/, "$1 ") : e3[0];
            }
            function l2(e3) {
              return e3[2] ? u2(i2 + s2 - e3[2].length) + e3[2] + u2(o2) + e3[4].replace(/^([=:])\s+/, "$1 ") : e3[0];
            }
            function c2(e3) {
              return e3[2] ? u2(i2) + e3[2] + u2(o2) + e3[4].replace(/^([=:])\s+/, "$1 ") : e3[0];
            }
            var n2 = true, r2 = true, i2, s2, o2;
            return e2.map(function(e3) {
              var t3 = e3.match(/(\s*)(.*?)(\s*)([=:].*)/);
              return t3 ? i2 == null ? (i2 = t3[1].length, s2 = t3[2].length, o2 = t3[3].length, t3) : (i2 + s2 + o2 != t3[1].length + t3[2].length + t3[3].length && (r2 = false), i2 != t3[1].length && (n2 = false), i2 > t3[1].length && (i2 = t3[1].length), s2 < t3[2].length && (s2 = t3[2].length), o2 > t3[3].length && (o2 = t3[3].length), t3) : [e3];
            }).map(t2 ? f2 : n2 ? r2 ? l2 : f2 : c2);
          };
        }).call(d.prototype), t.onSessionChange = function(e2) {
          var t2 = e2.session;
          t2 && !t2.multiSelect && (t2.$selectionMarkers = [], t2.selection.$initRangeList(), t2.multiSelect = t2.selection), this.multiSelect = t2 && t2.multiSelect;
          var n2 = e2.oldSession;
          n2 && (n2.multiSelect.off("addRange", this.$onAddRange), n2.multiSelect.off("removeRange", this.$onRemoveRange), n2.multiSelect.off("multiSelect", this.$onMultiSelect), n2.multiSelect.off("singleSelect", this.$onSingleSelect), n2.multiSelect.lead.off("change", this.$checkMultiselectChange), n2.multiSelect.anchor.off("change", this.$checkMultiselectChange)), t2 && (t2.multiSelect.on("addRange", this.$onAddRange), t2.multiSelect.on("removeRange", this.$onRemoveRange), t2.multiSelect.on("multiSelect", this.$onMultiSelect), t2.multiSelect.on("singleSelect", this.$onSingleSelect), t2.multiSelect.lead.on("change", this.$checkMultiselectChange), t2.multiSelect.anchor.on("change", this.$checkMultiselectChange)), t2 && this.inMultiSelectMode != t2.selection.inMultiSelectMode && (t2.selection.inMultiSelectMode ? this.$onMultiSelect() : this.$onSingleSelect());
        }, t.MultiSelect = m, e("./config").defineOptions(d.prototype, "editor", { enableMultiselect: { set: function(e2) {
          m(this), e2 ? (this.on("changeSession", this.$multiselectOnSessionChange), this.on("mousedown", o)) : (this.off("changeSession", this.$multiselectOnSessionChange), this.off("mousedown", o));
        }, value: true }, enableBlockSelect: { set: function(e2) {
          this.$blockSelectEnabled = e2;
        }, value: true } });
      }), ace.define("ace/mode/folding/fold_mode", ["require", "exports", "module", "ace/range"], function(e, t, n) {
        "use strict";
        var r = e("../../range").Range, i = t.FoldMode = function() {
        };
        (function() {
          this.foldingStartMarker = null, this.foldingStopMarker = null, this.getFoldWidget = function(e2, t2, n2) {
            var r2 = e2.getLine(n2);
            return this.foldingStartMarker.test(r2) ? "start" : t2 == "markbeginend" && this.foldingStopMarker && this.foldingStopMarker.test(r2) ? "end" : "";
          }, this.getFoldWidgetRange = function(e2, t2, n2) {
            return null;
          }, this.indentationBlock = function(e2, t2, n2) {
            var i2 = /\S/, s = e2.getLine(t2), o = s.search(i2);
            if (o == -1)
              return;
            var u = n2 || s.length, a = e2.getLength(), f = t2, l = t2;
            while (++t2 < a) {
              var c = e2.getLine(t2).search(i2);
              if (c == -1)
                continue;
              if (c <= o) {
                var h = e2.getTokenAt(t2, 0);
                if (!h || h.type !== "string")
                  break;
              }
              l = t2;
            }
            if (l > f) {
              var p = e2.getLine(l).length;
              return new r(f, u, l, p);
            }
          }, this.openingBracketBlock = function(e2, t2, n2, i2, s) {
            var o = { row: n2, column: i2 + 1 }, u = e2.$findClosingBracket(t2, o, s);
            if (!u)
              return;
            var a = e2.foldWidgets[u.row];
            return a == null && (a = e2.getFoldWidget(u.row)), a == "start" && u.row > o.row && (u.row--, u.column = e2.getLine(u.row).length), r.fromPoints(o, u);
          }, this.closingBracketBlock = function(e2, t2, n2, i2, s) {
            var o = { row: n2, column: i2 }, u = e2.$findOpeningBracket(t2, o);
            if (!u)
              return;
            return u.column++, o.column--, r.fromPoints(u, o);
          };
        }).call(i.prototype);
      }), ace.define("ace/theme/textmate", ["require", "exports", "module", "ace/lib/dom"], function(e, t, n) {
        "use strict";
        t.isDark = false, t.cssClass = "ace-tm", t.cssText = '.ace-tm .ace_gutter {background: #f0f0f0;color: #333;}.ace-tm .ace_print-margin {width: 1px;background: #e8e8e8;}.ace-tm .ace_fold {background-color: #6B72E6;}.ace-tm {background-color: #FFFFFF;color: black;}.ace-tm .ace_cursor {color: black;}.ace-tm .ace_invisible {color: rgb(191, 191, 191);}.ace-tm .ace_storage,.ace-tm .ace_keyword {color: blue;}.ace-tm .ace_constant {color: rgb(197, 6, 11);}.ace-tm .ace_constant.ace_buildin {color: rgb(88, 72, 246);}.ace-tm .ace_constant.ace_language {color: rgb(88, 92, 246);}.ace-tm .ace_constant.ace_library {color: rgb(6, 150, 14);}.ace-tm .ace_invalid {background-color: rgba(255, 0, 0, 0.1);color: red;}.ace-tm .ace_support.ace_function {color: rgb(60, 76, 114);}.ace-tm .ace_support.ace_constant {color: rgb(6, 150, 14);}.ace-tm .ace_support.ace_type,.ace-tm .ace_support.ace_class {color: rgb(109, 121, 222);}.ace-tm .ace_keyword.ace_operator {color: rgb(104, 118, 135);}.ace-tm .ace_string {color: rgb(3, 106, 7);}.ace-tm .ace_comment {color: rgb(76, 136, 107);}.ace-tm .ace_comment.ace_doc {color: rgb(0, 102, 255);}.ace-tm .ace_comment.ace_doc.ace_tag {color: rgb(128, 159, 191);}.ace-tm .ace_constant.ace_numeric {color: rgb(0, 0, 205);}.ace-tm .ace_variable {color: rgb(49, 132, 149);}.ace-tm .ace_xml-pe {color: rgb(104, 104, 91);}.ace-tm .ace_entity.ace_name.ace_function {color: #0000A2;}.ace-tm .ace_heading {color: rgb(12, 7, 255);}.ace-tm .ace_list {color:rgb(185, 6, 144);}.ace-tm .ace_meta.ace_tag {color:rgb(0, 22, 142);}.ace-tm .ace_string.ace_regex {color: rgb(255, 0, 0)}.ace-tm .ace_marker-layer .ace_selection {background: rgb(181, 213, 255);}.ace-tm.ace_multiselect .ace_selection.ace_start {box-shadow: 0 0 3px 0px white;}.ace-tm .ace_marker-layer .ace_step {background: rgb(252, 255, 0);}.ace-tm .ace_marker-layer .ace_stack {background: rgb(164, 229, 101);}.ace-tm .ace_marker-layer .ace_bracket {margin: -1px 0 0 -1px;border: 1px solid rgb(192, 192, 192);}.ace-tm .ace_marker-layer .ace_active-line {background: rgba(0, 0, 0, 0.07);}.ace-tm .ace_gutter-active-line {background-color : #dcdcdc;}.ace-tm .ace_marker-layer .ace_selected-word {background: rgb(250, 250, 255);border: 1px solid rgb(200, 200, 250);}.ace-tm .ace_indent-guide {background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAE0lEQVQImWP4////f4bLly//BwAmVgd1/w11/gAAAABJRU5ErkJggg==") right repeat-y;}', t.$id = "ace/theme/textmate";
        var r = e("../lib/dom");
        r.importCssString(t.cssText, t.cssClass, false);
      }), ace.define("ace/line_widgets", ["require", "exports", "module", "ace/lib/dom"], function(e, t, n) {
        "use strict";
        function i(e2) {
          this.session = e2, this.session.widgetManager = this, this.session.getRowLength = this.getRowLength, this.session.$getWidgetScreenLength = this.$getWidgetScreenLength, this.updateOnChange = this.updateOnChange.bind(this), this.renderWidgets = this.renderWidgets.bind(this), this.measureWidgets = this.measureWidgets.bind(this), this.session._changedWidgets = [], this.$onChangeEditor = this.$onChangeEditor.bind(this), this.session.on("change", this.updateOnChange), this.session.on("changeFold", this.updateOnFold), this.session.on("changeEditor", this.$onChangeEditor);
        }
        var r = e("./lib/dom");
        (function() {
          this.getRowLength = function(e2) {
            var t2;
            return this.lineWidgets ? t2 = this.lineWidgets[e2] && this.lineWidgets[e2].rowCount || 0 : t2 = 0, !this.$useWrapMode || !this.$wrapData[e2] ? 1 + t2 : this.$wrapData[e2].length + 1 + t2;
          }, this.$getWidgetScreenLength = function() {
            var e2 = 0;
            return this.lineWidgets.forEach(function(t2) {
              t2 && t2.rowCount && !t2.hidden && (e2 += t2.rowCount);
            }), e2;
          }, this.$onChangeEditor = function(e2) {
            this.attach(e2.editor);
          }, this.attach = function(e2) {
            e2 && e2.widgetManager && e2.widgetManager != this && e2.widgetManager.detach();
            if (this.editor == e2)
              return;
            this.detach(), this.editor = e2, e2 && (e2.widgetManager = this, e2.renderer.on("beforeRender", this.measureWidgets), e2.renderer.on("afterRender", this.renderWidgets));
          }, this.detach = function(e2) {
            var t2 = this.editor;
            if (!t2)
              return;
            this.editor = null, t2.widgetManager = null, t2.renderer.off("beforeRender", this.measureWidgets), t2.renderer.off("afterRender", this.renderWidgets);
            var n2 = this.session.lineWidgets;
            n2 && n2.forEach(function(e3) {
              e3 && e3.el && e3.el.parentNode && (e3._inDocument = false, e3.el.parentNode.removeChild(e3.el));
            });
          }, this.updateOnFold = function(e2, t2) {
            var n2 = t2.lineWidgets;
            if (!n2 || !e2.action)
              return;
            var r2 = e2.data, i2 = r2.start.row, s = r2.end.row, o = e2.action == "add";
            for (var u = i2 + 1; u < s; u++)
              n2[u] && (n2[u].hidden = o);
            n2[s] && (o ? n2[i2] ? n2[s].hidden = o : n2[i2] = n2[s] : (n2[i2] == n2[s] && (n2[i2] = void 0), n2[s].hidden = o));
          }, this.updateOnChange = function(e2) {
            var t2 = this.session.lineWidgets;
            if (!t2)
              return;
            var n2 = e2.start.row, r2 = e2.end.row - n2;
            if (r2 !== 0)
              if (e2.action == "remove") {
                var i2 = t2.splice(n2 + 1, r2);
                !t2[n2] && i2[i2.length - 1] && (t2[n2] = i2.pop()), i2.forEach(function(e3) {
                  e3 && this.removeLineWidget(e3);
                }, this), this.$updateRows();
              } else {
                var s = new Array(r2);
                t2[n2] && t2[n2].column != null && e2.start.column > t2[n2].column && n2++, s.unshift(n2, 0), t2.splice.apply(t2, s), this.$updateRows();
              }
          }, this.$updateRows = function() {
            var e2 = this.session.lineWidgets;
            if (!e2)
              return;
            var t2 = true;
            e2.forEach(function(e3, n2) {
              if (e3) {
                t2 = false, e3.row = n2;
                while (e3.$oldWidget)
                  e3.$oldWidget.row = n2, e3 = e3.$oldWidget;
              }
            }), t2 && (this.session.lineWidgets = null);
          }, this.$registerLineWidget = function(e2) {
            this.session.lineWidgets || (this.session.lineWidgets = new Array(this.session.getLength()));
            var t2 = this.session.lineWidgets[e2.row];
            return t2 && (e2.$oldWidget = t2, t2.el && t2.el.parentNode && (t2.el.parentNode.removeChild(t2.el), t2._inDocument = false)), this.session.lineWidgets[e2.row] = e2, e2;
          }, this.addLineWidget = function(e2) {
            this.$registerLineWidget(e2), e2.session = this.session;
            if (!this.editor)
              return e2;
            var t2 = this.editor.renderer;
            e2.html && !e2.el && (e2.el = r.createElement("div"), e2.el.innerHTML = e2.html), e2.el && (r.addCssClass(e2.el, "ace_lineWidgetContainer"), e2.el.style.position = "absolute", e2.el.style.zIndex = 5, t2.container.appendChild(e2.el), e2._inDocument = true, e2.coverGutter || (e2.el.style.zIndex = 3), e2.pixelHeight == null && (e2.pixelHeight = e2.el.offsetHeight)), e2.rowCount == null && (e2.rowCount = e2.pixelHeight / t2.layerConfig.lineHeight);
            var n2 = this.session.getFoldAt(e2.row, 0);
            e2.$fold = n2;
            if (n2) {
              var i2 = this.session.lineWidgets;
              e2.row == n2.end.row && !i2[n2.start.row] ? i2[n2.start.row] = e2 : e2.hidden = true;
            }
            return this.session._emit("changeFold", { data: { start: { row: e2.row } } }), this.$updateRows(), this.renderWidgets(null, t2), this.onWidgetChanged(e2), e2;
          }, this.removeLineWidget = function(e2) {
            e2._inDocument = false, e2.session = null, e2.el && e2.el.parentNode && e2.el.parentNode.removeChild(e2.el);
            if (e2.editor && e2.editor.destroy)
              try {
                e2.editor.destroy();
              } catch (t2) {
              }
            if (this.session.lineWidgets) {
              var n2 = this.session.lineWidgets[e2.row];
              if (n2 == e2)
                this.session.lineWidgets[e2.row] = e2.$oldWidget, e2.$oldWidget && this.onWidgetChanged(e2.$oldWidget);
              else
                while (n2) {
                  if (n2.$oldWidget == e2) {
                    n2.$oldWidget = e2.$oldWidget;
                    break;
                  }
                  n2 = n2.$oldWidget;
                }
            }
            this.session._emit("changeFold", { data: { start: { row: e2.row } } }), this.$updateRows();
          }, this.getWidgetsAtRow = function(e2) {
            var t2 = this.session.lineWidgets, n2 = t2 && t2[e2], r2 = [];
            while (n2)
              r2.push(n2), n2 = n2.$oldWidget;
            return r2;
          }, this.onWidgetChanged = function(e2) {
            this.session._changedWidgets.push(e2), this.editor && this.editor.renderer.updateFull();
          }, this.measureWidgets = function(e2, t2) {
            var n2 = this.session._changedWidgets, r2 = t2.layerConfig;
            if (!n2 || !n2.length)
              return;
            var i2 = Infinity;
            for (var s = 0; s < n2.length; s++) {
              var o = n2[s];
              if (!o || !o.el)
                continue;
              if (o.session != this.session)
                continue;
              if (!o._inDocument) {
                if (this.session.lineWidgets[o.row] != o)
                  continue;
                o._inDocument = true, t2.container.appendChild(o.el);
              }
              o.h = o.el.offsetHeight, o.fixedWidth || (o.w = o.el.offsetWidth, o.screenWidth = Math.ceil(o.w / r2.characterWidth));
              var u = o.h / r2.lineHeight;
              o.coverLine && (u -= this.session.getRowLineCount(o.row), u < 0 && (u = 0)), o.rowCount != u && (o.rowCount = u, o.row < i2 && (i2 = o.row));
            }
            i2 != Infinity && (this.session._emit("changeFold", { data: { start: { row: i2 } } }), this.session.lineWidgetWidth = null), this.session._changedWidgets = [];
          }, this.renderWidgets = function(e2, t2) {
            var n2 = t2.layerConfig, r2 = this.session.lineWidgets;
            if (!r2)
              return;
            var i2 = Math.min(this.firstRow, n2.firstRow), s = Math.max(this.lastRow, n2.lastRow, r2.length);
            while (i2 > 0 && !r2[i2])
              i2--;
            this.firstRow = n2.firstRow, this.lastRow = n2.lastRow, t2.$cursorLayer.config = n2;
            for (var o = i2; o <= s; o++) {
              var u = r2[o];
              if (!u || !u.el)
                continue;
              if (u.hidden) {
                u.el.style.top = -100 - (u.pixelHeight || 0) + "px";
                continue;
              }
              u._inDocument || (u._inDocument = true, t2.container.appendChild(u.el));
              var a = t2.$cursorLayer.getPixelPosition({ row: o, column: 0 }, true).top;
              u.coverLine || (a += n2.lineHeight * this.session.getRowLineCount(u.row)), u.el.style.top = a - n2.offset + "px";
              var f = u.coverGutter ? 0 : t2.gutterWidth;
              u.fixedWidth || (f -= t2.scrollLeft), u.el.style.left = f + "px", u.fullWidth && u.screenWidth && (u.el.style.minWidth = n2.width + 2 * n2.padding + "px"), u.fixedWidth ? u.el.style.right = t2.scrollBar.getWidth() + "px" : u.el.style.right = "";
            }
          };
        }).call(i.prototype), t.LineWidgets = i;
      }), ace.define("ace/ext/error_marker", ["require", "exports", "module", "ace/line_widgets", "ace/lib/dom", "ace/range"], function(e, t, n) {
        "use strict";
        function o(e2, t2, n2) {
          var r2 = 0, i2 = e2.length - 1;
          while (r2 <= i2) {
            var s2 = r2 + i2 >> 1, o2 = n2(t2, e2[s2]);
            if (o2 > 0)
              r2 = s2 + 1;
            else {
              if (!(o2 < 0))
                return s2;
              i2 = s2 - 1;
            }
          }
          return -(r2 + 1);
        }
        function u(e2, t2, n2) {
          var r2 = e2.getAnnotations().sort(s.comparePoints);
          if (!r2.length)
            return;
          var i2 = o(r2, { row: t2, column: -1 }, s.comparePoints);
          i2 < 0 && (i2 = -i2 - 1), i2 >= r2.length ? i2 = n2 > 0 ? 0 : r2.length - 1 : i2 === 0 && n2 < 0 && (i2 = r2.length - 1);
          var u2 = r2[i2];
          if (!u2 || !n2)
            return;
          if (u2.row === t2) {
            do
              u2 = r2[i2 += n2];
            while (u2 && u2.row === t2);
            if (!u2)
              return r2.slice();
          }
          var a = [];
          t2 = u2.row;
          do
            a[n2 < 0 ? "unshift" : "push"](u2), u2 = r2[i2 += n2];
          while (u2 && u2.row == t2);
          return a.length && a;
        }
        var r = e("../line_widgets").LineWidgets, i = e("../lib/dom"), s = e("../range").Range;
        t.showErrorMarker = function(e2, t2) {
          var n2 = e2.session;
          n2.widgetManager || (n2.widgetManager = new r(n2), n2.widgetManager.attach(e2));
          var s2 = e2.getCursorPosition(), o2 = s2.row, a = n2.widgetManager.getWidgetsAtRow(o2).filter(function(e3) {
            return e3.type == "errorMarker";
          })[0];
          a ? a.destroy() : o2 -= t2;
          var f = u(n2, o2, t2), l;
          if (f) {
            var c = f[0];
            s2.column = (c.pos && typeof c.column != "number" ? c.pos.sc : c.column) || 0, s2.row = c.row, l = e2.renderer.$gutterLayer.$annotations[s2.row];
          } else {
            if (a)
              return;
            l = { text: ["Looks good!"], className: "ace_ok" };
          }
          e2.session.unfold(s2.row), e2.selection.moveToPosition(s2);
          var h = { row: s2.row, fixedWidth: true, coverGutter: true, el: i.createElement("div"), type: "errorMarker" }, p = h.el.appendChild(i.createElement("div")), d = h.el.appendChild(i.createElement("div"));
          d.className = "error_widget_arrow " + l.className;
          var v = e2.renderer.$cursorLayer.getPixelPosition(s2).left;
          d.style.left = v + e2.renderer.gutterWidth - 5 + "px", h.el.className = "error_widget_wrapper", p.className = "error_widget " + l.className, p.innerHTML = l.text.join("<br>"), p.appendChild(i.createElement("div"));
          var m = function(e3, t3, n3) {
            if (t3 === 0 && (n3 === "esc" || n3 === "return"))
              return h.destroy(), { command: "null" };
          };
          h.destroy = function() {
            if (e2.$mouseHandler.isMousePressed)
              return;
            e2.keyBinding.removeKeyboardHandler(m), n2.widgetManager.removeLineWidget(h), e2.off("changeSelection", h.destroy), e2.off("changeSession", h.destroy), e2.off("mouseup", h.destroy), e2.off("change", h.destroy);
          }, e2.keyBinding.addKeyboardHandler(m), e2.on("changeSelection", h.destroy), e2.on("changeSession", h.destroy), e2.on("mouseup", h.destroy), e2.on("change", h.destroy), e2.session.widgetManager.addLineWidget(h), h.el.onmousedown = e2.focus.bind(e2), e2.renderer.scrollCursorIntoView(null, 0.5, { bottom: h.el.offsetHeight });
        }, i.importCssString("    .error_widget_wrapper {        background: inherit;        color: inherit;        border:none    }    .error_widget {        border-top: solid 2px;        border-bottom: solid 2px;        margin: 5px 0;        padding: 10px 40px;        white-space: pre-wrap;    }    .error_widget.ace_error, .error_widget_arrow.ace_error{        border-color: #ff5a5a    }    .error_widget.ace_warning, .error_widget_arrow.ace_warning{        border-color: #F1D817    }    .error_widget.ace_info, .error_widget_arrow.ace_info{        border-color: #5a5a5a    }    .error_widget.ace_ok, .error_widget_arrow.ace_ok{        border-color: #5aaa5a    }    .error_widget_arrow {        position: absolute;        border: solid 5px;        border-top-color: transparent!important;        border-right-color: transparent!important;        border-left-color: transparent!important;        top: -5px;    }", "error_marker.css", false);
      }), ace.define("ace/ace", ["require", "exports", "module", "ace/lib/fixoldbrowsers", "ace/lib/dom", "ace/lib/event", "ace/range", "ace/editor", "ace/edit_session", "ace/undomanager", "ace/virtual_renderer", "ace/worker/worker_client", "ace/keyboard/hash_handler", "ace/placeholder", "ace/multi_select", "ace/mode/folding/fold_mode", "ace/theme/textmate", "ace/ext/error_marker", "ace/config"], function(e, t, n) {
        "use strict";
        e("./lib/fixoldbrowsers");
        var r = e("./lib/dom"), i = e("./lib/event"), s = e("./range").Range, o = e("./editor").Editor, u = e("./edit_session").EditSession, a = e("./undomanager").UndoManager, f = e("./virtual_renderer").VirtualRenderer;
        e("./worker/worker_client"), e("./keyboard/hash_handler"), e("./placeholder"), e("./multi_select"), e("./mode/folding/fold_mode"), e("./theme/textmate"), e("./ext/error_marker"), t.config = e("./config"), t.require = e, typeof define == "function" && (t.define = define), t.edit = function(e2, n2) {
          if (typeof e2 == "string") {
            var s2 = e2;
            e2 = document.getElementById(s2);
            if (!e2)
              throw new Error("ace.edit can't find div #" + s2);
          }
          if (e2 && e2.env && e2.env.editor instanceof o)
            return e2.env.editor;
          var u2 = "";
          if (e2 && /input|textarea/i.test(e2.tagName)) {
            var a2 = e2;
            u2 = a2.value, e2 = r.createElement("pre"), a2.parentNode.replaceChild(e2, a2);
          } else
            e2 && (u2 = e2.textContent, e2.innerHTML = "");
          var l = t.createEditSession(u2), c = new o(new f(e2), l, n2), h = { document: l, editor: c, onResize: c.resize.bind(c, null) };
          return a2 && (h.textarea = a2), i.addListener(window, "resize", h.onResize), c.on("destroy", function() {
            i.removeListener(window, "resize", h.onResize), h.editor.container.env = null;
          }), c.container.env = c.env = h, c;
        }, t.createEditSession = function(e2, t2) {
          var n2 = new u(e2, t2);
          return n2.setUndoManager(new a()), n2;
        }, t.Range = s, t.Editor = o, t.EditSession = u, t.UndoManager = a, t.VirtualRenderer = f, t.version = t.config.version;
      });
      (function() {
        ace.require(["ace/ace"], function(a) {
          if (a) {
            a.config.init(true);
            a.define = ace.define;
          }
          if (!window.ace)
            window.ace = a;
          for (var key in a)
            if (a.hasOwnProperty(key))
              window.ace[key] = a[key];
          window.ace["default"] = window.ace;
          if (typeof module == "object" && typeof exports == "object" && module) {
            module.exports = window.ace;
          }
        });
      })();
    }
  });

  // vendor/assets/javascript/ace/ext-language_tools.js
  var require_ext_language_tools = __commonJS({
    "vendor/assets/javascript/ace/ext-language_tools.js"(exports, module) {
      ace.define("ace/snippets", ["require", "exports", "module", "ace/lib/dom", "ace/lib/oop", "ace/lib/event_emitter", "ace/lib/lang", "ace/range", "ace/range_list", "ace/keyboard/hash_handler", "ace/tokenizer", "ace/clipboard", "ace/editor"], function(e, t, n) {
        "use strict";
        function p(e2) {
          var t2 = (/* @__PURE__ */ new Date()).toLocaleString("en-us", e2);
          return t2.length == 1 ? "0" + t2 : t2;
        }
        var r = e("./lib/dom"), i = e("./lib/oop"), s = e("./lib/event_emitter").EventEmitter, o = e("./lib/lang"), u = e("./range").Range, a = e("./range_list").RangeList, f = e("./keyboard/hash_handler").HashHandler, l = e("./tokenizer").Tokenizer, c = e("./clipboard"), h = { CURRENT_WORD: function(e2) {
          return e2.session.getTextRange(e2.session.getWordRange());
        }, SELECTION: function(e2, t2, n2) {
          var r2 = e2.session.getTextRange();
          return n2 ? r2.replace(/\n\r?([ \t]*\S)/g, "\n" + n2 + "$1") : r2;
        }, CURRENT_LINE: function(e2) {
          return e2.session.getLine(e2.getCursorPosition().row);
        }, PREV_LINE: function(e2) {
          return e2.session.getLine(e2.getCursorPosition().row - 1);
        }, LINE_INDEX: function(e2) {
          return e2.getCursorPosition().row;
        }, LINE_NUMBER: function(e2) {
          return e2.getCursorPosition().row + 1;
        }, SOFT_TABS: function(e2) {
          return e2.session.getUseSoftTabs() ? "YES" : "NO";
        }, TAB_SIZE: function(e2) {
          return e2.session.getTabSize();
        }, CLIPBOARD: function(e2) {
          return c.getText && c.getText();
        }, FILENAME: function(e2) {
          return /[^/\\]*$/.exec(this.FILEPATH(e2))[0];
        }, FILENAME_BASE: function(e2) {
          return /[^/\\]*$/.exec(this.FILEPATH(e2))[0].replace(/\.[^.]*$/, "");
        }, DIRECTORY: function(e2) {
          return this.FILEPATH(e2).replace(/[^/\\]*$/, "");
        }, FILEPATH: function(e2) {
          return "/not implemented.txt";
        }, WORKSPACE_NAME: function() {
          return "Unknown";
        }, FULLNAME: function() {
          return "Unknown";
        }, BLOCK_COMMENT_START: function(e2) {
          var t2 = e2.session.$mode || {};
          return t2.blockComment && t2.blockComment.start || "";
        }, BLOCK_COMMENT_END: function(e2) {
          var t2 = e2.session.$mode || {};
          return t2.blockComment && t2.blockComment.end || "";
        }, LINE_COMMENT: function(e2) {
          var t2 = e2.session.$mode || {};
          return t2.lineCommentStart || "";
        }, CURRENT_YEAR: p.bind(null, { year: "numeric" }), CURRENT_YEAR_SHORT: p.bind(null, { year: "2-digit" }), CURRENT_MONTH: p.bind(null, { month: "numeric" }), CURRENT_MONTH_NAME: p.bind(null, { month: "long" }), CURRENT_MONTH_NAME_SHORT: p.bind(null, { month: "short" }), CURRENT_DATE: p.bind(null, { day: "2-digit" }), CURRENT_DAY_NAME: p.bind(null, { weekday: "long" }), CURRENT_DAY_NAME_SHORT: p.bind(null, { weekday: "short" }), CURRENT_HOUR: p.bind(null, { hour: "2-digit", hour12: false }), CURRENT_MINUTE: p.bind(null, { minute: "2-digit" }), CURRENT_SECOND: p.bind(null, { second: "2-digit" }) };
        h.SELECTED_TEXT = h.SELECTION;
        var d = function() {
          this.snippetMap = {}, this.snippetNameMap = {};
        };
        (function() {
          i.implement(this, s), this.getTokenizer = function() {
            return d.$tokenizer || this.createTokenizer();
          }, this.createTokenizer = function() {
            function e2(e3) {
              return e3 = e3.substr(1), /^\d+$/.test(e3) ? [{ tabstopId: parseInt(e3, 10) }] : [{ text: e3 }];
            }
            function t2(e3) {
              return "(?:[^\\\\" + e3 + "]|\\\\.)";
            }
            var n2 = { regex: "/(" + t2("/") + "+)/", onMatch: function(e3, t3, n3) {
              var r2 = n3[0];
              return r2.fmtString = true, r2.guard = e3.slice(1, -1), r2.flag = "", "";
            }, next: "formatString" };
            return d.$tokenizer = new l({ start: [{ regex: /\\./, onMatch: function(e3, t3, n3) {
              var r2 = e3[1];
              return r2 == "}" && n3.length ? e3 = r2 : "`$\\".indexOf(r2) != -1 && (e3 = r2), [e3];
            } }, { regex: /}/, onMatch: function(e3, t3, n3) {
              return [n3.length ? n3.shift() : e3];
            } }, { regex: /\$(?:\d+|\w+)/, onMatch: e2 }, { regex: /\$\{[\dA-Z_a-z]+/, onMatch: function(t3, n3, r2) {
              var i2 = e2(t3.substr(1));
              return r2.unshift(i2[0]), i2;
            }, next: "snippetVar" }, { regex: /\n/, token: "newline", merge: false }], snippetVar: [{ regex: "\\|" + t2("\\|") + "*\\|", onMatch: function(e3, t3, n3) {
              var r2 = e3.slice(1, -1).replace(/\\[,|\\]|,/g, function(e4) {
                return e4.length == 2 ? e4[1] : "\0";
              }).split("\0").map(function(e4) {
                return { value: e4 };
              });
              return n3[0].choices = r2, [r2[0]];
            }, next: "start" }, n2, { regex: "([^:}\\\\]|\\\\.)*:?", token: "", next: "start" }], formatString: [{ regex: /:/, onMatch: function(e3, t3, n3) {
              return n3.length && n3[0].expectElse ? (n3[0].expectElse = false, n3[0].ifEnd = { elseEnd: n3[0] }, [n3[0].ifEnd]) : ":";
            } }, { regex: /\\./, onMatch: function(e3, t3, n3) {
              var r2 = e3[1];
              return r2 == "}" && n3.length ? e3 = r2 : "`$\\".indexOf(r2) != -1 ? e3 = r2 : r2 == "n" ? e3 = "\n" : r2 == "t" ? e3 = "	" : "ulULE".indexOf(r2) != -1 && (e3 = { changeCase: r2, local: r2 > "a" }), [e3];
            } }, { regex: "/\\w*}", onMatch: function(e3, t3, n3) {
              var r2 = n3.shift();
              return r2 && (r2.flag = e3.slice(1, -1)), this.next = r2 && r2.tabstopId ? "start" : "", [r2 || e3];
            }, next: "start" }, { regex: /\$(?:\d+|\w+)/, onMatch: function(e3, t3, n3) {
              return [{ text: e3.slice(1) }];
            } }, { regex: /\${\w+/, onMatch: function(e3, t3, n3) {
              var r2 = { text: e3.slice(2) };
              return n3.unshift(r2), [r2];
            }, next: "formatStringVar" }, { regex: /\n/, token: "newline", merge: false }, { regex: /}/, onMatch: function(e3, t3, n3) {
              var r2 = n3.shift();
              return this.next = r2 && r2.tabstopId ? "start" : "", [r2 || e3];
            }, next: "start" }], formatStringVar: [{ regex: /:\/\w+}/, onMatch: function(e3, t3, n3) {
              var r2 = n3[0];
              return r2.formatFunction = e3.slice(2, -1), [n3.shift()];
            }, next: "formatString" }, n2, { regex: /:[\?\-+]?/, onMatch: function(e3, t3, n3) {
              e3[1] == "+" && (n3[0].ifEnd = n3[0]), e3[1] == "?" && (n3[0].expectElse = true);
            }, next: "formatString" }, { regex: "([^:}\\\\]|\\\\.)*:?", token: "", next: "formatString" }] }), d.$tokenizer;
          }, this.tokenizeTmSnippet = function(e2, t2) {
            return this.getTokenizer().getLineTokens(e2, t2).tokens.map(function(e3) {
              return e3.value || e3;
            });
          }, this.getVariableValue = function(e2, t2, n2) {
            if (/^\d+$/.test(t2))
              return (this.variables.__ || {})[t2] || "";
            if (/^[A-Z]\d+$/.test(t2))
              return (this.variables[t2[0] + "__"] || {})[t2.substr(1)] || "";
            t2 = t2.replace(/^TM_/, "");
            if (!this.variables.hasOwnProperty(t2))
              return "";
            var r2 = this.variables[t2];
            return typeof r2 == "function" && (r2 = this.variables[t2](e2, t2, n2)), r2 == null ? "" : r2;
          }, this.variables = h, this.tmStrFormat = function(e2, t2, n2) {
            if (!t2.fmt)
              return e2;
            var r2 = t2.flag || "", i2 = t2.guard;
            i2 = new RegExp(i2, r2.replace(/[^gim]/g, ""));
            var s2 = typeof t2.fmt == "string" ? this.tokenizeTmSnippet(t2.fmt, "formatString") : t2.fmt, o2 = this, u2 = e2.replace(i2, function() {
              var e3 = o2.variables.__;
              o2.variables.__ = [].slice.call(arguments);
              var t3 = o2.resolveVariables(s2, n2), r3 = "E";
              for (var i3 = 0; i3 < t3.length; i3++) {
                var u3 = t3[i3];
                if (typeof u3 == "object") {
                  t3[i3] = "";
                  if (u3.changeCase && u3.local) {
                    var a2 = t3[i3 + 1];
                    a2 && typeof a2 == "string" && (u3.changeCase == "u" ? t3[i3] = a2[0].toUpperCase() : t3[i3] = a2[0].toLowerCase(), t3[i3 + 1] = a2.substr(1));
                  } else
                    u3.changeCase && (r3 = u3.changeCase);
                } else
                  r3 == "U" ? t3[i3] = u3.toUpperCase() : r3 == "L" && (t3[i3] = u3.toLowerCase());
              }
              return o2.variables.__ = e3, t3.join("");
            });
            return u2;
          }, this.tmFormatFunction = function(e2, t2, n2) {
            return t2.formatFunction == "upcase" ? e2.toUpperCase() : t2.formatFunction == "downcase" ? e2.toLowerCase() : e2;
          }, this.resolveVariables = function(e2, t2) {
            function f2(t3) {
              var n3 = e2.indexOf(t3, s2 + 1);
              n3 != -1 && (s2 = n3);
            }
            var n2 = [], r2 = "", i2 = true;
            for (var s2 = 0; s2 < e2.length; s2++) {
              var o2 = e2[s2];
              if (typeof o2 == "string") {
                n2.push(o2), o2 == "\n" ? (i2 = true, r2 = "") : i2 && (r2 = /^\t*/.exec(o2)[0], i2 = /\S/.test(o2));
                continue;
              }
              if (!o2)
                continue;
              i2 = false;
              if (o2.fmtString) {
                var u2 = e2.indexOf(o2, s2 + 1);
                u2 == -1 && (u2 = e2.length), o2.fmt = e2.slice(s2 + 1, u2), s2 = u2;
              }
              if (o2.text) {
                var a2 = this.getVariableValue(t2, o2.text, r2) + "";
                o2.fmtString && (a2 = this.tmStrFormat(a2, o2, t2)), o2.formatFunction && (a2 = this.tmFormatFunction(a2, o2, t2)), a2 && !o2.ifEnd ? (n2.push(a2), f2(o2)) : !a2 && o2.ifEnd && f2(o2.ifEnd);
              } else
                o2.elseEnd ? f2(o2.elseEnd) : o2.tabstopId != null ? n2.push(o2) : o2.changeCase != null && n2.push(o2);
            }
            return n2;
          }, this.insertSnippetForSelection = function(e2, t2) {
            function f2(e3) {
              var t3 = [];
              for (var n3 = 0; n3 < e3.length; n3++) {
                var r3 = e3[n3];
                if (typeof r3 == "object") {
                  if (a2[r3.tabstopId])
                    continue;
                  var i3 = e3.lastIndexOf(r3, n3 - 1);
                  r3 = t3[i3] || { tabstopId: r3.tabstopId };
                }
                t3[n3] = r3;
              }
              return t3;
            }
            var n2 = e2.getCursorPosition(), r2 = e2.session.getLine(n2.row), i2 = e2.session.getTabString(), s2 = r2.match(/^\s*/)[0];
            n2.column < s2.length && (s2 = s2.slice(0, n2.column)), t2 = t2.replace(/\r/g, "");
            var o2 = this.tokenizeTmSnippet(t2);
            o2 = this.resolveVariables(o2, e2), o2 = o2.map(function(e3) {
              return e3 == "\n" ? e3 + s2 : typeof e3 == "string" ? e3.replace(/\t/g, i2) : e3;
            });
            var u2 = [];
            o2.forEach(function(e3, t3) {
              if (typeof e3 != "object")
                return;
              var n3 = e3.tabstopId, r3 = u2[n3];
              r3 || (r3 = u2[n3] = [], r3.index = n3, r3.value = "", r3.parents = {});
              if (r3.indexOf(e3) !== -1)
                return;
              e3.choices && !r3.choices && (r3.choices = e3.choices), r3.push(e3);
              var i3 = o2.indexOf(e3, t3 + 1);
              if (i3 === -1)
                return;
              var s3 = o2.slice(t3 + 1, i3), a3 = s3.some(function(e4) {
                return typeof e4 == "object";
              });
              a3 && !r3.value ? r3.value = s3 : s3.length && (!r3.value || typeof r3.value != "string") && (r3.value = s3.join(""));
            }), u2.forEach(function(e3) {
              e3.length = 0;
            });
            var a2 = {};
            for (var l2 = 0; l2 < o2.length; l2++) {
              var c2 = o2[l2];
              if (typeof c2 != "object")
                continue;
              var h2 = c2.tabstopId, p2 = u2[h2], d2 = o2.indexOf(c2, l2 + 1);
              if (a2[h2]) {
                a2[h2] === c2 && (delete a2[h2], Object.keys(a2).forEach(function(e3) {
                  p2.parents[e3] = true;
                }));
                continue;
              }
              a2[h2] = c2;
              var m2 = p2.value;
              typeof m2 != "string" ? m2 = f2(m2) : c2.fmt && (m2 = this.tmStrFormat(m2, c2, e2)), o2.splice.apply(o2, [l2 + 1, Math.max(0, d2 - l2)].concat(m2, c2)), p2.indexOf(c2) === -1 && p2.push(c2);
            }
            var g2 = 0, y2 = 0, b = "";
            o2.forEach(function(e3) {
              if (typeof e3 == "string") {
                var t3 = e3.split("\n");
                t3.length > 1 ? (y2 = t3[t3.length - 1].length, g2 += t3.length - 1) : y2 += e3.length, b += e3;
              } else
                e3 && (e3.start ? e3.end = { row: g2, column: y2 } : e3.start = { row: g2, column: y2 });
            });
            var w = e2.getSelectionRange(), E = e2.session.replace(w, b), S = new v(e2), x = e2.inVirtualSelectionMode && e2.selection.index;
            S.addTabstops(u2, w.start, E, x);
          }, this.insertSnippet = function(e2, t2) {
            var n2 = this;
            if (e2.inVirtualSelectionMode)
              return n2.insertSnippetForSelection(e2, t2);
            e2.forEachSelection(function() {
              n2.insertSnippetForSelection(e2, t2);
            }, null, { keepOrder: true }), e2.tabstopManager && e2.tabstopManager.tabNext();
          }, this.$getScope = function(e2) {
            var t2 = e2.session.$mode.$id || "";
            t2 = t2.split("/").pop();
            if (t2 === "html" || t2 === "php") {
              t2 === "php" && !e2.session.$mode.inlinePhp && (t2 = "html");
              var n2 = e2.getCursorPosition(), r2 = e2.session.getState(n2.row);
              typeof r2 == "object" && (r2 = r2[0]), r2.substring && (r2.substring(0, 3) == "js-" ? t2 = "javascript" : r2.substring(0, 4) == "css-" ? t2 = "css" : r2.substring(0, 4) == "php-" && (t2 = "php"));
            }
            return t2;
          }, this.getActiveScopes = function(e2) {
            var t2 = this.$getScope(e2), n2 = [t2], r2 = this.snippetMap;
            return r2[t2] && r2[t2].includeScopes && n2.push.apply(n2, r2[t2].includeScopes), n2.push("_"), n2;
          }, this.expandWithTab = function(e2, t2) {
            var n2 = this, r2 = e2.forEachSelection(function() {
              return n2.expandSnippetForSelection(e2, t2);
            }, null, { keepOrder: true });
            return r2 && e2.tabstopManager && e2.tabstopManager.tabNext(), r2;
          }, this.expandSnippetForSelection = function(e2, t2) {
            var n2 = e2.getCursorPosition(), r2 = e2.session.getLine(n2.row), i2 = r2.substring(0, n2.column), s2 = r2.substr(n2.column), o2 = this.snippetMap, u2;
            return this.getActiveScopes(e2).some(function(e3) {
              var t3 = o2[e3];
              return t3 && (u2 = this.findMatchingSnippet(t3, i2, s2)), !!u2;
            }, this), u2 ? t2 && t2.dryRun ? true : (e2.session.doc.removeInLine(n2.row, n2.column - u2.replaceBefore.length, n2.column + u2.replaceAfter.length), this.variables.M__ = u2.matchBefore, this.variables.T__ = u2.matchAfter, this.insertSnippetForSelection(e2, u2.content), this.variables.M__ = this.variables.T__ = null, true) : false;
          }, this.findMatchingSnippet = function(e2, t2, n2) {
            for (var r2 = e2.length; r2--; ) {
              var i2 = e2[r2];
              if (i2.startRe && !i2.startRe.test(t2))
                continue;
              if (i2.endRe && !i2.endRe.test(n2))
                continue;
              if (!i2.startRe && !i2.endRe)
                continue;
              return i2.matchBefore = i2.startRe ? i2.startRe.exec(t2) : [""], i2.matchAfter = i2.endRe ? i2.endRe.exec(n2) : [""], i2.replaceBefore = i2.triggerRe ? i2.triggerRe.exec(t2)[0] : "", i2.replaceAfter = i2.endTriggerRe ? i2.endTriggerRe.exec(n2)[0] : "", i2;
            }
          }, this.snippetMap = {}, this.snippetNameMap = {}, this.register = function(e2, t2) {
            function s2(e3) {
              return e3 && !/^\^?\(.*\)\$?$|^\\b$/.test(e3) && (e3 = "(?:" + e3 + ")"), e3 || "";
            }
            function u2(e3, t3, n3) {
              return e3 = s2(e3), t3 = s2(t3), n3 ? (e3 = t3 + e3, e3 && e3[e3.length - 1] != "$" && (e3 += "$")) : (e3 += t3, e3 && e3[0] != "^" && (e3 = "^" + e3)), new RegExp(e3);
            }
            function a2(e3) {
              e3.scope || (e3.scope = t2 || "_"), t2 = e3.scope, n2[t2] || (n2[t2] = [], r2[t2] = {});
              var s3 = r2[t2];
              if (e3.name) {
                var a3 = s3[e3.name];
                a3 && i2.unregister(a3), s3[e3.name] = e3;
              }
              n2[t2].push(e3), e3.prefix && (e3.tabTrigger = e3.prefix), !e3.content && e3.body && (e3.content = Array.isArray(e3.body) ? e3.body.join("\n") : e3.body), e3.tabTrigger && !e3.trigger && (!e3.guard && /^\w/.test(e3.tabTrigger) && (e3.guard = "\\b"), e3.trigger = o.escapeRegExp(e3.tabTrigger));
              if (!e3.trigger && !e3.guard && !e3.endTrigger && !e3.endGuard)
                return;
              e3.startRe = u2(e3.trigger, e3.guard, true), e3.triggerRe = new RegExp(e3.trigger), e3.endRe = u2(e3.endTrigger, e3.endGuard, true), e3.endTriggerRe = new RegExp(e3.endTrigger);
            }
            var n2 = this.snippetMap, r2 = this.snippetNameMap, i2 = this;
            e2 || (e2 = []), Array.isArray(e2) ? e2.forEach(a2) : Object.keys(e2).forEach(function(t3) {
              a2(e2[t3]);
            }), this._signal("registerSnippets", { scope: t2 });
          }, this.unregister = function(e2, t2) {
            function i2(e3) {
              var i3 = r2[e3.scope || t2];
              if (i3 && i3[e3.name]) {
                delete i3[e3.name];
                var s2 = n2[e3.scope || t2], o2 = s2 && s2.indexOf(e3);
                o2 >= 0 && s2.splice(o2, 1);
              }
            }
            var n2 = this.snippetMap, r2 = this.snippetNameMap;
            e2.content ? i2(e2) : Array.isArray(e2) && e2.forEach(i2);
          }, this.parseSnippetFile = function(e2) {
            e2 = e2.replace(/\r/g, "");
            var t2 = [], n2 = {}, r2 = /^#.*|^({[\s\S]*})\s*$|^(\S+) (.*)$|^((?:\n*\t.*)+)/gm, i2;
            while (i2 = r2.exec(e2)) {
              if (i2[1])
                try {
                  n2 = JSON.parse(i2[1]), t2.push(n2);
                } catch (s2) {
                }
              if (i2[4])
                n2.content = i2[4].replace(/^\t/gm, ""), t2.push(n2), n2 = {};
              else {
                var o2 = i2[2], u2 = i2[3];
                if (o2 == "regex") {
                  var a2 = /\/((?:[^\/\\]|\\.)*)|$/g;
                  n2.guard = a2.exec(u2)[1], n2.trigger = a2.exec(u2)[1], n2.endTrigger = a2.exec(u2)[1], n2.endGuard = a2.exec(u2)[1];
                } else
                  o2 == "snippet" ? (n2.tabTrigger = u2.match(/^\S*/)[0], n2.name || (n2.name = u2)) : o2 && (n2[o2] = u2);
              }
            }
            return t2;
          }, this.getSnippetByName = function(e2, t2) {
            var n2 = this.snippetNameMap, r2;
            return this.getActiveScopes(t2).some(function(t3) {
              var i2 = n2[t3];
              return i2 && (r2 = i2[e2]), !!r2;
            }, this), r2;
          };
        }).call(d.prototype);
        var v = function(e2) {
          if (e2.tabstopManager)
            return e2.tabstopManager;
          e2.tabstopManager = this, this.$onChange = this.onChange.bind(this), this.$onChangeSelection = o.delayedCall(this.onChangeSelection.bind(this)).schedule, this.$onChangeSession = this.onChangeSession.bind(this), this.$onAfterExec = this.onAfterExec.bind(this), this.attach(e2);
        };
        (function() {
          this.attach = function(e2) {
            this.index = 0, this.ranges = [], this.tabstops = [], this.$openTabstops = null, this.selectedTabstop = null, this.editor = e2, this.editor.on("change", this.$onChange), this.editor.on("changeSelection", this.$onChangeSelection), this.editor.on("changeSession", this.$onChangeSession), this.editor.commands.on("afterExec", this.$onAfterExec), this.editor.keyBinding.addKeyboardHandler(this.keyboardHandler);
          }, this.detach = function() {
            this.tabstops.forEach(this.removeTabstopMarkers, this), this.ranges = null, this.tabstops = null, this.selectedTabstop = null, this.editor.removeListener("change", this.$onChange), this.editor.removeListener("changeSelection", this.$onChangeSelection), this.editor.removeListener("changeSession", this.$onChangeSession), this.editor.commands.removeListener("afterExec", this.$onAfterExec), this.editor.keyBinding.removeKeyboardHandler(this.keyboardHandler), this.editor.tabstopManager = null, this.editor = null;
          }, this.onChange = function(e2) {
            var t2 = e2.action[0] == "r", n2 = this.selectedTabstop || {}, r2 = n2.parents || {}, i2 = (this.tabstops || []).slice();
            for (var s2 = 0; s2 < i2.length; s2++) {
              var o2 = i2[s2], u2 = o2 == n2 || r2[o2.index];
              o2.rangeList.$bias = u2 ? 0 : 1;
              if (e2.action == "remove" && o2 !== n2) {
                var a2 = o2.parents && o2.parents[n2.index], f2 = o2.rangeList.pointIndex(e2.start, a2);
                f2 = f2 < 0 ? -f2 - 1 : f2 + 1;
                var l2 = o2.rangeList.pointIndex(e2.end, a2);
                l2 = l2 < 0 ? -l2 - 1 : l2 - 1;
                var c2 = o2.rangeList.ranges.slice(f2, l2);
                for (var h2 = 0; h2 < c2.length; h2++)
                  this.removeRange(c2[h2]);
              }
              o2.rangeList.$onChange(e2);
            }
            var p2 = this.editor.session;
            !this.$inChange && t2 && p2.getLength() == 1 && !p2.getValue() && this.detach();
          }, this.updateLinkedFields = function() {
            var e2 = this.selectedTabstop;
            if (!e2 || !e2.hasLinkedRanges || !e2.firstNonLinked)
              return;
            this.$inChange = true;
            var n2 = this.editor.session, r2 = n2.getTextRange(e2.firstNonLinked);
            for (var i2 = 0; i2 < e2.length; i2++) {
              var s2 = e2[i2];
              if (!s2.linked)
                continue;
              var o2 = s2.original, u2 = t.snippetManager.tmStrFormat(r2, o2, this.editor);
              n2.replace(s2, u2);
            }
            this.$inChange = false;
          }, this.onAfterExec = function(e2) {
            e2.command && !e2.command.readOnly && this.updateLinkedFields();
          }, this.onChangeSelection = function() {
            if (!this.editor)
              return;
            var e2 = this.editor.selection.lead, t2 = this.editor.selection.anchor, n2 = this.editor.selection.isEmpty();
            for (var r2 = 0; r2 < this.ranges.length; r2++) {
              if (this.ranges[r2].linked)
                continue;
              var i2 = this.ranges[r2].contains(e2.row, e2.column), s2 = n2 || this.ranges[r2].contains(t2.row, t2.column);
              if (i2 && s2)
                return;
            }
            this.detach();
          }, this.onChangeSession = function() {
            this.detach();
          }, this.tabNext = function(e2) {
            var t2 = this.tabstops.length, n2 = this.index + (e2 || 1);
            n2 = Math.min(Math.max(n2, 1), t2), n2 == t2 && (n2 = 0), this.selectTabstop(n2), n2 === 0 && this.detach();
          }, this.selectTabstop = function(e2) {
            this.$openTabstops = null;
            var t2 = this.tabstops[this.index];
            t2 && this.addTabstopMarkers(t2), this.index = e2, t2 = this.tabstops[this.index];
            if (!t2 || !t2.length)
              return;
            this.selectedTabstop = t2;
            var n2 = t2.firstNonLinked || t2;
            t2.choices && (n2.cursor = n2.start);
            if (!this.editor.inVirtualSelectionMode) {
              var r2 = this.editor.multiSelect;
              r2.toSingleRange(n2);
              for (var i2 = 0; i2 < t2.length; i2++) {
                if (t2.hasLinkedRanges && t2[i2].linked)
                  continue;
                r2.addRange(t2[i2].clone(), true);
              }
            } else
              this.editor.selection.fromOrientedRange(n2);
            this.editor.keyBinding.addKeyboardHandler(this.keyboardHandler), this.selectedTabstop && this.selectedTabstop.choices && this.editor.execCommand("startAutocomplete", { matches: this.selectedTabstop.choices });
          }, this.addTabstops = function(e2, t2, n2) {
            var r2 = this.useLink || !this.editor.getOption("enableMultiselect");
            this.$openTabstops || (this.$openTabstops = []);
            if (!e2[0]) {
              var i2 = u.fromPoints(n2, n2);
              g(i2.start, t2), g(i2.end, t2), e2[0] = [i2], e2[0].index = 0;
            }
            var s2 = this.index, o2 = [s2 + 1, 0], f2 = this.ranges;
            e2.forEach(function(e3, n3) {
              var i3 = this.$openTabstops[n3] || e3;
              for (var s3 = 0; s3 < e3.length; s3++) {
                var l2 = e3[s3], c2 = u.fromPoints(l2.start, l2.end || l2.start);
                m(c2.start, t2), m(c2.end, t2), c2.original = l2, c2.tabstop = i3, f2.push(c2), i3 != e3 ? i3.unshift(c2) : i3[s3] = c2, l2.fmtString || i3.firstNonLinked && r2 ? (c2.linked = true, i3.hasLinkedRanges = true) : i3.firstNonLinked || (i3.firstNonLinked = c2);
              }
              i3.firstNonLinked || (i3.hasLinkedRanges = false), i3 === e3 && (o2.push(i3), this.$openTabstops[n3] = i3), this.addTabstopMarkers(i3), i3.rangeList = i3.rangeList || new a(), i3.rangeList.$bias = 0, i3.rangeList.addList(i3);
            }, this), o2.length > 2 && (this.tabstops.length && o2.push(o2.splice(2, 1)[0]), this.tabstops.splice.apply(this.tabstops, o2));
          }, this.addTabstopMarkers = function(e2) {
            var t2 = this.editor.session;
            e2.forEach(function(e3) {
              e3.markerId || (e3.markerId = t2.addMarker(e3, "ace_snippet-marker", "text"));
            });
          }, this.removeTabstopMarkers = function(e2) {
            var t2 = this.editor.session;
            e2.forEach(function(e3) {
              t2.removeMarker(e3.markerId), e3.markerId = null;
            });
          }, this.removeRange = function(e2) {
            var t2 = e2.tabstop.indexOf(e2);
            t2 != -1 && e2.tabstop.splice(t2, 1), t2 = this.ranges.indexOf(e2), t2 != -1 && this.ranges.splice(t2, 1), t2 = e2.tabstop.rangeList.ranges.indexOf(e2), t2 != -1 && e2.tabstop.splice(t2, 1), this.editor.session.removeMarker(e2.markerId), e2.tabstop.length || (t2 = this.tabstops.indexOf(e2.tabstop), t2 != -1 && this.tabstops.splice(t2, 1), this.tabstops.length || this.detach());
          }, this.keyboardHandler = new f(), this.keyboardHandler.bindKeys({ Tab: function(e2) {
            if (t.snippetManager && t.snippetManager.expandWithTab(e2))
              return;
            e2.tabstopManager.tabNext(1), e2.renderer.scrollCursorIntoView();
          }, "Shift-Tab": function(e2) {
            e2.tabstopManager.tabNext(-1), e2.renderer.scrollCursorIntoView();
          }, Esc: function(e2) {
            e2.tabstopManager.detach();
          } });
        }).call(v.prototype);
        var m = function(e2, t2) {
          e2.row == 0 && (e2.column += t2.column), e2.row += t2.row;
        }, g = function(e2, t2) {
          e2.row == t2.row && (e2.column -= t2.column), e2.row -= t2.row;
        };
        r.importCssString(".ace_snippet-marker {    -moz-box-sizing: border-box;    box-sizing: border-box;    background: rgba(194, 193, 208, 0.09);    border: 1px dotted rgba(211, 208, 235, 0.62);    position: absolute;}", "snippets.css", false), t.snippetManager = new d();
        var y = e("./editor").Editor;
        (function() {
          this.insertSnippet = function(e2, n2) {
            return t.snippetManager.insertSnippet(this, e2, n2);
          }, this.expandSnippet = function(e2) {
            return t.snippetManager.expandWithTab(this, e2);
          };
        }).call(y.prototype);
      }), ace.define("ace/autocomplete/popup", ["require", "exports", "module", "ace/virtual_renderer", "ace/editor", "ace/range", "ace/lib/event", "ace/lib/lang", "ace/lib/dom"], function(e, t, n) {
        "use strict";
        var r = e("../virtual_renderer").VirtualRenderer, i = e("../editor").Editor, s = e("../range").Range, o = e("../lib/event"), u = e("../lib/lang"), a = e("../lib/dom"), f = function(e2) {
          var t2 = new r(e2);
          t2.$maxLines = 4;
          var n2 = new i(t2);
          return n2.setHighlightActiveLine(false), n2.setShowPrintMargin(false), n2.renderer.setShowGutter(false), n2.renderer.setHighlightGutterLine(false), n2.$mouseHandler.$focusTimeout = 0, n2.$highlightTagPending = true, n2;
        }, l = function(e2) {
          var t2 = a.createElement("div"), n2 = new f(t2);
          e2 && e2.appendChild(t2), t2.style.display = "none", n2.renderer.content.style.cursor = "default", n2.renderer.setStyle("ace_autocomplete"), n2.setOption("displayIndentGuides", false), n2.setOption("dragDelay", 150);
          var r2 = function() {
          };
          n2.focus = r2, n2.$isFocused = true, n2.renderer.$cursorLayer.restartTimer = r2, n2.renderer.$cursorLayer.element.style.opacity = 0, n2.renderer.$maxLines = 8, n2.renderer.$keepTextAreaAtCursor = false, n2.setHighlightActiveLine(false), n2.session.highlight(""), n2.session.$searchHighlight.clazz = "ace_highlight-marker", n2.on("mousedown", function(e3) {
            var t3 = e3.getDocumentPosition();
            n2.selection.moveToPosition(t3), c.start.row = c.end.row = t3.row, e3.stop();
          });
          var i2, l2 = new s(-1, 0, -1, Infinity), c = new s(-1, 0, -1, Infinity);
          c.id = n2.session.addMarker(c, "ace_active-line", "fullLine"), n2.setSelectOnHover = function(e3) {
            e3 ? l2.id && (n2.session.removeMarker(l2.id), l2.id = null) : l2.id = n2.session.addMarker(l2, "ace_line-hover", "fullLine");
          }, n2.setSelectOnHover(false), n2.on("mousemove", function(e3) {
            if (!i2) {
              i2 = e3;
              return;
            }
            if (i2.x == e3.x && i2.y == e3.y)
              return;
            i2 = e3, i2.scrollTop = n2.renderer.scrollTop;
            var t3 = i2.getDocumentPosition().row;
            l2.start.row != t3 && (l2.id || n2.setRow(t3), p(t3));
          }), n2.renderer.on("beforeRender", function() {
            if (i2 && l2.start.row != -1) {
              i2.$pos = null;
              var e3 = i2.getDocumentPosition().row;
              l2.id || n2.setRow(e3), p(e3, true);
            }
          }), n2.renderer.on("afterRender", function() {
            var e3 = n2.getRow(), t3 = n2.renderer.$textLayer, r3 = t3.element.childNodes[e3 - t3.config.firstRow];
            r3 !== t3.selectedNode && t3.selectedNode && a.removeCssClass(t3.selectedNode, "ace_selected"), t3.selectedNode = r3, r3 && a.addCssClass(r3, "ace_selected");
          });
          var h = function() {
            p(-1);
          }, p = function(e3, t3) {
            e3 !== l2.start.row && (l2.start.row = l2.end.row = e3, t3 || n2.session._emit("changeBackMarker"), n2._emit("changeHoverMarker"));
          };
          n2.getHoveredRow = function() {
            return l2.start.row;
          }, o.addListener(n2.container, "mouseout", h), n2.on("hide", h), n2.on("changeSelection", h), n2.session.doc.getLength = function() {
            return n2.data.length;
          }, n2.session.doc.getLine = function(e3) {
            var t3 = n2.data[e3];
            return typeof t3 == "string" ? t3 : t3 && t3.value || "";
          };
          var d = n2.session.bgTokenizer;
          return d.$tokenizeRow = function(e3) {
            function s2(e4, n3) {
              e4 && r3.push({ type: (t3.className || "") + (n3 || ""), value: e4 });
            }
            var t3 = n2.data[e3], r3 = [];
            if (!t3)
              return r3;
            typeof t3 == "string" && (t3 = { value: t3 });
            var i3 = t3.caption || t3.value || t3.name, o2 = i3.toLowerCase(), u2 = (n2.filterText || "").toLowerCase(), a2 = 0, f2 = 0;
            for (var l3 = 0; l3 <= u2.length; l3++)
              if (l3 != f2 && (t3.matchMask & 1 << l3 || l3 == u2.length)) {
                var c2 = u2.slice(f2, l3);
                f2 = l3;
                var h2 = o2.indexOf(c2, a2);
                if (h2 == -1)
                  continue;
                s2(i3.slice(a2, h2), ""), a2 = h2 + c2.length, s2(i3.slice(h2, a2), "completion-highlight");
              }
            return s2(i3.slice(a2, i3.length), ""), t3.meta && r3.push({ type: "completion-meta", value: t3.meta }), t3.message && r3.push({ type: "completion-message", value: t3.message }), r3;
          }, d.$updateOnChange = r2, d.start = r2, n2.session.$computeWidth = function() {
            return this.screenWidth = 0;
          }, n2.isOpen = false, n2.isTopdown = false, n2.autoSelect = true, n2.filterText = "", n2.data = [], n2.setData = function(e3, t3) {
            n2.filterText = t3 || "", n2.setValue(u.stringRepeat("\n", e3.length), -1), n2.data = e3 || [], n2.setRow(0);
          }, n2.getData = function(e3) {
            return n2.data[e3];
          }, n2.getRow = function() {
            return c.start.row;
          }, n2.setRow = function(e3) {
            e3 = Math.max(this.autoSelect ? 0 : -1, Math.min(this.data.length, e3)), c.start.row != e3 && (n2.selection.clearSelection(), c.start.row = c.end.row = e3 || 0, n2.session._emit("changeBackMarker"), n2.moveCursorTo(e3 || 0, 0), n2.isOpen && n2._signal("select"));
          }, n2.on("changeSelection", function() {
            n2.isOpen && n2.setRow(n2.selection.lead.row), n2.renderer.scrollCursorIntoView();
          }), n2.hide = function() {
            this.container.style.display = "none", this._signal("hide"), n2.isOpen = false;
          }, n2.show = function(e3, t3, r3) {
            var s2 = this.container, o2 = window.innerHeight, u2 = window.innerWidth, a2 = this.renderer, f2 = a2.$maxLines * t3 * 1.4, l3 = e3.top + this.$borderSize, c2 = l3 > o2 / 2 && !r3;
            c2 && l3 + t3 + f2 > o2 ? (a2.$maxPixelHeight = l3 - 2 * this.$borderSize, s2.style.top = "", s2.style.bottom = o2 - l3 + "px", n2.isTopdown = false) : (l3 += t3, a2.$maxPixelHeight = o2 - l3 - 0.2 * t3, s2.style.top = l3 + "px", s2.style.bottom = "", n2.isTopdown = true), s2.style.display = "";
            var h2 = e3.left;
            h2 + s2.offsetWidth > u2 && (h2 = u2 - s2.offsetWidth), s2.style.left = h2 + "px", this._signal("show"), i2 = null, n2.isOpen = true;
          }, n2.goTo = function(e3) {
            var t3 = this.getRow(), n3 = this.session.getLength() - 1;
            switch (e3) {
              case "up":
                t3 = t3 <= 0 ? n3 : t3 - 1;
                break;
              case "down":
                t3 = t3 >= n3 ? -1 : t3 + 1;
                break;
              case "start":
                t3 = 0;
                break;
              case "end":
                t3 = n3;
            }
            this.setRow(t3);
          }, n2.getTextLeftOffset = function() {
            return this.$borderSize + this.renderer.$padding + this.$imageSize;
          }, n2.$imageSize = 0, n2.$borderSize = 1, n2;
        };
        a.importCssString(".ace_editor.ace_autocomplete .ace_marker-layer .ace_active-line {    background-color: #CAD6FA;    z-index: 1;}.ace_dark.ace_editor.ace_autocomplete .ace_marker-layer .ace_active-line {    background-color: #3a674e;}.ace_editor.ace_autocomplete .ace_line-hover {    border: 1px solid #abbffe;    margin-top: -1px;    background: rgba(233,233,253,0.4);    position: absolute;    z-index: 2;}.ace_dark.ace_editor.ace_autocomplete .ace_line-hover {    border: 1px solid rgba(109, 150, 13, 0.8);    background: rgba(58, 103, 78, 0.62);}.ace_completion-meta {    opacity: 0.5;    margin: 0.9em;}.ace_completion-message {    color: blue;}.ace_editor.ace_autocomplete .ace_completion-highlight{    color: #2d69c7;}.ace_dark.ace_editor.ace_autocomplete .ace_completion-highlight{    color: #93ca12;}.ace_editor.ace_autocomplete {    width: 300px;    z-index: 200000;    border: 1px lightgray solid;    position: fixed;    box-shadow: 2px 3px 5px rgba(0,0,0,.2);    line-height: 1.4;    background: #fefefe;    color: #111;}.ace_dark.ace_editor.ace_autocomplete {    border: 1px #484747 solid;    box-shadow: 2px 3px 5px rgba(0, 0, 0, 0.51);    line-height: 1.4;    background: #25282c;    color: #c1c1c1;}", "autocompletion.css", false), t.AcePopup = l, t.$singleLineEditor = f;
      }), ace.define("ace/autocomplete/util", ["require", "exports", "module"], function(e, t, n) {
        "use strict";
        t.parForEach = function(e2, t2, n2) {
          var r2 = 0, i = e2.length;
          i === 0 && n2();
          for (var s = 0; s < i; s++)
            t2(e2[s], function(e3, t3) {
              r2++, r2 === i && n2(e3, t3);
            });
        };
        var r = /[a-zA-Z_0-9\$\-\u00A2-\u2000\u2070-\uFFFF]/;
        t.retrievePrecedingIdentifier = function(e2, t2, n2) {
          n2 = n2 || r;
          var i = [];
          for (var s = t2 - 1; s >= 0; s--) {
            if (!n2.test(e2[s]))
              break;
            i.push(e2[s]);
          }
          return i.reverse().join("");
        }, t.retrieveFollowingIdentifier = function(e2, t2, n2) {
          n2 = n2 || r;
          var i = [];
          for (var s = t2; s < e2.length; s++) {
            if (!n2.test(e2[s]))
              break;
            i.push(e2[s]);
          }
          return i;
        }, t.getCompletionPrefix = function(e2) {
          var t2 = e2.getCursorPosition(), n2 = e2.session.getLine(t2.row), r2;
          return e2.completers.forEach(function(e3) {
            e3.identifierRegexps && e3.identifierRegexps.forEach(function(e4) {
              !r2 && e4 && (r2 = this.retrievePrecedingIdentifier(n2, t2.column, e4));
            }.bind(this));
          }.bind(this)), r2 || this.retrievePrecedingIdentifier(n2, t2.column);
        };
      }), ace.define("ace/autocomplete", ["require", "exports", "module", "ace/keyboard/hash_handler", "ace/autocomplete/popup", "ace/autocomplete/util", "ace/lib/lang", "ace/lib/dom", "ace/snippets", "ace/config"], function(e, t, n) {
        "use strict";
        var r = e("./keyboard/hash_handler").HashHandler, i = e("./autocomplete/popup").AcePopup, s = e("./autocomplete/util"), o = e("./lib/lang"), u = e("./lib/dom"), a = e("./snippets").snippetManager, f = e("./config"), l = function() {
          this.autoInsert = false, this.autoSelect = true, this.exactMatch = false, this.gatherCompletionsId = 0, this.keyboardHandler = new r(), this.keyboardHandler.bindKeys(this.commands), this.blurListener = this.blurListener.bind(this), this.changeListener = this.changeListener.bind(this), this.mousedownListener = this.mousedownListener.bind(this), this.mousewheelListener = this.mousewheelListener.bind(this), this.changeTimer = o.delayedCall(function() {
            this.updateCompletions(true);
          }.bind(this)), this.tooltipTimer = o.delayedCall(this.updateDocTooltip.bind(this), 50);
        };
        (function() {
          this.$init = function() {
            return this.popup = new i(document.body || document.documentElement), this.popup.on("click", function(e2) {
              this.insertMatch(), e2.stop();
            }.bind(this)), this.popup.focus = this.editor.focus.bind(this.editor), this.popup.on("show", this.tooltipTimer.bind(null, null)), this.popup.on("select", this.tooltipTimer.bind(null, null)), this.popup.on("changeHoverMarker", this.tooltipTimer.bind(null, null)), this.popup;
          }, this.getPopup = function() {
            return this.popup || this.$init();
          }, this.openPopup = function(e2, t2, n2) {
            this.popup || this.$init(), this.popup.autoSelect = this.autoSelect, this.popup.setData(this.completions.filtered, this.completions.filterText), e2.keyBinding.addKeyboardHandler(this.keyboardHandler);
            var r2 = e2.renderer;
            this.popup.setRow(this.autoSelect ? 0 : -1);
            if (!n2) {
              this.popup.setTheme(e2.getTheme()), this.popup.setFontSize(e2.getFontSize());
              var i2 = r2.layerConfig.lineHeight, s2 = r2.$cursorLayer.getPixelPosition(this.base, true);
              s2.left -= this.popup.getTextLeftOffset();
              var o2 = e2.container.getBoundingClientRect();
              s2.top += o2.top - r2.layerConfig.offset, s2.left += o2.left - e2.renderer.scrollLeft, s2.left += r2.gutterWidth, this.popup.show(s2, i2);
            } else
              n2 && !t2 && this.detach();
            this.changeTimer.cancel();
          }, this.detach = function() {
            this.editor.keyBinding.removeKeyboardHandler(this.keyboardHandler), this.editor.off("changeSelection", this.changeListener), this.editor.off("blur", this.blurListener), this.editor.off("mousedown", this.mousedownListener), this.editor.off("mousewheel", this.mousewheelListener), this.changeTimer.cancel(), this.hideDocTooltip(), this.gatherCompletionsId += 1, this.popup && this.popup.isOpen && this.popup.hide(), this.base && this.base.detach(), this.activated = false, this.completions = this.base = null;
          }, this.changeListener = function(e2) {
            var t2 = this.editor.selection.lead;
            (t2.row != this.base.row || t2.column < this.base.column) && this.detach(), this.activated ? this.changeTimer.schedule() : this.detach();
          }, this.blurListener = function(e2) {
            var t2 = document.activeElement, n2 = this.editor.textInput.getElement(), r2 = e2.relatedTarget && this.tooltipNode && this.tooltipNode.contains(e2.relatedTarget), i2 = this.popup && this.popup.container;
            t2 != n2 && t2.parentNode != i2 && !r2 && t2 != this.tooltipNode && e2.relatedTarget != n2 && this.detach();
          }, this.mousedownListener = function(e2) {
            this.detach();
          }, this.mousewheelListener = function(e2) {
            this.detach();
          }, this.goTo = function(e2) {
            this.popup.goTo(e2);
          }, this.insertMatch = function(e2, t2) {
            e2 || (e2 = this.popup.getData(this.popup.getRow()));
            if (!e2)
              return false;
            var n2 = this.completions;
            this.editor.startOperation({ command: { name: "insertMatch" } });
            if (e2.completer && e2.completer.insertMatch)
              e2.completer.insertMatch(this.editor, e2);
            else {
              if (n2.filterText) {
                var r2 = this.editor.selection.getAllRanges();
                for (var i2 = 0, s2; s2 = r2[i2]; i2++)
                  s2.start.column -= n2.filterText.length, this.editor.session.remove(s2);
              }
              e2.snippet ? a.insertSnippet(this.editor, e2.snippet) : this.editor.execCommand("insertstring", e2.value || e2);
            }
            this.completions == n2 && this.detach(), this.editor.endOperation();
          }, this.commands = { Up: function(e2) {
            e2.completer.goTo("up");
          }, Down: function(e2) {
            e2.completer.goTo("down");
          }, "Ctrl-Up|Ctrl-Home": function(e2) {
            e2.completer.goTo("start");
          }, "Ctrl-Down|Ctrl-End": function(e2) {
            e2.completer.goTo("end");
          }, Esc: function(e2) {
            e2.completer.detach();
          }, Return: function(e2) {
            return e2.completer.insertMatch();
          }, "Shift-Return": function(e2) {
            e2.completer.insertMatch(null, { deleteSuffix: true });
          }, Tab: function(e2) {
            var t2 = e2.completer.insertMatch();
            if (!!t2 || !!e2.tabstopManager)
              return t2;
            e2.completer.goTo("down");
          }, PageUp: function(e2) {
            e2.completer.popup.gotoPageUp();
          }, PageDown: function(e2) {
            e2.completer.popup.gotoPageDown();
          } }, this.gatherCompletions = function(e2, t2) {
            var n2 = e2.getSession(), r2 = e2.getCursorPosition(), i2 = s.getCompletionPrefix(e2);
            this.base = n2.doc.createAnchor(r2.row, r2.column - i2.length), this.base.$insertRight = true;
            var o2 = [], u2 = e2.completers.length;
            return e2.completers.forEach(function(a2, f2) {
              a2.getCompletions(e2, n2, r2, i2, function(n3, r3) {
                !n3 && r3 && (o2 = o2.concat(r3)), t2(null, { prefix: s.getCompletionPrefix(e2), matches: o2, finished: --u2 === 0 });
              });
            }), true;
          }, this.showPopup = function(e2, t2) {
            this.editor && this.detach(), this.activated = true, this.editor = e2, e2.completer != this && (e2.completer && e2.completer.detach(), e2.completer = this), e2.on("changeSelection", this.changeListener), e2.on("blur", this.blurListener), e2.on("mousedown", this.mousedownListener), e2.on("mousewheel", this.mousewheelListener), this.updateCompletions(false, t2);
          }, this.updateCompletions = function(e2, t2) {
            if (e2 && this.base && this.completions) {
              var n2 = this.editor.getCursorPosition(), r2 = this.editor.session.getTextRange({ start: this.base, end: n2 });
              if (r2 == this.completions.filterText)
                return;
              this.completions.setFilter(r2);
              if (!this.completions.filtered.length)
                return this.detach();
              if (this.completions.filtered.length == 1 && this.completions.filtered[0].value == r2 && !this.completions.filtered[0].snippet)
                return this.detach();
              this.openPopup(this.editor, r2, e2);
              return;
            }
            if (t2 && t2.matches) {
              var n2 = this.editor.getSelectionRange().start;
              return this.base = this.editor.session.doc.createAnchor(n2.row, n2.column), this.base.$insertRight = true, this.completions = new c(t2.matches), this.openPopup(this.editor, "", e2);
            }
            var i2 = this.gatherCompletionsId, s2 = function(e3) {
              if (!e3.finished)
                return;
              return this.detach();
            }.bind(this), o2 = function(t3) {
              var n3 = t3.prefix, r3 = t3.matches;
              this.completions = new c(r3), this.exactMatch && (this.completions.exactMatch = true), this.completions.setFilter(n3);
              var i3 = this.completions.filtered;
              if (!i3.length)
                return s2(t3);
              if (i3.length == 1 && i3[0].value == n3 && !i3[0].snippet)
                return s2(t3);
              if (this.autoInsert && i3.length == 1 && t3.finished)
                return this.insertMatch(i3[0]);
              this.openPopup(this.editor, n3, e2);
            }.bind(this), u2 = true, a2 = null;
            this.gatherCompletions(this.editor, function(e3, t3) {
              var n3 = t3.prefix, r3 = t3 && t3.matches;
              if (!r3 || !r3.length)
                return s2(t3);
              if (n3.indexOf(t3.prefix) !== 0 || i2 != this.gatherCompletionsId)
                return;
              if (u2) {
                a2 = t3;
                return;
              }
              o2(t3);
            }.bind(this)), u2 = false;
            if (a2) {
              var f2 = a2;
              a2 = null, o2(f2);
            }
          }, this.cancelContextMenu = function() {
            this.editor.$mouseHandler.cancelContextMenu();
          }, this.updateDocTooltip = function() {
            var e2 = this.popup, t2 = e2.data, n2 = t2 && (t2[e2.getHoveredRow()] || t2[e2.getRow()]), r2 = null;
            if (!n2 || !this.editor || !this.popup.isOpen)
              return this.hideDocTooltip();
            this.editor.completers.some(function(e3) {
              return e3.getDocTooltip && (r2 = e3.getDocTooltip(n2)), r2;
            }), !r2 && typeof n2 != "string" && (r2 = n2), typeof r2 == "string" && (r2 = { docText: r2 });
            if (!r2 || !r2.docHTML && !r2.docText)
              return this.hideDocTooltip();
            this.showDocTooltip(r2);
          }, this.showDocTooltip = function(e2) {
            this.tooltipNode || (this.tooltipNode = u.createElement("div"), this.tooltipNode.className = "ace_tooltip ace_doc-tooltip", this.tooltipNode.style.margin = 0, this.tooltipNode.style.pointerEvents = "auto", this.tooltipNode.tabIndex = -1, this.tooltipNode.onblur = this.blurListener.bind(this), this.tooltipNode.onclick = this.onTooltipClick.bind(this));
            var t2 = this.tooltipNode;
            e2.docHTML ? t2.innerHTML = e2.docHTML : e2.docText && (t2.textContent = e2.docText), t2.parentNode || document.body.appendChild(t2);
            var n2 = this.popup, r2 = n2.container.getBoundingClientRect();
            t2.style.top = n2.container.style.top, t2.style.bottom = n2.container.style.bottom, t2.style.display = "block", window.innerWidth - r2.right < 320 ? r2.left < 320 ? n2.isTopdown ? (t2.style.top = r2.bottom + "px", t2.style.left = r2.left + "px", t2.style.right = "", t2.style.bottom = "") : (t2.style.top = n2.container.offsetTop - t2.offsetHeight + "px", t2.style.left = r2.left + "px", t2.style.right = "", t2.style.bottom = "") : (t2.style.right = window.innerWidth - r2.left + "px", t2.style.left = "") : (t2.style.left = r2.right + 1 + "px", t2.style.right = "");
          }, this.hideDocTooltip = function() {
            this.tooltipTimer.cancel();
            if (!this.tooltipNode)
              return;
            var e2 = this.tooltipNode;
            !this.editor.isFocused() && document.activeElement == e2 && this.editor.focus(), this.tooltipNode = null, e2.parentNode && e2.parentNode.removeChild(e2);
          }, this.onTooltipClick = function(e2) {
            var t2 = e2.target;
            while (t2 && t2 != this.tooltipNode) {
              if (t2.nodeName == "A" && t2.href) {
                t2.rel = "noreferrer", t2.target = "_blank";
                break;
              }
              t2 = t2.parentNode;
            }
          }, this.destroy = function() {
            this.detach();
            if (this.popup) {
              this.popup.destroy();
              var e2 = this.popup.container;
              e2 && e2.parentNode && e2.parentNode.removeChild(e2);
            }
            this.editor && this.editor.completer == this && this.editor.completer == null, this.popup = null;
          };
        }).call(l.prototype), l.for = function(e2) {
          return e2.completer ? e2.completer : (f.get("sharedPopups") ? (l.$shared || (l.$sharedInstance = new l()), e2.completer = l.$sharedInstance) : (e2.completer = new l(), e2.once("destroy", function(e3, t2) {
            t2.completer.destroy();
          })), e2.completer);
        }, l.startCommand = { name: "startAutocomplete", exec: function(e2, t2) {
          var n2 = l.for(e2);
          n2.autoInsert = false, n2.autoSelect = true, n2.showPopup(e2, t2), n2.cancelContextMenu();
        }, bindKey: "Ctrl-Space|Ctrl-Shift-Space|Alt-Space" };
        var c = function(e2, t2) {
          this.all = e2, this.filtered = e2, this.filterText = t2 || "", this.exactMatch = false;
        };
        (function() {
          this.setFilter = function(e2) {
            if (e2.length > this.filterText && e2.lastIndexOf(this.filterText, 0) === 0)
              var t2 = this.filtered;
            else
              var t2 = this.all;
            this.filterText = e2, t2 = this.filterCompletions(t2, this.filterText), t2 = t2.sort(function(e3, t3) {
              return t3.exactMatch - e3.exactMatch || t3.$score - e3.$score || (e3.caption || e3.value).localeCompare(t3.caption || t3.value);
            });
            var n2 = null;
            t2 = t2.filter(function(e3) {
              var t3 = e3.snippet || e3.caption || e3.value;
              return t3 === n2 ? false : (n2 = t3, true);
            }), this.filtered = t2;
          }, this.filterCompletions = function(e2, t2) {
            var n2 = [], r2 = t2.toUpperCase(), i2 = t2.toLowerCase();
            e:
              for (var s2 = 0, o2; o2 = e2[s2]; s2++) {
                var u2 = o2.caption || o2.value || o2.snippet;
                if (!u2)
                  continue;
                var a2 = -1, f2 = 0, l2 = 0, c2, h;
                if (this.exactMatch) {
                  if (t2 !== u2.substr(0, t2.length))
                    continue e;
                } else {
                  var p = u2.toLowerCase().indexOf(i2);
                  if (p > -1)
                    l2 = p;
                  else
                    for (var d = 0; d < t2.length; d++) {
                      var v = u2.indexOf(i2[d], a2 + 1), m = u2.indexOf(r2[d], a2 + 1);
                      c2 = v >= 0 ? m < 0 || v < m ? v : m : m;
                      if (c2 < 0)
                        continue e;
                      h = c2 - a2 - 1, h > 0 && (a2 === -1 && (l2 += 10), l2 += h, f2 |= 1 << d), a2 = c2;
                    }
                }
                o2.matchMask = f2, o2.exactMatch = l2 ? 0 : 1, o2.$score = (o2.score || 0) - l2, n2.push(o2);
              }
            return n2;
          };
        }).call(c.prototype), t.Autocomplete = l, t.FilteredList = c;
      }), ace.define("ace/autocomplete/text_completer", ["require", "exports", "module", "ace/range"], function(e, t, n) {
        function s(e2, t2) {
          var n2 = e2.getTextRange(r.fromPoints({ row: 0, column: 0 }, t2));
          return n2.split(i).length - 1;
        }
        function o(e2, t2) {
          var n2 = s(e2, t2), r2 = e2.getValue().split(i), o2 = /* @__PURE__ */ Object.create(null), u = r2[n2];
          return r2.forEach(function(e3, t3) {
            if (!e3 || e3 === u)
              return;
            var i2 = Math.abs(n2 - t3), s2 = r2.length - i2;
            o2[e3] ? o2[e3] = Math.max(s2, o2[e3]) : o2[e3] = s2;
          }), o2;
        }
        var r = e("../range").Range, i = /[^a-zA-Z_0-9\$\-\u00C0-\u1FFF\u2C00-\uD7FF\w]+/;
        t.getCompletions = function(e2, t2, n2, r2, i2) {
          var s2 = o(t2, n2), u = Object.keys(s2);
          i2(null, u.map(function(e3) {
            return { caption: e3, value: e3, score: s2[e3], meta: "local" };
          }));
        };
      }), ace.define("ace/ext/language_tools", ["require", "exports", "module", "ace/snippets", "ace/autocomplete", "ace/config", "ace/lib/lang", "ace/autocomplete/util", "ace/autocomplete/text_completer", "ace/editor", "ace/config"], function(e, t, n) {
        "use strict";
        var r = e("../snippets").snippetManager, i = e("../autocomplete").Autocomplete, s = e("../config"), o = e("../lib/lang"), u = e("../autocomplete/util"), a = e("../autocomplete/text_completer"), f = { getCompletions: function(e2, t2, n2, r2, i2) {
          if (t2.$mode.completer)
            return t2.$mode.completer.getCompletions(e2, t2, n2, r2, i2);
          var s2 = e2.session.getState(n2.row), o2 = t2.$mode.getCompletions(s2, t2, n2, r2);
          i2(null, o2);
        } }, l = function(e2) {
          var t2 = {};
          return e2.replace(/\${(\d+)(:(.*?))?}/g, function(e3, n2, r2, i2) {
            return t2[n2] = i2 || "";
          }).replace(/\$(\d+?)/g, function(e3, n2) {
            return t2[n2];
          });
        }, c = { getCompletions: function(e2, t2, n2, i2, s2) {
          var o2 = [], u2 = t2.getTokenAt(n2.row, n2.column);
          u2 && u2.type.match(/(tag-name|tag-open|tag-whitespace|attribute-name|attribute-value)\.xml$/) ? o2.push("html-tag") : o2 = r.getActiveScopes(e2);
          var a2 = r.snippetMap, f2 = [];
          o2.forEach(function(e3) {
            var t3 = a2[e3] || [];
            for (var n3 = t3.length; n3--; ) {
              var r2 = t3[n3], i3 = r2.name || r2.tabTrigger;
              if (!i3)
                continue;
              f2.push({ caption: i3, snippet: r2.content, meta: r2.tabTrigger && !r2.name ? r2.tabTrigger + "\u21E5 " : "snippet", type: "snippet" });
            }
          }, this), s2(null, f2);
        }, getDocTooltip: function(e2) {
          e2.type == "snippet" && !e2.docHTML && (e2.docHTML = ["<b>", o.escapeHTML(e2.caption), "</b>", "<hr></hr>", o.escapeHTML(l(e2.snippet))].join(""));
        } }, h = [c, a, f];
        t.setCompleters = function(e2) {
          h.length = 0, e2 && h.push.apply(h, e2);
        }, t.addCompleter = function(e2) {
          h.push(e2);
        }, t.textCompleter = a, t.keyWordCompleter = f, t.snippetCompleter = c;
        var p = { name: "expandSnippet", exec: function(e2) {
          return r.expandWithTab(e2);
        }, bindKey: "Tab" }, d = function(e2, t2) {
          v(t2.session.$mode);
        }, v = function(e2) {
          typeof e2 == "string" && (e2 = s.$modes[e2]);
          if (!e2)
            return;
          r.files || (r.files = {}), m(e2.$id, e2.snippetFileId), e2.modes && e2.modes.forEach(v);
        }, m = function(e2, t2) {
          if (!t2 || !e2 || r.files[e2])
            return;
          r.files[e2] = {}, s.loadModule(t2, function(t3) {
            if (!t3)
              return;
            r.files[e2] = t3, !t3.snippets && t3.snippetText && (t3.snippets = r.parseSnippetFile(t3.snippetText)), r.register(t3.snippets || [], t3.scope), t3.includeScopes && (r.snippetMap[t3.scope].includeScopes = t3.includeScopes, t3.includeScopes.forEach(function(e3) {
              v("ace/mode/" + e3);
            }));
          });
        }, g = function(e2) {
          var t2 = e2.editor, n2 = t2.completer && t2.completer.activated;
          if (e2.command.name === "backspace")
            n2 && !u.getCompletionPrefix(t2) && t2.completer.detach();
          else if (e2.command.name === "insertstring") {
            var r2 = u.getCompletionPrefix(t2);
            if (r2 && !n2) {
              var s2 = i.for(t2);
              s2.autoInsert = false, s2.showPopup(t2);
            }
          }
        }, y = e("../editor").Editor;
        e("../config").defineOptions(y.prototype, "editor", { enableBasicAutocompletion: { set: function(e2) {
          e2 ? (this.completers || (this.completers = Array.isArray(e2) ? e2 : h), this.commands.addCommand(i.startCommand)) : this.commands.removeCommand(i.startCommand);
        }, value: false }, enableLiveAutocompletion: { set: function(e2) {
          e2 ? (this.completers || (this.completers = Array.isArray(e2) ? e2 : h), this.commands.on("afterExec", g)) : this.commands.removeListener("afterExec", g);
        }, value: false }, enableSnippets: { set: function(e2) {
          e2 ? (this.commands.addCommand(p), this.on("changeMode", d), d(null, this)) : (this.commands.removeCommand(p), this.off("changeMode", d));
        }, value: false } });
      });
      (function() {
        ace.require(["ace/ext/language_tools"], function(m) {
          if (typeof module == "object" && typeof exports == "object" && module) {
            module.exports = m;
          }
        });
      })();
    }
  });

  // node_modules/lodash/lodash.js
  var require_lodash = __commonJS({
    "node_modules/lodash/lodash.js"(exports, module) {
      (function() {
        var undefined2;
        var VERSION = "4.17.21";
        var LARGE_ARRAY_SIZE = 200;
        var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
        var HASH_UNDEFINED = "__lodash_hash_undefined__";
        var MAX_MEMOIZE_SIZE = 500;
        var PLACEHOLDER = "__lodash_placeholder__";
        var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
        var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
        var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
        var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
        var HOT_COUNT = 800, HOT_SPAN = 16;
        var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
        var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
        var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
        var wrapFlags = [
          ["ary", WRAP_ARY_FLAG],
          ["bind", WRAP_BIND_FLAG],
          ["bindKey", WRAP_BIND_KEY_FLAG],
          ["curry", WRAP_CURRY_FLAG],
          ["curryRight", WRAP_CURRY_RIGHT_FLAG],
          ["flip", WRAP_FLIP_FLAG],
          ["partial", WRAP_PARTIAL_FLAG],
          ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
          ["rearg", WRAP_REARG_FLAG]
        ];
        var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
        var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
        var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
        var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
        var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
        var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
        var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
        var reTrimStart = /^\s+/;
        var reWhitespace = /\s/;
        var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
        var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
        var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
        var reEscapeChar = /\\(\\)?/g;
        var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
        var reFlags = /\w*$/;
        var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
        var reIsBinary = /^0b[01]+$/i;
        var reIsHostCtor = /^\[object .+?Constructor\]$/;
        var reIsOctal = /^0o[0-7]+$/i;
        var reIsUint = /^(?:0|[1-9]\d*)$/;
        var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
        var reNoMatch = /($^)/;
        var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
        var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
        var rsApos = "['\u2019]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
        var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
        var reApos = RegExp(rsApos, "g");
        var reComboMark = RegExp(rsCombo, "g");
        var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
        var reUnicodeWord = RegExp([
          rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
          rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
          rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
          rsUpper + "+" + rsOptContrUpper,
          rsOrdUpper,
          rsOrdLower,
          rsDigits,
          rsEmoji
        ].join("|"), "g");
        var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
        var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
        var contextProps = [
          "Array",
          "Buffer",
          "DataView",
          "Date",
          "Error",
          "Float32Array",
          "Float64Array",
          "Function",
          "Int8Array",
          "Int16Array",
          "Int32Array",
          "Map",
          "Math",
          "Object",
          "Promise",
          "RegExp",
          "Set",
          "String",
          "Symbol",
          "TypeError",
          "Uint8Array",
          "Uint8ClampedArray",
          "Uint16Array",
          "Uint32Array",
          "WeakMap",
          "_",
          "clearTimeout",
          "isFinite",
          "parseInt",
          "setTimeout"
        ];
        var templateCounter = -1;
        var typedArrayTags = {};
        typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
        typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
        var cloneableTags = {};
        cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
        cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
        var deburredLetters = {
          // Latin-1 Supplement block.
          "\xC0": "A",
          "\xC1": "A",
          "\xC2": "A",
          "\xC3": "A",
          "\xC4": "A",
          "\xC5": "A",
          "\xE0": "a",
          "\xE1": "a",
          "\xE2": "a",
          "\xE3": "a",
          "\xE4": "a",
          "\xE5": "a",
          "\xC7": "C",
          "\xE7": "c",
          "\xD0": "D",
          "\xF0": "d",
          "\xC8": "E",
          "\xC9": "E",
          "\xCA": "E",
          "\xCB": "E",
          "\xE8": "e",
          "\xE9": "e",
          "\xEA": "e",
          "\xEB": "e",
          "\xCC": "I",
          "\xCD": "I",
          "\xCE": "I",
          "\xCF": "I",
          "\xEC": "i",
          "\xED": "i",
          "\xEE": "i",
          "\xEF": "i",
          "\xD1": "N",
          "\xF1": "n",
          "\xD2": "O",
          "\xD3": "O",
          "\xD4": "O",
          "\xD5": "O",
          "\xD6": "O",
          "\xD8": "O",
          "\xF2": "o",
          "\xF3": "o",
          "\xF4": "o",
          "\xF5": "o",
          "\xF6": "o",
          "\xF8": "o",
          "\xD9": "U",
          "\xDA": "U",
          "\xDB": "U",
          "\xDC": "U",
          "\xF9": "u",
          "\xFA": "u",
          "\xFB": "u",
          "\xFC": "u",
          "\xDD": "Y",
          "\xFD": "y",
          "\xFF": "y",
          "\xC6": "Ae",
          "\xE6": "ae",
          "\xDE": "Th",
          "\xFE": "th",
          "\xDF": "ss",
          // Latin Extended-A block.
          "\u0100": "A",
          "\u0102": "A",
          "\u0104": "A",
          "\u0101": "a",
          "\u0103": "a",
          "\u0105": "a",
          "\u0106": "C",
          "\u0108": "C",
          "\u010A": "C",
          "\u010C": "C",
          "\u0107": "c",
          "\u0109": "c",
          "\u010B": "c",
          "\u010D": "c",
          "\u010E": "D",
          "\u0110": "D",
          "\u010F": "d",
          "\u0111": "d",
          "\u0112": "E",
          "\u0114": "E",
          "\u0116": "E",
          "\u0118": "E",
          "\u011A": "E",
          "\u0113": "e",
          "\u0115": "e",
          "\u0117": "e",
          "\u0119": "e",
          "\u011B": "e",
          "\u011C": "G",
          "\u011E": "G",
          "\u0120": "G",
          "\u0122": "G",
          "\u011D": "g",
          "\u011F": "g",
          "\u0121": "g",
          "\u0123": "g",
          "\u0124": "H",
          "\u0126": "H",
          "\u0125": "h",
          "\u0127": "h",
          "\u0128": "I",
          "\u012A": "I",
          "\u012C": "I",
          "\u012E": "I",
          "\u0130": "I",
          "\u0129": "i",
          "\u012B": "i",
          "\u012D": "i",
          "\u012F": "i",
          "\u0131": "i",
          "\u0134": "J",
          "\u0135": "j",
          "\u0136": "K",
          "\u0137": "k",
          "\u0138": "k",
          "\u0139": "L",
          "\u013B": "L",
          "\u013D": "L",
          "\u013F": "L",
          "\u0141": "L",
          "\u013A": "l",
          "\u013C": "l",
          "\u013E": "l",
          "\u0140": "l",
          "\u0142": "l",
          "\u0143": "N",
          "\u0145": "N",
          "\u0147": "N",
          "\u014A": "N",
          "\u0144": "n",
          "\u0146": "n",
          "\u0148": "n",
          "\u014B": "n",
          "\u014C": "O",
          "\u014E": "O",
          "\u0150": "O",
          "\u014D": "o",
          "\u014F": "o",
          "\u0151": "o",
          "\u0154": "R",
          "\u0156": "R",
          "\u0158": "R",
          "\u0155": "r",
          "\u0157": "r",
          "\u0159": "r",
          "\u015A": "S",
          "\u015C": "S",
          "\u015E": "S",
          "\u0160": "S",
          "\u015B": "s",
          "\u015D": "s",
          "\u015F": "s",
          "\u0161": "s",
          "\u0162": "T",
          "\u0164": "T",
          "\u0166": "T",
          "\u0163": "t",
          "\u0165": "t",
          "\u0167": "t",
          "\u0168": "U",
          "\u016A": "U",
          "\u016C": "U",
          "\u016E": "U",
          "\u0170": "U",
          "\u0172": "U",
          "\u0169": "u",
          "\u016B": "u",
          "\u016D": "u",
          "\u016F": "u",
          "\u0171": "u",
          "\u0173": "u",
          "\u0174": "W",
          "\u0175": "w",
          "\u0176": "Y",
          "\u0177": "y",
          "\u0178": "Y",
          "\u0179": "Z",
          "\u017B": "Z",
          "\u017D": "Z",
          "\u017A": "z",
          "\u017C": "z",
          "\u017E": "z",
          "\u0132": "IJ",
          "\u0133": "ij",
          "\u0152": "Oe",
          "\u0153": "oe",
          "\u0149": "'n",
          "\u017F": "s"
        };
        var htmlEscapes = {
          "&": "&amp;",
          "<": "&lt;",
          ">": "&gt;",
          '"': "&quot;",
          "'": "&#39;"
        };
        var htmlUnescapes = {
          "&amp;": "&",
          "&lt;": "<",
          "&gt;": ">",
          "&quot;": '"',
          "&#39;": "'"
        };
        var stringEscapes = {
          "\\": "\\",
          "'": "'",
          "\n": "n",
          "\r": "r",
          "\u2028": "u2028",
          "\u2029": "u2029"
        };
        var freeParseFloat = parseFloat, freeParseInt = parseInt;
        var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
        var freeSelf = typeof self == "object" && self && self.Object === Object && self;
        var root = freeGlobal || freeSelf || Function("return this")();
        var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
        var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
        var moduleExports = freeModule && freeModule.exports === freeExports;
        var freeProcess = moduleExports && freeGlobal.process;
        var nodeUtil = function() {
          try {
            var types = freeModule && freeModule.require && freeModule.require("util").types;
            if (types) {
              return types;
            }
            return freeProcess && freeProcess.binding && freeProcess.binding("util");
          } catch (e) {
          }
        }();
        var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
        function apply(func, thisArg, args) {
          switch (args.length) {
            case 0:
              return func.call(thisArg);
            case 1:
              return func.call(thisArg, args[0]);
            case 2:
              return func.call(thisArg, args[0], args[1]);
            case 3:
              return func.call(thisArg, args[0], args[1], args[2]);
          }
          return func.apply(thisArg, args);
        }
        function arrayAggregator(array, setter, iteratee, accumulator) {
          var index = -1, length = array == null ? 0 : array.length;
          while (++index < length) {
            var value = array[index];
            setter(accumulator, value, iteratee(value), array);
          }
          return accumulator;
        }
        function arrayEach(array, iteratee) {
          var index = -1, length = array == null ? 0 : array.length;
          while (++index < length) {
            if (iteratee(array[index], index, array) === false) {
              break;
            }
          }
          return array;
        }
        function arrayEachRight(array, iteratee) {
          var length = array == null ? 0 : array.length;
          while (length--) {
            if (iteratee(array[length], length, array) === false) {
              break;
            }
          }
          return array;
        }
        function arrayEvery(array, predicate) {
          var index = -1, length = array == null ? 0 : array.length;
          while (++index < length) {
            if (!predicate(array[index], index, array)) {
              return false;
            }
          }
          return true;
        }
        function arrayFilter(array, predicate) {
          var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
          while (++index < length) {
            var value = array[index];
            if (predicate(value, index, array)) {
              result[resIndex++] = value;
            }
          }
          return result;
        }
        function arrayIncludes(array, value) {
          var length = array == null ? 0 : array.length;
          return !!length && baseIndexOf(array, value, 0) > -1;
        }
        function arrayIncludesWith(array, value, comparator) {
          var index = -1, length = array == null ? 0 : array.length;
          while (++index < length) {
            if (comparator(value, array[index])) {
              return true;
            }
          }
          return false;
        }
        function arrayMap(array, iteratee) {
          var index = -1, length = array == null ? 0 : array.length, result = Array(length);
          while (++index < length) {
            result[index] = iteratee(array[index], index, array);
          }
          return result;
        }
        function arrayPush(array, values) {
          var index = -1, length = values.length, offset = array.length;
          while (++index < length) {
            array[offset + index] = values[index];
          }
          return array;
        }
        function arrayReduce(array, iteratee, accumulator, initAccum) {
          var index = -1, length = array == null ? 0 : array.length;
          if (initAccum && length) {
            accumulator = array[++index];
          }
          while (++index < length) {
            accumulator = iteratee(accumulator, array[index], index, array);
          }
          return accumulator;
        }
        function arrayReduceRight(array, iteratee, accumulator, initAccum) {
          var length = array == null ? 0 : array.length;
          if (initAccum && length) {
            accumulator = array[--length];
          }
          while (length--) {
            accumulator = iteratee(accumulator, array[length], length, array);
          }
          return accumulator;
        }
        function arraySome(array, predicate) {
          var index = -1, length = array == null ? 0 : array.length;
          while (++index < length) {
            if (predicate(array[index], index, array)) {
              return true;
            }
          }
          return false;
        }
        var asciiSize = baseProperty("length");
        function asciiToArray(string) {
          return string.split("");
        }
        function asciiWords(string) {
          return string.match(reAsciiWord) || [];
        }
        function baseFindKey(collection, predicate, eachFunc) {
          var result;
          eachFunc(collection, function(value, key, collection2) {
            if (predicate(value, key, collection2)) {
              result = key;
              return false;
            }
          });
          return result;
        }
        function baseFindIndex(array, predicate, fromIndex, fromRight) {
          var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
          while (fromRight ? index-- : ++index < length) {
            if (predicate(array[index], index, array)) {
              return index;
            }
          }
          return -1;
        }
        function baseIndexOf(array, value, fromIndex) {
          return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
        }
        function baseIndexOfWith(array, value, fromIndex, comparator) {
          var index = fromIndex - 1, length = array.length;
          while (++index < length) {
            if (comparator(array[index], value)) {
              return index;
            }
          }
          return -1;
        }
        function baseIsNaN(value) {
          return value !== value;
        }
        function baseMean(array, iteratee) {
          var length = array == null ? 0 : array.length;
          return length ? baseSum(array, iteratee) / length : NAN;
        }
        function baseProperty(key) {
          return function(object) {
            return object == null ? undefined2 : object[key];
          };
        }
        function basePropertyOf(object) {
          return function(key) {
            return object == null ? undefined2 : object[key];
          };
        }
        function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
          eachFunc(collection, function(value, index, collection2) {
            accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection2);
          });
          return accumulator;
        }
        function baseSortBy(array, comparer) {
          var length = array.length;
          array.sort(comparer);
          while (length--) {
            array[length] = array[length].value;
          }
          return array;
        }
        function baseSum(array, iteratee) {
          var result, index = -1, length = array.length;
          while (++index < length) {
            var current = iteratee(array[index]);
            if (current !== undefined2) {
              result = result === undefined2 ? current : result + current;
            }
          }
          return result;
        }
        function baseTimes(n, iteratee) {
          var index = -1, result = Array(n);
          while (++index < n) {
            result[index] = iteratee(index);
          }
          return result;
        }
        function baseToPairs(object, props) {
          return arrayMap(props, function(key) {
            return [key, object[key]];
          });
        }
        function baseTrim(string) {
          return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
        }
        function baseUnary(func) {
          return function(value) {
            return func(value);
          };
        }
        function baseValues(object, props) {
          return arrayMap(props, function(key) {
            return object[key];
          });
        }
        function cacheHas(cache, key) {
          return cache.has(key);
        }
        function charsStartIndex(strSymbols, chrSymbols) {
          var index = -1, length = strSymbols.length;
          while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
          }
          return index;
        }
        function charsEndIndex(strSymbols, chrSymbols) {
          var index = strSymbols.length;
          while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
          }
          return index;
        }
        function countHolders(array, placeholder) {
          var length = array.length, result = 0;
          while (length--) {
            if (array[length] === placeholder) {
              ++result;
            }
          }
          return result;
        }
        var deburrLetter = basePropertyOf(deburredLetters);
        var escapeHtmlChar = basePropertyOf(htmlEscapes);
        function escapeStringChar(chr) {
          return "\\" + stringEscapes[chr];
        }
        function getValue(object, key) {
          return object == null ? undefined2 : object[key];
        }
        function hasUnicode(string) {
          return reHasUnicode.test(string);
        }
        function hasUnicodeWord(string) {
          return reHasUnicodeWord.test(string);
        }
        function iteratorToArray(iterator) {
          var data, result = [];
          while (!(data = iterator.next()).done) {
            result.push(data.value);
          }
          return result;
        }
        function mapToArray(map) {
          var index = -1, result = Array(map.size);
          map.forEach(function(value, key) {
            result[++index] = [key, value];
          });
          return result;
        }
        function overArg(func, transform) {
          return function(arg) {
            return func(transform(arg));
          };
        }
        function replaceHolders(array, placeholder) {
          var index = -1, length = array.length, resIndex = 0, result = [];
          while (++index < length) {
            var value = array[index];
            if (value === placeholder || value === PLACEHOLDER) {
              array[index] = PLACEHOLDER;
              result[resIndex++] = index;
            }
          }
          return result;
        }
        function setToArray(set) {
          var index = -1, result = Array(set.size);
          set.forEach(function(value) {
            result[++index] = value;
          });
          return result;
        }
        function setToPairs(set) {
          var index = -1, result = Array(set.size);
          set.forEach(function(value) {
            result[++index] = [value, value];
          });
          return result;
        }
        function strictIndexOf(array, value, fromIndex) {
          var index = fromIndex - 1, length = array.length;
          while (++index < length) {
            if (array[index] === value) {
              return index;
            }
          }
          return -1;
        }
        function strictLastIndexOf(array, value, fromIndex) {
          var index = fromIndex + 1;
          while (index--) {
            if (array[index] === value) {
              return index;
            }
          }
          return index;
        }
        function stringSize(string) {
          return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
        }
        function stringToArray(string) {
          return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
        }
        function trimmedEndIndex(string) {
          var index = string.length;
          while (index-- && reWhitespace.test(string.charAt(index))) {
          }
          return index;
        }
        var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
        function unicodeSize(string) {
          var result = reUnicode.lastIndex = 0;
          while (reUnicode.test(string)) {
            ++result;
          }
          return result;
        }
        function unicodeToArray(string) {
          return string.match(reUnicode) || [];
        }
        function unicodeWords(string) {
          return string.match(reUnicodeWord) || [];
        }
        var runInContext = function runInContext2(context) {
          context = context == null ? root : _2.defaults(root.Object(), context, _2.pick(root, contextProps));
          var Array2 = context.Array, Date2 = context.Date, Error2 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError;
          var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype;
          var coreJsData = context["__core-js_shared__"];
          var funcToString = funcProto.toString;
          var hasOwnProperty = objectProto.hasOwnProperty;
          var idCounter = 0;
          var maskSrcKey = function() {
            var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
            return uid ? "Symbol(src)_1." + uid : "";
          }();
          var nativeObjectToString = objectProto.toString;
          var objectCtorString = funcToString.call(Object2);
          var oldDash = root._;
          var reIsNative = RegExp2(
            "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
          );
          var Buffer2 = moduleExports ? context.Buffer : undefined2, Symbol2 = context.Symbol, Uint8Array2 = context.Uint8Array, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : undefined2, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined2, symIterator = Symbol2 ? Symbol2.iterator : undefined2, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined2;
          var defineProperty = function() {
            try {
              var func = getNative(Object2, "defineProperty");
              func({}, "", {});
              return func;
            } catch (e) {
            }
          }();
          var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;
          var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined2, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
          var DataView2 = getNative(context, "DataView"), Map2 = getNative(context, "Map"), Promise2 = getNative(context, "Promise"), Set2 = getNative(context, "Set"), WeakMap2 = getNative(context, "WeakMap"), nativeCreate = getNative(Object2, "create");
          var metaMap = WeakMap2 && new WeakMap2();
          var realNames = {};
          var dataViewCtorString = toSource(DataView2), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
          var symbolProto = Symbol2 ? Symbol2.prototype : undefined2, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined2, symbolToString = symbolProto ? symbolProto.toString : undefined2;
          function lodash(value) {
            if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
              if (value instanceof LodashWrapper) {
                return value;
              }
              if (hasOwnProperty.call(value, "__wrapped__")) {
                return wrapperClone(value);
              }
            }
            return new LodashWrapper(value);
          }
          var baseCreate = /* @__PURE__ */ function() {
            function object() {
            }
            return function(proto) {
              if (!isObject(proto)) {
                return {};
              }
              if (objectCreate) {
                return objectCreate(proto);
              }
              object.prototype = proto;
              var result2 = new object();
              object.prototype = undefined2;
              return result2;
            };
          }();
          function baseLodash() {
          }
          function LodashWrapper(value, chainAll) {
            this.__wrapped__ = value;
            this.__actions__ = [];
            this.__chain__ = !!chainAll;
            this.__index__ = 0;
            this.__values__ = undefined2;
          }
          lodash.templateSettings = {
            /**
             * Used to detect `data` property values to be HTML-escaped.
             *
             * @memberOf _.templateSettings
             * @type {RegExp}
             */
            "escape": reEscape,
            /**
             * Used to detect code to be evaluated.
             *
             * @memberOf _.templateSettings
             * @type {RegExp}
             */
            "evaluate": reEvaluate,
            /**
             * Used to detect `data` property values to inject.
             *
             * @memberOf _.templateSettings
             * @type {RegExp}
             */
            "interpolate": reInterpolate,
            /**
             * Used to reference the data object in the template text.
             *
             * @memberOf _.templateSettings
             * @type {string}
             */
            "variable": "",
            /**
             * Used to import variables into the compiled template.
             *
             * @memberOf _.templateSettings
             * @type {Object}
             */
            "imports": {
              /**
               * A reference to the `lodash` function.
               *
               * @memberOf _.templateSettings.imports
               * @type {Function}
               */
              "_": lodash
            }
          };
          lodash.prototype = baseLodash.prototype;
          lodash.prototype.constructor = lodash;
          LodashWrapper.prototype = baseCreate(baseLodash.prototype);
          LodashWrapper.prototype.constructor = LodashWrapper;
          function LazyWrapper(value) {
            this.__wrapped__ = value;
            this.__actions__ = [];
            this.__dir__ = 1;
            this.__filtered__ = false;
            this.__iteratees__ = [];
            this.__takeCount__ = MAX_ARRAY_LENGTH;
            this.__views__ = [];
          }
          function lazyClone() {
            var result2 = new LazyWrapper(this.__wrapped__);
            result2.__actions__ = copyArray2(this.__actions__);
            result2.__dir__ = this.__dir__;
            result2.__filtered__ = this.__filtered__;
            result2.__iteratees__ = copyArray2(this.__iteratees__);
            result2.__takeCount__ = this.__takeCount__;
            result2.__views__ = copyArray2(this.__views__);
            return result2;
          }
          function lazyReverse() {
            if (this.__filtered__) {
              var result2 = new LazyWrapper(this);
              result2.__dir__ = -1;
              result2.__filtered__ = true;
            } else {
              result2 = this.clone();
              result2.__dir__ *= -1;
            }
            return result2;
          }
          function lazyValue() {
            var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start2 = view.start, end = view.end, length = end - start2, index = isRight ? end : start2 - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
            if (!isArr || !isRight && arrLength == length && takeCount == length) {
              return baseWrapperValue(array, this.__actions__);
            }
            var result2 = [];
            outer:
              while (length-- && resIndex < takeCount) {
                index += dir;
                var iterIndex = -1, value = array[index];
                while (++iterIndex < iterLength) {
                  var data = iteratees[iterIndex], iteratee2 = data.iteratee, type = data.type, computed = iteratee2(value);
                  if (type == LAZY_MAP_FLAG) {
                    value = computed;
                  } else if (!computed) {
                    if (type == LAZY_FILTER_FLAG) {
                      continue outer;
                    } else {
                      break outer;
                    }
                  }
                }
                result2[resIndex++] = value;
              }
            return result2;
          }
          LazyWrapper.prototype = baseCreate(baseLodash.prototype);
          LazyWrapper.prototype.constructor = LazyWrapper;
          function Hash(entries) {
            var index = -1, length = entries == null ? 0 : entries.length;
            this.clear();
            while (++index < length) {
              var entry = entries[index];
              this.set(entry[0], entry[1]);
            }
          }
          function hashClear() {
            this.__data__ = nativeCreate ? nativeCreate(null) : {};
            this.size = 0;
          }
          function hashDelete(key) {
            var result2 = this.has(key) && delete this.__data__[key];
            this.size -= result2 ? 1 : 0;
            return result2;
          }
          function hashGet(key) {
            var data = this.__data__;
            if (nativeCreate) {
              var result2 = data[key];
              return result2 === HASH_UNDEFINED ? undefined2 : result2;
            }
            return hasOwnProperty.call(data, key) ? data[key] : undefined2;
          }
          function hashHas(key) {
            var data = this.__data__;
            return nativeCreate ? data[key] !== undefined2 : hasOwnProperty.call(data, key);
          }
          function hashSet(key, value) {
            var data = this.__data__;
            this.size += this.has(key) ? 0 : 1;
            data[key] = nativeCreate && value === undefined2 ? HASH_UNDEFINED : value;
            return this;
          }
          Hash.prototype.clear = hashClear;
          Hash.prototype["delete"] = hashDelete;
          Hash.prototype.get = hashGet;
          Hash.prototype.has = hashHas;
          Hash.prototype.set = hashSet;
          function ListCache(entries) {
            var index = -1, length = entries == null ? 0 : entries.length;
            this.clear();
            while (++index < length) {
              var entry = entries[index];
              this.set(entry[0], entry[1]);
            }
          }
          function listCacheClear() {
            this.__data__ = [];
            this.size = 0;
          }
          function listCacheDelete(key) {
            var data = this.__data__, index = assocIndexOf(data, key);
            if (index < 0) {
              return false;
            }
            var lastIndex = data.length - 1;
            if (index == lastIndex) {
              data.pop();
            } else {
              splice.call(data, index, 1);
            }
            --this.size;
            return true;
          }
          function listCacheGet(key) {
            var data = this.__data__, index = assocIndexOf(data, key);
            return index < 0 ? undefined2 : data[index][1];
          }
          function listCacheHas(key) {
            return assocIndexOf(this.__data__, key) > -1;
          }
          function listCacheSet(key, value) {
            var data = this.__data__, index = assocIndexOf(data, key);
            if (index < 0) {
              ++this.size;
              data.push([key, value]);
            } else {
              data[index][1] = value;
            }
            return this;
          }
          ListCache.prototype.clear = listCacheClear;
          ListCache.prototype["delete"] = listCacheDelete;
          ListCache.prototype.get = listCacheGet;
          ListCache.prototype.has = listCacheHas;
          ListCache.prototype.set = listCacheSet;
          function MapCache(entries) {
            var index = -1, length = entries == null ? 0 : entries.length;
            this.clear();
            while (++index < length) {
              var entry = entries[index];
              this.set(entry[0], entry[1]);
            }
          }
          function mapCacheClear() {
            this.size = 0;
            this.__data__ = {
              "hash": new Hash(),
              "map": new (Map2 || ListCache)(),
              "string": new Hash()
            };
          }
          function mapCacheDelete(key) {
            var result2 = getMapData(this, key)["delete"](key);
            this.size -= result2 ? 1 : 0;
            return result2;
          }
          function mapCacheGet(key) {
            return getMapData(this, key).get(key);
          }
          function mapCacheHas(key) {
            return getMapData(this, key).has(key);
          }
          function mapCacheSet(key, value) {
            var data = getMapData(this, key), size2 = data.size;
            data.set(key, value);
            this.size += data.size == size2 ? 0 : 1;
            return this;
          }
          MapCache.prototype.clear = mapCacheClear;
          MapCache.prototype["delete"] = mapCacheDelete;
          MapCache.prototype.get = mapCacheGet;
          MapCache.prototype.has = mapCacheHas;
          MapCache.prototype.set = mapCacheSet;
          function SetCache(values2) {
            var index = -1, length = values2 == null ? 0 : values2.length;
            this.__data__ = new MapCache();
            while (++index < length) {
              this.add(values2[index]);
            }
          }
          function setCacheAdd(value) {
            this.__data__.set(value, HASH_UNDEFINED);
            return this;
          }
          function setCacheHas(value) {
            return this.__data__.has(value);
          }
          SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
          SetCache.prototype.has = setCacheHas;
          function Stack(entries) {
            var data = this.__data__ = new ListCache(entries);
            this.size = data.size;
          }
          function stackClear() {
            this.__data__ = new ListCache();
            this.size = 0;
          }
          function stackDelete(key) {
            var data = this.__data__, result2 = data["delete"](key);
            this.size = data.size;
            return result2;
          }
          function stackGet(key) {
            return this.__data__.get(key);
          }
          function stackHas(key) {
            return this.__data__.has(key);
          }
          function stackSet(key, value) {
            var data = this.__data__;
            if (data instanceof ListCache) {
              var pairs = data.__data__;
              if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
                pairs.push([key, value]);
                this.size = ++data.size;
                return this;
              }
              data = this.__data__ = new MapCache(pairs);
            }
            data.set(key, value);
            this.size = data.size;
            return this;
          }
          Stack.prototype.clear = stackClear;
          Stack.prototype["delete"] = stackDelete;
          Stack.prototype.get = stackGet;
          Stack.prototype.has = stackHas;
          Stack.prototype.set = stackSet;
          function arrayLikeKeys(value, inherited) {
            var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String2) : [], length = result2.length;
            for (var key in value) {
              if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
              (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
              isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
              isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
              isIndex(key, length)))) {
                result2.push(key);
              }
            }
            return result2;
          }
          function arraySample(array) {
            var length = array.length;
            return length ? array[baseRandom(0, length - 1)] : undefined2;
          }
          function arraySampleSize(array, n) {
            return shuffleSelf(copyArray2(array), baseClamp(n, 0, array.length));
          }
          function arrayShuffle(array) {
            return shuffleSelf(copyArray2(array));
          }
          function assignMergeValue(object, key, value) {
            if (value !== undefined2 && !eq(object[key], value) || value === undefined2 && !(key in object)) {
              baseAssignValue(object, key, value);
            }
          }
          function assignValue(object, key, value) {
            var objValue = object[key];
            if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined2 && !(key in object)) {
              baseAssignValue(object, key, value);
            }
          }
          function assocIndexOf(array, key) {
            var length = array.length;
            while (length--) {
              if (eq(array[length][0], key)) {
                return length;
              }
            }
            return -1;
          }
          function baseAggregator(collection, setter, iteratee2, accumulator) {
            baseEach(collection, function(value, key, collection2) {
              setter(accumulator, value, iteratee2(value), collection2);
            });
            return accumulator;
          }
          function baseAssign(object, source) {
            return object && copyObject(source, keys(source), object);
          }
          function baseAssignIn(object, source) {
            return object && copyObject(source, keysIn(source), object);
          }
          function baseAssignValue(object, key, value) {
            if (key == "__proto__" && defineProperty) {
              defineProperty(object, key, {
                "configurable": true,
                "enumerable": true,
                "value": value,
                "writable": true
              });
            } else {
              object[key] = value;
            }
          }
          function baseAt(object, paths) {
            var index = -1, length = paths.length, result2 = Array2(length), skip = object == null;
            while (++index < length) {
              result2[index] = skip ? undefined2 : get(object, paths[index]);
            }
            return result2;
          }
          function baseClamp(number, lower, upper) {
            if (number === number) {
              if (upper !== undefined2) {
                number = number <= upper ? number : upper;
              }
              if (lower !== undefined2) {
                number = number >= lower ? number : lower;
              }
            }
            return number;
          }
          function baseClone(value, bitmask, customizer, key, object, stack) {
            var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
            if (customizer) {
              result2 = object ? customizer(value, key, object, stack) : customizer(value);
            }
            if (result2 !== undefined2) {
              return result2;
            }
            if (!isObject(value)) {
              return value;
            }
            var isArr = isArray(value);
            if (isArr) {
              result2 = initCloneArray(value);
              if (!isDeep) {
                return copyArray2(value, result2);
              }
            } else {
              var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
              if (isBuffer(value)) {
                return cloneBuffer(value, isDeep);
              }
              if (tag == objectTag || tag == argsTag || isFunc && !object) {
                result2 = isFlat || isFunc ? {} : initCloneObject(value);
                if (!isDeep) {
                  return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
                }
              } else {
                if (!cloneableTags[tag]) {
                  return object ? value : {};
                }
                result2 = initCloneByTag(value, tag, isDeep);
              }
            }
            stack || (stack = new Stack());
            var stacked = stack.get(value);
            if (stacked) {
              return stacked;
            }
            stack.set(value, result2);
            if (isSet(value)) {
              value.forEach(function(subValue) {
                result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
              });
            } else if (isMap(value)) {
              value.forEach(function(subValue, key2) {
                result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
              });
            }
            var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
            var props = isArr ? undefined2 : keysFunc(value);
            arrayEach(props || value, function(subValue, key2) {
              if (props) {
                key2 = subValue;
                subValue = value[key2];
              }
              assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
            });
            return result2;
          }
          function baseConforms(source) {
            var props = keys(source);
            return function(object) {
              return baseConformsTo(object, source, props);
            };
          }
          function baseConformsTo(object, source, props) {
            var length = props.length;
            if (object == null) {
              return !length;
            }
            object = Object2(object);
            while (length--) {
              var key = props[length], predicate = source[key], value = object[key];
              if (value === undefined2 && !(key in object) || !predicate(value)) {
                return false;
              }
            }
            return true;
          }
          function baseDelay(func, wait, args) {
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            return setTimeout2(function() {
              func.apply(undefined2, args);
            }, wait);
          }
          function baseDifference(array, values2, iteratee2, comparator) {
            var index = -1, includes2 = arrayIncludes, isCommon = true, length = array.length, result2 = [], valuesLength = values2.length;
            if (!length) {
              return result2;
            }
            if (iteratee2) {
              values2 = arrayMap(values2, baseUnary(iteratee2));
            }
            if (comparator) {
              includes2 = arrayIncludesWith;
              isCommon = false;
            } else if (values2.length >= LARGE_ARRAY_SIZE) {
              includes2 = cacheHas;
              isCommon = false;
              values2 = new SetCache(values2);
            }
            outer:
              while (++index < length) {
                var value = array[index], computed = iteratee2 == null ? value : iteratee2(value);
                value = comparator || value !== 0 ? value : 0;
                if (isCommon && computed === computed) {
                  var valuesIndex = valuesLength;
                  while (valuesIndex--) {
                    if (values2[valuesIndex] === computed) {
                      continue outer;
                    }
                  }
                  result2.push(value);
                } else if (!includes2(values2, computed, comparator)) {
                  result2.push(value);
                }
              }
            return result2;
          }
          var baseEach = createBaseEach(baseForOwn);
          var baseEachRight = createBaseEach(baseForOwnRight, true);
          function baseEvery(collection, predicate) {
            var result2 = true;
            baseEach(collection, function(value, index, collection2) {
              result2 = !!predicate(value, index, collection2);
              return result2;
            });
            return result2;
          }
          function baseExtremum(array, iteratee2, comparator) {
            var index = -1, length = array.length;
            while (++index < length) {
              var value = array[index], current = iteratee2(value);
              if (current != null && (computed === undefined2 ? current === current && !isSymbol(current) : comparator(current, computed))) {
                var computed = current, result2 = value;
              }
            }
            return result2;
          }
          function baseFill(array, value, start2, end) {
            var length = array.length;
            start2 = toInteger(start2);
            if (start2 < 0) {
              start2 = -start2 > length ? 0 : length + start2;
            }
            end = end === undefined2 || end > length ? length : toInteger(end);
            if (end < 0) {
              end += length;
            }
            end = start2 > end ? 0 : toLength(end);
            while (start2 < end) {
              array[start2++] = value;
            }
            return array;
          }
          function baseFilter(collection, predicate) {
            var result2 = [];
            baseEach(collection, function(value, index, collection2) {
              if (predicate(value, index, collection2)) {
                result2.push(value);
              }
            });
            return result2;
          }
          function baseFlatten(array, depth, predicate, isStrict, result2) {
            var index = -1, length = array.length;
            predicate || (predicate = isFlattenable);
            result2 || (result2 = []);
            while (++index < length) {
              var value = array[index];
              if (depth > 0 && predicate(value)) {
                if (depth > 1) {
                  baseFlatten(value, depth - 1, predicate, isStrict, result2);
                } else {
                  arrayPush(result2, value);
                }
              } else if (!isStrict) {
                result2[result2.length] = value;
              }
            }
            return result2;
          }
          var baseFor = createBaseFor();
          var baseForRight = createBaseFor(true);
          function baseForOwn(object, iteratee2) {
            return object && baseFor(object, iteratee2, keys);
          }
          function baseForOwnRight(object, iteratee2) {
            return object && baseForRight(object, iteratee2, keys);
          }
          function baseFunctions(object, props) {
            return arrayFilter(props, function(key) {
              return isFunction(object[key]);
            });
          }
          function baseGet(object, path) {
            path = castPath(path, object);
            var index = 0, length = path.length;
            while (object != null && index < length) {
              object = object[toKey(path[index++])];
            }
            return index && index == length ? object : undefined2;
          }
          function baseGetAllKeys(object, keysFunc, symbolsFunc) {
            var result2 = keysFunc(object);
            return isArray(object) ? result2 : arrayPush(result2, symbolsFunc(object));
          }
          function baseGetTag(value) {
            if (value == null) {
              return value === undefined2 ? undefinedTag : nullTag;
            }
            return symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString(value);
          }
          function baseGt(value, other) {
            return value > other;
          }
          function baseHas(object, key) {
            return object != null && hasOwnProperty.call(object, key);
          }
          function baseHasIn(object, key) {
            return object != null && key in Object2(object);
          }
          function baseInRange(number, start2, end) {
            return number >= nativeMin(start2, end) && number < nativeMax(start2, end);
          }
          function baseIntersection(arrays, iteratee2, comparator) {
            var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
            while (othIndex--) {
              var array = arrays[othIndex];
              if (othIndex && iteratee2) {
                array = arrayMap(array, baseUnary(iteratee2));
              }
              maxLength = nativeMin(array.length, maxLength);
              caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined2;
            }
            array = arrays[0];
            var index = -1, seen = caches[0];
            outer:
              while (++index < length && result2.length < maxLength) {
                var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
                value = comparator || value !== 0 ? value : 0;
                if (!(seen ? cacheHas(seen, computed) : includes2(result2, computed, comparator))) {
                  othIndex = othLength;
                  while (--othIndex) {
                    var cache = caches[othIndex];
                    if (!(cache ? cacheHas(cache, computed) : includes2(arrays[othIndex], computed, comparator))) {
                      continue outer;
                    }
                  }
                  if (seen) {
                    seen.push(computed);
                  }
                  result2.push(value);
                }
              }
            return result2;
          }
          function baseInverter(object, setter, iteratee2, accumulator) {
            baseForOwn(object, function(value, key, object2) {
              setter(accumulator, iteratee2(value), key, object2);
            });
            return accumulator;
          }
          function baseInvoke(object, path, args) {
            path = castPath(path, object);
            object = parent(object, path);
            var func = object == null ? object : object[toKey(last(path))];
            return func == null ? undefined2 : apply(func, object, args);
          }
          function baseIsArguments(value) {
            return isObjectLike(value) && baseGetTag(value) == argsTag;
          }
          function baseIsArrayBuffer(value) {
            return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
          }
          function baseIsDate(value) {
            return isObjectLike(value) && baseGetTag(value) == dateTag;
          }
          function baseIsEqual(value, other, bitmask, customizer, stack) {
            if (value === other) {
              return true;
            }
            if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
              return value !== value && other !== other;
            }
            return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
          }
          function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
            var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
            objTag = objTag == argsTag ? objectTag : objTag;
            othTag = othTag == argsTag ? objectTag : othTag;
            var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
            if (isSameTag && isBuffer(object)) {
              if (!isBuffer(other)) {
                return false;
              }
              objIsArr = true;
              objIsObj = false;
            }
            if (isSameTag && !objIsObj) {
              stack || (stack = new Stack());
              return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
            }
            if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
              var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
              if (objIsWrapped || othIsWrapped) {
                var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
                stack || (stack = new Stack());
                return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
              }
            }
            if (!isSameTag) {
              return false;
            }
            stack || (stack = new Stack());
            return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
          }
          function baseIsMap(value) {
            return isObjectLike(value) && getTag(value) == mapTag;
          }
          function baseIsMatch(object, source, matchData, customizer) {
            var index = matchData.length, length = index, noCustomizer = !customizer;
            if (object == null) {
              return !length;
            }
            object = Object2(object);
            while (index--) {
              var data = matchData[index];
              if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
                return false;
              }
            }
            while (++index < length) {
              data = matchData[index];
              var key = data[0], objValue = object[key], srcValue = data[1];
              if (noCustomizer && data[2]) {
                if (objValue === undefined2 && !(key in object)) {
                  return false;
                }
              } else {
                var stack = new Stack();
                if (customizer) {
                  var result2 = customizer(objValue, srcValue, key, object, source, stack);
                }
                if (!(result2 === undefined2 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result2)) {
                  return false;
                }
              }
            }
            return true;
          }
          function baseIsNative(value) {
            if (!isObject(value) || isMasked(value)) {
              return false;
            }
            var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
            return pattern.test(toSource(value));
          }
          function baseIsRegExp(value) {
            return isObjectLike(value) && baseGetTag(value) == regexpTag;
          }
          function baseIsSet(value) {
            return isObjectLike(value) && getTag(value) == setTag;
          }
          function baseIsTypedArray(value) {
            return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
          }
          function baseIteratee(value) {
            if (typeof value == "function") {
              return value;
            }
            if (value == null) {
              return identity;
            }
            if (typeof value == "object") {
              return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
            }
            return property(value);
          }
          function baseKeys(object) {
            if (!isPrototype(object)) {
              return nativeKeys(object);
            }
            var result2 = [];
            for (var key in Object2(object)) {
              if (hasOwnProperty.call(object, key) && key != "constructor") {
                result2.push(key);
              }
            }
            return result2;
          }
          function baseKeysIn(object) {
            if (!isObject(object)) {
              return nativeKeysIn(object);
            }
            var isProto = isPrototype(object), result2 = [];
            for (var key in object) {
              if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
                result2.push(key);
              }
            }
            return result2;
          }
          function baseLt(value, other) {
            return value < other;
          }
          function baseMap(collection, iteratee2) {
            var index = -1, result2 = isArrayLike(collection) ? Array2(collection.length) : [];
            baseEach(collection, function(value, key, collection2) {
              result2[++index] = iteratee2(value, key, collection2);
            });
            return result2;
          }
          function baseMatches(source) {
            var matchData = getMatchData(source);
            if (matchData.length == 1 && matchData[0][2]) {
              return matchesStrictComparable(matchData[0][0], matchData[0][1]);
            }
            return function(object) {
              return object === source || baseIsMatch(object, source, matchData);
            };
          }
          function baseMatchesProperty(path, srcValue) {
            if (isKey(path) && isStrictComparable(srcValue)) {
              return matchesStrictComparable(toKey(path), srcValue);
            }
            return function(object) {
              var objValue = get(object, path);
              return objValue === undefined2 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
            };
          }
          function baseMerge(object, source, srcIndex, customizer, stack) {
            if (object === source) {
              return;
            }
            baseFor(source, function(srcValue, key) {
              stack || (stack = new Stack());
              if (isObject(srcValue)) {
                baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
              } else {
                var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : undefined2;
                if (newValue === undefined2) {
                  newValue = srcValue;
                }
                assignMergeValue(object, key, newValue);
              }
            }, keysIn);
          }
          function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
            var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
            if (stacked) {
              assignMergeValue(object, key, stacked);
              return;
            }
            var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined2;
            var isCommon = newValue === undefined2;
            if (isCommon) {
              var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
              newValue = srcValue;
              if (isArr || isBuff || isTyped) {
                if (isArray(objValue)) {
                  newValue = objValue;
                } else if (isArrayLikeObject(objValue)) {
                  newValue = copyArray2(objValue);
                } else if (isBuff) {
                  isCommon = false;
                  newValue = cloneBuffer(srcValue, true);
                } else if (isTyped) {
                  isCommon = false;
                  newValue = cloneTypedArray(srcValue, true);
                } else {
                  newValue = [];
                }
              } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
                newValue = objValue;
                if (isArguments(objValue)) {
                  newValue = toPlainObject(objValue);
                } else if (!isObject(objValue) || isFunction(objValue)) {
                  newValue = initCloneObject(srcValue);
                }
              } else {
                isCommon = false;
              }
            }
            if (isCommon) {
              stack.set(srcValue, newValue);
              mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
              stack["delete"](srcValue);
            }
            assignMergeValue(object, key, newValue);
          }
          function baseNth(array, n) {
            var length = array.length;
            if (!length) {
              return;
            }
            n += n < 0 ? length : 0;
            return isIndex(n, length) ? array[n] : undefined2;
          }
          function baseOrderBy(collection, iteratees, orders) {
            if (iteratees.length) {
              iteratees = arrayMap(iteratees, function(iteratee2) {
                if (isArray(iteratee2)) {
                  return function(value) {
                    return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
                  };
                }
                return iteratee2;
              });
            } else {
              iteratees = [identity];
            }
            var index = -1;
            iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
            var result2 = baseMap(collection, function(value, key, collection2) {
              var criteria = arrayMap(iteratees, function(iteratee2) {
                return iteratee2(value);
              });
              return { "criteria": criteria, "index": ++index, "value": value };
            });
            return baseSortBy(result2, function(object, other) {
              return compareMultiple(object, other, orders);
            });
          }
          function basePick(object, paths) {
            return basePickBy(object, paths, function(value, path) {
              return hasIn(object, path);
            });
          }
          function basePickBy(object, paths, predicate) {
            var index = -1, length = paths.length, result2 = {};
            while (++index < length) {
              var path = paths[index], value = baseGet(object, path);
              if (predicate(value, path)) {
                baseSet(result2, castPath(path, object), value);
              }
            }
            return result2;
          }
          function basePropertyDeep(path) {
            return function(object) {
              return baseGet(object, path);
            };
          }
          function basePullAll(array, values2, iteratee2, comparator) {
            var indexOf4 = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length = values2.length, seen = array;
            if (array === values2) {
              values2 = copyArray2(values2);
            }
            if (iteratee2) {
              seen = arrayMap(array, baseUnary(iteratee2));
            }
            while (++index < length) {
              var fromIndex = 0, value = values2[index], computed = iteratee2 ? iteratee2(value) : value;
              while ((fromIndex = indexOf4(seen, computed, fromIndex, comparator)) > -1) {
                if (seen !== array) {
                  splice.call(seen, fromIndex, 1);
                }
                splice.call(array, fromIndex, 1);
              }
            }
            return array;
          }
          function basePullAt(array, indexes) {
            var length = array ? indexes.length : 0, lastIndex = length - 1;
            while (length--) {
              var index = indexes[length];
              if (length == lastIndex || index !== previous) {
                var previous = index;
                if (isIndex(index)) {
                  splice.call(array, index, 1);
                } else {
                  baseUnset(array, index);
                }
              }
            }
            return array;
          }
          function baseRandom(lower, upper) {
            return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
          }
          function baseRange(start2, end, step, fromRight) {
            var index = -1, length = nativeMax(nativeCeil((end - start2) / (step || 1)), 0), result2 = Array2(length);
            while (length--) {
              result2[fromRight ? length : ++index] = start2;
              start2 += step;
            }
            return result2;
          }
          function baseRepeat(string, n) {
            var result2 = "";
            if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
              return result2;
            }
            do {
              if (n % 2) {
                result2 += string;
              }
              n = nativeFloor(n / 2);
              if (n) {
                string += string;
              }
            } while (n);
            return result2;
          }
          function baseRest(func, start2) {
            return setToString(overRest(func, start2, identity), func + "");
          }
          function baseSample(collection) {
            return arraySample(values(collection));
          }
          function baseSampleSize(collection, n) {
            var array = values(collection);
            return shuffleSelf(array, baseClamp(n, 0, array.length));
          }
          function baseSet(object, path, value, customizer) {
            if (!isObject(object)) {
              return object;
            }
            path = castPath(path, object);
            var index = -1, length = path.length, lastIndex = length - 1, nested = object;
            while (nested != null && ++index < length) {
              var key = toKey(path[index]), newValue = value;
              if (key === "__proto__" || key === "constructor" || key === "prototype") {
                return object;
              }
              if (index != lastIndex) {
                var objValue = nested[key];
                newValue = customizer ? customizer(objValue, key, nested) : undefined2;
                if (newValue === undefined2) {
                  newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
                }
              }
              assignValue(nested, key, newValue);
              nested = nested[key];
            }
            return object;
          }
          var baseSetData = !metaMap ? identity : function(func, data) {
            metaMap.set(func, data);
            return func;
          };
          var baseSetToString = !defineProperty ? identity : function(func, string) {
            return defineProperty(func, "toString", {
              "configurable": true,
              "enumerable": false,
              "value": constant(string),
              "writable": true
            });
          };
          function baseShuffle(collection) {
            return shuffleSelf(values(collection));
          }
          function baseSlice(array, start2, end) {
            var index = -1, length = array.length;
            if (start2 < 0) {
              start2 = -start2 > length ? 0 : length + start2;
            }
            end = end > length ? length : end;
            if (end < 0) {
              end += length;
            }
            length = start2 > end ? 0 : end - start2 >>> 0;
            start2 >>>= 0;
            var result2 = Array2(length);
            while (++index < length) {
              result2[index] = array[index + start2];
            }
            return result2;
          }
          function baseSome(collection, predicate) {
            var result2;
            baseEach(collection, function(value, index, collection2) {
              result2 = predicate(value, index, collection2);
              return !result2;
            });
            return !!result2;
          }
          function baseSortedIndex(array, value, retHighest) {
            var low = 0, high = array == null ? low : array.length;
            if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
              while (low < high) {
                var mid = low + high >>> 1, computed = array[mid];
                if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) {
                  low = mid + 1;
                } else {
                  high = mid;
                }
              }
              return high;
            }
            return baseSortedIndexBy(array, value, identity, retHighest);
          }
          function baseSortedIndexBy(array, value, iteratee2, retHighest) {
            var low = 0, high = array == null ? 0 : array.length;
            if (high === 0) {
              return 0;
            }
            value = iteratee2(value);
            var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined2;
            while (low < high) {
              var mid = nativeFloor((low + high) / 2), computed = iteratee2(array[mid]), othIsDefined = computed !== undefined2, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
              if (valIsNaN) {
                var setLow = retHighest || othIsReflexive;
              } else if (valIsUndefined) {
                setLow = othIsReflexive && (retHighest || othIsDefined);
              } else if (valIsNull) {
                setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
              } else if (valIsSymbol) {
                setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
              } else if (othIsNull || othIsSymbol) {
                setLow = false;
              } else {
                setLow = retHighest ? computed <= value : computed < value;
              }
              if (setLow) {
                low = mid + 1;
              } else {
                high = mid;
              }
            }
            return nativeMin(high, MAX_ARRAY_INDEX);
          }
          function baseSortedUniq(array, iteratee2) {
            var index = -1, length = array.length, resIndex = 0, result2 = [];
            while (++index < length) {
              var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
              if (!index || !eq(computed, seen)) {
                var seen = computed;
                result2[resIndex++] = value === 0 ? 0 : value;
              }
            }
            return result2;
          }
          function baseToNumber(value) {
            if (typeof value == "number") {
              return value;
            }
            if (isSymbol(value)) {
              return NAN;
            }
            return +value;
          }
          function baseToString(value) {
            if (typeof value == "string") {
              return value;
            }
            if (isArray(value)) {
              return arrayMap(value, baseToString) + "";
            }
            if (isSymbol(value)) {
              return symbolToString ? symbolToString.call(value) : "";
            }
            var result2 = value + "";
            return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
          }
          function baseUniq(array, iteratee2, comparator) {
            var index = -1, includes2 = arrayIncludes, length = array.length, isCommon = true, result2 = [], seen = result2;
            if (comparator) {
              isCommon = false;
              includes2 = arrayIncludesWith;
            } else if (length >= LARGE_ARRAY_SIZE) {
              var set2 = iteratee2 ? null : createSet(array);
              if (set2) {
                return setToArray(set2);
              }
              isCommon = false;
              includes2 = cacheHas;
              seen = new SetCache();
            } else {
              seen = iteratee2 ? [] : result2;
            }
            outer:
              while (++index < length) {
                var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
                value = comparator || value !== 0 ? value : 0;
                if (isCommon && computed === computed) {
                  var seenIndex = seen.length;
                  while (seenIndex--) {
                    if (seen[seenIndex] === computed) {
                      continue outer;
                    }
                  }
                  if (iteratee2) {
                    seen.push(computed);
                  }
                  result2.push(value);
                } else if (!includes2(seen, computed, comparator)) {
                  if (seen !== result2) {
                    seen.push(computed);
                  }
                  result2.push(value);
                }
              }
            return result2;
          }
          function baseUnset(object, path) {
            path = castPath(path, object);
            object = parent(object, path);
            return object == null || delete object[toKey(last(path))];
          }
          function baseUpdate(object, path, updater, customizer) {
            return baseSet(object, path, updater(baseGet(object, path)), customizer);
          }
          function baseWhile(array, predicate, isDrop, fromRight) {
            var length = array.length, index = fromRight ? length : -1;
            while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {
            }
            return isDrop ? baseSlice(array, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array, fromRight ? index + 1 : 0, fromRight ? length : index);
          }
          function baseWrapperValue(value, actions) {
            var result2 = value;
            if (result2 instanceof LazyWrapper) {
              result2 = result2.value();
            }
            return arrayReduce(actions, function(result3, action) {
              return action.func.apply(action.thisArg, arrayPush([result3], action.args));
            }, result2);
          }
          function baseXor(arrays, iteratee2, comparator) {
            var length = arrays.length;
            if (length < 2) {
              return length ? baseUniq(arrays[0]) : [];
            }
            var index = -1, result2 = Array2(length);
            while (++index < length) {
              var array = arrays[index], othIndex = -1;
              while (++othIndex < length) {
                if (othIndex != index) {
                  result2[index] = baseDifference(result2[index] || array, arrays[othIndex], iteratee2, comparator);
                }
              }
            }
            return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
          }
          function baseZipObject(props, values2, assignFunc) {
            var index = -1, length = props.length, valsLength = values2.length, result2 = {};
            while (++index < length) {
              var value = index < valsLength ? values2[index] : undefined2;
              assignFunc(result2, props[index], value);
            }
            return result2;
          }
          function castArrayLikeObject(value) {
            return isArrayLikeObject(value) ? value : [];
          }
          function castFunction(value) {
            return typeof value == "function" ? value : identity;
          }
          function castPath(value, object) {
            if (isArray(value)) {
              return value;
            }
            return isKey(value, object) ? [value] : stringToPath(toString(value));
          }
          var castRest = baseRest;
          function castSlice(array, start2, end) {
            var length = array.length;
            end = end === undefined2 ? length : end;
            return !start2 && end >= length ? array : baseSlice(array, start2, end);
          }
          var clearTimeout2 = ctxClearTimeout || function(id) {
            return root.clearTimeout(id);
          };
          function cloneBuffer(buffer, isDeep) {
            if (isDeep) {
              return buffer.slice();
            }
            var length = buffer.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
            buffer.copy(result2);
            return result2;
          }
          function cloneArrayBuffer(arrayBuffer) {
            var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
            new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
            return result2;
          }
          function cloneDataView(dataView, isDeep) {
            var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
            return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
          }
          function cloneRegExp(regexp) {
            var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
            result2.lastIndex = regexp.lastIndex;
            return result2;
          }
          function cloneSymbol(symbol) {
            return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
          }
          function cloneTypedArray(typedArray, isDeep) {
            var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
            return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
          }
          function compareAscending(value, other) {
            if (value !== other) {
              var valIsDefined = value !== undefined2, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
              var othIsDefined = other !== undefined2, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
              if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
                return 1;
              }
              if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
                return -1;
              }
            }
            return 0;
          }
          function compareMultiple(object, other, orders) {
            var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
            while (++index < length) {
              var result2 = compareAscending(objCriteria[index], othCriteria[index]);
              if (result2) {
                if (index >= ordersLength) {
                  return result2;
                }
                var order = orders[index];
                return result2 * (order == "desc" ? -1 : 1);
              }
            }
            return object.index - other.index;
          }
          function composeArgs(args, partials, holders, isCurried) {
            var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
            while (++leftIndex < leftLength) {
              result2[leftIndex] = partials[leftIndex];
            }
            while (++argsIndex < holdersLength) {
              if (isUncurried || argsIndex < argsLength) {
                result2[holders[argsIndex]] = args[argsIndex];
              }
            }
            while (rangeLength--) {
              result2[leftIndex++] = args[argsIndex++];
            }
            return result2;
          }
          function composeArgsRight(args, partials, holders, isCurried) {
            var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
            while (++argsIndex < rangeLength) {
              result2[argsIndex] = args[argsIndex];
            }
            var offset = argsIndex;
            while (++rightIndex < rightLength) {
              result2[offset + rightIndex] = partials[rightIndex];
            }
            while (++holdersIndex < holdersLength) {
              if (isUncurried || argsIndex < argsLength) {
                result2[offset + holders[holdersIndex]] = args[argsIndex++];
              }
            }
            return result2;
          }
          function copyArray2(source, array) {
            var index = -1, length = source.length;
            array || (array = Array2(length));
            while (++index < length) {
              array[index] = source[index];
            }
            return array;
          }
          function copyObject(source, props, object, customizer) {
            var isNew = !object;
            object || (object = {});
            var index = -1, length = props.length;
            while (++index < length) {
              var key = props[index];
              var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined2;
              if (newValue === undefined2) {
                newValue = source[key];
              }
              if (isNew) {
                baseAssignValue(object, key, newValue);
              } else {
                assignValue(object, key, newValue);
              }
            }
            return object;
          }
          function copySymbols(source, object) {
            return copyObject(source, getSymbols(source), object);
          }
          function copySymbolsIn(source, object) {
            return copyObject(source, getSymbolsIn(source), object);
          }
          function createAggregator(setter, initializer) {
            return function(collection, iteratee2) {
              var func = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
              return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
            };
          }
          function createAssigner(assigner) {
            return baseRest(function(object, sources) {
              var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined2, guard = length > 2 ? sources[2] : undefined2;
              customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined2;
              if (guard && isIterateeCall(sources[0], sources[1], guard)) {
                customizer = length < 3 ? undefined2 : customizer;
                length = 1;
              }
              object = Object2(object);
              while (++index < length) {
                var source = sources[index];
                if (source) {
                  assigner(object, source, index, customizer);
                }
              }
              return object;
            });
          }
          function createBaseEach(eachFunc, fromRight) {
            return function(collection, iteratee2) {
              if (collection == null) {
                return collection;
              }
              if (!isArrayLike(collection)) {
                return eachFunc(collection, iteratee2);
              }
              var length = collection.length, index = fromRight ? length : -1, iterable = Object2(collection);
              while (fromRight ? index-- : ++index < length) {
                if (iteratee2(iterable[index], index, iterable) === false) {
                  break;
                }
              }
              return collection;
            };
          }
          function createBaseFor(fromRight) {
            return function(object, iteratee2, keysFunc) {
              var index = -1, iterable = Object2(object), props = keysFunc(object), length = props.length;
              while (length--) {
                var key = props[fromRight ? length : ++index];
                if (iteratee2(iterable[key], key, iterable) === false) {
                  break;
                }
              }
              return object;
            };
          }
          function createBind(func, bitmask, thisArg) {
            var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
            function wrapper() {
              var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
              return fn.apply(isBind ? thisArg : this, arguments);
            }
            return wrapper;
          }
          function createCaseFirst(methodName) {
            return function(string) {
              string = toString(string);
              var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined2;
              var chr = strSymbols ? strSymbols[0] : string.charAt(0);
              var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
              return chr[methodName]() + trailing;
            };
          }
          function createCompounder(callback) {
            return function(string) {
              return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
            };
          }
          function createCtor(Ctor) {
            return function() {
              var args = arguments;
              switch (args.length) {
                case 0:
                  return new Ctor();
                case 1:
                  return new Ctor(args[0]);
                case 2:
                  return new Ctor(args[0], args[1]);
                case 3:
                  return new Ctor(args[0], args[1], args[2]);
                case 4:
                  return new Ctor(args[0], args[1], args[2], args[3]);
                case 5:
                  return new Ctor(args[0], args[1], args[2], args[3], args[4]);
                case 6:
                  return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
                case 7:
                  return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
              }
              var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
              return isObject(result2) ? result2 : thisBinding;
            };
          }
          function createCurry(func, bitmask, arity) {
            var Ctor = createCtor(func);
            function wrapper() {
              var length = arguments.length, args = Array2(length), index = length, placeholder = getHolder(wrapper);
              while (index--) {
                args[index] = arguments[index];
              }
              var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
              length -= holders.length;
              if (length < arity) {
                return createRecurry(
                  func,
                  bitmask,
                  createHybrid,
                  wrapper.placeholder,
                  undefined2,
                  args,
                  holders,
                  undefined2,
                  undefined2,
                  arity - length
                );
              }
              var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
              return apply(fn, this, args);
            }
            return wrapper;
          }
          function createFind(findIndexFunc) {
            return function(collection, predicate, fromIndex) {
              var iterable = Object2(collection);
              if (!isArrayLike(collection)) {
                var iteratee2 = getIteratee(predicate, 3);
                collection = keys(collection);
                predicate = function(key) {
                  return iteratee2(iterable[key], key, iterable);
                };
              }
              var index = findIndexFunc(collection, predicate, fromIndex);
              return index > -1 ? iterable[iteratee2 ? collection[index] : index] : undefined2;
            };
          }
          function createFlow(fromRight) {
            return flatRest(function(funcs) {
              var length = funcs.length, index = length, prereq = LodashWrapper.prototype.thru;
              if (fromRight) {
                funcs.reverse();
              }
              while (index--) {
                var func = funcs[index];
                if (typeof func != "function") {
                  throw new TypeError2(FUNC_ERROR_TEXT);
                }
                if (prereq && !wrapper && getFuncName(func) == "wrapper") {
                  var wrapper = new LodashWrapper([], true);
                }
              }
              index = wrapper ? index : length;
              while (++index < length) {
                func = funcs[index];
                var funcName = getFuncName(func), data = funcName == "wrapper" ? getData(func) : undefined2;
                if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
                  wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
                } else {
                  wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
                }
              }
              return function() {
                var args = arguments, value = args[0];
                if (wrapper && args.length == 1 && isArray(value)) {
                  return wrapper.plant(value).value();
                }
                var index2 = 0, result2 = length ? funcs[index2].apply(this, args) : value;
                while (++index2 < length) {
                  result2 = funcs[index2].call(this, result2);
                }
                return result2;
              };
            });
          }
          function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
            var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined2 : createCtor(func);
            function wrapper() {
              var length = arguments.length, args = Array2(length), index = length;
              while (index--) {
                args[index] = arguments[index];
              }
              if (isCurried) {
                var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
              }
              if (partials) {
                args = composeArgs(args, partials, holders, isCurried);
              }
              if (partialsRight) {
                args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
              }
              length -= holdersCount;
              if (isCurried && length < arity) {
                var newHolders = replaceHolders(args, placeholder);
                return createRecurry(
                  func,
                  bitmask,
                  createHybrid,
                  wrapper.placeholder,
                  thisArg,
                  args,
                  newHolders,
                  argPos,
                  ary2,
                  arity - length
                );
              }
              var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
              length = args.length;
              if (argPos) {
                args = reorder(args, argPos);
              } else if (isFlip && length > 1) {
                args.reverse();
              }
              if (isAry && ary2 < length) {
                args.length = ary2;
              }
              if (this && this !== root && this instanceof wrapper) {
                fn = Ctor || createCtor(fn);
              }
              return fn.apply(thisBinding, args);
            }
            return wrapper;
          }
          function createInverter(setter, toIteratee) {
            return function(object, iteratee2) {
              return baseInverter(object, setter, toIteratee(iteratee2), {});
            };
          }
          function createMathOperation(operator, defaultValue) {
            return function(value, other) {
              var result2;
              if (value === undefined2 && other === undefined2) {
                return defaultValue;
              }
              if (value !== undefined2) {
                result2 = value;
              }
              if (other !== undefined2) {
                if (result2 === undefined2) {
                  return other;
                }
                if (typeof value == "string" || typeof other == "string") {
                  value = baseToString(value);
                  other = baseToString(other);
                } else {
                  value = baseToNumber(value);
                  other = baseToNumber(other);
                }
                result2 = operator(value, other);
              }
              return result2;
            };
          }
          function createOver(arrayFunc) {
            return flatRest(function(iteratees) {
              iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
              return baseRest(function(args) {
                var thisArg = this;
                return arrayFunc(iteratees, function(iteratee2) {
                  return apply(iteratee2, thisArg, args);
                });
              });
            });
          }
          function createPadding(length, chars) {
            chars = chars === undefined2 ? " " : baseToString(chars);
            var charsLength = chars.length;
            if (charsLength < 2) {
              return charsLength ? baseRepeat(chars, length) : chars;
            }
            var result2 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
            return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length).join("") : result2.slice(0, length);
          }
          function createPartial(func, bitmask, thisArg, partials) {
            var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
            function wrapper() {
              var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root && this instanceof wrapper ? Ctor : func;
              while (++leftIndex < leftLength) {
                args[leftIndex] = partials[leftIndex];
              }
              while (argsLength--) {
                args[leftIndex++] = arguments[++argsIndex];
              }
              return apply(fn, isBind ? thisArg : this, args);
            }
            return wrapper;
          }
          function createRange(fromRight) {
            return function(start2, end, step) {
              if (step && typeof step != "number" && isIterateeCall(start2, end, step)) {
                end = step = undefined2;
              }
              start2 = toFinite(start2);
              if (end === undefined2) {
                end = start2;
                start2 = 0;
              } else {
                end = toFinite(end);
              }
              step = step === undefined2 ? start2 < end ? 1 : -1 : toFinite(step);
              return baseRange(start2, end, step, fromRight);
            };
          }
          function createRelationalOperation(operator) {
            return function(value, other) {
              if (!(typeof value == "string" && typeof other == "string")) {
                value = toNumber(value);
                other = toNumber(other);
              }
              return operator(value, other);
            };
          }
          function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
            var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined2, newHoldersRight = isCurry ? undefined2 : holders, newPartials = isCurry ? partials : undefined2, newPartialsRight = isCurry ? undefined2 : partials;
            bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
            bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
            if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
              bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
            }
            var newData = [
              func,
              bitmask,
              thisArg,
              newPartials,
              newHolders,
              newPartialsRight,
              newHoldersRight,
              argPos,
              ary2,
              arity
            ];
            var result2 = wrapFunc.apply(undefined2, newData);
            if (isLaziable(func)) {
              setData(result2, newData);
            }
            result2.placeholder = placeholder;
            return setWrapToString(result2, func, bitmask);
          }
          function createRound(methodName) {
            var func = Math2[methodName];
            return function(number, precision) {
              number = toNumber(number);
              precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
              if (precision && nativeIsFinite(number)) {
                var pair = (toString(number) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
                pair = (toString(value) + "e").split("e");
                return +(pair[0] + "e" + (+pair[1] - precision));
              }
              return func(number);
            };
          }
          var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop : function(values2) {
            return new Set2(values2);
          };
          function createToPairs(keysFunc) {
            return function(object) {
              var tag = getTag(object);
              if (tag == mapTag) {
                return mapToArray(object);
              }
              if (tag == setTag) {
                return setToPairs(object);
              }
              return baseToPairs(object, keysFunc(object));
            };
          }
          function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
            var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
            if (!isBindKey && typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            var length = partials ? partials.length : 0;
            if (!length) {
              bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
              partials = holders = undefined2;
            }
            ary2 = ary2 === undefined2 ? ary2 : nativeMax(toInteger(ary2), 0);
            arity = arity === undefined2 ? arity : toInteger(arity);
            length -= holders ? holders.length : 0;
            if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
              var partialsRight = partials, holdersRight = holders;
              partials = holders = undefined2;
            }
            var data = isBindKey ? undefined2 : getData(func);
            var newData = [
              func,
              bitmask,
              thisArg,
              partials,
              holders,
              partialsRight,
              holdersRight,
              argPos,
              ary2,
              arity
            ];
            if (data) {
              mergeData(newData, data);
            }
            func = newData[0];
            bitmask = newData[1];
            thisArg = newData[2];
            partials = newData[3];
            holders = newData[4];
            arity = newData[9] = newData[9] === undefined2 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
            if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
              bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
            }
            if (!bitmask || bitmask == WRAP_BIND_FLAG) {
              var result2 = createBind(func, bitmask, thisArg);
            } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
              result2 = createCurry(func, bitmask, arity);
            } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
              result2 = createPartial(func, bitmask, thisArg, partials);
            } else {
              result2 = createHybrid.apply(undefined2, newData);
            }
            var setter = data ? baseSetData : setData;
            return setWrapToString(setter(result2, newData), func, bitmask);
          }
          function customDefaultsAssignIn(objValue, srcValue, key, object) {
            if (objValue === undefined2 || eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key)) {
              return srcValue;
            }
            return objValue;
          }
          function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
            if (isObject(objValue) && isObject(srcValue)) {
              stack.set(srcValue, objValue);
              baseMerge(objValue, srcValue, undefined2, customDefaultsMerge, stack);
              stack["delete"](srcValue);
            }
            return objValue;
          }
          function customOmitClone(value) {
            return isPlainObject(value) ? undefined2 : value;
          }
          function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
            if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
              return false;
            }
            var arrStacked = stack.get(array);
            var othStacked = stack.get(other);
            if (arrStacked && othStacked) {
              return arrStacked == other && othStacked == array;
            }
            var index = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined2;
            stack.set(array, other);
            stack.set(other, array);
            while (++index < arrLength) {
              var arrValue = array[index], othValue = other[index];
              if (customizer) {
                var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
              }
              if (compared !== undefined2) {
                if (compared) {
                  continue;
                }
                result2 = false;
                break;
              }
              if (seen) {
                if (!arraySome(other, function(othValue2, othIndex) {
                  if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                    return seen.push(othIndex);
                  }
                })) {
                  result2 = false;
                  break;
                }
              } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                result2 = false;
                break;
              }
            }
            stack["delete"](array);
            stack["delete"](other);
            return result2;
          }
          function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
            switch (tag) {
              case dataViewTag:
                if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
                  return false;
                }
                object = object.buffer;
                other = other.buffer;
              case arrayBufferTag:
                if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
                  return false;
                }
                return true;
              case boolTag:
              case dateTag:
              case numberTag:
                return eq(+object, +other);
              case errorTag:
                return object.name == other.name && object.message == other.message;
              case regexpTag:
              case stringTag:
                return object == other + "";
              case mapTag:
                var convert = mapToArray;
              case setTag:
                var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
                convert || (convert = setToArray);
                if (object.size != other.size && !isPartial) {
                  return false;
                }
                var stacked = stack.get(object);
                if (stacked) {
                  return stacked == other;
                }
                bitmask |= COMPARE_UNORDERED_FLAG;
                stack.set(object, other);
                var result2 = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
                stack["delete"](object);
                return result2;
              case symbolTag:
                if (symbolValueOf) {
                  return symbolValueOf.call(object) == symbolValueOf.call(other);
                }
            }
            return false;
          }
          function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
            if (objLength != othLength && !isPartial) {
              return false;
            }
            var index = objLength;
            while (index--) {
              var key = objProps[index];
              if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
                return false;
              }
            }
            var objStacked = stack.get(object);
            var othStacked = stack.get(other);
            if (objStacked && othStacked) {
              return objStacked == other && othStacked == object;
            }
            var result2 = true;
            stack.set(object, other);
            stack.set(other, object);
            var skipCtor = isPartial;
            while (++index < objLength) {
              key = objProps[index];
              var objValue = object[key], othValue = other[key];
              if (customizer) {
                var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
              }
              if (!(compared === undefined2 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
                result2 = false;
                break;
              }
              skipCtor || (skipCtor = key == "constructor");
            }
            if (result2 && !skipCtor) {
              var objCtor = object.constructor, othCtor = other.constructor;
              if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
                result2 = false;
              }
            }
            stack["delete"](object);
            stack["delete"](other);
            return result2;
          }
          function flatRest(func) {
            return setToString(overRest(func, undefined2, flatten2), func + "");
          }
          function getAllKeys(object) {
            return baseGetAllKeys(object, keys, getSymbols);
          }
          function getAllKeysIn(object) {
            return baseGetAllKeys(object, keysIn, getSymbolsIn);
          }
          var getData = !metaMap ? noop : function(func) {
            return metaMap.get(func);
          };
          function getFuncName(func) {
            var result2 = func.name + "", array = realNames[result2], length = hasOwnProperty.call(realNames, result2) ? array.length : 0;
            while (length--) {
              var data = array[length], otherFunc = data.func;
              if (otherFunc == null || otherFunc == func) {
                return data.name;
              }
            }
            return result2;
          }
          function getHolder(func) {
            var object = hasOwnProperty.call(lodash, "placeholder") ? lodash : func;
            return object.placeholder;
          }
          function getIteratee() {
            var result2 = lodash.iteratee || iteratee;
            result2 = result2 === iteratee ? baseIteratee : result2;
            return arguments.length ? result2(arguments[0], arguments[1]) : result2;
          }
          function getMapData(map2, key) {
            var data = map2.__data__;
            return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
          }
          function getMatchData(object) {
            var result2 = keys(object), length = result2.length;
            while (length--) {
              var key = result2[length], value = object[key];
              result2[length] = [key, value, isStrictComparable(value)];
            }
            return result2;
          }
          function getNative(object, key) {
            var value = getValue(object, key);
            return baseIsNative(value) ? value : undefined2;
          }
          function getRawTag(value) {
            var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
            try {
              value[symToStringTag] = undefined2;
              var unmasked = true;
            } catch (e) {
            }
            var result2 = nativeObjectToString.call(value);
            if (unmasked) {
              if (isOwn) {
                value[symToStringTag] = tag;
              } else {
                delete value[symToStringTag];
              }
            }
            return result2;
          }
          var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
            if (object == null) {
              return [];
            }
            object = Object2(object);
            return arrayFilter(nativeGetSymbols(object), function(symbol) {
              return propertyIsEnumerable.call(object, symbol);
            });
          };
          var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
            var result2 = [];
            while (object) {
              arrayPush(result2, getSymbols(object));
              object = getPrototype(object);
            }
            return result2;
          };
          var getTag = baseGetTag;
          if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
            getTag = function(value) {
              var result2 = baseGetTag(value), Ctor = result2 == objectTag ? value.constructor : undefined2, ctorString = Ctor ? toSource(Ctor) : "";
              if (ctorString) {
                switch (ctorString) {
                  case dataViewCtorString:
                    return dataViewTag;
                  case mapCtorString:
                    return mapTag;
                  case promiseCtorString:
                    return promiseTag;
                  case setCtorString:
                    return setTag;
                  case weakMapCtorString:
                    return weakMapTag;
                }
              }
              return result2;
            };
          }
          function getView(start2, end, transforms) {
            var index = -1, length = transforms.length;
            while (++index < length) {
              var data = transforms[index], size2 = data.size;
              switch (data.type) {
                case "drop":
                  start2 += size2;
                  break;
                case "dropRight":
                  end -= size2;
                  break;
                case "take":
                  end = nativeMin(end, start2 + size2);
                  break;
                case "takeRight":
                  start2 = nativeMax(start2, end - size2);
                  break;
              }
            }
            return { "start": start2, "end": end };
          }
          function getWrapDetails(source) {
            var match = source.match(reWrapDetails);
            return match ? match[1].split(reSplitDetails) : [];
          }
          function hasPath(object, path, hasFunc) {
            path = castPath(path, object);
            var index = -1, length = path.length, result2 = false;
            while (++index < length) {
              var key = toKey(path[index]);
              if (!(result2 = object != null && hasFunc(object, key))) {
                break;
              }
              object = object[key];
            }
            if (result2 || ++index != length) {
              return result2;
            }
            length = object == null ? 0 : object.length;
            return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
          }
          function initCloneArray(array) {
            var length = array.length, result2 = new array.constructor(length);
            if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
              result2.index = array.index;
              result2.input = array.input;
            }
            return result2;
          }
          function initCloneObject(object) {
            return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
          }
          function initCloneByTag(object, tag, isDeep) {
            var Ctor = object.constructor;
            switch (tag) {
              case arrayBufferTag:
                return cloneArrayBuffer(object);
              case boolTag:
              case dateTag:
                return new Ctor(+object);
              case dataViewTag:
                return cloneDataView(object, isDeep);
              case float32Tag:
              case float64Tag:
              case int8Tag:
              case int16Tag:
              case int32Tag:
              case uint8Tag:
              case uint8ClampedTag:
              case uint16Tag:
              case uint32Tag:
                return cloneTypedArray(object, isDeep);
              case mapTag:
                return new Ctor();
              case numberTag:
              case stringTag:
                return new Ctor(object);
              case regexpTag:
                return cloneRegExp(object);
              case setTag:
                return new Ctor();
              case symbolTag:
                return cloneSymbol(object);
            }
          }
          function insertWrapDetails(source, details) {
            var length = details.length;
            if (!length) {
              return source;
            }
            var lastIndex = length - 1;
            details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
            details = details.join(length > 2 ? ", " : " ");
            return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
          }
          function isFlattenable(value) {
            return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
          }
          function isIndex(value, length) {
            var type = typeof value;
            length = length == null ? MAX_SAFE_INTEGER : length;
            return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
          }
          function isIterateeCall(value, index, object) {
            if (!isObject(object)) {
              return false;
            }
            var type = typeof index;
            if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
              return eq(object[index], value);
            }
            return false;
          }
          function isKey(value, object) {
            if (isArray(value)) {
              return false;
            }
            var type = typeof value;
            if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
              return true;
            }
            return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object2(object);
          }
          function isKeyable(value) {
            var type = typeof value;
            return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
          }
          function isLaziable(func) {
            var funcName = getFuncName(func), other = lodash[funcName];
            if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
              return false;
            }
            if (func === other) {
              return true;
            }
            var data = getData(other);
            return !!data && func === data[0];
          }
          function isMasked(func) {
            return !!maskSrcKey && maskSrcKey in func;
          }
          var isMaskable = coreJsData ? isFunction : stubFalse;
          function isPrototype(value) {
            var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
            return value === proto;
          }
          function isStrictComparable(value) {
            return value === value && !isObject(value);
          }
          function matchesStrictComparable(key, srcValue) {
            return function(object) {
              if (object == null) {
                return false;
              }
              return object[key] === srcValue && (srcValue !== undefined2 || key in Object2(object));
            };
          }
          function memoizeCapped(func) {
            var result2 = memoize(func, function(key) {
              if (cache.size === MAX_MEMOIZE_SIZE) {
                cache.clear();
              }
              return key;
            });
            var cache = result2.cache;
            return result2;
          }
          function mergeData(data, source) {
            var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
            var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
            if (!(isCommon || isCombo)) {
              return data;
            }
            if (srcBitmask & WRAP_BIND_FLAG) {
              data[2] = source[2];
              newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
            }
            var value = source[3];
            if (value) {
              var partials = data[3];
              data[3] = partials ? composeArgs(partials, value, source[4]) : value;
              data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
            }
            value = source[5];
            if (value) {
              partials = data[5];
              data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
              data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
            }
            value = source[7];
            if (value) {
              data[7] = value;
            }
            if (srcBitmask & WRAP_ARY_FLAG) {
              data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
            }
            if (data[9] == null) {
              data[9] = source[9];
            }
            data[0] = source[0];
            data[1] = newBitmask;
            return data;
          }
          function nativeKeysIn(object) {
            var result2 = [];
            if (object != null) {
              for (var key in Object2(object)) {
                result2.push(key);
              }
            }
            return result2;
          }
          function objectToString(value) {
            return nativeObjectToString.call(value);
          }
          function overRest(func, start2, transform2) {
            start2 = nativeMax(start2 === undefined2 ? func.length - 1 : start2, 0);
            return function() {
              var args = arguments, index = -1, length = nativeMax(args.length - start2, 0), array = Array2(length);
              while (++index < length) {
                array[index] = args[start2 + index];
              }
              index = -1;
              var otherArgs = Array2(start2 + 1);
              while (++index < start2) {
                otherArgs[index] = args[index];
              }
              otherArgs[start2] = transform2(array);
              return apply(func, this, otherArgs);
            };
          }
          function parent(object, path) {
            return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
          }
          function reorder(array, indexes) {
            var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray2(array);
            while (length--) {
              var index = indexes[length];
              array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined2;
            }
            return array;
          }
          function safeGet(object, key) {
            if (key === "constructor" && typeof object[key] === "function") {
              return;
            }
            if (key == "__proto__") {
              return;
            }
            return object[key];
          }
          var setData = shortOut(baseSetData);
          var setTimeout2 = ctxSetTimeout || function(func, wait) {
            return root.setTimeout(func, wait);
          };
          var setToString = shortOut(baseSetToString);
          function setWrapToString(wrapper, reference, bitmask) {
            var source = reference + "";
            return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
          }
          function shortOut(func) {
            var count = 0, lastCalled = 0;
            return function() {
              var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
              lastCalled = stamp;
              if (remaining > 0) {
                if (++count >= HOT_COUNT) {
                  return arguments[0];
                }
              } else {
                count = 0;
              }
              return func.apply(undefined2, arguments);
            };
          }
          function shuffleSelf(array, size2) {
            var index = -1, length = array.length, lastIndex = length - 1;
            size2 = size2 === undefined2 ? length : size2;
            while (++index < size2) {
              var rand = baseRandom(index, lastIndex), value = array[rand];
              array[rand] = array[index];
              array[index] = value;
            }
            array.length = size2;
            return array;
          }
          var stringToPath = memoizeCapped(function(string) {
            var result2 = [];
            if (string.charCodeAt(0) === 46) {
              result2.push("");
            }
            string.replace(rePropName, function(match, number, quote, subString) {
              result2.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
            });
            return result2;
          });
          function toKey(value) {
            if (typeof value == "string" || isSymbol(value)) {
              return value;
            }
            var result2 = value + "";
            return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
          }
          function toSource(func) {
            if (func != null) {
              try {
                return funcToString.call(func);
              } catch (e) {
              }
              try {
                return func + "";
              } catch (e) {
              }
            }
            return "";
          }
          function updateWrapDetails(details, bitmask) {
            arrayEach(wrapFlags, function(pair) {
              var value = "_." + pair[0];
              if (bitmask & pair[1] && !arrayIncludes(details, value)) {
                details.push(value);
              }
            });
            return details.sort();
          }
          function wrapperClone(wrapper) {
            if (wrapper instanceof LazyWrapper) {
              return wrapper.clone();
            }
            var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
            result2.__actions__ = copyArray2(wrapper.__actions__);
            result2.__index__ = wrapper.__index__;
            result2.__values__ = wrapper.__values__;
            return result2;
          }
          function chunk(array, size2, guard) {
            if (guard ? isIterateeCall(array, size2, guard) : size2 === undefined2) {
              size2 = 1;
            } else {
              size2 = nativeMax(toInteger(size2), 0);
            }
            var length = array == null ? 0 : array.length;
            if (!length || size2 < 1) {
              return [];
            }
            var index = 0, resIndex = 0, result2 = Array2(nativeCeil(length / size2));
            while (index < length) {
              result2[resIndex++] = baseSlice(array, index, index += size2);
            }
            return result2;
          }
          function compact(array) {
            var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result2 = [];
            while (++index < length) {
              var value = array[index];
              if (value) {
                result2[resIndex++] = value;
              }
            }
            return result2;
          }
          function concat() {
            var length = arguments.length;
            if (!length) {
              return [];
            }
            var args = Array2(length - 1), array = arguments[0], index = length;
            while (index--) {
              args[index - 1] = arguments[index];
            }
            return arrayPush(isArray(array) ? copyArray2(array) : [array], baseFlatten(args, 1));
          }
          var difference = baseRest(function(array, values2) {
            return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];
          });
          var differenceBy = baseRest(function(array, values2) {
            var iteratee2 = last(values2);
            if (isArrayLikeObject(iteratee2)) {
              iteratee2 = undefined2;
            }
            return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
          });
          var differenceWith = baseRest(function(array, values2) {
            var comparator = last(values2);
            if (isArrayLikeObject(comparator)) {
              comparator = undefined2;
            }
            return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), undefined2, comparator) : [];
          });
          function drop(array, n, guard) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return [];
            }
            n = guard || n === undefined2 ? 1 : toInteger(n);
            return baseSlice(array, n < 0 ? 0 : n, length);
          }
          function dropRight(array, n, guard) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return [];
            }
            n = guard || n === undefined2 ? 1 : toInteger(n);
            n = length - n;
            return baseSlice(array, 0, n < 0 ? 0 : n);
          }
          function dropRightWhile(array, predicate) {
            return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
          }
          function dropWhile(array, predicate) {
            return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
          }
          function fill(array, value, start2, end) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return [];
            }
            if (start2 && typeof start2 != "number" && isIterateeCall(array, value, start2)) {
              start2 = 0;
              end = length;
            }
            return baseFill(array, value, start2, end);
          }
          function findIndex(array, predicate, fromIndex) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return -1;
            }
            var index = fromIndex == null ? 0 : toInteger(fromIndex);
            if (index < 0) {
              index = nativeMax(length + index, 0);
            }
            return baseFindIndex(array, getIteratee(predicate, 3), index);
          }
          function findLastIndex(array, predicate, fromIndex) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return -1;
            }
            var index = length - 1;
            if (fromIndex !== undefined2) {
              index = toInteger(fromIndex);
              index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
            }
            return baseFindIndex(array, getIteratee(predicate, 3), index, true);
          }
          function flatten2(array) {
            var length = array == null ? 0 : array.length;
            return length ? baseFlatten(array, 1) : [];
          }
          function flattenDeep(array) {
            var length = array == null ? 0 : array.length;
            return length ? baseFlatten(array, INFINITY) : [];
          }
          function flattenDepth(array, depth) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return [];
            }
            depth = depth === undefined2 ? 1 : toInteger(depth);
            return baseFlatten(array, depth);
          }
          function fromPairs(pairs) {
            var index = -1, length = pairs == null ? 0 : pairs.length, result2 = {};
            while (++index < length) {
              var pair = pairs[index];
              result2[pair[0]] = pair[1];
            }
            return result2;
          }
          function head(array) {
            return array && array.length ? array[0] : undefined2;
          }
          function indexOf3(array, value, fromIndex) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return -1;
            }
            var index = fromIndex == null ? 0 : toInteger(fromIndex);
            if (index < 0) {
              index = nativeMax(length + index, 0);
            }
            return baseIndexOf(array, value, index);
          }
          function initial(array) {
            var length = array == null ? 0 : array.length;
            return length ? baseSlice(array, 0, -1) : [];
          }
          var intersection = baseRest(function(arrays) {
            var mapped = arrayMap(arrays, castArrayLikeObject);
            return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
          });
          var intersectionBy = baseRest(function(arrays) {
            var iteratee2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
            if (iteratee2 === last(mapped)) {
              iteratee2 = undefined2;
            } else {
              mapped.pop();
            }
            return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
          });
          var intersectionWith = baseRest(function(arrays) {
            var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
            comparator = typeof comparator == "function" ? comparator : undefined2;
            if (comparator) {
              mapped.pop();
            }
            return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined2, comparator) : [];
          });
          function join(array, separator) {
            return array == null ? "" : nativeJoin.call(array, separator);
          }
          function last(array) {
            var length = array == null ? 0 : array.length;
            return length ? array[length - 1] : undefined2;
          }
          function lastIndexOf(array, value, fromIndex) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return -1;
            }
            var index = length;
            if (fromIndex !== undefined2) {
              index = toInteger(fromIndex);
              index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
            }
            return value === value ? strictLastIndexOf(array, value, index) : baseFindIndex(array, baseIsNaN, index, true);
          }
          function nth(array, n) {
            return array && array.length ? baseNth(array, toInteger(n)) : undefined2;
          }
          var pull = baseRest(pullAll);
          function pullAll(array, values2) {
            return array && array.length && values2 && values2.length ? basePullAll(array, values2) : array;
          }
          function pullAllBy(array, values2, iteratee2) {
            return array && array.length && values2 && values2.length ? basePullAll(array, values2, getIteratee(iteratee2, 2)) : array;
          }
          function pullAllWith(array, values2, comparator) {
            return array && array.length && values2 && values2.length ? basePullAll(array, values2, undefined2, comparator) : array;
          }
          var pullAt = flatRest(function(array, indexes) {
            var length = array == null ? 0 : array.length, result2 = baseAt(array, indexes);
            basePullAt(array, arrayMap(indexes, function(index) {
              return isIndex(index, length) ? +index : index;
            }).sort(compareAscending));
            return result2;
          });
          function remove(array, predicate) {
            var result2 = [];
            if (!(array && array.length)) {
              return result2;
            }
            var index = -1, indexes = [], length = array.length;
            predicate = getIteratee(predicate, 3);
            while (++index < length) {
              var value = array[index];
              if (predicate(value, index, array)) {
                result2.push(value);
                indexes.push(index);
              }
            }
            basePullAt(array, indexes);
            return result2;
          }
          function reverse(array) {
            return array == null ? array : nativeReverse.call(array);
          }
          function slice(array, start2, end) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return [];
            }
            if (end && typeof end != "number" && isIterateeCall(array, start2, end)) {
              start2 = 0;
              end = length;
            } else {
              start2 = start2 == null ? 0 : toInteger(start2);
              end = end === undefined2 ? length : toInteger(end);
            }
            return baseSlice(array, start2, end);
          }
          function sortedIndex(array, value) {
            return baseSortedIndex(array, value);
          }
          function sortedIndexBy(array, value, iteratee2) {
            return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2));
          }
          function sortedIndexOf(array, value) {
            var length = array == null ? 0 : array.length;
            if (length) {
              var index = baseSortedIndex(array, value);
              if (index < length && eq(array[index], value)) {
                return index;
              }
            }
            return -1;
          }
          function sortedLastIndex(array, value) {
            return baseSortedIndex(array, value, true);
          }
          function sortedLastIndexBy(array, value, iteratee2) {
            return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2), true);
          }
          function sortedLastIndexOf(array, value) {
            var length = array == null ? 0 : array.length;
            if (length) {
              var index = baseSortedIndex(array, value, true) - 1;
              if (eq(array[index], value)) {
                return index;
              }
            }
            return -1;
          }
          function sortedUniq(array) {
            return array && array.length ? baseSortedUniq(array) : [];
          }
          function sortedUniqBy(array, iteratee2) {
            return array && array.length ? baseSortedUniq(array, getIteratee(iteratee2, 2)) : [];
          }
          function tail(array) {
            var length = array == null ? 0 : array.length;
            return length ? baseSlice(array, 1, length) : [];
          }
          function take(array, n, guard) {
            if (!(array && array.length)) {
              return [];
            }
            n = guard || n === undefined2 ? 1 : toInteger(n);
            return baseSlice(array, 0, n < 0 ? 0 : n);
          }
          function takeRight(array, n, guard) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return [];
            }
            n = guard || n === undefined2 ? 1 : toInteger(n);
            n = length - n;
            return baseSlice(array, n < 0 ? 0 : n, length);
          }
          function takeRightWhile(array, predicate) {
            return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
          }
          function takeWhile(array, predicate) {
            return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
          }
          var union = baseRest(function(arrays) {
            return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
          });
          var unionBy = baseRest(function(arrays) {
            var iteratee2 = last(arrays);
            if (isArrayLikeObject(iteratee2)) {
              iteratee2 = undefined2;
            }
            return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
          });
          var unionWith = baseRest(function(arrays) {
            var comparator = last(arrays);
            comparator = typeof comparator == "function" ? comparator : undefined2;
            return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined2, comparator);
          });
          function uniq(array) {
            return array && array.length ? baseUniq(array) : [];
          }
          function uniqBy(array, iteratee2) {
            return array && array.length ? baseUniq(array, getIteratee(iteratee2, 2)) : [];
          }
          function uniqWith(array, comparator) {
            comparator = typeof comparator == "function" ? comparator : undefined2;
            return array && array.length ? baseUniq(array, undefined2, comparator) : [];
          }
          function unzip(array) {
            if (!(array && array.length)) {
              return [];
            }
            var length = 0;
            array = arrayFilter(array, function(group) {
              if (isArrayLikeObject(group)) {
                length = nativeMax(group.length, length);
                return true;
              }
            });
            return baseTimes(length, function(index) {
              return arrayMap(array, baseProperty(index));
            });
          }
          function unzipWith(array, iteratee2) {
            if (!(array && array.length)) {
              return [];
            }
            var result2 = unzip(array);
            if (iteratee2 == null) {
              return result2;
            }
            return arrayMap(result2, function(group) {
              return apply(iteratee2, undefined2, group);
            });
          }
          var without = baseRest(function(array, values2) {
            return isArrayLikeObject(array) ? baseDifference(array, values2) : [];
          });
          var xor = baseRest(function(arrays) {
            return baseXor(arrayFilter(arrays, isArrayLikeObject));
          });
          var xorBy = baseRest(function(arrays) {
            var iteratee2 = last(arrays);
            if (isArrayLikeObject(iteratee2)) {
              iteratee2 = undefined2;
            }
            return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
          });
          var xorWith = baseRest(function(arrays) {
            var comparator = last(arrays);
            comparator = typeof comparator == "function" ? comparator : undefined2;
            return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined2, comparator);
          });
          var zip2 = baseRest(unzip);
          function zipObject(props, values2) {
            return baseZipObject(props || [], values2 || [], assignValue);
          }
          function zipObjectDeep(props, values2) {
            return baseZipObject(props || [], values2 || [], baseSet);
          }
          var zipWith = baseRest(function(arrays) {
            var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined2;
            iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined2;
            return unzipWith(arrays, iteratee2);
          });
          function chain(value) {
            var result2 = lodash(value);
            result2.__chain__ = true;
            return result2;
          }
          function tap(value, interceptor) {
            interceptor(value);
            return value;
          }
          function thru(value, interceptor) {
            return interceptor(value);
          }
          var wrapperAt = flatRest(function(paths) {
            var length = paths.length, start2 = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
              return baseAt(object, paths);
            };
            if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start2)) {
              return this.thru(interceptor);
            }
            value = value.slice(start2, +start2 + (length ? 1 : 0));
            value.__actions__.push({
              "func": thru,
              "args": [interceptor],
              "thisArg": undefined2
            });
            return new LodashWrapper(value, this.__chain__).thru(function(array) {
              if (length && !array.length) {
                array.push(undefined2);
              }
              return array;
            });
          });
          function wrapperChain() {
            return chain(this);
          }
          function wrapperCommit() {
            return new LodashWrapper(this.value(), this.__chain__);
          }
          function wrapperNext() {
            if (this.__values__ === undefined2) {
              this.__values__ = toArray(this.value());
            }
            var done = this.__index__ >= this.__values__.length, value = done ? undefined2 : this.__values__[this.__index__++];
            return { "done": done, "value": value };
          }
          function wrapperToIterator() {
            return this;
          }
          function wrapperPlant(value) {
            var result2, parent2 = this;
            while (parent2 instanceof baseLodash) {
              var clone2 = wrapperClone(parent2);
              clone2.__index__ = 0;
              clone2.__values__ = undefined2;
              if (result2) {
                previous.__wrapped__ = clone2;
              } else {
                result2 = clone2;
              }
              var previous = clone2;
              parent2 = parent2.__wrapped__;
            }
            previous.__wrapped__ = value;
            return result2;
          }
          function wrapperReverse() {
            var value = this.__wrapped__;
            if (value instanceof LazyWrapper) {
              var wrapped = value;
              if (this.__actions__.length) {
                wrapped = new LazyWrapper(this);
              }
              wrapped = wrapped.reverse();
              wrapped.__actions__.push({
                "func": thru,
                "args": [reverse],
                "thisArg": undefined2
              });
              return new LodashWrapper(wrapped, this.__chain__);
            }
            return this.thru(reverse);
          }
          function wrapperValue() {
            return baseWrapperValue(this.__wrapped__, this.__actions__);
          }
          var countBy = createAggregator(function(result2, value, key) {
            if (hasOwnProperty.call(result2, key)) {
              ++result2[key];
            } else {
              baseAssignValue(result2, key, 1);
            }
          });
          function every(collection, predicate, guard) {
            var func = isArray(collection) ? arrayEvery : baseEvery;
            if (guard && isIterateeCall(collection, predicate, guard)) {
              predicate = undefined2;
            }
            return func(collection, getIteratee(predicate, 3));
          }
          function filter(collection, predicate) {
            var func = isArray(collection) ? arrayFilter : baseFilter;
            return func(collection, getIteratee(predicate, 3));
          }
          var find = createFind(findIndex);
          var findLast = createFind(findLastIndex);
          function flatMap(collection, iteratee2) {
            return baseFlatten(map(collection, iteratee2), 1);
          }
          function flatMapDeep(collection, iteratee2) {
            return baseFlatten(map(collection, iteratee2), INFINITY);
          }
          function flatMapDepth(collection, iteratee2, depth) {
            depth = depth === undefined2 ? 1 : toInteger(depth);
            return baseFlatten(map(collection, iteratee2), depth);
          }
          function forEach(collection, iteratee2) {
            var func = isArray(collection) ? arrayEach : baseEach;
            return func(collection, getIteratee(iteratee2, 3));
          }
          function forEachRight(collection, iteratee2) {
            var func = isArray(collection) ? arrayEachRight : baseEachRight;
            return func(collection, getIteratee(iteratee2, 3));
          }
          var groupBy = createAggregator(function(result2, value, key) {
            if (hasOwnProperty.call(result2, key)) {
              result2[key].push(value);
            } else {
              baseAssignValue(result2, key, [value]);
            }
          });
          function includes(collection, value, fromIndex, guard) {
            collection = isArrayLike(collection) ? collection : values(collection);
            fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
            var length = collection.length;
            if (fromIndex < 0) {
              fromIndex = nativeMax(length + fromIndex, 0);
            }
            return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
          }
          var invokeMap = baseRest(function(collection, path, args) {
            var index = -1, isFunc = typeof path == "function", result2 = isArrayLike(collection) ? Array2(collection.length) : [];
            baseEach(collection, function(value) {
              result2[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
            });
            return result2;
          });
          var keyBy = createAggregator(function(result2, value, key) {
            baseAssignValue(result2, key, value);
          });
          function map(collection, iteratee2) {
            var func = isArray(collection) ? arrayMap : baseMap;
            return func(collection, getIteratee(iteratee2, 3));
          }
          function orderBy(collection, iteratees, orders, guard) {
            if (collection == null) {
              return [];
            }
            if (!isArray(iteratees)) {
              iteratees = iteratees == null ? [] : [iteratees];
            }
            orders = guard ? undefined2 : orders;
            if (!isArray(orders)) {
              orders = orders == null ? [] : [orders];
            }
            return baseOrderBy(collection, iteratees, orders);
          }
          var partition = createAggregator(function(result2, value, key) {
            result2[key ? 0 : 1].push(value);
          }, function() {
            return [[], []];
          });
          function reduce(collection, iteratee2, accumulator) {
            var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
            return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
          }
          function reduceRight(collection, iteratee2, accumulator) {
            var func = isArray(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
            return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
          }
          function reject(collection, predicate) {
            var func = isArray(collection) ? arrayFilter : baseFilter;
            return func(collection, negate(getIteratee(predicate, 3)));
          }
          function sample(collection) {
            var func = isArray(collection) ? arraySample : baseSample;
            return func(collection);
          }
          function sampleSize(collection, n, guard) {
            if (guard ? isIterateeCall(collection, n, guard) : n === undefined2) {
              n = 1;
            } else {
              n = toInteger(n);
            }
            var func = isArray(collection) ? arraySampleSize : baseSampleSize;
            return func(collection, n);
          }
          function shuffle(collection) {
            var func = isArray(collection) ? arrayShuffle : baseShuffle;
            return func(collection);
          }
          function size(collection) {
            if (collection == null) {
              return 0;
            }
            if (isArrayLike(collection)) {
              return isString(collection) ? stringSize(collection) : collection.length;
            }
            var tag = getTag(collection);
            if (tag == mapTag || tag == setTag) {
              return collection.size;
            }
            return baseKeys(collection).length;
          }
          function some(collection, predicate, guard) {
            var func = isArray(collection) ? arraySome : baseSome;
            if (guard && isIterateeCall(collection, predicate, guard)) {
              predicate = undefined2;
            }
            return func(collection, getIteratee(predicate, 3));
          }
          var sortBy = baseRest(function(collection, iteratees) {
            if (collection == null) {
              return [];
            }
            var length = iteratees.length;
            if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
              iteratees = [];
            } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
              iteratees = [iteratees[0]];
            }
            return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
          });
          var now3 = ctxNow || function() {
            return root.Date.now();
          };
          function after(n, func) {
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            n = toInteger(n);
            return function() {
              if (--n < 1) {
                return func.apply(this, arguments);
              }
            };
          }
          function ary(func, n, guard) {
            n = guard ? undefined2 : n;
            n = func && n == null ? func.length : n;
            return createWrap(func, WRAP_ARY_FLAG, undefined2, undefined2, undefined2, undefined2, n);
          }
          function before(n, func) {
            var result2;
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            n = toInteger(n);
            return function() {
              if (--n > 0) {
                result2 = func.apply(this, arguments);
              }
              if (n <= 1) {
                func = undefined2;
              }
              return result2;
            };
          }
          var bind = baseRest(function(func, thisArg, partials) {
            var bitmask = WRAP_BIND_FLAG;
            if (partials.length) {
              var holders = replaceHolders(partials, getHolder(bind));
              bitmask |= WRAP_PARTIAL_FLAG;
            }
            return createWrap(func, bitmask, thisArg, partials, holders);
          });
          var bindKey = baseRest(function(object, key, partials) {
            var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
            if (partials.length) {
              var holders = replaceHolders(partials, getHolder(bindKey));
              bitmask |= WRAP_PARTIAL_FLAG;
            }
            return createWrap(key, bitmask, object, partials, holders);
          });
          function curry(func, arity, guard) {
            arity = guard ? undefined2 : arity;
            var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
            result2.placeholder = curry.placeholder;
            return result2;
          }
          function curryRight(func, arity, guard) {
            arity = guard ? undefined2 : arity;
            var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
            result2.placeholder = curryRight.placeholder;
            return result2;
          }
          function debounce(func, wait, options) {
            var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            wait = toNumber(wait) || 0;
            if (isObject(options)) {
              leading = !!options.leading;
              maxing = "maxWait" in options;
              maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
              trailing = "trailing" in options ? !!options.trailing : trailing;
            }
            function invokeFunc(time) {
              var args = lastArgs, thisArg = lastThis;
              lastArgs = lastThis = undefined2;
              lastInvokeTime = time;
              result2 = func.apply(thisArg, args);
              return result2;
            }
            function leadingEdge(time) {
              lastInvokeTime = time;
              timerId = setTimeout2(timerExpired, wait);
              return leading ? invokeFunc(time) : result2;
            }
            function remainingWait(time) {
              var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
              return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
            }
            function shouldInvoke(time) {
              var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
              return lastCallTime === undefined2 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
            }
            function timerExpired() {
              var time = now3();
              if (shouldInvoke(time)) {
                return trailingEdge(time);
              }
              timerId = setTimeout2(timerExpired, remainingWait(time));
            }
            function trailingEdge(time) {
              timerId = undefined2;
              if (trailing && lastArgs) {
                return invokeFunc(time);
              }
              lastArgs = lastThis = undefined2;
              return result2;
            }
            function cancel() {
              if (timerId !== undefined2) {
                clearTimeout2(timerId);
              }
              lastInvokeTime = 0;
              lastArgs = lastCallTime = lastThis = timerId = undefined2;
            }
            function flush() {
              return timerId === undefined2 ? result2 : trailingEdge(now3());
            }
            function debounced() {
              var time = now3(), isInvoking = shouldInvoke(time);
              lastArgs = arguments;
              lastThis = this;
              lastCallTime = time;
              if (isInvoking) {
                if (timerId === undefined2) {
                  return leadingEdge(lastCallTime);
                }
                if (maxing) {
                  clearTimeout2(timerId);
                  timerId = setTimeout2(timerExpired, wait);
                  return invokeFunc(lastCallTime);
                }
              }
              if (timerId === undefined2) {
                timerId = setTimeout2(timerExpired, wait);
              }
              return result2;
            }
            debounced.cancel = cancel;
            debounced.flush = flush;
            return debounced;
          }
          var defer = baseRest(function(func, args) {
            return baseDelay(func, 1, args);
          });
          var delay = baseRest(function(func, wait, args) {
            return baseDelay(func, toNumber(wait) || 0, args);
          });
          function flip(func) {
            return createWrap(func, WRAP_FLIP_FLAG);
          }
          function memoize(func, resolver) {
            if (typeof func != "function" || resolver != null && typeof resolver != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            var memoized = function() {
              var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
              if (cache.has(key)) {
                return cache.get(key);
              }
              var result2 = func.apply(this, args);
              memoized.cache = cache.set(key, result2) || cache;
              return result2;
            };
            memoized.cache = new (memoize.Cache || MapCache)();
            return memoized;
          }
          memoize.Cache = MapCache;
          function negate(predicate) {
            if (typeof predicate != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            return function() {
              var args = arguments;
              switch (args.length) {
                case 0:
                  return !predicate.call(this);
                case 1:
                  return !predicate.call(this, args[0]);
                case 2:
                  return !predicate.call(this, args[0], args[1]);
                case 3:
                  return !predicate.call(this, args[0], args[1], args[2]);
              }
              return !predicate.apply(this, args);
            };
          }
          function once(func) {
            return before(2, func);
          }
          var overArgs = castRest(function(func, transforms) {
            transforms = transforms.length == 1 && isArray(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
            var funcsLength = transforms.length;
            return baseRest(function(args) {
              var index = -1, length = nativeMin(args.length, funcsLength);
              while (++index < length) {
                args[index] = transforms[index].call(this, args[index]);
              }
              return apply(func, this, args);
            });
          });
          var partial = baseRest(function(func, partials) {
            var holders = replaceHolders(partials, getHolder(partial));
            return createWrap(func, WRAP_PARTIAL_FLAG, undefined2, partials, holders);
          });
          var partialRight = baseRest(function(func, partials) {
            var holders = replaceHolders(partials, getHolder(partialRight));
            return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined2, partials, holders);
          });
          var rearg = flatRest(function(func, indexes) {
            return createWrap(func, WRAP_REARG_FLAG, undefined2, undefined2, undefined2, indexes);
          });
          function rest(func, start2) {
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            start2 = start2 === undefined2 ? start2 : toInteger(start2);
            return baseRest(func, start2);
          }
          function spread(func, start2) {
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            start2 = start2 == null ? 0 : nativeMax(toInteger(start2), 0);
            return baseRest(function(args) {
              var array = args[start2], otherArgs = castSlice(args, 0, start2);
              if (array) {
                arrayPush(otherArgs, array);
              }
              return apply(func, this, otherArgs);
            });
          }
          function throttle(func, wait, options) {
            var leading = true, trailing = true;
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            if (isObject(options)) {
              leading = "leading" in options ? !!options.leading : leading;
              trailing = "trailing" in options ? !!options.trailing : trailing;
            }
            return debounce(func, wait, {
              "leading": leading,
              "maxWait": wait,
              "trailing": trailing
            });
          }
          function unary(func) {
            return ary(func, 1);
          }
          function wrap(value, wrapper) {
            return partial(castFunction(wrapper), value);
          }
          function castArray() {
            if (!arguments.length) {
              return [];
            }
            var value = arguments[0];
            return isArray(value) ? value : [value];
          }
          function clone(value) {
            return baseClone(value, CLONE_SYMBOLS_FLAG);
          }
          function cloneWith(value, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
          }
          function cloneDeep(value) {
            return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
          }
          function cloneDeepWith(value, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
          }
          function conformsTo(object, source) {
            return source == null || baseConformsTo(object, source, keys(source));
          }
          function eq(value, other) {
            return value === other || value !== value && other !== other;
          }
          var gt = createRelationalOperation(baseGt);
          var gte = createRelationalOperation(function(value, other) {
            return value >= other;
          });
          var isArguments = baseIsArguments(/* @__PURE__ */ function() {
            return arguments;
          }()) ? baseIsArguments : function(value) {
            return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
          };
          var isArray = Array2.isArray;
          var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
          function isArrayLike(value) {
            return value != null && isLength(value.length) && !isFunction(value);
          }
          function isArrayLikeObject(value) {
            return isObjectLike(value) && isArrayLike(value);
          }
          function isBoolean(value) {
            return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
          }
          var isBuffer = nativeIsBuffer || stubFalse;
          var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
          function isElement(value) {
            return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
          }
          function isEmpty(value) {
            if (value == null) {
              return true;
            }
            if (isArrayLike(value) && (isArray(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
              return !value.length;
            }
            var tag = getTag(value);
            if (tag == mapTag || tag == setTag) {
              return !value.size;
            }
            if (isPrototype(value)) {
              return !baseKeys(value).length;
            }
            for (var key in value) {
              if (hasOwnProperty.call(value, key)) {
                return false;
              }
            }
            return true;
          }
          function isEqual(value, other) {
            return baseIsEqual(value, other);
          }
          function isEqualWith(value, other, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            var result2 = customizer ? customizer(value, other) : undefined2;
            return result2 === undefined2 ? baseIsEqual(value, other, undefined2, customizer) : !!result2;
          }
          function isError(value) {
            if (!isObjectLike(value)) {
              return false;
            }
            var tag = baseGetTag(value);
            return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject(value);
          }
          function isFinite2(value) {
            return typeof value == "number" && nativeIsFinite(value);
          }
          function isFunction(value) {
            if (!isObject(value)) {
              return false;
            }
            var tag = baseGetTag(value);
            return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
          }
          function isInteger(value) {
            return typeof value == "number" && value == toInteger(value);
          }
          function isLength(value) {
            return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
          }
          function isObject(value) {
            var type = typeof value;
            return value != null && (type == "object" || type == "function");
          }
          function isObjectLike(value) {
            return value != null && typeof value == "object";
          }
          var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
          function isMatch(object, source) {
            return object === source || baseIsMatch(object, source, getMatchData(source));
          }
          function isMatchWith(object, source, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            return baseIsMatch(object, source, getMatchData(source), customizer);
          }
          function isNaN2(value) {
            return isNumber(value) && value != +value;
          }
          function isNative(value) {
            if (isMaskable(value)) {
              throw new Error2(CORE_ERROR_TEXT);
            }
            return baseIsNative(value);
          }
          function isNull(value) {
            return value === null;
          }
          function isNil(value) {
            return value == null;
          }
          function isNumber(value) {
            return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
          }
          function isPlainObject(value) {
            if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
              return false;
            }
            var proto = getPrototype(value);
            if (proto === null) {
              return true;
            }
            var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
            return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
          }
          var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
          function isSafeInteger(value) {
            return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
          }
          var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
          function isString(value) {
            return typeof value == "string" || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
          }
          function isSymbol(value) {
            return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
          }
          var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
          function isUndefined(value) {
            return value === undefined2;
          }
          function isWeakMap(value) {
            return isObjectLike(value) && getTag(value) == weakMapTag;
          }
          function isWeakSet(value) {
            return isObjectLike(value) && baseGetTag(value) == weakSetTag;
          }
          var lt = createRelationalOperation(baseLt);
          var lte = createRelationalOperation(function(value, other) {
            return value <= other;
          });
          function toArray(value) {
            if (!value) {
              return [];
            }
            if (isArrayLike(value)) {
              return isString(value) ? stringToArray(value) : copyArray2(value);
            }
            if (symIterator && value[symIterator]) {
              return iteratorToArray(value[symIterator]());
            }
            var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
            return func(value);
          }
          function toFinite(value) {
            if (!value) {
              return value === 0 ? value : 0;
            }
            value = toNumber(value);
            if (value === INFINITY || value === -INFINITY) {
              var sign2 = value < 0 ? -1 : 1;
              return sign2 * MAX_INTEGER;
            }
            return value === value ? value : 0;
          }
          function toInteger(value) {
            var result2 = toFinite(value), remainder = result2 % 1;
            return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
          }
          function toLength(value) {
            return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
          }
          function toNumber(value) {
            if (typeof value == "number") {
              return value;
            }
            if (isSymbol(value)) {
              return NAN;
            }
            if (isObject(value)) {
              var other = typeof value.valueOf == "function" ? value.valueOf() : value;
              value = isObject(other) ? other + "" : other;
            }
            if (typeof value != "string") {
              return value === 0 ? value : +value;
            }
            value = baseTrim(value);
            var isBinary = reIsBinary.test(value);
            return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
          }
          function toPlainObject(value) {
            return copyObject(value, keysIn(value));
          }
          function toSafeInteger(value) {
            return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
          }
          function toString(value) {
            return value == null ? "" : baseToString(value);
          }
          var assign = createAssigner(function(object, source) {
            if (isPrototype(source) || isArrayLike(source)) {
              copyObject(source, keys(source), object);
              return;
            }
            for (var key in source) {
              if (hasOwnProperty.call(source, key)) {
                assignValue(object, key, source[key]);
              }
            }
          });
          var assignIn = createAssigner(function(object, source) {
            copyObject(source, keysIn(source), object);
          });
          var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
            copyObject(source, keysIn(source), object, customizer);
          });
          var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
            copyObject(source, keys(source), object, customizer);
          });
          var at = flatRest(baseAt);
          function create(prototype, properties) {
            var result2 = baseCreate(prototype);
            return properties == null ? result2 : baseAssign(result2, properties);
          }
          var defaults = baseRest(function(object, sources) {
            object = Object2(object);
            var index = -1;
            var length = sources.length;
            var guard = length > 2 ? sources[2] : undefined2;
            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
              length = 1;
            }
            while (++index < length) {
              var source = sources[index];
              var props = keysIn(source);
              var propsIndex = -1;
              var propsLength = props.length;
              while (++propsIndex < propsLength) {
                var key = props[propsIndex];
                var value = object[key];
                if (value === undefined2 || eq(value, objectProto[key]) && !hasOwnProperty.call(object, key)) {
                  object[key] = source[key];
                }
              }
            }
            return object;
          });
          var defaultsDeep = baseRest(function(args) {
            args.push(undefined2, customDefaultsMerge);
            return apply(mergeWith, undefined2, args);
          });
          function findKey(object, predicate) {
            return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
          }
          function findLastKey(object, predicate) {
            return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
          }
          function forIn(object, iteratee2) {
            return object == null ? object : baseFor(object, getIteratee(iteratee2, 3), keysIn);
          }
          function forInRight(object, iteratee2) {
            return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn);
          }
          function forOwn(object, iteratee2) {
            return object && baseForOwn(object, getIteratee(iteratee2, 3));
          }
          function forOwnRight(object, iteratee2) {
            return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
          }
          function functions(object) {
            return object == null ? [] : baseFunctions(object, keys(object));
          }
          function functionsIn(object) {
            return object == null ? [] : baseFunctions(object, keysIn(object));
          }
          function get(object, path, defaultValue) {
            var result2 = object == null ? undefined2 : baseGet(object, path);
            return result2 === undefined2 ? defaultValue : result2;
          }
          function has(object, path) {
            return object != null && hasPath(object, path, baseHas);
          }
          function hasIn(object, path) {
            return object != null && hasPath(object, path, baseHasIn);
          }
          var invert = createInverter(function(result2, value, key) {
            if (value != null && typeof value.toString != "function") {
              value = nativeObjectToString.call(value);
            }
            result2[value] = key;
          }, constant(identity));
          var invertBy = createInverter(function(result2, value, key) {
            if (value != null && typeof value.toString != "function") {
              value = nativeObjectToString.call(value);
            }
            if (hasOwnProperty.call(result2, value)) {
              result2[value].push(key);
            } else {
              result2[value] = [key];
            }
          }, getIteratee);
          var invoke = baseRest(baseInvoke);
          function keys(object) {
            return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
          }
          function keysIn(object) {
            return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
          }
          function mapKeys(object, iteratee2) {
            var result2 = {};
            iteratee2 = getIteratee(iteratee2, 3);
            baseForOwn(object, function(value, key, object2) {
              baseAssignValue(result2, iteratee2(value, key, object2), value);
            });
            return result2;
          }
          function mapValues(object, iteratee2) {
            var result2 = {};
            iteratee2 = getIteratee(iteratee2, 3);
            baseForOwn(object, function(value, key, object2) {
              baseAssignValue(result2, key, iteratee2(value, key, object2));
            });
            return result2;
          }
          var merge = createAssigner(function(object, source, srcIndex) {
            baseMerge(object, source, srcIndex);
          });
          var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
            baseMerge(object, source, srcIndex, customizer);
          });
          var omit = flatRest(function(object, paths) {
            var result2 = {};
            if (object == null) {
              return result2;
            }
            var isDeep = false;
            paths = arrayMap(paths, function(path) {
              path = castPath(path, object);
              isDeep || (isDeep = path.length > 1);
              return path;
            });
            copyObject(object, getAllKeysIn(object), result2);
            if (isDeep) {
              result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
            }
            var length = paths.length;
            while (length--) {
              baseUnset(result2, paths[length]);
            }
            return result2;
          });
          function omitBy(object, predicate) {
            return pickBy(object, negate(getIteratee(predicate)));
          }
          var pick = flatRest(function(object, paths) {
            return object == null ? {} : basePick(object, paths);
          });
          function pickBy(object, predicate) {
            if (object == null) {
              return {};
            }
            var props = arrayMap(getAllKeysIn(object), function(prop) {
              return [prop];
            });
            predicate = getIteratee(predicate);
            return basePickBy(object, props, function(value, path) {
              return predicate(value, path[0]);
            });
          }
          function result(object, path, defaultValue) {
            path = castPath(path, object);
            var index = -1, length = path.length;
            if (!length) {
              length = 1;
              object = undefined2;
            }
            while (++index < length) {
              var value = object == null ? undefined2 : object[toKey(path[index])];
              if (value === undefined2) {
                index = length;
                value = defaultValue;
              }
              object = isFunction(value) ? value.call(object) : value;
            }
            return object;
          }
          function set(object, path, value) {
            return object == null ? object : baseSet(object, path, value);
          }
          function setWith(object, path, value, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            return object == null ? object : baseSet(object, path, value, customizer);
          }
          var toPairs = createToPairs(keys);
          var toPairsIn = createToPairs(keysIn);
          function transform(object, iteratee2, accumulator) {
            var isArr = isArray(object), isArrLike = isArr || isBuffer(object) || isTypedArray(object);
            iteratee2 = getIteratee(iteratee2, 4);
            if (accumulator == null) {
              var Ctor = object && object.constructor;
              if (isArrLike) {
                accumulator = isArr ? new Ctor() : [];
              } else if (isObject(object)) {
                accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
              } else {
                accumulator = {};
              }
            }
            (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object2) {
              return iteratee2(accumulator, value, index, object2);
            });
            return accumulator;
          }
          function unset(object, path) {
            return object == null ? true : baseUnset(object, path);
          }
          function update(object, path, updater) {
            return object == null ? object : baseUpdate(object, path, castFunction(updater));
          }
          function updateWith(object, path, updater, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
          }
          function values(object) {
            return object == null ? [] : baseValues(object, keys(object));
          }
          function valuesIn(object) {
            return object == null ? [] : baseValues(object, keysIn(object));
          }
          function clamp2(number, lower, upper) {
            if (upper === undefined2) {
              upper = lower;
              lower = undefined2;
            }
            if (upper !== undefined2) {
              upper = toNumber(upper);
              upper = upper === upper ? upper : 0;
            }
            if (lower !== undefined2) {
              lower = toNumber(lower);
              lower = lower === lower ? lower : 0;
            }
            return baseClamp(toNumber(number), lower, upper);
          }
          function inRange(number, start2, end) {
            start2 = toFinite(start2);
            if (end === undefined2) {
              end = start2;
              start2 = 0;
            } else {
              end = toFinite(end);
            }
            number = toNumber(number);
            return baseInRange(number, start2, end);
          }
          function random(lower, upper, floating) {
            if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
              upper = floating = undefined2;
            }
            if (floating === undefined2) {
              if (typeof upper == "boolean") {
                floating = upper;
                upper = undefined2;
              } else if (typeof lower == "boolean") {
                floating = lower;
                lower = undefined2;
              }
            }
            if (lower === undefined2 && upper === undefined2) {
              lower = 0;
              upper = 1;
            } else {
              lower = toFinite(lower);
              if (upper === undefined2) {
                upper = lower;
                lower = 0;
              } else {
                upper = toFinite(upper);
              }
            }
            if (lower > upper) {
              var temp = lower;
              lower = upper;
              upper = temp;
            }
            if (floating || lower % 1 || upper % 1) {
              var rand = nativeRandom();
              return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
            }
            return baseRandom(lower, upper);
          }
          var camelCase = createCompounder(function(result2, word, index) {
            word = word.toLowerCase();
            return result2 + (index ? capitalize2(word) : word);
          });
          function capitalize2(string) {
            return upperFirst(toString(string).toLowerCase());
          }
          function deburr(string) {
            string = toString(string);
            return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
          }
          function endsWith(string, target, position) {
            string = toString(string);
            target = baseToString(target);
            var length = string.length;
            position = position === undefined2 ? length : baseClamp(toInteger(position), 0, length);
            var end = position;
            position -= target.length;
            return position >= 0 && string.slice(position, end) == target;
          }
          function escape2(string) {
            string = toString(string);
            return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
          }
          function escapeRegExp(string) {
            string = toString(string);
            return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
          }
          var kebabCase = createCompounder(function(result2, word, index) {
            return result2 + (index ? "-" : "") + word.toLowerCase();
          });
          var lowerCase = createCompounder(function(result2, word, index) {
            return result2 + (index ? " " : "") + word.toLowerCase();
          });
          var lowerFirst = createCaseFirst("toLowerCase");
          function pad(string, length, chars) {
            string = toString(string);
            length = toInteger(length);
            var strLength = length ? stringSize(string) : 0;
            if (!length || strLength >= length) {
              return string;
            }
            var mid = (length - strLength) / 2;
            return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
          }
          function padEnd(string, length, chars) {
            string = toString(string);
            length = toInteger(length);
            var strLength = length ? stringSize(string) : 0;
            return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
          }
          function padStart(string, length, chars) {
            string = toString(string);
            length = toInteger(length);
            var strLength = length ? stringSize(string) : 0;
            return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
          }
          function parseInt2(string, radix, guard) {
            if (guard || radix == null) {
              radix = 0;
            } else if (radix) {
              radix = +radix;
            }
            return nativeParseInt(toString(string).replace(reTrimStart, ""), radix || 0);
          }
          function repeat(string, n, guard) {
            if (guard ? isIterateeCall(string, n, guard) : n === undefined2) {
              n = 1;
            } else {
              n = toInteger(n);
            }
            return baseRepeat(toString(string), n);
          }
          function replace() {
            var args = arguments, string = toString(args[0]);
            return args.length < 3 ? string : string.replace(args[1], args[2]);
          }
          var snakeCase = createCompounder(function(result2, word, index) {
            return result2 + (index ? "_" : "") + word.toLowerCase();
          });
          function split(string, separator, limit) {
            if (limit && typeof limit != "number" && isIterateeCall(string, separator, limit)) {
              separator = limit = undefined2;
            }
            limit = limit === undefined2 ? MAX_ARRAY_LENGTH : limit >>> 0;
            if (!limit) {
              return [];
            }
            string = toString(string);
            if (string && (typeof separator == "string" || separator != null && !isRegExp(separator))) {
              separator = baseToString(separator);
              if (!separator && hasUnicode(string)) {
                return castSlice(stringToArray(string), 0, limit);
              }
            }
            return string.split(separator, limit);
          }
          var startCase = createCompounder(function(result2, word, index) {
            return result2 + (index ? " " : "") + upperFirst(word);
          });
          function startsWith(string, target, position) {
            string = toString(string);
            position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length);
            target = baseToString(target);
            return string.slice(position, position + target.length) == target;
          }
          function template(string, options, guard) {
            var settings = lodash.templateSettings;
            if (guard && isIterateeCall(string, options, guard)) {
              options = undefined2;
            }
            string = toString(string);
            options = assignInWith({}, options, settings, customDefaultsAssignIn);
            var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
            var isEscaping, isEvaluating, index = 0, interpolate2 = options.interpolate || reNoMatch, source = "__p += '";
            var reDelimiters = RegExp2(
              (options.escape || reNoMatch).source + "|" + interpolate2.source + "|" + (interpolate2 === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$",
              "g"
            );
            var sourceURL = "//# sourceURL=" + (hasOwnProperty.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
            string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
              interpolateValue || (interpolateValue = esTemplateValue);
              source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);
              if (escapeValue) {
                isEscaping = true;
                source += "' +\n__e(" + escapeValue + ") +\n'";
              }
              if (evaluateValue) {
                isEvaluating = true;
                source += "';\n" + evaluateValue + ";\n__p += '";
              }
              if (interpolateValue) {
                source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
              }
              index = offset + match.length;
              return match;
            });
            source += "';\n";
            var variable = hasOwnProperty.call(options, "variable") && options.variable;
            if (!variable) {
              source = "with (obj) {\n" + source + "\n}\n";
            } else if (reForbiddenIdentifierChars.test(variable)) {
              throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
            }
            source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
            source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
            var result2 = attempt(function() {
              return Function2(importsKeys, sourceURL + "return " + source).apply(undefined2, importsValues);
            });
            result2.source = source;
            if (isError(result2)) {
              throw result2;
            }
            return result2;
          }
          function toLower(value) {
            return toString(value).toLowerCase();
          }
          function toUpper(value) {
            return toString(value).toUpperCase();
          }
          function trim(string, chars, guard) {
            string = toString(string);
            if (string && (guard || chars === undefined2)) {
              return baseTrim(string);
            }
            if (!string || !(chars = baseToString(chars))) {
              return string;
            }
            var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start2 = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
            return castSlice(strSymbols, start2, end).join("");
          }
          function trimEnd(string, chars, guard) {
            string = toString(string);
            if (string && (guard || chars === undefined2)) {
              return string.slice(0, trimmedEndIndex(string) + 1);
            }
            if (!string || !(chars = baseToString(chars))) {
              return string;
            }
            var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
            return castSlice(strSymbols, 0, end).join("");
          }
          function trimStart(string, chars, guard) {
            string = toString(string);
            if (string && (guard || chars === undefined2)) {
              return string.replace(reTrimStart, "");
            }
            if (!string || !(chars = baseToString(chars))) {
              return string;
            }
            var strSymbols = stringToArray(string), start2 = charsStartIndex(strSymbols, stringToArray(chars));
            return castSlice(strSymbols, start2).join("");
          }
          function truncate(string, options) {
            var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
            if (isObject(options)) {
              var separator = "separator" in options ? options.separator : separator;
              length = "length" in options ? toInteger(options.length) : length;
              omission = "omission" in options ? baseToString(options.omission) : omission;
            }
            string = toString(string);
            var strLength = string.length;
            if (hasUnicode(string)) {
              var strSymbols = stringToArray(string);
              strLength = strSymbols.length;
            }
            if (length >= strLength) {
              return string;
            }
            var end = length - stringSize(omission);
            if (end < 1) {
              return omission;
            }
            var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string.slice(0, end);
            if (separator === undefined2) {
              return result2 + omission;
            }
            if (strSymbols) {
              end += result2.length - end;
            }
            if (isRegExp(separator)) {
              if (string.slice(end).search(separator)) {
                var match, substring = result2;
                if (!separator.global) {
                  separator = RegExp2(separator.source, toString(reFlags.exec(separator)) + "g");
                }
                separator.lastIndex = 0;
                while (match = separator.exec(substring)) {
                  var newEnd = match.index;
                }
                result2 = result2.slice(0, newEnd === undefined2 ? end : newEnd);
              }
            } else if (string.indexOf(baseToString(separator), end) != end) {
              var index = result2.lastIndexOf(separator);
              if (index > -1) {
                result2 = result2.slice(0, index);
              }
            }
            return result2 + omission;
          }
          function unescape2(string) {
            string = toString(string);
            return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
          }
          var upperCase = createCompounder(function(result2, word, index) {
            return result2 + (index ? " " : "") + word.toUpperCase();
          });
          var upperFirst = createCaseFirst("toUpperCase");
          function words(string, pattern, guard) {
            string = toString(string);
            pattern = guard ? undefined2 : pattern;
            if (pattern === undefined2) {
              return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
            }
            return string.match(pattern) || [];
          }
          var attempt = baseRest(function(func, args) {
            try {
              return apply(func, undefined2, args);
            } catch (e) {
              return isError(e) ? e : new Error2(e);
            }
          });
          var bindAll = flatRest(function(object, methodNames) {
            arrayEach(methodNames, function(key) {
              key = toKey(key);
              baseAssignValue(object, key, bind(object[key], object));
            });
            return object;
          });
          function cond(pairs) {
            var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
            pairs = !length ? [] : arrayMap(pairs, function(pair) {
              if (typeof pair[1] != "function") {
                throw new TypeError2(FUNC_ERROR_TEXT);
              }
              return [toIteratee(pair[0]), pair[1]];
            });
            return baseRest(function(args) {
              var index = -1;
              while (++index < length) {
                var pair = pairs[index];
                if (apply(pair[0], this, args)) {
                  return apply(pair[1], this, args);
                }
              }
            });
          }
          function conforms(source) {
            return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
          }
          function constant(value) {
            return function() {
              return value;
            };
          }
          function defaultTo(value, defaultValue) {
            return value == null || value !== value ? defaultValue : value;
          }
          var flow = createFlow();
          var flowRight = createFlow(true);
          function identity(value) {
            return value;
          }
          function iteratee(func) {
            return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
          }
          function matches(source) {
            return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
          }
          function matchesProperty(path, srcValue) {
            return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
          }
          var method = baseRest(function(path, args) {
            return function(object) {
              return baseInvoke(object, path, args);
            };
          });
          var methodOf = baseRest(function(object, args) {
            return function(path) {
              return baseInvoke(object, path, args);
            };
          });
          function mixin(object, source, options) {
            var props = keys(source), methodNames = baseFunctions(source, props);
            if (options == null && !(isObject(source) && (methodNames.length || !props.length))) {
              options = source;
              source = object;
              object = this;
              methodNames = baseFunctions(source, keys(source));
            }
            var chain2 = !(isObject(options) && "chain" in options) || !!options.chain, isFunc = isFunction(object);
            arrayEach(methodNames, function(methodName) {
              var func = source[methodName];
              object[methodName] = func;
              if (isFunc) {
                object.prototype[methodName] = function() {
                  var chainAll = this.__chain__;
                  if (chain2 || chainAll) {
                    var result2 = object(this.__wrapped__), actions = result2.__actions__ = copyArray2(this.__actions__);
                    actions.push({ "func": func, "args": arguments, "thisArg": object });
                    result2.__chain__ = chainAll;
                    return result2;
                  }
                  return func.apply(object, arrayPush([this.value()], arguments));
                };
              }
            });
            return object;
          }
          function noConflict() {
            if (root._ === this) {
              root._ = oldDash;
            }
            return this;
          }
          function noop() {
          }
          function nthArg(n) {
            n = toInteger(n);
            return baseRest(function(args) {
              return baseNth(args, n);
            });
          }
          var over = createOver(arrayMap);
          var overEvery = createOver(arrayEvery);
          var overSome = createOver(arraySome);
          function property(path) {
            return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
          }
          function propertyOf(object) {
            return function(path) {
              return object == null ? undefined2 : baseGet(object, path);
            };
          }
          var range = createRange();
          var rangeRight = createRange(true);
          function stubArray() {
            return [];
          }
          function stubFalse() {
            return false;
          }
          function stubObject() {
            return {};
          }
          function stubString() {
            return "";
          }
          function stubTrue() {
            return true;
          }
          function times(n, iteratee2) {
            n = toInteger(n);
            if (n < 1 || n > MAX_SAFE_INTEGER) {
              return [];
            }
            var index = MAX_ARRAY_LENGTH, length = nativeMin(n, MAX_ARRAY_LENGTH);
            iteratee2 = getIteratee(iteratee2);
            n -= MAX_ARRAY_LENGTH;
            var result2 = baseTimes(length, iteratee2);
            while (++index < n) {
              iteratee2(index);
            }
            return result2;
          }
          function toPath(value) {
            if (isArray(value)) {
              return arrayMap(value, toKey);
            }
            return isSymbol(value) ? [value] : copyArray2(stringToPath(toString(value)));
          }
          function uniqueId(prefix) {
            var id = ++idCounter;
            return toString(prefix) + id;
          }
          var add2 = createMathOperation(function(augend, addend) {
            return augend + addend;
          }, 0);
          var ceil = createRound("ceil");
          var divide = createMathOperation(function(dividend, divisor) {
            return dividend / divisor;
          }, 1);
          var floor = createRound("floor");
          function max(array) {
            return array && array.length ? baseExtremum(array, identity, baseGt) : undefined2;
          }
          function maxBy(array, iteratee2) {
            return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseGt) : undefined2;
          }
          function mean(array) {
            return baseMean(array, identity);
          }
          function meanBy(array, iteratee2) {
            return baseMean(array, getIteratee(iteratee2, 2));
          }
          function min(array) {
            return array && array.length ? baseExtremum(array, identity, baseLt) : undefined2;
          }
          function minBy(array, iteratee2) {
            return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseLt) : undefined2;
          }
          var multiply = createMathOperation(function(multiplier, multiplicand) {
            return multiplier * multiplicand;
          }, 1);
          var round = createRound("round");
          var subtract = createMathOperation(function(minuend, subtrahend) {
            return minuend - subtrahend;
          }, 0);
          function sum(array) {
            return array && array.length ? baseSum(array, identity) : 0;
          }
          function sumBy(array, iteratee2) {
            return array && array.length ? baseSum(array, getIteratee(iteratee2, 2)) : 0;
          }
          lodash.after = after;
          lodash.ary = ary;
          lodash.assign = assign;
          lodash.assignIn = assignIn;
          lodash.assignInWith = assignInWith;
          lodash.assignWith = assignWith;
          lodash.at = at;
          lodash.before = before;
          lodash.bind = bind;
          lodash.bindAll = bindAll;
          lodash.bindKey = bindKey;
          lodash.castArray = castArray;
          lodash.chain = chain;
          lodash.chunk = chunk;
          lodash.compact = compact;
          lodash.concat = concat;
          lodash.cond = cond;
          lodash.conforms = conforms;
          lodash.constant = constant;
          lodash.countBy = countBy;
          lodash.create = create;
          lodash.curry = curry;
          lodash.curryRight = curryRight;
          lodash.debounce = debounce;
          lodash.defaults = defaults;
          lodash.defaultsDeep = defaultsDeep;
          lodash.defer = defer;
          lodash.delay = delay;
          lodash.difference = difference;
          lodash.differenceBy = differenceBy;
          lodash.differenceWith = differenceWith;
          lodash.drop = drop;
          lodash.dropRight = dropRight;
          lodash.dropRightWhile = dropRightWhile;
          lodash.dropWhile = dropWhile;
          lodash.fill = fill;
          lodash.filter = filter;
          lodash.flatMap = flatMap;
          lodash.flatMapDeep = flatMapDeep;
          lodash.flatMapDepth = flatMapDepth;
          lodash.flatten = flatten2;
          lodash.flattenDeep = flattenDeep;
          lodash.flattenDepth = flattenDepth;
          lodash.flip = flip;
          lodash.flow = flow;
          lodash.flowRight = flowRight;
          lodash.fromPairs = fromPairs;
          lodash.functions = functions;
          lodash.functionsIn = functionsIn;
          lodash.groupBy = groupBy;
          lodash.initial = initial;
          lodash.intersection = intersection;
          lodash.intersectionBy = intersectionBy;
          lodash.intersectionWith = intersectionWith;
          lodash.invert = invert;
          lodash.invertBy = invertBy;
          lodash.invokeMap = invokeMap;
          lodash.iteratee = iteratee;
          lodash.keyBy = keyBy;
          lodash.keys = keys;
          lodash.keysIn = keysIn;
          lodash.map = map;
          lodash.mapKeys = mapKeys;
          lodash.mapValues = mapValues;
          lodash.matches = matches;
          lodash.matchesProperty = matchesProperty;
          lodash.memoize = memoize;
          lodash.merge = merge;
          lodash.mergeWith = mergeWith;
          lodash.method = method;
          lodash.methodOf = methodOf;
          lodash.mixin = mixin;
          lodash.negate = negate;
          lodash.nthArg = nthArg;
          lodash.omit = omit;
          lodash.omitBy = omitBy;
          lodash.once = once;
          lodash.orderBy = orderBy;
          lodash.over = over;
          lodash.overArgs = overArgs;
          lodash.overEvery = overEvery;
          lodash.overSome = overSome;
          lodash.partial = partial;
          lodash.partialRight = partialRight;
          lodash.partition = partition;
          lodash.pick = pick;
          lodash.pickBy = pickBy;
          lodash.property = property;
          lodash.propertyOf = propertyOf;
          lodash.pull = pull;
          lodash.pullAll = pullAll;
          lodash.pullAllBy = pullAllBy;
          lodash.pullAllWith = pullAllWith;
          lodash.pullAt = pullAt;
          lodash.range = range;
          lodash.rangeRight = rangeRight;
          lodash.rearg = rearg;
          lodash.reject = reject;
          lodash.remove = remove;
          lodash.rest = rest;
          lodash.reverse = reverse;
          lodash.sampleSize = sampleSize;
          lodash.set = set;
          lodash.setWith = setWith;
          lodash.shuffle = shuffle;
          lodash.slice = slice;
          lodash.sortBy = sortBy;
          lodash.sortedUniq = sortedUniq;
          lodash.sortedUniqBy = sortedUniqBy;
          lodash.split = split;
          lodash.spread = spread;
          lodash.tail = tail;
          lodash.take = take;
          lodash.takeRight = takeRight;
          lodash.takeRightWhile = takeRightWhile;
          lodash.takeWhile = takeWhile;
          lodash.tap = tap;
          lodash.throttle = throttle;
          lodash.thru = thru;
          lodash.toArray = toArray;
          lodash.toPairs = toPairs;
          lodash.toPairsIn = toPairsIn;
          lodash.toPath = toPath;
          lodash.toPlainObject = toPlainObject;
          lodash.transform = transform;
          lodash.unary = unary;
          lodash.union = union;
          lodash.unionBy = unionBy;
          lodash.unionWith = unionWith;
          lodash.uniq = uniq;
          lodash.uniqBy = uniqBy;
          lodash.uniqWith = uniqWith;
          lodash.unset = unset;
          lodash.unzip = unzip;
          lodash.unzipWith = unzipWith;
          lodash.update = update;
          lodash.updateWith = updateWith;
          lodash.values = values;
          lodash.valuesIn = valuesIn;
          lodash.without = without;
          lodash.words = words;
          lodash.wrap = wrap;
          lodash.xor = xor;
          lodash.xorBy = xorBy;
          lodash.xorWith = xorWith;
          lodash.zip = zip2;
          lodash.zipObject = zipObject;
          lodash.zipObjectDeep = zipObjectDeep;
          lodash.zipWith = zipWith;
          lodash.entries = toPairs;
          lodash.entriesIn = toPairsIn;
          lodash.extend = assignIn;
          lodash.extendWith = assignInWith;
          mixin(lodash, lodash);
          lodash.add = add2;
          lodash.attempt = attempt;
          lodash.camelCase = camelCase;
          lodash.capitalize = capitalize2;
          lodash.ceil = ceil;
          lodash.clamp = clamp2;
          lodash.clone = clone;
          lodash.cloneDeep = cloneDeep;
          lodash.cloneDeepWith = cloneDeepWith;
          lodash.cloneWith = cloneWith;
          lodash.conformsTo = conformsTo;
          lodash.deburr = deburr;
          lodash.defaultTo = defaultTo;
          lodash.divide = divide;
          lodash.endsWith = endsWith;
          lodash.eq = eq;
          lodash.escape = escape2;
          lodash.escapeRegExp = escapeRegExp;
          lodash.every = every;
          lodash.find = find;
          lodash.findIndex = findIndex;
          lodash.findKey = findKey;
          lodash.findLast = findLast;
          lodash.findLastIndex = findLastIndex;
          lodash.findLastKey = findLastKey;
          lodash.floor = floor;
          lodash.forEach = forEach;
          lodash.forEachRight = forEachRight;
          lodash.forIn = forIn;
          lodash.forInRight = forInRight;
          lodash.forOwn = forOwn;
          lodash.forOwnRight = forOwnRight;
          lodash.get = get;
          lodash.gt = gt;
          lodash.gte = gte;
          lodash.has = has;
          lodash.hasIn = hasIn;
          lodash.head = head;
          lodash.identity = identity;
          lodash.includes = includes;
          lodash.indexOf = indexOf3;
          lodash.inRange = inRange;
          lodash.invoke = invoke;
          lodash.isArguments = isArguments;
          lodash.isArray = isArray;
          lodash.isArrayBuffer = isArrayBuffer;
          lodash.isArrayLike = isArrayLike;
          lodash.isArrayLikeObject = isArrayLikeObject;
          lodash.isBoolean = isBoolean;
          lodash.isBuffer = isBuffer;
          lodash.isDate = isDate;
          lodash.isElement = isElement;
          lodash.isEmpty = isEmpty;
          lodash.isEqual = isEqual;
          lodash.isEqualWith = isEqualWith;
          lodash.isError = isError;
          lodash.isFinite = isFinite2;
          lodash.isFunction = isFunction;
          lodash.isInteger = isInteger;
          lodash.isLength = isLength;
          lodash.isMap = isMap;
          lodash.isMatch = isMatch;
          lodash.isMatchWith = isMatchWith;
          lodash.isNaN = isNaN2;
          lodash.isNative = isNative;
          lodash.isNil = isNil;
          lodash.isNull = isNull;
          lodash.isNumber = isNumber;
          lodash.isObject = isObject;
          lodash.isObjectLike = isObjectLike;
          lodash.isPlainObject = isPlainObject;
          lodash.isRegExp = isRegExp;
          lodash.isSafeInteger = isSafeInteger;
          lodash.isSet = isSet;
          lodash.isString = isString;
          lodash.isSymbol = isSymbol;
          lodash.isTypedArray = isTypedArray;
          lodash.isUndefined = isUndefined;
          lodash.isWeakMap = isWeakMap;
          lodash.isWeakSet = isWeakSet;
          lodash.join = join;
          lodash.kebabCase = kebabCase;
          lodash.last = last;
          lodash.lastIndexOf = lastIndexOf;
          lodash.lowerCase = lowerCase;
          lodash.lowerFirst = lowerFirst;
          lodash.lt = lt;
          lodash.lte = lte;
          lodash.max = max;
          lodash.maxBy = maxBy;
          lodash.mean = mean;
          lodash.meanBy = meanBy;
          lodash.min = min;
          lodash.minBy = minBy;
          lodash.stubArray = stubArray;
          lodash.stubFalse = stubFalse;
          lodash.stubObject = stubObject;
          lodash.stubString = stubString;
          lodash.stubTrue = stubTrue;
          lodash.multiply = multiply;
          lodash.nth = nth;
          lodash.noConflict = noConflict;
          lodash.noop = noop;
          lodash.now = now3;
          lodash.pad = pad;
          lodash.padEnd = padEnd;
          lodash.padStart = padStart;
          lodash.parseInt = parseInt2;
          lodash.random = random;
          lodash.reduce = reduce;
          lodash.reduceRight = reduceRight;
          lodash.repeat = repeat;
          lodash.replace = replace;
          lodash.result = result;
          lodash.round = round;
          lodash.runInContext = runInContext2;
          lodash.sample = sample;
          lodash.size = size;
          lodash.snakeCase = snakeCase;
          lodash.some = some;
          lodash.sortedIndex = sortedIndex;
          lodash.sortedIndexBy = sortedIndexBy;
          lodash.sortedIndexOf = sortedIndexOf;
          lodash.sortedLastIndex = sortedLastIndex;
          lodash.sortedLastIndexBy = sortedLastIndexBy;
          lodash.sortedLastIndexOf = sortedLastIndexOf;
          lodash.startCase = startCase;
          lodash.startsWith = startsWith;
          lodash.subtract = subtract;
          lodash.sum = sum;
          lodash.sumBy = sumBy;
          lodash.template = template;
          lodash.times = times;
          lodash.toFinite = toFinite;
          lodash.toInteger = toInteger;
          lodash.toLength = toLength;
          lodash.toLower = toLower;
          lodash.toNumber = toNumber;
          lodash.toSafeInteger = toSafeInteger;
          lodash.toString = toString;
          lodash.toUpper = toUpper;
          lodash.trim = trim;
          lodash.trimEnd = trimEnd;
          lodash.trimStart = trimStart;
          lodash.truncate = truncate;
          lodash.unescape = unescape2;
          lodash.uniqueId = uniqueId;
          lodash.upperCase = upperCase;
          lodash.upperFirst = upperFirst;
          lodash.each = forEach;
          lodash.eachRight = forEachRight;
          lodash.first = head;
          mixin(lodash, function() {
            var source = {};
            baseForOwn(lodash, function(func, methodName) {
              if (!hasOwnProperty.call(lodash.prototype, methodName)) {
                source[methodName] = func;
              }
            });
            return source;
          }(), { "chain": false });
          lodash.VERSION = VERSION;
          arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
            lodash[methodName].placeholder = lodash;
          });
          arrayEach(["drop", "take"], function(methodName, index) {
            LazyWrapper.prototype[methodName] = function(n) {
              n = n === undefined2 ? 1 : nativeMax(toInteger(n), 0);
              var result2 = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();
              if (result2.__filtered__) {
                result2.__takeCount__ = nativeMin(n, result2.__takeCount__);
              } else {
                result2.__views__.push({
                  "size": nativeMin(n, MAX_ARRAY_LENGTH),
                  "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
                });
              }
              return result2;
            };
            LazyWrapper.prototype[methodName + "Right"] = function(n) {
              return this.reverse()[methodName](n).reverse();
            };
          });
          arrayEach(["filter", "map", "takeWhile"], function(methodName, index) {
            var type = index + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
            LazyWrapper.prototype[methodName] = function(iteratee2) {
              var result2 = this.clone();
              result2.__iteratees__.push({
                "iteratee": getIteratee(iteratee2, 3),
                "type": type
              });
              result2.__filtered__ = result2.__filtered__ || isFilter;
              return result2;
            };
          });
          arrayEach(["head", "last"], function(methodName, index) {
            var takeName = "take" + (index ? "Right" : "");
            LazyWrapper.prototype[methodName] = function() {
              return this[takeName](1).value()[0];
            };
          });
          arrayEach(["initial", "tail"], function(methodName, index) {
            var dropName = "drop" + (index ? "" : "Right");
            LazyWrapper.prototype[methodName] = function() {
              return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
            };
          });
          LazyWrapper.prototype.compact = function() {
            return this.filter(identity);
          };
          LazyWrapper.prototype.find = function(predicate) {
            return this.filter(predicate).head();
          };
          LazyWrapper.prototype.findLast = function(predicate) {
            return this.reverse().find(predicate);
          };
          LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
            if (typeof path == "function") {
              return new LazyWrapper(this);
            }
            return this.map(function(value) {
              return baseInvoke(value, path, args);
            });
          });
          LazyWrapper.prototype.reject = function(predicate) {
            return this.filter(negate(getIteratee(predicate)));
          };
          LazyWrapper.prototype.slice = function(start2, end) {
            start2 = toInteger(start2);
            var result2 = this;
            if (result2.__filtered__ && (start2 > 0 || end < 0)) {
              return new LazyWrapper(result2);
            }
            if (start2 < 0) {
              result2 = result2.takeRight(-start2);
            } else if (start2) {
              result2 = result2.drop(start2);
            }
            if (end !== undefined2) {
              end = toInteger(end);
              result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start2);
            }
            return result2;
          };
          LazyWrapper.prototype.takeRightWhile = function(predicate) {
            return this.reverse().takeWhile(predicate).reverse();
          };
          LazyWrapper.prototype.toArray = function() {
            return this.take(MAX_ARRAY_LENGTH);
          };
          baseForOwn(LazyWrapper.prototype, function(func, methodName) {
            var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
            if (!lodashFunc) {
              return;
            }
            lodash.prototype[methodName] = function() {
              var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray(value);
              var interceptor = function(value2) {
                var result3 = lodashFunc.apply(lodash, arrayPush([value2], args));
                return isTaker && chainAll ? result3[0] : result3;
              };
              if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
                isLazy = useLazy = false;
              }
              var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
              if (!retUnwrapped && useLazy) {
                value = onlyLazy ? value : new LazyWrapper(this);
                var result2 = func.apply(value, args);
                result2.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined2 });
                return new LodashWrapper(result2, chainAll);
              }
              if (isUnwrapped && onlyLazy) {
                return func.apply(this, args);
              }
              result2 = this.thru(interceptor);
              return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
            };
          });
          arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
            var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
            lodash.prototype[methodName] = function() {
              var args = arguments;
              if (retUnwrapped && !this.__chain__) {
                var value = this.value();
                return func.apply(isArray(value) ? value : [], args);
              }
              return this[chainName](function(value2) {
                return func.apply(isArray(value2) ? value2 : [], args);
              });
            };
          });
          baseForOwn(LazyWrapper.prototype, function(func, methodName) {
            var lodashFunc = lodash[methodName];
            if (lodashFunc) {
              var key = lodashFunc.name + "";
              if (!hasOwnProperty.call(realNames, key)) {
                realNames[key] = [];
              }
              realNames[key].push({ "name": methodName, "func": lodashFunc });
            }
          });
          realNames[createHybrid(undefined2, WRAP_BIND_KEY_FLAG).name] = [{
            "name": "wrapper",
            "func": undefined2
          }];
          LazyWrapper.prototype.clone = lazyClone;
          LazyWrapper.prototype.reverse = lazyReverse;
          LazyWrapper.prototype.value = lazyValue;
          lodash.prototype.at = wrapperAt;
          lodash.prototype.chain = wrapperChain;
          lodash.prototype.commit = wrapperCommit;
          lodash.prototype.next = wrapperNext;
          lodash.prototype.plant = wrapperPlant;
          lodash.prototype.reverse = wrapperReverse;
          lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
          lodash.prototype.first = lodash.prototype.head;
          if (symIterator) {
            lodash.prototype[symIterator] = wrapperToIterator;
          }
          return lodash;
        };
        var _2 = runInContext();
        if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
          root._ = _2;
          define(function() {
            return _2;
          });
        } else if (freeModule) {
          (freeModule.exports = _2)._ = _2;
          freeExports._ = _2;
        } else {
          root._ = _2;
        }
      }).call(exports);
    }
  });

  // node_modules/@hotwired/turbo/dist/turbo.es2017-esm.js
  (function() {
    if (window.Reflect === void 0 || window.customElements === void 0 || window.customElements.polyfillWrapFlushCallback) {
      return;
    }
    const BuiltInHTMLElement = HTMLElement;
    const wrapperForTheName = {
      "HTMLElement": function HTMLElement2() {
        return Reflect.construct(BuiltInHTMLElement, [], this.constructor);
      }
    };
    window.HTMLElement = wrapperForTheName["HTMLElement"];
    HTMLElement.prototype = BuiltInHTMLElement.prototype;
    HTMLElement.prototype.constructor = HTMLElement;
    Object.setPrototypeOf(HTMLElement, BuiltInHTMLElement);
  })();
  (function(prototype) {
    if (typeof prototype.requestSubmit == "function")
      return;
    prototype.requestSubmit = function(submitter) {
      if (submitter) {
        validateSubmitter(submitter, this);
        submitter.click();
      } else {
        submitter = document.createElement("input");
        submitter.type = "submit";
        submitter.hidden = true;
        this.appendChild(submitter);
        submitter.click();
        this.removeChild(submitter);
      }
    };
    function validateSubmitter(submitter, form) {
      submitter instanceof HTMLElement || raise(TypeError, "parameter 1 is not of type 'HTMLElement'");
      submitter.type == "submit" || raise(TypeError, "The specified element is not a submit button");
      submitter.form == form || raise(DOMException, "The specified element is not owned by this form element", "NotFoundError");
    }
    function raise(errorConstructor, message, name) {
      throw new errorConstructor("Failed to execute 'requestSubmit' on 'HTMLFormElement': " + message + ".", name);
    }
  })(HTMLFormElement.prototype);
  var submittersByForm = /* @__PURE__ */ new WeakMap();
  function findSubmitterFromClickTarget(target) {
    const element = target instanceof Element ? target : target instanceof Node ? target.parentElement : null;
    const candidate = element ? element.closest("input, button") : null;
    return (candidate === null || candidate === void 0 ? void 0 : candidate.type) == "submit" ? candidate : null;
  }
  function clickCaptured(event) {
    const submitter = findSubmitterFromClickTarget(event.target);
    if (submitter && submitter.form) {
      submittersByForm.set(submitter.form, submitter);
    }
  }
  (function() {
    if ("submitter" in Event.prototype)
      return;
    let prototype;
    if ("SubmitEvent" in window && /Apple Computer/.test(navigator.vendor)) {
      prototype = window.SubmitEvent.prototype;
    } else if ("SubmitEvent" in window) {
      return;
    } else {
      prototype = window.Event.prototype;
    }
    addEventListener("click", clickCaptured, true);
    Object.defineProperty(prototype, "submitter", {
      get() {
        if (this.type == "submit" && this.target instanceof HTMLFormElement) {
          return submittersByForm.get(this.target);
        }
      }
    });
  })();
  var FrameLoadingStyle;
  (function(FrameLoadingStyle2) {
    FrameLoadingStyle2["eager"] = "eager";
    FrameLoadingStyle2["lazy"] = "lazy";
  })(FrameLoadingStyle || (FrameLoadingStyle = {}));
  var FrameElement = class _FrameElement extends HTMLElement {
    constructor() {
      super();
      this.loaded = Promise.resolve();
      this.delegate = new _FrameElement.delegateConstructor(this);
    }
    static get observedAttributes() {
      return ["disabled", "loading", "src"];
    }
    connectedCallback() {
      this.delegate.connect();
    }
    disconnectedCallback() {
      this.delegate.disconnect();
    }
    reload() {
      const { src } = this;
      this.src = null;
      this.src = src;
    }
    attributeChangedCallback(name) {
      if (name == "loading") {
        this.delegate.loadingStyleChanged();
      } else if (name == "src") {
        this.delegate.sourceURLChanged();
      } else {
        this.delegate.disabledChanged();
      }
    }
    get src() {
      return this.getAttribute("src");
    }
    set src(value) {
      if (value) {
        this.setAttribute("src", value);
      } else {
        this.removeAttribute("src");
      }
    }
    get loading() {
      return frameLoadingStyleFromString(this.getAttribute("loading") || "");
    }
    set loading(value) {
      if (value) {
        this.setAttribute("loading", value);
      } else {
        this.removeAttribute("loading");
      }
    }
    get disabled() {
      return this.hasAttribute("disabled");
    }
    set disabled(value) {
      if (value) {
        this.setAttribute("disabled", "");
      } else {
        this.removeAttribute("disabled");
      }
    }
    get autoscroll() {
      return this.hasAttribute("autoscroll");
    }
    set autoscroll(value) {
      if (value) {
        this.setAttribute("autoscroll", "");
      } else {
        this.removeAttribute("autoscroll");
      }
    }
    get complete() {
      return !this.delegate.isLoading;
    }
    get isActive() {
      return this.ownerDocument === document && !this.isPreview;
    }
    get isPreview() {
      var _a, _b;
      return (_b = (_a = this.ownerDocument) === null || _a === void 0 ? void 0 : _a.documentElement) === null || _b === void 0 ? void 0 : _b.hasAttribute("data-turbo-preview");
    }
  };
  function frameLoadingStyleFromString(style) {
    switch (style.toLowerCase()) {
      case "lazy":
        return FrameLoadingStyle.lazy;
      default:
        return FrameLoadingStyle.eager;
    }
  }
  function expandURL(locatable) {
    return new URL(locatable.toString(), document.baseURI);
  }
  function getAnchor(url) {
    let anchorMatch;
    if (url.hash) {
      return url.hash.slice(1);
    } else if (anchorMatch = url.href.match(/#(.*)$/)) {
      return anchorMatch[1];
    }
  }
  function getAction(form, submitter) {
    const action = (submitter === null || submitter === void 0 ? void 0 : submitter.getAttribute("formaction")) || form.getAttribute("action") || form.action;
    return expandURL(action);
  }
  function getExtension(url) {
    return (getLastPathComponent(url).match(/\.[^.]*$/) || [])[0] || "";
  }
  function isHTML(url) {
    return !!getExtension(url).match(/^(?:|\.(?:htm|html|xhtml))$/);
  }
  function isPrefixedBy(baseURL, url) {
    const prefix = getPrefix(url);
    return baseURL.href === expandURL(prefix).href || baseURL.href.startsWith(prefix);
  }
  function locationIsVisitable(location2, rootLocation) {
    return isPrefixedBy(location2, rootLocation) && isHTML(location2);
  }
  function getRequestURL(url) {
    const anchor = getAnchor(url);
    return anchor != null ? url.href.slice(0, -(anchor.length + 1)) : url.href;
  }
  function toCacheKey(url) {
    return getRequestURL(url);
  }
  function urlsAreEqual(left, right) {
    return expandURL(left).href == expandURL(right).href;
  }
  function getPathComponents(url) {
    return url.pathname.split("/").slice(1);
  }
  function getLastPathComponent(url) {
    return getPathComponents(url).slice(-1)[0];
  }
  function getPrefix(url) {
    return addTrailingSlash(url.origin + url.pathname);
  }
  function addTrailingSlash(value) {
    return value.endsWith("/") ? value : value + "/";
  }
  var FetchResponse = class {
    constructor(response) {
      this.response = response;
    }
    get succeeded() {
      return this.response.ok;
    }
    get failed() {
      return !this.succeeded;
    }
    get clientError() {
      return this.statusCode >= 400 && this.statusCode <= 499;
    }
    get serverError() {
      return this.statusCode >= 500 && this.statusCode <= 599;
    }
    get redirected() {
      return this.response.redirected;
    }
    get location() {
      return expandURL(this.response.url);
    }
    get isHTML() {
      return this.contentType && this.contentType.match(/^(?:text\/([^\s;,]+\b)?html|application\/xhtml\+xml)\b/);
    }
    get statusCode() {
      return this.response.status;
    }
    get contentType() {
      return this.header("Content-Type");
    }
    get responseText() {
      return this.response.clone().text();
    }
    get responseHTML() {
      if (this.isHTML) {
        return this.response.clone().text();
      } else {
        return Promise.resolve(void 0);
      }
    }
    header(name) {
      return this.response.headers.get(name);
    }
  };
  function dispatch(eventName, { target, cancelable, detail } = {}) {
    const event = new CustomEvent(eventName, { cancelable, bubbles: true, detail });
    if (target && target.isConnected) {
      target.dispatchEvent(event);
    } else {
      document.documentElement.dispatchEvent(event);
    }
    return event;
  }
  function nextAnimationFrame() {
    return new Promise((resolve) => requestAnimationFrame(() => resolve()));
  }
  function nextEventLoopTick() {
    return new Promise((resolve) => setTimeout(() => resolve(), 0));
  }
  function nextMicrotask() {
    return Promise.resolve();
  }
  function parseHTMLDocument(html = "") {
    return new DOMParser().parseFromString(html, "text/html");
  }
  function unindent(strings, ...values) {
    const lines = interpolate(strings, values).replace(/^\n/, "").split("\n");
    const match = lines[0].match(/^\s+/);
    const indent = match ? match[0].length : 0;
    return lines.map((line) => line.slice(indent)).join("\n");
  }
  function interpolate(strings, values) {
    return strings.reduce((result, string, i) => {
      const value = values[i] == void 0 ? "" : values[i];
      return result + string + value;
    }, "");
  }
  function uuid() {
    return Array.apply(null, { length: 36 }).map((_2, i) => {
      if (i == 8 || i == 13 || i == 18 || i == 23) {
        return "-";
      } else if (i == 14) {
        return "4";
      } else if (i == 19) {
        return (Math.floor(Math.random() * 4) + 8).toString(16);
      } else {
        return Math.floor(Math.random() * 15).toString(16);
      }
    }).join("");
  }
  function getAttribute(attributeName, ...elements) {
    for (const value of elements.map((element) => element === null || element === void 0 ? void 0 : element.getAttribute(attributeName))) {
      if (typeof value == "string")
        return value;
    }
    return null;
  }
  function markAsBusy(...elements) {
    for (const element of elements) {
      if (element.localName == "turbo-frame") {
        element.setAttribute("busy", "");
      }
      element.setAttribute("aria-busy", "true");
    }
  }
  function clearBusyState(...elements) {
    for (const element of elements) {
      if (element.localName == "turbo-frame") {
        element.removeAttribute("busy");
      }
      element.removeAttribute("aria-busy");
    }
  }
  var FetchMethod;
  (function(FetchMethod2) {
    FetchMethod2[FetchMethod2["get"] = 0] = "get";
    FetchMethod2[FetchMethod2["post"] = 1] = "post";
    FetchMethod2[FetchMethod2["put"] = 2] = "put";
    FetchMethod2[FetchMethod2["patch"] = 3] = "patch";
    FetchMethod2[FetchMethod2["delete"] = 4] = "delete";
  })(FetchMethod || (FetchMethod = {}));
  function fetchMethodFromString(method) {
    switch (method.toLowerCase()) {
      case "get":
        return FetchMethod.get;
      case "post":
        return FetchMethod.post;
      case "put":
        return FetchMethod.put;
      case "patch":
        return FetchMethod.patch;
      case "delete":
        return FetchMethod.delete;
    }
  }
  var FetchRequest = class {
    constructor(delegate, method, location2, body = new URLSearchParams(), target = null) {
      this.abortController = new AbortController();
      this.resolveRequestPromise = (value) => {
      };
      this.delegate = delegate;
      this.method = method;
      this.headers = this.defaultHeaders;
      this.body = body;
      this.url = location2;
      this.target = target;
    }
    get location() {
      return this.url;
    }
    get params() {
      return this.url.searchParams;
    }
    get entries() {
      return this.body ? Array.from(this.body.entries()) : [];
    }
    cancel() {
      this.abortController.abort();
    }
    async perform() {
      var _a, _b;
      const { fetchOptions } = this;
      (_b = (_a = this.delegate).prepareHeadersForRequest) === null || _b === void 0 ? void 0 : _b.call(_a, this.headers, this);
      await this.allowRequestToBeIntercepted(fetchOptions);
      try {
        this.delegate.requestStarted(this);
        const response = await fetch(this.url.href, fetchOptions);
        return await this.receive(response);
      } catch (error2) {
        if (error2.name !== "AbortError") {
          this.delegate.requestErrored(this, error2);
          throw error2;
        }
      } finally {
        this.delegate.requestFinished(this);
      }
    }
    async receive(response) {
      const fetchResponse = new FetchResponse(response);
      const event = dispatch("turbo:before-fetch-response", { cancelable: true, detail: { fetchResponse }, target: this.target });
      if (event.defaultPrevented) {
        this.delegate.requestPreventedHandlingResponse(this, fetchResponse);
      } else if (fetchResponse.succeeded) {
        this.delegate.requestSucceededWithResponse(this, fetchResponse);
      } else {
        this.delegate.requestFailedWithResponse(this, fetchResponse);
      }
      return fetchResponse;
    }
    get fetchOptions() {
      var _a;
      return {
        method: FetchMethod[this.method].toUpperCase(),
        credentials: "same-origin",
        headers: this.headers,
        redirect: "follow",
        body: this.isIdempotent ? null : this.body,
        signal: this.abortSignal,
        referrer: (_a = this.delegate.referrer) === null || _a === void 0 ? void 0 : _a.href
      };
    }
    get defaultHeaders() {
      return {
        "Accept": "text/html, application/xhtml+xml"
      };
    }
    get isIdempotent() {
      return this.method == FetchMethod.get;
    }
    get abortSignal() {
      return this.abortController.signal;
    }
    async allowRequestToBeIntercepted(fetchOptions) {
      const requestInterception = new Promise((resolve) => this.resolveRequestPromise = resolve);
      const event = dispatch("turbo:before-fetch-request", {
        cancelable: true,
        detail: {
          fetchOptions,
          url: this.url,
          resume: this.resolveRequestPromise
        },
        target: this.target
      });
      if (event.defaultPrevented)
        await requestInterception;
    }
  };
  var AppearanceObserver = class {
    constructor(delegate, element) {
      this.started = false;
      this.intersect = (entries) => {
        const lastEntry = entries.slice(-1)[0];
        if (lastEntry === null || lastEntry === void 0 ? void 0 : lastEntry.isIntersecting) {
          this.delegate.elementAppearedInViewport(this.element);
        }
      };
      this.delegate = delegate;
      this.element = element;
      this.intersectionObserver = new IntersectionObserver(this.intersect);
    }
    start() {
      if (!this.started) {
        this.started = true;
        this.intersectionObserver.observe(this.element);
      }
    }
    stop() {
      if (this.started) {
        this.started = false;
        this.intersectionObserver.unobserve(this.element);
      }
    }
  };
  var StreamMessage = class {
    constructor(html) {
      this.templateElement = document.createElement("template");
      this.templateElement.innerHTML = html;
    }
    static wrap(message) {
      if (typeof message == "string") {
        return new this(message);
      } else {
        return message;
      }
    }
    get fragment() {
      const fragment2 = document.createDocumentFragment();
      for (const element of this.foreignElements) {
        fragment2.appendChild(document.importNode(element, true));
      }
      return fragment2;
    }
    get foreignElements() {
      return this.templateChildren.reduce((streamElements, child) => {
        if (child.tagName.toLowerCase() == "turbo-stream") {
          return [...streamElements, child];
        } else {
          return streamElements;
        }
      }, []);
    }
    get templateChildren() {
      return Array.from(this.templateElement.content.children);
    }
  };
  StreamMessage.contentType = "text/vnd.turbo-stream.html";
  var FormSubmissionState;
  (function(FormSubmissionState2) {
    FormSubmissionState2[FormSubmissionState2["initialized"] = 0] = "initialized";
    FormSubmissionState2[FormSubmissionState2["requesting"] = 1] = "requesting";
    FormSubmissionState2[FormSubmissionState2["waiting"] = 2] = "waiting";
    FormSubmissionState2[FormSubmissionState2["receiving"] = 3] = "receiving";
    FormSubmissionState2[FormSubmissionState2["stopping"] = 4] = "stopping";
    FormSubmissionState2[FormSubmissionState2["stopped"] = 5] = "stopped";
  })(FormSubmissionState || (FormSubmissionState = {}));
  var FormEnctype;
  (function(FormEnctype2) {
    FormEnctype2["urlEncoded"] = "application/x-www-form-urlencoded";
    FormEnctype2["multipart"] = "multipart/form-data";
    FormEnctype2["plain"] = "text/plain";
  })(FormEnctype || (FormEnctype = {}));
  function formEnctypeFromString(encoding) {
    switch (encoding.toLowerCase()) {
      case FormEnctype.multipart:
        return FormEnctype.multipart;
      case FormEnctype.plain:
        return FormEnctype.plain;
      default:
        return FormEnctype.urlEncoded;
    }
  }
  var FormSubmission = class _FormSubmission {
    constructor(delegate, formElement, submitter, mustRedirect = false) {
      this.state = FormSubmissionState.initialized;
      this.delegate = delegate;
      this.formElement = formElement;
      this.submitter = submitter;
      this.formData = buildFormData(formElement, submitter);
      this.location = expandURL(this.action);
      if (this.method == FetchMethod.get) {
        mergeFormDataEntries(this.location, [...this.body.entries()]);
      }
      this.fetchRequest = new FetchRequest(this, this.method, this.location, this.body, this.formElement);
      this.mustRedirect = mustRedirect;
    }
    static confirmMethod(message, element) {
      return confirm(message);
    }
    get method() {
      var _a;
      const method = ((_a = this.submitter) === null || _a === void 0 ? void 0 : _a.getAttribute("formmethod")) || this.formElement.getAttribute("method") || "";
      return fetchMethodFromString(method.toLowerCase()) || FetchMethod.get;
    }
    get action() {
      var _a;
      const formElementAction = typeof this.formElement.action === "string" ? this.formElement.action : null;
      return ((_a = this.submitter) === null || _a === void 0 ? void 0 : _a.getAttribute("formaction")) || this.formElement.getAttribute("action") || formElementAction || "";
    }
    get body() {
      if (this.enctype == FormEnctype.urlEncoded || this.method == FetchMethod.get) {
        return new URLSearchParams(this.stringFormData);
      } else {
        return this.formData;
      }
    }
    get enctype() {
      var _a;
      return formEnctypeFromString(((_a = this.submitter) === null || _a === void 0 ? void 0 : _a.getAttribute("formenctype")) || this.formElement.enctype);
    }
    get isIdempotent() {
      return this.fetchRequest.isIdempotent;
    }
    get stringFormData() {
      return [...this.formData].reduce((entries, [name, value]) => {
        return entries.concat(typeof value == "string" ? [[name, value]] : []);
      }, []);
    }
    get confirmationMessage() {
      return this.formElement.getAttribute("data-turbo-confirm");
    }
    get needsConfirmation() {
      return this.confirmationMessage !== null;
    }
    async start() {
      const { initialized, requesting } = FormSubmissionState;
      if (this.needsConfirmation) {
        const answer = _FormSubmission.confirmMethod(this.confirmationMessage, this.formElement);
        if (!answer) {
          return;
        }
      }
      if (this.state == initialized) {
        this.state = requesting;
        return this.fetchRequest.perform();
      }
    }
    stop() {
      const { stopping, stopped } = FormSubmissionState;
      if (this.state != stopping && this.state != stopped) {
        this.state = stopping;
        this.fetchRequest.cancel();
        return true;
      }
    }
    prepareHeadersForRequest(headers, request) {
      if (!request.isIdempotent) {
        const token = getCookieValue(getMetaContent("csrf-param")) || getMetaContent("csrf-token");
        if (token) {
          headers["X-CSRF-Token"] = token;
        }
        headers["Accept"] = [StreamMessage.contentType, headers["Accept"]].join(", ");
      }
    }
    requestStarted(request) {
      var _a;
      this.state = FormSubmissionState.waiting;
      (_a = this.submitter) === null || _a === void 0 ? void 0 : _a.setAttribute("disabled", "");
      dispatch("turbo:submit-start", { target: this.formElement, detail: { formSubmission: this } });
      this.delegate.formSubmissionStarted(this);
    }
    requestPreventedHandlingResponse(request, response) {
      this.result = { success: response.succeeded, fetchResponse: response };
    }
    requestSucceededWithResponse(request, response) {
      if (response.clientError || response.serverError) {
        this.delegate.formSubmissionFailedWithResponse(this, response);
      } else if (this.requestMustRedirect(request) && responseSucceededWithoutRedirect(response)) {
        const error2 = new Error("Form responses must redirect to another location");
        this.delegate.formSubmissionErrored(this, error2);
      } else {
        this.state = FormSubmissionState.receiving;
        this.result = { success: true, fetchResponse: response };
        this.delegate.formSubmissionSucceededWithResponse(this, response);
      }
    }
    requestFailedWithResponse(request, response) {
      this.result = { success: false, fetchResponse: response };
      this.delegate.formSubmissionFailedWithResponse(this, response);
    }
    requestErrored(request, error2) {
      this.result = { success: false, error: error2 };
      this.delegate.formSubmissionErrored(this, error2);
    }
    requestFinished(request) {
      var _a;
      this.state = FormSubmissionState.stopped;
      (_a = this.submitter) === null || _a === void 0 ? void 0 : _a.removeAttribute("disabled");
      dispatch("turbo:submit-end", { target: this.formElement, detail: Object.assign({ formSubmission: this }, this.result) });
      this.delegate.formSubmissionFinished(this);
    }
    requestMustRedirect(request) {
      return !request.isIdempotent && this.mustRedirect;
    }
  };
  function buildFormData(formElement, submitter) {
    const formData = new FormData(formElement);
    const name = submitter === null || submitter === void 0 ? void 0 : submitter.getAttribute("name");
    const value = submitter === null || submitter === void 0 ? void 0 : submitter.getAttribute("value");
    if (name && value != null && formData.get(name) != value) {
      formData.append(name, value);
    }
    return formData;
  }
  function getCookieValue(cookieName) {
    if (cookieName != null) {
      const cookies = document.cookie ? document.cookie.split("; ") : [];
      const cookie = cookies.find((cookie2) => cookie2.startsWith(cookieName));
      if (cookie) {
        const value = cookie.split("=").slice(1).join("=");
        return value ? decodeURIComponent(value) : void 0;
      }
    }
  }
  function getMetaContent(name) {
    const element = document.querySelector(`meta[name="${name}"]`);
    return element && element.content;
  }
  function responseSucceededWithoutRedirect(response) {
    return response.statusCode == 200 && !response.redirected;
  }
  function mergeFormDataEntries(url, entries) {
    const searchParams = new URLSearchParams();
    for (const [name, value] of entries) {
      if (value instanceof File)
        continue;
      searchParams.append(name, value);
    }
    url.search = searchParams.toString();
    return url;
  }
  var Snapshot = class {
    constructor(element) {
      this.element = element;
    }
    get children() {
      return [...this.element.children];
    }
    hasAnchor(anchor) {
      return this.getElementForAnchor(anchor) != null;
    }
    getElementForAnchor(anchor) {
      return anchor ? this.element.querySelector(`[id='${anchor}'], a[name='${anchor}']`) : null;
    }
    get isConnected() {
      return this.element.isConnected;
    }
    get firstAutofocusableElement() {
      return this.element.querySelector("[autofocus]");
    }
    get permanentElements() {
      return [...this.element.querySelectorAll("[id][data-turbo-permanent]")];
    }
    getPermanentElementById(id) {
      return this.element.querySelector(`#${id}[data-turbo-permanent]`);
    }
    getPermanentElementMapForSnapshot(snapshot) {
      const permanentElementMap = {};
      for (const currentPermanentElement of this.permanentElements) {
        const { id } = currentPermanentElement;
        const newPermanentElement = snapshot.getPermanentElementById(id);
        if (newPermanentElement) {
          permanentElementMap[id] = [currentPermanentElement, newPermanentElement];
        }
      }
      return permanentElementMap;
    }
  };
  var FormInterceptor = class {
    constructor(delegate, element) {
      this.submitBubbled = (event) => {
        const form = event.target;
        if (!event.defaultPrevented && form instanceof HTMLFormElement && form.closest("turbo-frame, html") == this.element) {
          const submitter = event.submitter || void 0;
          const method = (submitter === null || submitter === void 0 ? void 0 : submitter.getAttribute("formmethod")) || form.method;
          if (method != "dialog" && this.delegate.shouldInterceptFormSubmission(form, submitter)) {
            event.preventDefault();
            event.stopImmediatePropagation();
            this.delegate.formSubmissionIntercepted(form, submitter);
          }
        }
      };
      this.delegate = delegate;
      this.element = element;
    }
    start() {
      this.element.addEventListener("submit", this.submitBubbled);
    }
    stop() {
      this.element.removeEventListener("submit", this.submitBubbled);
    }
  };
  var View = class {
    constructor(delegate, element) {
      this.resolveRenderPromise = (value) => {
      };
      this.resolveInterceptionPromise = (value) => {
      };
      this.delegate = delegate;
      this.element = element;
    }
    scrollToAnchor(anchor) {
      const element = this.snapshot.getElementForAnchor(anchor);
      if (element) {
        this.scrollToElement(element);
        this.focusElement(element);
      } else {
        this.scrollToPosition({ x: 0, y: 0 });
      }
    }
    scrollToAnchorFromLocation(location2) {
      this.scrollToAnchor(getAnchor(location2));
    }
    scrollToElement(element) {
      element.scrollIntoView();
    }
    focusElement(element) {
      if (element instanceof HTMLElement) {
        if (element.hasAttribute("tabindex")) {
          element.focus();
        } else {
          element.setAttribute("tabindex", "-1");
          element.focus();
          element.removeAttribute("tabindex");
        }
      }
    }
    scrollToPosition({ x, y }) {
      this.scrollRoot.scrollTo(x, y);
    }
    scrollToTop() {
      this.scrollToPosition({ x: 0, y: 0 });
    }
    get scrollRoot() {
      return window;
    }
    async render(renderer) {
      const { isPreview, shouldRender, newSnapshot: snapshot } = renderer;
      if (shouldRender) {
        try {
          this.renderPromise = new Promise((resolve) => this.resolveRenderPromise = resolve);
          this.renderer = renderer;
          this.prepareToRenderSnapshot(renderer);
          const renderInterception = new Promise((resolve) => this.resolveInterceptionPromise = resolve);
          const immediateRender = this.delegate.allowsImmediateRender(snapshot, this.resolveInterceptionPromise);
          if (!immediateRender)
            await renderInterception;
          await this.renderSnapshot(renderer);
          this.delegate.viewRenderedSnapshot(snapshot, isPreview);
          this.finishRenderingSnapshot(renderer);
        } finally {
          delete this.renderer;
          this.resolveRenderPromise(void 0);
          delete this.renderPromise;
        }
      } else {
        this.invalidate();
      }
    }
    invalidate() {
      this.delegate.viewInvalidated();
    }
    prepareToRenderSnapshot(renderer) {
      this.markAsPreview(renderer.isPreview);
      renderer.prepareToRender();
    }
    markAsPreview(isPreview) {
      if (isPreview) {
        this.element.setAttribute("data-turbo-preview", "");
      } else {
        this.element.removeAttribute("data-turbo-preview");
      }
    }
    async renderSnapshot(renderer) {
      await renderer.render();
    }
    finishRenderingSnapshot(renderer) {
      renderer.finishRendering();
    }
  };
  var FrameView = class extends View {
    invalidate() {
      this.element.innerHTML = "";
    }
    get snapshot() {
      return new Snapshot(this.element);
    }
  };
  var LinkInterceptor = class {
    constructor(delegate, element) {
      this.clickBubbled = (event) => {
        if (this.respondsToEventTarget(event.target)) {
          this.clickEvent = event;
        } else {
          delete this.clickEvent;
        }
      };
      this.linkClicked = (event) => {
        if (this.clickEvent && this.respondsToEventTarget(event.target) && event.target instanceof Element) {
          if (this.delegate.shouldInterceptLinkClick(event.target, event.detail.url)) {
            this.clickEvent.preventDefault();
            event.preventDefault();
            this.delegate.linkClickIntercepted(event.target, event.detail.url);
          }
        }
        delete this.clickEvent;
      };
      this.willVisit = () => {
        delete this.clickEvent;
      };
      this.delegate = delegate;
      this.element = element;
    }
    start() {
      this.element.addEventListener("click", this.clickBubbled);
      document.addEventListener("turbo:click", this.linkClicked);
      document.addEventListener("turbo:before-visit", this.willVisit);
    }
    stop() {
      this.element.removeEventListener("click", this.clickBubbled);
      document.removeEventListener("turbo:click", this.linkClicked);
      document.removeEventListener("turbo:before-visit", this.willVisit);
    }
    respondsToEventTarget(target) {
      const element = target instanceof Element ? target : target instanceof Node ? target.parentElement : null;
      return element && element.closest("turbo-frame, html") == this.element;
    }
  };
  var Bardo = class {
    constructor(permanentElementMap) {
      this.permanentElementMap = permanentElementMap;
    }
    static preservingPermanentElements(permanentElementMap, callback) {
      const bardo = new this(permanentElementMap);
      bardo.enter();
      callback();
      bardo.leave();
    }
    enter() {
      for (const id in this.permanentElementMap) {
        const [, newPermanentElement] = this.permanentElementMap[id];
        this.replaceNewPermanentElementWithPlaceholder(newPermanentElement);
      }
    }
    leave() {
      for (const id in this.permanentElementMap) {
        const [currentPermanentElement] = this.permanentElementMap[id];
        this.replaceCurrentPermanentElementWithClone(currentPermanentElement);
        this.replacePlaceholderWithPermanentElement(currentPermanentElement);
      }
    }
    replaceNewPermanentElementWithPlaceholder(permanentElement) {
      const placeholder = createPlaceholderForPermanentElement(permanentElement);
      permanentElement.replaceWith(placeholder);
    }
    replaceCurrentPermanentElementWithClone(permanentElement) {
      const clone = permanentElement.cloneNode(true);
      permanentElement.replaceWith(clone);
    }
    replacePlaceholderWithPermanentElement(permanentElement) {
      const placeholder = this.getPlaceholderById(permanentElement.id);
      placeholder === null || placeholder === void 0 ? void 0 : placeholder.replaceWith(permanentElement);
    }
    getPlaceholderById(id) {
      return this.placeholders.find((element) => element.content == id);
    }
    get placeholders() {
      return [...document.querySelectorAll("meta[name=turbo-permanent-placeholder][content]")];
    }
  };
  function createPlaceholderForPermanentElement(permanentElement) {
    const element = document.createElement("meta");
    element.setAttribute("name", "turbo-permanent-placeholder");
    element.setAttribute("content", permanentElement.id);
    return element;
  }
  var Renderer = class {
    constructor(currentSnapshot, newSnapshot, isPreview, willRender = true) {
      this.currentSnapshot = currentSnapshot;
      this.newSnapshot = newSnapshot;
      this.isPreview = isPreview;
      this.willRender = willRender;
      this.promise = new Promise((resolve, reject) => this.resolvingFunctions = { resolve, reject });
    }
    get shouldRender() {
      return true;
    }
    prepareToRender() {
      return;
    }
    finishRendering() {
      if (this.resolvingFunctions) {
        this.resolvingFunctions.resolve();
        delete this.resolvingFunctions;
      }
    }
    createScriptElement(element) {
      if (element.getAttribute("data-turbo-eval") == "false") {
        return element;
      } else {
        const createdScriptElement = document.createElement("script");
        if (this.cspNonce) {
          createdScriptElement.nonce = this.cspNonce;
        }
        createdScriptElement.textContent = element.textContent;
        createdScriptElement.async = false;
        copyElementAttributes(createdScriptElement, element);
        return createdScriptElement;
      }
    }
    preservingPermanentElements(callback) {
      Bardo.preservingPermanentElements(this.permanentElementMap, callback);
    }
    focusFirstAutofocusableElement() {
      const element = this.connectedSnapshot.firstAutofocusableElement;
      if (elementIsFocusable(element)) {
        element.focus();
      }
    }
    get connectedSnapshot() {
      return this.newSnapshot.isConnected ? this.newSnapshot : this.currentSnapshot;
    }
    get currentElement() {
      return this.currentSnapshot.element;
    }
    get newElement() {
      return this.newSnapshot.element;
    }
    get permanentElementMap() {
      return this.currentSnapshot.getPermanentElementMapForSnapshot(this.newSnapshot);
    }
    get cspNonce() {
      var _a;
      return (_a = document.head.querySelector('meta[name="csp-nonce"]')) === null || _a === void 0 ? void 0 : _a.getAttribute("content");
    }
  };
  function copyElementAttributes(destinationElement, sourceElement) {
    for (const { name, value } of [...sourceElement.attributes]) {
      destinationElement.setAttribute(name, value);
    }
  }
  function elementIsFocusable(element) {
    return element && typeof element.focus == "function";
  }
  var FrameRenderer = class extends Renderer {
    get shouldRender() {
      return true;
    }
    async render() {
      await nextAnimationFrame();
      this.preservingPermanentElements(() => {
        this.loadFrameElement();
      });
      this.scrollFrameIntoView();
      await nextAnimationFrame();
      this.focusFirstAutofocusableElement();
      await nextAnimationFrame();
      this.activateScriptElements();
    }
    loadFrameElement() {
      var _a;
      const destinationRange = document.createRange();
      destinationRange.selectNodeContents(this.currentElement);
      destinationRange.deleteContents();
      const frameElement = this.newElement;
      const sourceRange = (_a = frameElement.ownerDocument) === null || _a === void 0 ? void 0 : _a.createRange();
      if (sourceRange) {
        sourceRange.selectNodeContents(frameElement);
        this.currentElement.appendChild(sourceRange.extractContents());
      }
    }
    scrollFrameIntoView() {
      if (this.currentElement.autoscroll || this.newElement.autoscroll) {
        const element = this.currentElement.firstElementChild;
        const block = readScrollLogicalPosition(this.currentElement.getAttribute("data-autoscroll-block"), "end");
        if (element) {
          element.scrollIntoView({ block });
          return true;
        }
      }
      return false;
    }
    activateScriptElements() {
      for (const inertScriptElement of this.newScriptElements) {
        const activatedScriptElement = this.createScriptElement(inertScriptElement);
        inertScriptElement.replaceWith(activatedScriptElement);
      }
    }
    get newScriptElements() {
      return this.currentElement.querySelectorAll("script");
    }
  };
  function readScrollLogicalPosition(value, defaultValue) {
    if (value == "end" || value == "start" || value == "center" || value == "nearest") {
      return value;
    } else {
      return defaultValue;
    }
  }
  var ProgressBar = class _ProgressBar {
    constructor() {
      this.hiding = false;
      this.value = 0;
      this.visible = false;
      this.trickle = () => {
        this.setValue(this.value + Math.random() / 100);
      };
      this.stylesheetElement = this.createStylesheetElement();
      this.progressElement = this.createProgressElement();
      this.installStylesheetElement();
      this.setValue(0);
    }
    static get defaultCSS() {
      return unindent`
      .turbo-progress-bar {
        position: fixed;
        display: block;
        top: 0;
        left: 0;
        height: 3px;
        background: #0076ff;
        z-index: 9999;
        transition:
          width ${_ProgressBar.animationDuration}ms ease-out,
          opacity ${_ProgressBar.animationDuration / 2}ms ${_ProgressBar.animationDuration / 2}ms ease-in;
        transform: translate3d(0, 0, 0);
      }
    `;
    }
    show() {
      if (!this.visible) {
        this.visible = true;
        this.installProgressElement();
        this.startTrickling();
      }
    }
    hide() {
      if (this.visible && !this.hiding) {
        this.hiding = true;
        this.fadeProgressElement(() => {
          this.uninstallProgressElement();
          this.stopTrickling();
          this.visible = false;
          this.hiding = false;
        });
      }
    }
    setValue(value) {
      this.value = value;
      this.refresh();
    }
    installStylesheetElement() {
      document.head.insertBefore(this.stylesheetElement, document.head.firstChild);
    }
    installProgressElement() {
      this.progressElement.style.width = "0";
      this.progressElement.style.opacity = "1";
      document.documentElement.insertBefore(this.progressElement, document.body);
      this.refresh();
    }
    fadeProgressElement(callback) {
      this.progressElement.style.opacity = "0";
      setTimeout(callback, _ProgressBar.animationDuration * 1.5);
    }
    uninstallProgressElement() {
      if (this.progressElement.parentNode) {
        document.documentElement.removeChild(this.progressElement);
      }
    }
    startTrickling() {
      if (!this.trickleInterval) {
        this.trickleInterval = window.setInterval(this.trickle, _ProgressBar.animationDuration);
      }
    }
    stopTrickling() {
      window.clearInterval(this.trickleInterval);
      delete this.trickleInterval;
    }
    refresh() {
      requestAnimationFrame(() => {
        this.progressElement.style.width = `${10 + this.value * 90}%`;
      });
    }
    createStylesheetElement() {
      const element = document.createElement("style");
      element.type = "text/css";
      element.textContent = _ProgressBar.defaultCSS;
      return element;
    }
    createProgressElement() {
      const element = document.createElement("div");
      element.className = "turbo-progress-bar";
      return element;
    }
  };
  ProgressBar.animationDuration = 300;
  var HeadSnapshot = class extends Snapshot {
    constructor() {
      super(...arguments);
      this.detailsByOuterHTML = this.children.filter((element) => !elementIsNoscript(element)).map((element) => elementWithoutNonce(element)).reduce((result, element) => {
        const { outerHTML } = element;
        const details = outerHTML in result ? result[outerHTML] : {
          type: elementType(element),
          tracked: elementIsTracked(element),
          elements: []
        };
        return Object.assign(Object.assign({}, result), { [outerHTML]: Object.assign(Object.assign({}, details), { elements: [...details.elements, element] }) });
      }, {});
    }
    get trackedElementSignature() {
      return Object.keys(this.detailsByOuterHTML).filter((outerHTML) => this.detailsByOuterHTML[outerHTML].tracked).join("");
    }
    getScriptElementsNotInSnapshot(snapshot) {
      return this.getElementsMatchingTypeNotInSnapshot("script", snapshot);
    }
    getStylesheetElementsNotInSnapshot(snapshot) {
      return this.getElementsMatchingTypeNotInSnapshot("stylesheet", snapshot);
    }
    getElementsMatchingTypeNotInSnapshot(matchedType, snapshot) {
      return Object.keys(this.detailsByOuterHTML).filter((outerHTML) => !(outerHTML in snapshot.detailsByOuterHTML)).map((outerHTML) => this.detailsByOuterHTML[outerHTML]).filter(({ type }) => type == matchedType).map(({ elements: [element] }) => element);
    }
    get provisionalElements() {
      return Object.keys(this.detailsByOuterHTML).reduce((result, outerHTML) => {
        const { type, tracked, elements } = this.detailsByOuterHTML[outerHTML];
        if (type == null && !tracked) {
          return [...result, ...elements];
        } else if (elements.length > 1) {
          return [...result, ...elements.slice(1)];
        } else {
          return result;
        }
      }, []);
    }
    getMetaValue(name) {
      const element = this.findMetaElementByName(name);
      return element ? element.getAttribute("content") : null;
    }
    findMetaElementByName(name) {
      return Object.keys(this.detailsByOuterHTML).reduce((result, outerHTML) => {
        const { elements: [element] } = this.detailsByOuterHTML[outerHTML];
        return elementIsMetaElementWithName(element, name) ? element : result;
      }, void 0);
    }
  };
  function elementType(element) {
    if (elementIsScript(element)) {
      return "script";
    } else if (elementIsStylesheet(element)) {
      return "stylesheet";
    }
  }
  function elementIsTracked(element) {
    return element.getAttribute("data-turbo-track") == "reload";
  }
  function elementIsScript(element) {
    const tagName = element.tagName.toLowerCase();
    return tagName == "script";
  }
  function elementIsNoscript(element) {
    const tagName = element.tagName.toLowerCase();
    return tagName == "noscript";
  }
  function elementIsStylesheet(element) {
    const tagName = element.tagName.toLowerCase();
    return tagName == "style" || tagName == "link" && element.getAttribute("rel") == "stylesheet";
  }
  function elementIsMetaElementWithName(element, name) {
    const tagName = element.tagName.toLowerCase();
    return tagName == "meta" && element.getAttribute("name") == name;
  }
  function elementWithoutNonce(element) {
    if (element.hasAttribute("nonce")) {
      element.setAttribute("nonce", "");
    }
    return element;
  }
  var PageSnapshot = class _PageSnapshot extends Snapshot {
    constructor(element, headSnapshot) {
      super(element);
      this.headSnapshot = headSnapshot;
    }
    static fromHTMLString(html = "") {
      return this.fromDocument(parseHTMLDocument(html));
    }
    static fromElement(element) {
      return this.fromDocument(element.ownerDocument);
    }
    static fromDocument({ head, body }) {
      return new this(body, new HeadSnapshot(head));
    }
    clone() {
      return new _PageSnapshot(this.element.cloneNode(true), this.headSnapshot);
    }
    get headElement() {
      return this.headSnapshot.element;
    }
    get rootLocation() {
      var _a;
      const root = (_a = this.getSetting("root")) !== null && _a !== void 0 ? _a : "/";
      return expandURL(root);
    }
    get cacheControlValue() {
      return this.getSetting("cache-control");
    }
    get isPreviewable() {
      return this.cacheControlValue != "no-preview";
    }
    get isCacheable() {
      return this.cacheControlValue != "no-cache";
    }
    get isVisitable() {
      return this.getSetting("visit-control") != "reload";
    }
    getSetting(name) {
      return this.headSnapshot.getMetaValue(`turbo-${name}`);
    }
  };
  var TimingMetric;
  (function(TimingMetric2) {
    TimingMetric2["visitStart"] = "visitStart";
    TimingMetric2["requestStart"] = "requestStart";
    TimingMetric2["requestEnd"] = "requestEnd";
    TimingMetric2["visitEnd"] = "visitEnd";
  })(TimingMetric || (TimingMetric = {}));
  var VisitState;
  (function(VisitState2) {
    VisitState2["initialized"] = "initialized";
    VisitState2["started"] = "started";
    VisitState2["canceled"] = "canceled";
    VisitState2["failed"] = "failed";
    VisitState2["completed"] = "completed";
  })(VisitState || (VisitState = {}));
  var defaultOptions = {
    action: "advance",
    historyChanged: false,
    visitCachedSnapshot: () => {
    },
    willRender: true
  };
  var SystemStatusCode;
  (function(SystemStatusCode2) {
    SystemStatusCode2[SystemStatusCode2["networkFailure"] = 0] = "networkFailure";
    SystemStatusCode2[SystemStatusCode2["timeoutFailure"] = -1] = "timeoutFailure";
    SystemStatusCode2[SystemStatusCode2["contentTypeMismatch"] = -2] = "contentTypeMismatch";
  })(SystemStatusCode || (SystemStatusCode = {}));
  var Visit = class {
    constructor(delegate, location2, restorationIdentifier, options = {}) {
      this.identifier = uuid();
      this.timingMetrics = {};
      this.followedRedirect = false;
      this.historyChanged = false;
      this.scrolled = false;
      this.snapshotCached = false;
      this.state = VisitState.initialized;
      this.delegate = delegate;
      this.location = location2;
      this.restorationIdentifier = restorationIdentifier || uuid();
      const { action, historyChanged, referrer, snapshotHTML, response, visitCachedSnapshot, willRender } = Object.assign(Object.assign({}, defaultOptions), options);
      this.action = action;
      this.historyChanged = historyChanged;
      this.referrer = referrer;
      this.snapshotHTML = snapshotHTML;
      this.response = response;
      this.isSamePage = this.delegate.locationWithActionIsSamePage(this.location, this.action);
      this.visitCachedSnapshot = visitCachedSnapshot;
      this.willRender = willRender;
      this.scrolled = !willRender;
    }
    get adapter() {
      return this.delegate.adapter;
    }
    get view() {
      return this.delegate.view;
    }
    get history() {
      return this.delegate.history;
    }
    get restorationData() {
      return this.history.getRestorationDataForIdentifier(this.restorationIdentifier);
    }
    get silent() {
      return this.isSamePage;
    }
    start() {
      if (this.state == VisitState.initialized) {
        this.recordTimingMetric(TimingMetric.visitStart);
        this.state = VisitState.started;
        this.adapter.visitStarted(this);
        this.delegate.visitStarted(this);
      }
    }
    cancel() {
      if (this.state == VisitState.started) {
        if (this.request) {
          this.request.cancel();
        }
        this.cancelRender();
        this.state = VisitState.canceled;
      }
    }
    complete() {
      if (this.state == VisitState.started) {
        this.recordTimingMetric(TimingMetric.visitEnd);
        this.state = VisitState.completed;
        this.adapter.visitCompleted(this);
        this.delegate.visitCompleted(this);
        this.followRedirect();
      }
    }
    fail() {
      if (this.state == VisitState.started) {
        this.state = VisitState.failed;
        this.adapter.visitFailed(this);
      }
    }
    changeHistory() {
      var _a;
      if (!this.historyChanged) {
        const actionForHistory = this.location.href === ((_a = this.referrer) === null || _a === void 0 ? void 0 : _a.href) ? "replace" : this.action;
        const method = this.getHistoryMethodForAction(actionForHistory);
        this.history.update(method, this.location, this.restorationIdentifier);
        this.historyChanged = true;
      }
    }
    issueRequest() {
      if (this.hasPreloadedResponse()) {
        this.simulateRequest();
      } else if (this.shouldIssueRequest() && !this.request) {
        this.request = new FetchRequest(this, FetchMethod.get, this.location);
        this.request.perform();
      }
    }
    simulateRequest() {
      if (this.response) {
        this.startRequest();
        this.recordResponse();
        this.finishRequest();
      }
    }
    startRequest() {
      this.recordTimingMetric(TimingMetric.requestStart);
      this.adapter.visitRequestStarted(this);
    }
    recordResponse(response = this.response) {
      this.response = response;
      if (response) {
        const { statusCode } = response;
        if (isSuccessful(statusCode)) {
          this.adapter.visitRequestCompleted(this);
        } else {
          this.adapter.visitRequestFailedWithStatusCode(this, statusCode);
        }
      }
    }
    finishRequest() {
      this.recordTimingMetric(TimingMetric.requestEnd);
      this.adapter.visitRequestFinished(this);
    }
    loadResponse() {
      if (this.response) {
        const { statusCode, responseHTML } = this.response;
        this.render(async () => {
          this.cacheSnapshot();
          if (this.view.renderPromise)
            await this.view.renderPromise;
          if (isSuccessful(statusCode) && responseHTML != null) {
            await this.view.renderPage(PageSnapshot.fromHTMLString(responseHTML), false, this.willRender);
            this.adapter.visitRendered(this);
            this.complete();
          } else {
            await this.view.renderError(PageSnapshot.fromHTMLString(responseHTML));
            this.adapter.visitRendered(this);
            this.fail();
          }
        });
      }
    }
    getCachedSnapshot() {
      const snapshot = this.view.getCachedSnapshotForLocation(this.location) || this.getPreloadedSnapshot();
      if (snapshot && (!getAnchor(this.location) || snapshot.hasAnchor(getAnchor(this.location)))) {
        if (this.action == "restore" || snapshot.isPreviewable) {
          return snapshot;
        }
      }
    }
    getPreloadedSnapshot() {
      if (this.snapshotHTML) {
        return PageSnapshot.fromHTMLString(this.snapshotHTML);
      }
    }
    hasCachedSnapshot() {
      return this.getCachedSnapshot() != null;
    }
    loadCachedSnapshot() {
      const snapshot = this.getCachedSnapshot();
      if (snapshot) {
        const isPreview = this.shouldIssueRequest();
        this.render(async () => {
          this.cacheSnapshot();
          if (this.isSamePage) {
            this.adapter.visitRendered(this);
          } else {
            if (this.view.renderPromise)
              await this.view.renderPromise;
            await this.view.renderPage(snapshot, isPreview, this.willRender);
            this.adapter.visitRendered(this);
            if (!isPreview) {
              this.complete();
            }
          }
        });
      }
    }
    followRedirect() {
      var _a;
      if (this.redirectedToLocation && !this.followedRedirect && ((_a = this.response) === null || _a === void 0 ? void 0 : _a.redirected)) {
        this.adapter.visitProposedToLocation(this.redirectedToLocation, {
          action: "replace",
          response: this.response
        });
        this.followedRedirect = true;
      }
    }
    goToSamePageAnchor() {
      if (this.isSamePage) {
        this.render(async () => {
          this.cacheSnapshot();
          this.adapter.visitRendered(this);
        });
      }
    }
    requestStarted() {
      this.startRequest();
    }
    requestPreventedHandlingResponse(request, response) {
    }
    async requestSucceededWithResponse(request, response) {
      const responseHTML = await response.responseHTML;
      const { redirected, statusCode } = response;
      if (responseHTML == void 0) {
        this.recordResponse({ statusCode: SystemStatusCode.contentTypeMismatch, redirected });
      } else {
        this.redirectedToLocation = response.redirected ? response.location : void 0;
        this.recordResponse({ statusCode, responseHTML, redirected });
      }
    }
    async requestFailedWithResponse(request, response) {
      const responseHTML = await response.responseHTML;
      const { redirected, statusCode } = response;
      if (responseHTML == void 0) {
        this.recordResponse({ statusCode: SystemStatusCode.contentTypeMismatch, redirected });
      } else {
        this.recordResponse({ statusCode, responseHTML, redirected });
      }
    }
    requestErrored(request, error2) {
      this.recordResponse({ statusCode: SystemStatusCode.networkFailure, redirected: false });
    }
    requestFinished() {
      this.finishRequest();
    }
    performScroll() {
      if (!this.scrolled) {
        if (this.action == "restore") {
          this.scrollToRestoredPosition() || this.scrollToAnchor() || this.view.scrollToTop();
        } else {
          this.scrollToAnchor() || this.view.scrollToTop();
        }
        if (this.isSamePage) {
          this.delegate.visitScrolledToSamePageLocation(this.view.lastRenderedLocation, this.location);
        }
        this.scrolled = true;
      }
    }
    scrollToRestoredPosition() {
      const { scrollPosition } = this.restorationData;
      if (scrollPosition) {
        this.view.scrollToPosition(scrollPosition);
        return true;
      }
    }
    scrollToAnchor() {
      const anchor = getAnchor(this.location);
      if (anchor != null) {
        this.view.scrollToAnchor(anchor);
        return true;
      }
    }
    recordTimingMetric(metric) {
      this.timingMetrics[metric] = (/* @__PURE__ */ new Date()).getTime();
    }
    getTimingMetrics() {
      return Object.assign({}, this.timingMetrics);
    }
    getHistoryMethodForAction(action) {
      switch (action) {
        case "replace":
          return history.replaceState;
        case "advance":
        case "restore":
          return history.pushState;
      }
    }
    hasPreloadedResponse() {
      return typeof this.response == "object";
    }
    shouldIssueRequest() {
      if (this.isSamePage) {
        return false;
      } else if (this.action == "restore") {
        return !this.hasCachedSnapshot();
      } else {
        return this.willRender;
      }
    }
    cacheSnapshot() {
      if (!this.snapshotCached) {
        this.view.cacheSnapshot().then((snapshot) => snapshot && this.visitCachedSnapshot(snapshot));
        this.snapshotCached = true;
      }
    }
    async render(callback) {
      this.cancelRender();
      await new Promise((resolve) => {
        this.frame = requestAnimationFrame(() => resolve());
      });
      await callback();
      delete this.frame;
      this.performScroll();
    }
    cancelRender() {
      if (this.frame) {
        cancelAnimationFrame(this.frame);
        delete this.frame;
      }
    }
  };
  function isSuccessful(statusCode) {
    return statusCode >= 200 && statusCode < 300;
  }
  var BrowserAdapter = class {
    constructor(session2) {
      this.progressBar = new ProgressBar();
      this.showProgressBar = () => {
        this.progressBar.show();
      };
      this.session = session2;
    }
    visitProposedToLocation(location2, options) {
      this.navigator.startVisit(location2, uuid(), options);
    }
    visitStarted(visit2) {
      visit2.loadCachedSnapshot();
      visit2.issueRequest();
      visit2.changeHistory();
      visit2.goToSamePageAnchor();
    }
    visitRequestStarted(visit2) {
      this.progressBar.setValue(0);
      if (visit2.hasCachedSnapshot() || visit2.action != "restore") {
        this.showVisitProgressBarAfterDelay();
      } else {
        this.showProgressBar();
      }
    }
    visitRequestCompleted(visit2) {
      visit2.loadResponse();
    }
    visitRequestFailedWithStatusCode(visit2, statusCode) {
      switch (statusCode) {
        case SystemStatusCode.networkFailure:
        case SystemStatusCode.timeoutFailure:
        case SystemStatusCode.contentTypeMismatch:
          return this.reload();
        default:
          return visit2.loadResponse();
      }
    }
    visitRequestFinished(visit2) {
      this.progressBar.setValue(1);
      this.hideVisitProgressBar();
    }
    visitCompleted(visit2) {
    }
    pageInvalidated() {
      this.reload();
    }
    visitFailed(visit2) {
    }
    visitRendered(visit2) {
    }
    formSubmissionStarted(formSubmission) {
      this.progressBar.setValue(0);
      this.showFormProgressBarAfterDelay();
    }
    formSubmissionFinished(formSubmission) {
      this.progressBar.setValue(1);
      this.hideFormProgressBar();
    }
    showVisitProgressBarAfterDelay() {
      this.visitProgressBarTimeout = window.setTimeout(this.showProgressBar, this.session.progressBarDelay);
    }
    hideVisitProgressBar() {
      this.progressBar.hide();
      if (this.visitProgressBarTimeout != null) {
        window.clearTimeout(this.visitProgressBarTimeout);
        delete this.visitProgressBarTimeout;
      }
    }
    showFormProgressBarAfterDelay() {
      if (this.formProgressBarTimeout == null) {
        this.formProgressBarTimeout = window.setTimeout(this.showProgressBar, this.session.progressBarDelay);
      }
    }
    hideFormProgressBar() {
      this.progressBar.hide();
      if (this.formProgressBarTimeout != null) {
        window.clearTimeout(this.formProgressBarTimeout);
        delete this.formProgressBarTimeout;
      }
    }
    reload() {
      window.location.reload();
    }
    get navigator() {
      return this.session.navigator;
    }
  };
  var CacheObserver = class {
    constructor() {
      this.started = false;
    }
    start() {
      if (!this.started) {
        this.started = true;
        addEventListener("turbo:before-cache", this.removeStaleElements, false);
      }
    }
    stop() {
      if (this.started) {
        this.started = false;
        removeEventListener("turbo:before-cache", this.removeStaleElements, false);
      }
    }
    removeStaleElements() {
      const staleElements = [...document.querySelectorAll('[data-turbo-cache="false"]')];
      for (const element of staleElements) {
        element.remove();
      }
    }
  };
  var FormSubmitObserver = class {
    constructor(delegate) {
      this.started = false;
      this.submitCaptured = () => {
        removeEventListener("submit", this.submitBubbled, false);
        addEventListener("submit", this.submitBubbled, false);
      };
      this.submitBubbled = (event) => {
        if (!event.defaultPrevented) {
          const form = event.target instanceof HTMLFormElement ? event.target : void 0;
          const submitter = event.submitter || void 0;
          if (form) {
            const method = (submitter === null || submitter === void 0 ? void 0 : submitter.getAttribute("formmethod")) || form.getAttribute("method");
            if (method != "dialog" && this.delegate.willSubmitForm(form, submitter)) {
              event.preventDefault();
              this.delegate.formSubmitted(form, submitter);
            }
          }
        }
      };
      this.delegate = delegate;
    }
    start() {
      if (!this.started) {
        addEventListener("submit", this.submitCaptured, true);
        this.started = true;
      }
    }
    stop() {
      if (this.started) {
        removeEventListener("submit", this.submitCaptured, true);
        this.started = false;
      }
    }
  };
  var FrameRedirector = class {
    constructor(element) {
      this.element = element;
      this.linkInterceptor = new LinkInterceptor(this, element);
      this.formInterceptor = new FormInterceptor(this, element);
    }
    start() {
      this.linkInterceptor.start();
      this.formInterceptor.start();
    }
    stop() {
      this.linkInterceptor.stop();
      this.formInterceptor.stop();
    }
    shouldInterceptLinkClick(element, url) {
      return this.shouldRedirect(element);
    }
    linkClickIntercepted(element, url) {
      const frame = this.findFrameElement(element);
      if (frame) {
        frame.delegate.linkClickIntercepted(element, url);
      }
    }
    shouldInterceptFormSubmission(element, submitter) {
      return this.shouldSubmit(element, submitter);
    }
    formSubmissionIntercepted(element, submitter) {
      const frame = this.findFrameElement(element, submitter);
      if (frame) {
        frame.removeAttribute("reloadable");
        frame.delegate.formSubmissionIntercepted(element, submitter);
      }
    }
    shouldSubmit(form, submitter) {
      var _a;
      const action = getAction(form, submitter);
      const meta = this.element.ownerDocument.querySelector(`meta[name="turbo-root"]`);
      const rootLocation = expandURL((_a = meta === null || meta === void 0 ? void 0 : meta.content) !== null && _a !== void 0 ? _a : "/");
      return this.shouldRedirect(form, submitter) && locationIsVisitable(action, rootLocation);
    }
    shouldRedirect(element, submitter) {
      const frame = this.findFrameElement(element, submitter);
      return frame ? frame != element.closest("turbo-frame") : false;
    }
    findFrameElement(element, submitter) {
      const id = (submitter === null || submitter === void 0 ? void 0 : submitter.getAttribute("data-turbo-frame")) || element.getAttribute("data-turbo-frame");
      if (id && id != "_top") {
        const frame = this.element.querySelector(`#${id}:not([disabled])`);
        if (frame instanceof FrameElement) {
          return frame;
        }
      }
    }
  };
  var History = class {
    constructor(delegate) {
      this.restorationIdentifier = uuid();
      this.restorationData = {};
      this.started = false;
      this.pageLoaded = false;
      this.onPopState = (event) => {
        if (this.shouldHandlePopState()) {
          const { turbo } = event.state || {};
          if (turbo) {
            this.location = new URL(window.location.href);
            const { restorationIdentifier } = turbo;
            this.restorationIdentifier = restorationIdentifier;
            this.delegate.historyPoppedToLocationWithRestorationIdentifier(this.location, restorationIdentifier);
          }
        }
      };
      this.onPageLoad = async (event) => {
        await nextMicrotask();
        this.pageLoaded = true;
      };
      this.delegate = delegate;
    }
    start() {
      if (!this.started) {
        addEventListener("popstate", this.onPopState, false);
        addEventListener("load", this.onPageLoad, false);
        this.started = true;
        this.replace(new URL(window.location.href));
      }
    }
    stop() {
      if (this.started) {
        removeEventListener("popstate", this.onPopState, false);
        removeEventListener("load", this.onPageLoad, false);
        this.started = false;
      }
    }
    push(location2, restorationIdentifier) {
      this.update(history.pushState, location2, restorationIdentifier);
    }
    replace(location2, restorationIdentifier) {
      this.update(history.replaceState, location2, restorationIdentifier);
    }
    update(method, location2, restorationIdentifier = uuid()) {
      const state = { turbo: { restorationIdentifier } };
      method.call(history, state, "", location2.href);
      this.location = location2;
      this.restorationIdentifier = restorationIdentifier;
    }
    getRestorationDataForIdentifier(restorationIdentifier) {
      return this.restorationData[restorationIdentifier] || {};
    }
    updateRestorationData(additionalData) {
      const { restorationIdentifier } = this;
      const restorationData = this.restorationData[restorationIdentifier];
      this.restorationData[restorationIdentifier] = Object.assign(Object.assign({}, restorationData), additionalData);
    }
    assumeControlOfScrollRestoration() {
      var _a;
      if (!this.previousScrollRestoration) {
        this.previousScrollRestoration = (_a = history.scrollRestoration) !== null && _a !== void 0 ? _a : "auto";
        history.scrollRestoration = "manual";
      }
    }
    relinquishControlOfScrollRestoration() {
      if (this.previousScrollRestoration) {
        history.scrollRestoration = this.previousScrollRestoration;
        delete this.previousScrollRestoration;
      }
    }
    shouldHandlePopState() {
      return this.pageIsLoaded();
    }
    pageIsLoaded() {
      return this.pageLoaded || document.readyState == "complete";
    }
  };
  var LinkClickObserver = class {
    constructor(delegate) {
      this.started = false;
      this.clickCaptured = () => {
        removeEventListener("click", this.clickBubbled, false);
        addEventListener("click", this.clickBubbled, false);
      };
      this.clickBubbled = (event) => {
        if (this.clickEventIsSignificant(event)) {
          const target = event.composedPath && event.composedPath()[0] || event.target;
          const link = this.findLinkFromClickTarget(target);
          if (link) {
            const location2 = this.getLocationForLink(link);
            if (this.delegate.willFollowLinkToLocation(link, location2)) {
              event.preventDefault();
              this.delegate.followedLinkToLocation(link, location2);
            }
          }
        }
      };
      this.delegate = delegate;
    }
    start() {
      if (!this.started) {
        addEventListener("click", this.clickCaptured, true);
        this.started = true;
      }
    }
    stop() {
      if (this.started) {
        removeEventListener("click", this.clickCaptured, true);
        this.started = false;
      }
    }
    clickEventIsSignificant(event) {
      return !(event.target && event.target.isContentEditable || event.defaultPrevented || event.which > 1 || event.altKey || event.ctrlKey || event.metaKey || event.shiftKey);
    }
    findLinkFromClickTarget(target) {
      if (target instanceof Element) {
        return target.closest("a[href]:not([target^=_]):not([download])");
      }
    }
    getLocationForLink(link) {
      return expandURL(link.getAttribute("href") || "");
    }
  };
  function isAction(action) {
    return action == "advance" || action == "replace" || action == "restore";
  }
  var Navigator = class {
    constructor(delegate) {
      this.delegate = delegate;
    }
    proposeVisit(location2, options = {}) {
      if (this.delegate.allowsVisitingLocationWithAction(location2, options.action)) {
        if (locationIsVisitable(location2, this.view.snapshot.rootLocation)) {
          this.delegate.visitProposedToLocation(location2, options);
        } else {
          window.location.href = location2.toString();
        }
      }
    }
    startVisit(locatable, restorationIdentifier, options = {}) {
      this.stop();
      this.currentVisit = new Visit(this, expandURL(locatable), restorationIdentifier, Object.assign({ referrer: this.location }, options));
      this.currentVisit.start();
    }
    submitForm(form, submitter) {
      this.stop();
      this.formSubmission = new FormSubmission(this, form, submitter, true);
      this.formSubmission.start();
    }
    stop() {
      if (this.formSubmission) {
        this.formSubmission.stop();
        delete this.formSubmission;
      }
      if (this.currentVisit) {
        this.currentVisit.cancel();
        delete this.currentVisit;
      }
    }
    get adapter() {
      return this.delegate.adapter;
    }
    get view() {
      return this.delegate.view;
    }
    get history() {
      return this.delegate.history;
    }
    formSubmissionStarted(formSubmission) {
      if (typeof this.adapter.formSubmissionStarted === "function") {
        this.adapter.formSubmissionStarted(formSubmission);
      }
    }
    async formSubmissionSucceededWithResponse(formSubmission, fetchResponse) {
      if (formSubmission == this.formSubmission) {
        const responseHTML = await fetchResponse.responseHTML;
        if (responseHTML) {
          if (formSubmission.method != FetchMethod.get) {
            this.view.clearSnapshotCache();
          }
          const { statusCode, redirected } = fetchResponse;
          const action = this.getActionForFormSubmission(formSubmission);
          const visitOptions = { action, response: { statusCode, responseHTML, redirected } };
          this.proposeVisit(fetchResponse.location, visitOptions);
        }
      }
    }
    async formSubmissionFailedWithResponse(formSubmission, fetchResponse) {
      const responseHTML = await fetchResponse.responseHTML;
      if (responseHTML) {
        const snapshot = PageSnapshot.fromHTMLString(responseHTML);
        if (fetchResponse.serverError) {
          await this.view.renderError(snapshot);
        } else {
          await this.view.renderPage(snapshot);
        }
        this.view.scrollToTop();
        this.view.clearSnapshotCache();
      }
    }
    formSubmissionErrored(formSubmission, error2) {
      console.error(error2);
    }
    formSubmissionFinished(formSubmission) {
      if (typeof this.adapter.formSubmissionFinished === "function") {
        this.adapter.formSubmissionFinished(formSubmission);
      }
    }
    visitStarted(visit2) {
      this.delegate.visitStarted(visit2);
    }
    visitCompleted(visit2) {
      this.delegate.visitCompleted(visit2);
    }
    locationWithActionIsSamePage(location2, action) {
      const anchor = getAnchor(location2);
      const currentAnchor = getAnchor(this.view.lastRenderedLocation);
      const isRestorationToTop = action === "restore" && typeof anchor === "undefined";
      return action !== "replace" && getRequestURL(location2) === getRequestURL(this.view.lastRenderedLocation) && (isRestorationToTop || anchor != null && anchor !== currentAnchor);
    }
    visitScrolledToSamePageLocation(oldURL, newURL) {
      this.delegate.visitScrolledToSamePageLocation(oldURL, newURL);
    }
    get location() {
      return this.history.location;
    }
    get restorationIdentifier() {
      return this.history.restorationIdentifier;
    }
    getActionForFormSubmission(formSubmission) {
      const { formElement, submitter } = formSubmission;
      const action = getAttribute("data-turbo-action", submitter, formElement);
      return isAction(action) ? action : "advance";
    }
  };
  var PageStage;
  (function(PageStage2) {
    PageStage2[PageStage2["initial"] = 0] = "initial";
    PageStage2[PageStage2["loading"] = 1] = "loading";
    PageStage2[PageStage2["interactive"] = 2] = "interactive";
    PageStage2[PageStage2["complete"] = 3] = "complete";
  })(PageStage || (PageStage = {}));
  var PageObserver = class {
    constructor(delegate) {
      this.stage = PageStage.initial;
      this.started = false;
      this.interpretReadyState = () => {
        const { readyState } = this;
        if (readyState == "interactive") {
          this.pageIsInteractive();
        } else if (readyState == "complete") {
          this.pageIsComplete();
        }
      };
      this.pageWillUnload = () => {
        this.delegate.pageWillUnload();
      };
      this.delegate = delegate;
    }
    start() {
      if (!this.started) {
        if (this.stage == PageStage.initial) {
          this.stage = PageStage.loading;
        }
        document.addEventListener("readystatechange", this.interpretReadyState, false);
        addEventListener("pagehide", this.pageWillUnload, false);
        this.started = true;
      }
    }
    stop() {
      if (this.started) {
        document.removeEventListener("readystatechange", this.interpretReadyState, false);
        removeEventListener("pagehide", this.pageWillUnload, false);
        this.started = false;
      }
    }
    pageIsInteractive() {
      if (this.stage == PageStage.loading) {
        this.stage = PageStage.interactive;
        this.delegate.pageBecameInteractive();
      }
    }
    pageIsComplete() {
      this.pageIsInteractive();
      if (this.stage == PageStage.interactive) {
        this.stage = PageStage.complete;
        this.delegate.pageLoaded();
      }
    }
    get readyState() {
      return document.readyState;
    }
  };
  var ScrollObserver = class {
    constructor(delegate) {
      this.started = false;
      this.onScroll = () => {
        this.updatePosition({ x: window.pageXOffset, y: window.pageYOffset });
      };
      this.delegate = delegate;
    }
    start() {
      if (!this.started) {
        addEventListener("scroll", this.onScroll, false);
        this.onScroll();
        this.started = true;
      }
    }
    stop() {
      if (this.started) {
        removeEventListener("scroll", this.onScroll, false);
        this.started = false;
      }
    }
    updatePosition(position) {
      this.delegate.scrollPositionChanged(position);
    }
  };
  var StreamObserver = class {
    constructor(delegate) {
      this.sources = /* @__PURE__ */ new Set();
      this.started = false;
      this.inspectFetchResponse = (event) => {
        const response = fetchResponseFromEvent(event);
        if (response && fetchResponseIsStream(response)) {
          event.preventDefault();
          this.receiveMessageResponse(response);
        }
      };
      this.receiveMessageEvent = (event) => {
        if (this.started && typeof event.data == "string") {
          this.receiveMessageHTML(event.data);
        }
      };
      this.delegate = delegate;
    }
    start() {
      if (!this.started) {
        this.started = true;
        addEventListener("turbo:before-fetch-response", this.inspectFetchResponse, false);
      }
    }
    stop() {
      if (this.started) {
        this.started = false;
        removeEventListener("turbo:before-fetch-response", this.inspectFetchResponse, false);
      }
    }
    connectStreamSource(source) {
      if (!this.streamSourceIsConnected(source)) {
        this.sources.add(source);
        source.addEventListener("message", this.receiveMessageEvent, false);
      }
    }
    disconnectStreamSource(source) {
      if (this.streamSourceIsConnected(source)) {
        this.sources.delete(source);
        source.removeEventListener("message", this.receiveMessageEvent, false);
      }
    }
    streamSourceIsConnected(source) {
      return this.sources.has(source);
    }
    async receiveMessageResponse(response) {
      const html = await response.responseHTML;
      if (html) {
        this.receiveMessageHTML(html);
      }
    }
    receiveMessageHTML(html) {
      this.delegate.receivedMessageFromStream(new StreamMessage(html));
    }
  };
  function fetchResponseFromEvent(event) {
    var _a;
    const fetchResponse = (_a = event.detail) === null || _a === void 0 ? void 0 : _a.fetchResponse;
    if (fetchResponse instanceof FetchResponse) {
      return fetchResponse;
    }
  }
  function fetchResponseIsStream(response) {
    var _a;
    const contentType = (_a = response.contentType) !== null && _a !== void 0 ? _a : "";
    return contentType.startsWith(StreamMessage.contentType);
  }
  var ErrorRenderer = class extends Renderer {
    async render() {
      this.replaceHeadAndBody();
      this.activateScriptElements();
    }
    replaceHeadAndBody() {
      const { documentElement, head, body } = document;
      documentElement.replaceChild(this.newHead, head);
      documentElement.replaceChild(this.newElement, body);
    }
    activateScriptElements() {
      for (const replaceableElement of this.scriptElements) {
        const parentNode = replaceableElement.parentNode;
        if (parentNode) {
          const element = this.createScriptElement(replaceableElement);
          parentNode.replaceChild(element, replaceableElement);
        }
      }
    }
    get newHead() {
      return this.newSnapshot.headSnapshot.element;
    }
    get scriptElements() {
      return [...document.documentElement.querySelectorAll("script")];
    }
  };
  var PageRenderer = class extends Renderer {
    get shouldRender() {
      return this.newSnapshot.isVisitable && this.trackedElementsAreIdentical;
    }
    prepareToRender() {
      this.mergeHead();
    }
    async render() {
      if (this.willRender) {
        this.replaceBody();
      }
    }
    finishRendering() {
      super.finishRendering();
      if (!this.isPreview) {
        this.focusFirstAutofocusableElement();
      }
    }
    get currentHeadSnapshot() {
      return this.currentSnapshot.headSnapshot;
    }
    get newHeadSnapshot() {
      return this.newSnapshot.headSnapshot;
    }
    get newElement() {
      return this.newSnapshot.element;
    }
    mergeHead() {
      this.copyNewHeadStylesheetElements();
      this.copyNewHeadScriptElements();
      this.removeCurrentHeadProvisionalElements();
      this.copyNewHeadProvisionalElements();
    }
    replaceBody() {
      this.preservingPermanentElements(() => {
        this.activateNewBody();
        this.assignNewBody();
      });
    }
    get trackedElementsAreIdentical() {
      return this.currentHeadSnapshot.trackedElementSignature == this.newHeadSnapshot.trackedElementSignature;
    }
    copyNewHeadStylesheetElements() {
      for (const element of this.newHeadStylesheetElements) {
        document.head.appendChild(element);
      }
    }
    copyNewHeadScriptElements() {
      for (const element of this.newHeadScriptElements) {
        document.head.appendChild(this.createScriptElement(element));
      }
    }
    removeCurrentHeadProvisionalElements() {
      for (const element of this.currentHeadProvisionalElements) {
        document.head.removeChild(element);
      }
    }
    copyNewHeadProvisionalElements() {
      for (const element of this.newHeadProvisionalElements) {
        document.head.appendChild(element);
      }
    }
    activateNewBody() {
      document.adoptNode(this.newElement);
      this.activateNewBodyScriptElements();
    }
    activateNewBodyScriptElements() {
      for (const inertScriptElement of this.newBodyScriptElements) {
        const activatedScriptElement = this.createScriptElement(inertScriptElement);
        inertScriptElement.replaceWith(activatedScriptElement);
      }
    }
    assignNewBody() {
      if (document.body && this.newElement instanceof HTMLBodyElement) {
        document.body.replaceWith(this.newElement);
      } else {
        document.documentElement.appendChild(this.newElement);
      }
    }
    get newHeadStylesheetElements() {
      return this.newHeadSnapshot.getStylesheetElementsNotInSnapshot(this.currentHeadSnapshot);
    }
    get newHeadScriptElements() {
      return this.newHeadSnapshot.getScriptElementsNotInSnapshot(this.currentHeadSnapshot);
    }
    get currentHeadProvisionalElements() {
      return this.currentHeadSnapshot.provisionalElements;
    }
    get newHeadProvisionalElements() {
      return this.newHeadSnapshot.provisionalElements;
    }
    get newBodyScriptElements() {
      return this.newElement.querySelectorAll("script");
    }
  };
  var SnapshotCache = class {
    constructor(size) {
      this.keys = [];
      this.snapshots = {};
      this.size = size;
    }
    has(location2) {
      return toCacheKey(location2) in this.snapshots;
    }
    get(location2) {
      if (this.has(location2)) {
        const snapshot = this.read(location2);
        this.touch(location2);
        return snapshot;
      }
    }
    put(location2, snapshot) {
      this.write(location2, snapshot);
      this.touch(location2);
      return snapshot;
    }
    clear() {
      this.snapshots = {};
    }
    read(location2) {
      return this.snapshots[toCacheKey(location2)];
    }
    write(location2, snapshot) {
      this.snapshots[toCacheKey(location2)] = snapshot;
    }
    touch(location2) {
      const key = toCacheKey(location2);
      const index = this.keys.indexOf(key);
      if (index > -1)
        this.keys.splice(index, 1);
      this.keys.unshift(key);
      this.trim();
    }
    trim() {
      for (const key of this.keys.splice(this.size)) {
        delete this.snapshots[key];
      }
    }
  };
  var PageView = class extends View {
    constructor() {
      super(...arguments);
      this.snapshotCache = new SnapshotCache(10);
      this.lastRenderedLocation = new URL(location.href);
    }
    renderPage(snapshot, isPreview = false, willRender = true) {
      const renderer = new PageRenderer(this.snapshot, snapshot, isPreview, willRender);
      return this.render(renderer);
    }
    renderError(snapshot) {
      const renderer = new ErrorRenderer(this.snapshot, snapshot, false);
      return this.render(renderer);
    }
    clearSnapshotCache() {
      this.snapshotCache.clear();
    }
    async cacheSnapshot() {
      if (this.shouldCacheSnapshot) {
        this.delegate.viewWillCacheSnapshot();
        const { snapshot, lastRenderedLocation: location2 } = this;
        await nextEventLoopTick();
        const cachedSnapshot = snapshot.clone();
        this.snapshotCache.put(location2, cachedSnapshot);
        return cachedSnapshot;
      }
    }
    getCachedSnapshotForLocation(location2) {
      return this.snapshotCache.get(location2);
    }
    get snapshot() {
      return PageSnapshot.fromElement(this.element);
    }
    get shouldCacheSnapshot() {
      return this.snapshot.isCacheable;
    }
  };
  var Session = class {
    constructor() {
      this.navigator = new Navigator(this);
      this.history = new History(this);
      this.view = new PageView(this, document.documentElement);
      this.adapter = new BrowserAdapter(this);
      this.pageObserver = new PageObserver(this);
      this.cacheObserver = new CacheObserver();
      this.linkClickObserver = new LinkClickObserver(this);
      this.formSubmitObserver = new FormSubmitObserver(this);
      this.scrollObserver = new ScrollObserver(this);
      this.streamObserver = new StreamObserver(this);
      this.frameRedirector = new FrameRedirector(document.documentElement);
      this.drive = true;
      this.enabled = true;
      this.progressBarDelay = 500;
      this.started = false;
    }
    start() {
      if (!this.started) {
        this.pageObserver.start();
        this.cacheObserver.start();
        this.linkClickObserver.start();
        this.formSubmitObserver.start();
        this.scrollObserver.start();
        this.streamObserver.start();
        this.frameRedirector.start();
        this.history.start();
        this.started = true;
        this.enabled = true;
      }
    }
    disable() {
      this.enabled = false;
    }
    stop() {
      if (this.started) {
        this.pageObserver.stop();
        this.cacheObserver.stop();
        this.linkClickObserver.stop();
        this.formSubmitObserver.stop();
        this.scrollObserver.stop();
        this.streamObserver.stop();
        this.frameRedirector.stop();
        this.history.stop();
        this.started = false;
      }
    }
    registerAdapter(adapter) {
      this.adapter = adapter;
    }
    visit(location2, options = {}) {
      this.navigator.proposeVisit(expandURL(location2), options);
    }
    connectStreamSource(source) {
      this.streamObserver.connectStreamSource(source);
    }
    disconnectStreamSource(source) {
      this.streamObserver.disconnectStreamSource(source);
    }
    renderStreamMessage(message) {
      document.documentElement.appendChild(StreamMessage.wrap(message).fragment);
    }
    clearCache() {
      this.view.clearSnapshotCache();
    }
    setProgressBarDelay(delay) {
      this.progressBarDelay = delay;
    }
    get location() {
      return this.history.location;
    }
    get restorationIdentifier() {
      return this.history.restorationIdentifier;
    }
    historyPoppedToLocationWithRestorationIdentifier(location2, restorationIdentifier) {
      if (this.enabled) {
        this.navigator.startVisit(location2, restorationIdentifier, { action: "restore", historyChanged: true });
      } else {
        this.adapter.pageInvalidated();
      }
    }
    scrollPositionChanged(position) {
      this.history.updateRestorationData({ scrollPosition: position });
    }
    willFollowLinkToLocation(link, location2) {
      return this.elementDriveEnabled(link) && locationIsVisitable(location2, this.snapshot.rootLocation) && this.applicationAllowsFollowingLinkToLocation(link, location2);
    }
    followedLinkToLocation(link, location2) {
      const action = this.getActionForLink(link);
      this.convertLinkWithMethodClickToFormSubmission(link) || this.visit(location2.href, { action });
    }
    convertLinkWithMethodClickToFormSubmission(link) {
      const linkMethod = link.getAttribute("data-turbo-method");
      if (linkMethod) {
        const form = document.createElement("form");
        form.method = linkMethod;
        form.action = link.getAttribute("href") || "undefined";
        form.hidden = true;
        if (link.hasAttribute("data-turbo-confirm")) {
          form.setAttribute("data-turbo-confirm", link.getAttribute("data-turbo-confirm"));
        }
        const frame = this.getTargetFrameForLink(link);
        if (frame) {
          form.setAttribute("data-turbo-frame", frame);
          form.addEventListener("turbo:submit-start", () => form.remove());
        } else {
          form.addEventListener("submit", () => form.remove());
        }
        document.body.appendChild(form);
        return dispatch("submit", { cancelable: true, target: form });
      } else {
        return false;
      }
    }
    allowsVisitingLocationWithAction(location2, action) {
      return this.locationWithActionIsSamePage(location2, action) || this.applicationAllowsVisitingLocation(location2);
    }
    visitProposedToLocation(location2, options) {
      extendURLWithDeprecatedProperties(location2);
      this.adapter.visitProposedToLocation(location2, options);
    }
    visitStarted(visit2) {
      extendURLWithDeprecatedProperties(visit2.location);
      if (!visit2.silent) {
        this.notifyApplicationAfterVisitingLocation(visit2.location, visit2.action);
      }
    }
    visitCompleted(visit2) {
      this.notifyApplicationAfterPageLoad(visit2.getTimingMetrics());
    }
    locationWithActionIsSamePage(location2, action) {
      return this.navigator.locationWithActionIsSamePage(location2, action);
    }
    visitScrolledToSamePageLocation(oldURL, newURL) {
      this.notifyApplicationAfterVisitingSamePageLocation(oldURL, newURL);
    }
    willSubmitForm(form, submitter) {
      const action = getAction(form, submitter);
      return this.elementDriveEnabled(form) && (!submitter || this.elementDriveEnabled(submitter)) && locationIsVisitable(expandURL(action), this.snapshot.rootLocation);
    }
    formSubmitted(form, submitter) {
      this.navigator.submitForm(form, submitter);
    }
    pageBecameInteractive() {
      this.view.lastRenderedLocation = this.location;
      this.notifyApplicationAfterPageLoad();
    }
    pageLoaded() {
      this.history.assumeControlOfScrollRestoration();
    }
    pageWillUnload() {
      this.history.relinquishControlOfScrollRestoration();
    }
    receivedMessageFromStream(message) {
      this.renderStreamMessage(message);
    }
    viewWillCacheSnapshot() {
      var _a;
      if (!((_a = this.navigator.currentVisit) === null || _a === void 0 ? void 0 : _a.silent)) {
        this.notifyApplicationBeforeCachingSnapshot();
      }
    }
    allowsImmediateRender({ element }, resume) {
      const event = this.notifyApplicationBeforeRender(element, resume);
      return !event.defaultPrevented;
    }
    viewRenderedSnapshot(snapshot, isPreview) {
      this.view.lastRenderedLocation = this.history.location;
      this.notifyApplicationAfterRender();
    }
    viewInvalidated() {
      this.adapter.pageInvalidated();
    }
    frameLoaded(frame) {
      this.notifyApplicationAfterFrameLoad(frame);
    }
    frameRendered(fetchResponse, frame) {
      this.notifyApplicationAfterFrameRender(fetchResponse, frame);
    }
    applicationAllowsFollowingLinkToLocation(link, location2) {
      const event = this.notifyApplicationAfterClickingLinkToLocation(link, location2);
      return !event.defaultPrevented;
    }
    applicationAllowsVisitingLocation(location2) {
      const event = this.notifyApplicationBeforeVisitingLocation(location2);
      return !event.defaultPrevented;
    }
    notifyApplicationAfterClickingLinkToLocation(link, location2) {
      return dispatch("turbo:click", { target: link, detail: { url: location2.href }, cancelable: true });
    }
    notifyApplicationBeforeVisitingLocation(location2) {
      return dispatch("turbo:before-visit", { detail: { url: location2.href }, cancelable: true });
    }
    notifyApplicationAfterVisitingLocation(location2, action) {
      markAsBusy(document.documentElement);
      return dispatch("turbo:visit", { detail: { url: location2.href, action } });
    }
    notifyApplicationBeforeCachingSnapshot() {
      return dispatch("turbo:before-cache");
    }
    notifyApplicationBeforeRender(newBody, resume) {
      return dispatch("turbo:before-render", { detail: { newBody, resume }, cancelable: true });
    }
    notifyApplicationAfterRender() {
      return dispatch("turbo:render");
    }
    notifyApplicationAfterPageLoad(timing = {}) {
      clearBusyState(document.documentElement);
      return dispatch("turbo:load", { detail: { url: this.location.href, timing } });
    }
    notifyApplicationAfterVisitingSamePageLocation(oldURL, newURL) {
      dispatchEvent(new HashChangeEvent("hashchange", { oldURL: oldURL.toString(), newURL: newURL.toString() }));
    }
    notifyApplicationAfterFrameLoad(frame) {
      return dispatch("turbo:frame-load", { target: frame });
    }
    notifyApplicationAfterFrameRender(fetchResponse, frame) {
      return dispatch("turbo:frame-render", { detail: { fetchResponse }, target: frame, cancelable: true });
    }
    elementDriveEnabled(element) {
      const container = element === null || element === void 0 ? void 0 : element.closest("[data-turbo]");
      if (this.drive) {
        if (container) {
          return container.getAttribute("data-turbo") != "false";
        } else {
          return true;
        }
      } else {
        if (container) {
          return container.getAttribute("data-turbo") == "true";
        } else {
          return false;
        }
      }
    }
    getActionForLink(link) {
      const action = link.getAttribute("data-turbo-action");
      return isAction(action) ? action : "advance";
    }
    getTargetFrameForLink(link) {
      const frame = link.getAttribute("data-turbo-frame");
      if (frame) {
        return frame;
      } else {
        const container = link.closest("turbo-frame");
        if (container) {
          return container.id;
        }
      }
    }
    get snapshot() {
      return this.view.snapshot;
    }
  };
  function extendURLWithDeprecatedProperties(url) {
    Object.defineProperties(url, deprecatedLocationPropertyDescriptors);
  }
  var deprecatedLocationPropertyDescriptors = {
    absoluteURL: {
      get() {
        return this.toString();
      }
    }
  };
  var session = new Session();
  var { navigator: navigator$1 } = session;
  function start() {
    session.start();
  }
  function registerAdapter(adapter) {
    session.registerAdapter(adapter);
  }
  function visit(location2, options) {
    session.visit(location2, options);
  }
  function connectStreamSource(source) {
    session.connectStreamSource(source);
  }
  function disconnectStreamSource(source) {
    session.disconnectStreamSource(source);
  }
  function renderStreamMessage(message) {
    session.renderStreamMessage(message);
  }
  function clearCache() {
    session.clearCache();
  }
  function setProgressBarDelay(delay) {
    session.setProgressBarDelay(delay);
  }
  function setConfirmMethod(confirmMethod) {
    FormSubmission.confirmMethod = confirmMethod;
  }
  var Turbo = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    navigator: navigator$1,
    session,
    PageRenderer,
    PageSnapshot,
    start,
    registerAdapter,
    visit,
    connectStreamSource,
    disconnectStreamSource,
    renderStreamMessage,
    clearCache,
    setProgressBarDelay,
    setConfirmMethod
  });
  var FrameController = class {
    constructor(element) {
      this.fetchResponseLoaded = (fetchResponse) => {
      };
      this.currentFetchRequest = null;
      this.resolveVisitPromise = () => {
      };
      this.connected = false;
      this.hasBeenLoaded = false;
      this.settingSourceURL = false;
      this.element = element;
      this.view = new FrameView(this, this.element);
      this.appearanceObserver = new AppearanceObserver(this, this.element);
      this.linkInterceptor = new LinkInterceptor(this, this.element);
      this.formInterceptor = new FormInterceptor(this, this.element);
    }
    connect() {
      if (!this.connected) {
        this.connected = true;
        this.reloadable = false;
        if (this.loadingStyle == FrameLoadingStyle.lazy) {
          this.appearanceObserver.start();
        }
        this.linkInterceptor.start();
        this.formInterceptor.start();
        this.sourceURLChanged();
      }
    }
    disconnect() {
      if (this.connected) {
        this.connected = false;
        this.appearanceObserver.stop();
        this.linkInterceptor.stop();
        this.formInterceptor.stop();
      }
    }
    disabledChanged() {
      if (this.loadingStyle == FrameLoadingStyle.eager) {
        this.loadSourceURL();
      }
    }
    sourceURLChanged() {
      if (this.loadingStyle == FrameLoadingStyle.eager || this.hasBeenLoaded) {
        this.loadSourceURL();
      }
    }
    loadingStyleChanged() {
      if (this.loadingStyle == FrameLoadingStyle.lazy) {
        this.appearanceObserver.start();
      } else {
        this.appearanceObserver.stop();
        this.loadSourceURL();
      }
    }
    async loadSourceURL() {
      if (!this.settingSourceURL && this.enabled && this.isActive && (this.reloadable || this.sourceURL != this.currentURL)) {
        const previousURL = this.currentURL;
        this.currentURL = this.sourceURL;
        if (this.sourceURL) {
          try {
            this.element.loaded = this.visit(expandURL(this.sourceURL));
            this.appearanceObserver.stop();
            await this.element.loaded;
            this.hasBeenLoaded = true;
          } catch (error2) {
            this.currentURL = previousURL;
            throw error2;
          }
        }
      }
    }
    async loadResponse(fetchResponse) {
      if (fetchResponse.redirected || fetchResponse.succeeded && fetchResponse.isHTML) {
        this.sourceURL = fetchResponse.response.url;
      }
      try {
        const html = await fetchResponse.responseHTML;
        if (html) {
          const { body } = parseHTMLDocument(html);
          const snapshot = new Snapshot(await this.extractForeignFrameElement(body));
          const renderer = new FrameRenderer(this.view.snapshot, snapshot, false, false);
          if (this.view.renderPromise)
            await this.view.renderPromise;
          await this.view.render(renderer);
          session.frameRendered(fetchResponse, this.element);
          session.frameLoaded(this.element);
          this.fetchResponseLoaded(fetchResponse);
        }
      } catch (error2) {
        console.error(error2);
        this.view.invalidate();
      } finally {
        this.fetchResponseLoaded = () => {
        };
      }
    }
    elementAppearedInViewport(element) {
      this.loadSourceURL();
    }
    shouldInterceptLinkClick(element, url) {
      if (element.hasAttribute("data-turbo-method")) {
        return false;
      } else {
        return this.shouldInterceptNavigation(element);
      }
    }
    linkClickIntercepted(element, url) {
      this.reloadable = true;
      this.navigateFrame(element, url);
    }
    shouldInterceptFormSubmission(element, submitter) {
      return this.shouldInterceptNavigation(element, submitter);
    }
    formSubmissionIntercepted(element, submitter) {
      if (this.formSubmission) {
        this.formSubmission.stop();
      }
      this.reloadable = false;
      this.formSubmission = new FormSubmission(this, element, submitter);
      const { fetchRequest } = this.formSubmission;
      this.prepareHeadersForRequest(fetchRequest.headers, fetchRequest);
      this.formSubmission.start();
    }
    prepareHeadersForRequest(headers, request) {
      headers["Turbo-Frame"] = this.id;
    }
    requestStarted(request) {
      markAsBusy(this.element);
    }
    requestPreventedHandlingResponse(request, response) {
      this.resolveVisitPromise();
    }
    async requestSucceededWithResponse(request, response) {
      await this.loadResponse(response);
      this.resolveVisitPromise();
    }
    requestFailedWithResponse(request, response) {
      console.error(response);
      this.resolveVisitPromise();
    }
    requestErrored(request, error2) {
      console.error(error2);
      this.resolveVisitPromise();
    }
    requestFinished(request) {
      clearBusyState(this.element);
    }
    formSubmissionStarted({ formElement }) {
      markAsBusy(formElement, this.findFrameElement(formElement));
    }
    formSubmissionSucceededWithResponse(formSubmission, response) {
      const frame = this.findFrameElement(formSubmission.formElement, formSubmission.submitter);
      this.proposeVisitIfNavigatedWithAction(frame, formSubmission.formElement, formSubmission.submitter);
      frame.delegate.loadResponse(response);
    }
    formSubmissionFailedWithResponse(formSubmission, fetchResponse) {
      this.element.delegate.loadResponse(fetchResponse);
    }
    formSubmissionErrored(formSubmission, error2) {
      console.error(error2);
    }
    formSubmissionFinished({ formElement }) {
      clearBusyState(formElement, this.findFrameElement(formElement));
    }
    allowsImmediateRender(snapshot, resume) {
      return true;
    }
    viewRenderedSnapshot(snapshot, isPreview) {
    }
    viewInvalidated() {
    }
    async visit(url) {
      var _a;
      const request = new FetchRequest(this, FetchMethod.get, url, new URLSearchParams(), this.element);
      (_a = this.currentFetchRequest) === null || _a === void 0 ? void 0 : _a.cancel();
      this.currentFetchRequest = request;
      return new Promise((resolve) => {
        this.resolveVisitPromise = () => {
          this.resolveVisitPromise = () => {
          };
          this.currentFetchRequest = null;
          resolve();
        };
        request.perform();
      });
    }
    navigateFrame(element, url, submitter) {
      const frame = this.findFrameElement(element, submitter);
      this.proposeVisitIfNavigatedWithAction(frame, element, submitter);
      frame.setAttribute("reloadable", "");
      frame.src = url;
    }
    proposeVisitIfNavigatedWithAction(frame, element, submitter) {
      const action = getAttribute("data-turbo-action", submitter, element, frame);
      if (isAction(action)) {
        const { visitCachedSnapshot } = new SnapshotSubstitution(frame);
        frame.delegate.fetchResponseLoaded = (fetchResponse) => {
          if (frame.src) {
            const { statusCode, redirected } = fetchResponse;
            const responseHTML = frame.ownerDocument.documentElement.outerHTML;
            const response = { statusCode, redirected, responseHTML };
            session.visit(frame.src, { action, response, visitCachedSnapshot, willRender: false });
          }
        };
      }
    }
    findFrameElement(element, submitter) {
      var _a;
      const id = getAttribute("data-turbo-frame", submitter, element) || this.element.getAttribute("target");
      return (_a = getFrameElementById(id)) !== null && _a !== void 0 ? _a : this.element;
    }
    async extractForeignFrameElement(container) {
      let element;
      const id = CSS.escape(this.id);
      try {
        if (element = activateElement(container.querySelector(`turbo-frame#${id}`), this.currentURL)) {
          return element;
        }
        if (element = activateElement(container.querySelector(`turbo-frame[src][recurse~=${id}]`), this.currentURL)) {
          await element.loaded;
          return await this.extractForeignFrameElement(element);
        }
        console.error(`Response has no matching <turbo-frame id="${id}"> element`);
      } catch (error2) {
        console.error(error2);
      }
      return new FrameElement();
    }
    formActionIsVisitable(form, submitter) {
      const action = getAction(form, submitter);
      return locationIsVisitable(expandURL(action), this.rootLocation);
    }
    shouldInterceptNavigation(element, submitter) {
      const id = getAttribute("data-turbo-frame", submitter, element) || this.element.getAttribute("target");
      if (element instanceof HTMLFormElement && !this.formActionIsVisitable(element, submitter)) {
        return false;
      }
      if (!this.enabled || id == "_top") {
        return false;
      }
      if (id) {
        const frameElement = getFrameElementById(id);
        if (frameElement) {
          return !frameElement.disabled;
        }
      }
      if (!session.elementDriveEnabled(element)) {
        return false;
      }
      if (submitter && !session.elementDriveEnabled(submitter)) {
        return false;
      }
      return true;
    }
    get id() {
      return this.element.id;
    }
    get enabled() {
      return !this.element.disabled;
    }
    get sourceURL() {
      if (this.element.src) {
        return this.element.src;
      }
    }
    get reloadable() {
      const frame = this.findFrameElement(this.element);
      return frame.hasAttribute("reloadable");
    }
    set reloadable(value) {
      const frame = this.findFrameElement(this.element);
      if (value) {
        frame.setAttribute("reloadable", "");
      } else {
        frame.removeAttribute("reloadable");
      }
    }
    set sourceURL(sourceURL) {
      this.settingSourceURL = true;
      this.element.src = sourceURL !== null && sourceURL !== void 0 ? sourceURL : null;
      this.currentURL = this.element.src;
      this.settingSourceURL = false;
    }
    get loadingStyle() {
      return this.element.loading;
    }
    get isLoading() {
      return this.formSubmission !== void 0 || this.resolveVisitPromise() !== void 0;
    }
    get isActive() {
      return this.element.isActive && this.connected;
    }
    get rootLocation() {
      var _a;
      const meta = this.element.ownerDocument.querySelector(`meta[name="turbo-root"]`);
      const root = (_a = meta === null || meta === void 0 ? void 0 : meta.content) !== null && _a !== void 0 ? _a : "/";
      return expandURL(root);
    }
  };
  var SnapshotSubstitution = class {
    constructor(element) {
      this.visitCachedSnapshot = ({ element: element2 }) => {
        var _a;
        const { id, clone } = this;
        (_a = element2.querySelector("#" + id)) === null || _a === void 0 ? void 0 : _a.replaceWith(clone);
      };
      this.clone = element.cloneNode(true);
      this.id = element.id;
    }
  };
  function getFrameElementById(id) {
    if (id != null) {
      const element = document.getElementById(id);
      if (element instanceof FrameElement) {
        return element;
      }
    }
  }
  function activateElement(element, currentURL) {
    if (element) {
      const src = element.getAttribute("src");
      if (src != null && currentURL != null && urlsAreEqual(src, currentURL)) {
        throw new Error(`Matching <turbo-frame id="${element.id}"> element has a source URL which references itself`);
      }
      if (element.ownerDocument !== document) {
        element = document.importNode(element, true);
      }
      if (element instanceof FrameElement) {
        element.connectedCallback();
        element.disconnectedCallback();
        return element;
      }
    }
  }
  var StreamActions = {
    after() {
      this.targetElements.forEach((e) => {
        var _a;
        return (_a = e.parentElement) === null || _a === void 0 ? void 0 : _a.insertBefore(this.templateContent, e.nextSibling);
      });
    },
    append() {
      this.removeDuplicateTargetChildren();
      this.targetElements.forEach((e) => e.append(this.templateContent));
    },
    before() {
      this.targetElements.forEach((e) => {
        var _a;
        return (_a = e.parentElement) === null || _a === void 0 ? void 0 : _a.insertBefore(this.templateContent, e);
      });
    },
    prepend() {
      this.removeDuplicateTargetChildren();
      this.targetElements.forEach((e) => e.prepend(this.templateContent));
    },
    remove() {
      this.targetElements.forEach((e) => e.remove());
    },
    replace() {
      this.targetElements.forEach((e) => e.replaceWith(this.templateContent));
    },
    update() {
      this.targetElements.forEach((e) => {
        e.innerHTML = "";
        e.append(this.templateContent);
      });
    }
  };
  var StreamElement = class extends HTMLElement {
    async connectedCallback() {
      try {
        await this.render();
      } catch (error2) {
        console.error(error2);
      } finally {
        this.disconnect();
      }
    }
    async render() {
      var _a;
      return (_a = this.renderPromise) !== null && _a !== void 0 ? _a : this.renderPromise = (async () => {
        if (this.dispatchEvent(this.beforeRenderEvent)) {
          await nextAnimationFrame();
          this.performAction();
        }
      })();
    }
    disconnect() {
      try {
        this.remove();
      } catch (_a) {
      }
    }
    removeDuplicateTargetChildren() {
      this.duplicateChildren.forEach((c) => c.remove());
    }
    get duplicateChildren() {
      var _a;
      const existingChildren = this.targetElements.flatMap((e) => [...e.children]).filter((c) => !!c.id);
      const newChildrenIds = [...(_a = this.templateContent) === null || _a === void 0 ? void 0 : _a.children].filter((c) => !!c.id).map((c) => c.id);
      return existingChildren.filter((c) => newChildrenIds.includes(c.id));
    }
    get performAction() {
      if (this.action) {
        const actionFunction = StreamActions[this.action];
        if (actionFunction) {
          return actionFunction;
        }
        this.raise("unknown action");
      }
      this.raise("action attribute is missing");
    }
    get targetElements() {
      if (this.target) {
        return this.targetElementsById;
      } else if (this.targets) {
        return this.targetElementsByQuery;
      } else {
        this.raise("target or targets attribute is missing");
      }
    }
    get templateContent() {
      return this.templateElement.content.cloneNode(true);
    }
    get templateElement() {
      if (this.firstElementChild instanceof HTMLTemplateElement) {
        return this.firstElementChild;
      }
      this.raise("first child element must be a <template> element");
    }
    get action() {
      return this.getAttribute("action");
    }
    get target() {
      return this.getAttribute("target");
    }
    get targets() {
      return this.getAttribute("targets");
    }
    raise(message) {
      throw new Error(`${this.description}: ${message}`);
    }
    get description() {
      var _a, _b;
      return (_b = ((_a = this.outerHTML.match(/<[^>]+>/)) !== null && _a !== void 0 ? _a : [])[0]) !== null && _b !== void 0 ? _b : "<turbo-stream>";
    }
    get beforeRenderEvent() {
      return new CustomEvent("turbo:before-stream-render", { bubbles: true, cancelable: true });
    }
    get targetElementsById() {
      var _a;
      const element = (_a = this.ownerDocument) === null || _a === void 0 ? void 0 : _a.getElementById(this.target);
      if (element !== null) {
        return [element];
      } else {
        return [];
      }
    }
    get targetElementsByQuery() {
      var _a;
      const elements = (_a = this.ownerDocument) === null || _a === void 0 ? void 0 : _a.querySelectorAll(this.targets);
      if (elements.length !== 0) {
        return Array.prototype.slice.call(elements);
      } else {
        return [];
      }
    }
  };
  FrameElement.delegateConstructor = FrameController;
  customElements.define("turbo-frame", FrameElement);
  customElements.define("turbo-stream", StreamElement);
  (() => {
    let element = document.currentScript;
    if (!element)
      return;
    if (element.hasAttribute("data-turbo-suppress-warning"))
      return;
    while (element = element.parentElement) {
      if (element == document.body) {
        return console.warn(unindent`
        You are loading Turbo from a <script> element inside the <body> element. This is probably not what you meant to do!

        Load your applications JavaScript bundle inside the <head> element instead. <script> elements in <body> are evaluated with each page change.

        For more information, see: https://turbo.hotwired.dev/handbook/building#working-with-script-elements

        
        Suppress this warning by adding a "data-turbo-suppress-warning" attribute to: %s
      `, element.outerHTML);
      }
    }
  })();
  window.Turbo = Turbo;
  start();

  // node_modules/@hotwired/turbo-rails/app/javascript/turbo/cable.js
  var consumer;
  async function getConsumer() {
    return consumer || setConsumer(createConsumer2().then(setConsumer));
  }
  function setConsumer(newConsumer) {
    return consumer = newConsumer;
  }
  async function createConsumer2() {
    const { createConsumer: createConsumer4 } = await Promise.resolve().then(() => (init_src(), src_exports));
    return createConsumer4();
  }
  async function subscribeTo(channel, mixin) {
    const { subscriptions } = await getConsumer();
    return subscriptions.create(channel, mixin);
  }

  // node_modules/@hotwired/turbo-rails/app/javascript/turbo/snakeize.js
  function walk(obj) {
    if (!obj || typeof obj !== "object")
      return obj;
    if (obj instanceof Date || obj instanceof RegExp)
      return obj;
    if (Array.isArray(obj))
      return obj.map(walk);
    return Object.keys(obj).reduce(function(acc, key) {
      var camel = key[0].toLowerCase() + key.slice(1).replace(/([A-Z]+)/g, function(m, x) {
        return "_" + x.toLowerCase();
      });
      acc[camel] = walk(obj[key]);
      return acc;
    }, {});
  }

  // node_modules/@hotwired/turbo-rails/app/javascript/turbo/cable_stream_source_element.js
  var TurboCableStreamSourceElement = class extends HTMLElement {
    async connectedCallback() {
      connectStreamSource(this);
      this.subscription = await subscribeTo(this.channel, { received: this.dispatchMessageEvent.bind(this) });
    }
    disconnectedCallback() {
      disconnectStreamSource(this);
      if (this.subscription)
        this.subscription.unsubscribe();
    }
    dispatchMessageEvent(data) {
      const event = new MessageEvent("message", { data });
      return this.dispatchEvent(event);
    }
    get channel() {
      const channel = this.getAttribute("channel");
      const signed_stream_name = this.getAttribute("signed-stream-name");
      return { channel, signed_stream_name, ...walk({ ...this.dataset }) };
    }
  };
  customElements.define("turbo-cable-stream-source", TurboCableStreamSourceElement);

  // node_modules/@hotwired/turbo-rails/app/javascript/turbo/form_submissions.js
  function overrideMethodWithFormmethod({ detail: { formSubmission: { fetchRequest, submitter } } }) {
    if (submitter && submitter.formMethod && fetchRequest.body.has("_method")) {
      fetchRequest.body.set("_method", submitter.formMethod);
    }
  }

  // node_modules/@hotwired/turbo-rails/app/javascript/turbo/index.js
  addEventListener("turbo:submit-start", overrideMethodWithFormmethod);

  // node_modules/@hotwired/stimulus/dist/stimulus.js
  var EventListener = class {
    constructor(eventTarget, eventName, eventOptions) {
      this.eventTarget = eventTarget;
      this.eventName = eventName;
      this.eventOptions = eventOptions;
      this.unorderedBindings = /* @__PURE__ */ new Set();
    }
    connect() {
      this.eventTarget.addEventListener(this.eventName, this, this.eventOptions);
    }
    disconnect() {
      this.eventTarget.removeEventListener(this.eventName, this, this.eventOptions);
    }
    bindingConnected(binding) {
      this.unorderedBindings.add(binding);
    }
    bindingDisconnected(binding) {
      this.unorderedBindings.delete(binding);
    }
    handleEvent(event) {
      const extendedEvent = extendEvent(event);
      for (const binding of this.bindings) {
        if (extendedEvent.immediatePropagationStopped) {
          break;
        } else {
          binding.handleEvent(extendedEvent);
        }
      }
    }
    get bindings() {
      return Array.from(this.unorderedBindings).sort((left, right) => {
        const leftIndex = left.index, rightIndex = right.index;
        return leftIndex < rightIndex ? -1 : leftIndex > rightIndex ? 1 : 0;
      });
    }
  };
  function extendEvent(event) {
    if ("immediatePropagationStopped" in event) {
      return event;
    } else {
      const { stopImmediatePropagation } = event;
      return Object.assign(event, {
        immediatePropagationStopped: false,
        stopImmediatePropagation() {
          this.immediatePropagationStopped = true;
          stopImmediatePropagation.call(this);
        }
      });
    }
  }
  var Dispatcher = class {
    constructor(application2) {
      this.application = application2;
      this.eventListenerMaps = /* @__PURE__ */ new Map();
      this.started = false;
    }
    start() {
      if (!this.started) {
        this.started = true;
        this.eventListeners.forEach((eventListener) => eventListener.connect());
      }
    }
    stop() {
      if (this.started) {
        this.started = false;
        this.eventListeners.forEach((eventListener) => eventListener.disconnect());
      }
    }
    get eventListeners() {
      return Array.from(this.eventListenerMaps.values()).reduce((listeners, map) => listeners.concat(Array.from(map.values())), []);
    }
    bindingConnected(binding) {
      this.fetchEventListenerForBinding(binding).bindingConnected(binding);
    }
    bindingDisconnected(binding) {
      this.fetchEventListenerForBinding(binding).bindingDisconnected(binding);
    }
    handleError(error2, message, detail = {}) {
      this.application.handleError(error2, `Error ${message}`, detail);
    }
    fetchEventListenerForBinding(binding) {
      const { eventTarget, eventName, eventOptions } = binding;
      return this.fetchEventListener(eventTarget, eventName, eventOptions);
    }
    fetchEventListener(eventTarget, eventName, eventOptions) {
      const eventListenerMap = this.fetchEventListenerMapForEventTarget(eventTarget);
      const cacheKey = this.cacheKey(eventName, eventOptions);
      let eventListener = eventListenerMap.get(cacheKey);
      if (!eventListener) {
        eventListener = this.createEventListener(eventTarget, eventName, eventOptions);
        eventListenerMap.set(cacheKey, eventListener);
      }
      return eventListener;
    }
    createEventListener(eventTarget, eventName, eventOptions) {
      const eventListener = new EventListener(eventTarget, eventName, eventOptions);
      if (this.started) {
        eventListener.connect();
      }
      return eventListener;
    }
    fetchEventListenerMapForEventTarget(eventTarget) {
      let eventListenerMap = this.eventListenerMaps.get(eventTarget);
      if (!eventListenerMap) {
        eventListenerMap = /* @__PURE__ */ new Map();
        this.eventListenerMaps.set(eventTarget, eventListenerMap);
      }
      return eventListenerMap;
    }
    cacheKey(eventName, eventOptions) {
      const parts = [eventName];
      Object.keys(eventOptions).sort().forEach((key) => {
        parts.push(`${eventOptions[key] ? "" : "!"}${key}`);
      });
      return parts.join(":");
    }
  };
  var descriptorPattern = /^((.+?)(@(window|document))?->)?(.+?)(#([^:]+?))(:(.+))?$/;
  function parseActionDescriptorString(descriptorString) {
    const source = descriptorString.trim();
    const matches = source.match(descriptorPattern) || [];
    return {
      eventTarget: parseEventTarget(matches[4]),
      eventName: matches[2],
      eventOptions: matches[9] ? parseEventOptions(matches[9]) : {},
      identifier: matches[5],
      methodName: matches[7]
    };
  }
  function parseEventTarget(eventTargetName) {
    if (eventTargetName == "window") {
      return window;
    } else if (eventTargetName == "document") {
      return document;
    }
  }
  function parseEventOptions(eventOptions) {
    return eventOptions.split(":").reduce((options, token) => Object.assign(options, { [token.replace(/^!/, "")]: !/^!/.test(token) }), {});
  }
  function stringifyEventTarget(eventTarget) {
    if (eventTarget == window) {
      return "window";
    } else if (eventTarget == document) {
      return "document";
    }
  }
  function camelize(value) {
    return value.replace(/(?:[_-])([a-z0-9])/g, (_2, char) => char.toUpperCase());
  }
  function capitalize(value) {
    return value.charAt(0).toUpperCase() + value.slice(1);
  }
  function dasherize(value) {
    return value.replace(/([A-Z])/g, (_2, char) => `-${char.toLowerCase()}`);
  }
  function tokenize(value) {
    return value.match(/[^\s]+/g) || [];
  }
  var Action = class {
    constructor(element, index, descriptor) {
      this.element = element;
      this.index = index;
      this.eventTarget = descriptor.eventTarget || element;
      this.eventName = descriptor.eventName || getDefaultEventNameForElement(element) || error("missing event name");
      this.eventOptions = descriptor.eventOptions || {};
      this.identifier = descriptor.identifier || error("missing identifier");
      this.methodName = descriptor.methodName || error("missing method name");
    }
    static forToken(token) {
      return new this(token.element, token.index, parseActionDescriptorString(token.content));
    }
    toString() {
      const eventNameSuffix = this.eventTargetName ? `@${this.eventTargetName}` : "";
      return `${this.eventName}${eventNameSuffix}->${this.identifier}#${this.methodName}`;
    }
    get params() {
      if (this.eventTarget instanceof Element) {
        return this.getParamsFromEventTargetAttributes(this.eventTarget);
      } else {
        return {};
      }
    }
    getParamsFromEventTargetAttributes(eventTarget) {
      const params = {};
      const pattern = new RegExp(`^data-${this.identifier}-(.+)-param$`);
      const attributes = Array.from(eventTarget.attributes);
      attributes.forEach(({ name, value }) => {
        const match = name.match(pattern);
        const key = match && match[1];
        if (key) {
          Object.assign(params, { [camelize(key)]: typecast(value) });
        }
      });
      return params;
    }
    get eventTargetName() {
      return stringifyEventTarget(this.eventTarget);
    }
  };
  var defaultEventNames = {
    "a": (e) => "click",
    "button": (e) => "click",
    "form": (e) => "submit",
    "details": (e) => "toggle",
    "input": (e) => e.getAttribute("type") == "submit" ? "click" : "input",
    "select": (e) => "change",
    "textarea": (e) => "input"
  };
  function getDefaultEventNameForElement(element) {
    const tagName = element.tagName.toLowerCase();
    if (tagName in defaultEventNames) {
      return defaultEventNames[tagName](element);
    }
  }
  function error(message) {
    throw new Error(message);
  }
  function typecast(value) {
    try {
      return JSON.parse(value);
    } catch (o_O) {
      return value;
    }
  }
  var Binding = class {
    constructor(context, action) {
      this.context = context;
      this.action = action;
    }
    get index() {
      return this.action.index;
    }
    get eventTarget() {
      return this.action.eventTarget;
    }
    get eventOptions() {
      return this.action.eventOptions;
    }
    get identifier() {
      return this.context.identifier;
    }
    handleEvent(event) {
      if (this.willBeInvokedByEvent(event)) {
        this.invokeWithEvent(event);
      }
    }
    get eventName() {
      return this.action.eventName;
    }
    get method() {
      const method = this.controller[this.methodName];
      if (typeof method == "function") {
        return method;
      }
      throw new Error(`Action "${this.action}" references undefined method "${this.methodName}"`);
    }
    invokeWithEvent(event) {
      const { target, currentTarget } = event;
      try {
        const { params } = this.action;
        const actionEvent = Object.assign(event, { params });
        this.method.call(this.controller, actionEvent);
        this.context.logDebugActivity(this.methodName, { event, target, currentTarget, action: this.methodName });
      } catch (error2) {
        const { identifier, controller, element, index } = this;
        const detail = { identifier, controller, element, index, event };
        this.context.handleError(error2, `invoking action "${this.action}"`, detail);
      }
    }
    willBeInvokedByEvent(event) {
      const eventTarget = event.target;
      if (this.element === eventTarget) {
        return true;
      } else if (eventTarget instanceof Element && this.element.contains(eventTarget)) {
        return this.scope.containsElement(eventTarget);
      } else {
        return this.scope.containsElement(this.action.element);
      }
    }
    get controller() {
      return this.context.controller;
    }
    get methodName() {
      return this.action.methodName;
    }
    get element() {
      return this.scope.element;
    }
    get scope() {
      return this.context.scope;
    }
  };
  var ElementObserver = class {
    constructor(element, delegate) {
      this.mutationObserverInit = { attributes: true, childList: true, subtree: true };
      this.element = element;
      this.started = false;
      this.delegate = delegate;
      this.elements = /* @__PURE__ */ new Set();
      this.mutationObserver = new MutationObserver((mutations) => this.processMutations(mutations));
    }
    start() {
      if (!this.started) {
        this.started = true;
        this.mutationObserver.observe(this.element, this.mutationObserverInit);
        this.refresh();
      }
    }
    pause(callback) {
      if (this.started) {
        this.mutationObserver.disconnect();
        this.started = false;
      }
      callback();
      if (!this.started) {
        this.mutationObserver.observe(this.element, this.mutationObserverInit);
        this.started = true;
      }
    }
    stop() {
      if (this.started) {
        this.mutationObserver.takeRecords();
        this.mutationObserver.disconnect();
        this.started = false;
      }
    }
    refresh() {
      if (this.started) {
        const matches = new Set(this.matchElementsInTree());
        for (const element of Array.from(this.elements)) {
          if (!matches.has(element)) {
            this.removeElement(element);
          }
        }
        for (const element of Array.from(matches)) {
          this.addElement(element);
        }
      }
    }
    processMutations(mutations) {
      if (this.started) {
        for (const mutation of mutations) {
          this.processMutation(mutation);
        }
      }
    }
    processMutation(mutation) {
      if (mutation.type == "attributes") {
        this.processAttributeChange(mutation.target, mutation.attributeName);
      } else if (mutation.type == "childList") {
        this.processRemovedNodes(mutation.removedNodes);
        this.processAddedNodes(mutation.addedNodes);
      }
    }
    processAttributeChange(node, attributeName) {
      const element = node;
      if (this.elements.has(element)) {
        if (this.delegate.elementAttributeChanged && this.matchElement(element)) {
          this.delegate.elementAttributeChanged(element, attributeName);
        } else {
          this.removeElement(element);
        }
      } else if (this.matchElement(element)) {
        this.addElement(element);
      }
    }
    processRemovedNodes(nodes) {
      for (const node of Array.from(nodes)) {
        const element = this.elementFromNode(node);
        if (element) {
          this.processTree(element, this.removeElement);
        }
      }
    }
    processAddedNodes(nodes) {
      for (const node of Array.from(nodes)) {
        const element = this.elementFromNode(node);
        if (element && this.elementIsActive(element)) {
          this.processTree(element, this.addElement);
        }
      }
    }
    matchElement(element) {
      return this.delegate.matchElement(element);
    }
    matchElementsInTree(tree = this.element) {
      return this.delegate.matchElementsInTree(tree);
    }
    processTree(tree, processor) {
      for (const element of this.matchElementsInTree(tree)) {
        processor.call(this, element);
      }
    }
    elementFromNode(node) {
      if (node.nodeType == Node.ELEMENT_NODE) {
        return node;
      }
    }
    elementIsActive(element) {
      if (element.isConnected != this.element.isConnected) {
        return false;
      } else {
        return this.element.contains(element);
      }
    }
    addElement(element) {
      if (!this.elements.has(element)) {
        if (this.elementIsActive(element)) {
          this.elements.add(element);
          if (this.delegate.elementMatched) {
            this.delegate.elementMatched(element);
          }
        }
      }
    }
    removeElement(element) {
      if (this.elements.has(element)) {
        this.elements.delete(element);
        if (this.delegate.elementUnmatched) {
          this.delegate.elementUnmatched(element);
        }
      }
    }
  };
  var AttributeObserver = class {
    constructor(element, attributeName, delegate) {
      this.attributeName = attributeName;
      this.delegate = delegate;
      this.elementObserver = new ElementObserver(element, this);
    }
    get element() {
      return this.elementObserver.element;
    }
    get selector() {
      return `[${this.attributeName}]`;
    }
    start() {
      this.elementObserver.start();
    }
    pause(callback) {
      this.elementObserver.pause(callback);
    }
    stop() {
      this.elementObserver.stop();
    }
    refresh() {
      this.elementObserver.refresh();
    }
    get started() {
      return this.elementObserver.started;
    }
    matchElement(element) {
      return element.hasAttribute(this.attributeName);
    }
    matchElementsInTree(tree) {
      const match = this.matchElement(tree) ? [tree] : [];
      const matches = Array.from(tree.querySelectorAll(this.selector));
      return match.concat(matches);
    }
    elementMatched(element) {
      if (this.delegate.elementMatchedAttribute) {
        this.delegate.elementMatchedAttribute(element, this.attributeName);
      }
    }
    elementUnmatched(element) {
      if (this.delegate.elementUnmatchedAttribute) {
        this.delegate.elementUnmatchedAttribute(element, this.attributeName);
      }
    }
    elementAttributeChanged(element, attributeName) {
      if (this.delegate.elementAttributeValueChanged && this.attributeName == attributeName) {
        this.delegate.elementAttributeValueChanged(element, attributeName);
      }
    }
  };
  var StringMapObserver = class {
    constructor(element, delegate) {
      this.element = element;
      this.delegate = delegate;
      this.started = false;
      this.stringMap = /* @__PURE__ */ new Map();
      this.mutationObserver = new MutationObserver((mutations) => this.processMutations(mutations));
    }
    start() {
      if (!this.started) {
        this.started = true;
        this.mutationObserver.observe(this.element, { attributes: true, attributeOldValue: true });
        this.refresh();
      }
    }
    stop() {
      if (this.started) {
        this.mutationObserver.takeRecords();
        this.mutationObserver.disconnect();
        this.started = false;
      }
    }
    refresh() {
      if (this.started) {
        for (const attributeName of this.knownAttributeNames) {
          this.refreshAttribute(attributeName, null);
        }
      }
    }
    processMutations(mutations) {
      if (this.started) {
        for (const mutation of mutations) {
          this.processMutation(mutation);
        }
      }
    }
    processMutation(mutation) {
      const attributeName = mutation.attributeName;
      if (attributeName) {
        this.refreshAttribute(attributeName, mutation.oldValue);
      }
    }
    refreshAttribute(attributeName, oldValue) {
      const key = this.delegate.getStringMapKeyForAttribute(attributeName);
      if (key != null) {
        if (!this.stringMap.has(attributeName)) {
          this.stringMapKeyAdded(key, attributeName);
        }
        const value = this.element.getAttribute(attributeName);
        if (this.stringMap.get(attributeName) != value) {
          this.stringMapValueChanged(value, key, oldValue);
        }
        if (value == null) {
          const oldValue2 = this.stringMap.get(attributeName);
          this.stringMap.delete(attributeName);
          if (oldValue2)
            this.stringMapKeyRemoved(key, attributeName, oldValue2);
        } else {
          this.stringMap.set(attributeName, value);
        }
      }
    }
    stringMapKeyAdded(key, attributeName) {
      if (this.delegate.stringMapKeyAdded) {
        this.delegate.stringMapKeyAdded(key, attributeName);
      }
    }
    stringMapValueChanged(value, key, oldValue) {
      if (this.delegate.stringMapValueChanged) {
        this.delegate.stringMapValueChanged(value, key, oldValue);
      }
    }
    stringMapKeyRemoved(key, attributeName, oldValue) {
      if (this.delegate.stringMapKeyRemoved) {
        this.delegate.stringMapKeyRemoved(key, attributeName, oldValue);
      }
    }
    get knownAttributeNames() {
      return Array.from(new Set(this.currentAttributeNames.concat(this.recordedAttributeNames)));
    }
    get currentAttributeNames() {
      return Array.from(this.element.attributes).map((attribute) => attribute.name);
    }
    get recordedAttributeNames() {
      return Array.from(this.stringMap.keys());
    }
  };
  function add(map, key, value) {
    fetch2(map, key).add(value);
  }
  function del(map, key, value) {
    fetch2(map, key).delete(value);
    prune(map, key);
  }
  function fetch2(map, key) {
    let values = map.get(key);
    if (!values) {
      values = /* @__PURE__ */ new Set();
      map.set(key, values);
    }
    return values;
  }
  function prune(map, key) {
    const values = map.get(key);
    if (values != null && values.size == 0) {
      map.delete(key);
    }
  }
  var Multimap = class {
    constructor() {
      this.valuesByKey = /* @__PURE__ */ new Map();
    }
    get keys() {
      return Array.from(this.valuesByKey.keys());
    }
    get values() {
      const sets = Array.from(this.valuesByKey.values());
      return sets.reduce((values, set) => values.concat(Array.from(set)), []);
    }
    get size() {
      const sets = Array.from(this.valuesByKey.values());
      return sets.reduce((size, set) => size + set.size, 0);
    }
    add(key, value) {
      add(this.valuesByKey, key, value);
    }
    delete(key, value) {
      del(this.valuesByKey, key, value);
    }
    has(key, value) {
      const values = this.valuesByKey.get(key);
      return values != null && values.has(value);
    }
    hasKey(key) {
      return this.valuesByKey.has(key);
    }
    hasValue(value) {
      const sets = Array.from(this.valuesByKey.values());
      return sets.some((set) => set.has(value));
    }
    getValuesForKey(key) {
      const values = this.valuesByKey.get(key);
      return values ? Array.from(values) : [];
    }
    getKeysForValue(value) {
      return Array.from(this.valuesByKey).filter(([key, values]) => values.has(value)).map(([key, values]) => key);
    }
  };
  var TokenListObserver = class {
    constructor(element, attributeName, delegate) {
      this.attributeObserver = new AttributeObserver(element, attributeName, this);
      this.delegate = delegate;
      this.tokensByElement = new Multimap();
    }
    get started() {
      return this.attributeObserver.started;
    }
    start() {
      this.attributeObserver.start();
    }
    pause(callback) {
      this.attributeObserver.pause(callback);
    }
    stop() {
      this.attributeObserver.stop();
    }
    refresh() {
      this.attributeObserver.refresh();
    }
    get element() {
      return this.attributeObserver.element;
    }
    get attributeName() {
      return this.attributeObserver.attributeName;
    }
    elementMatchedAttribute(element) {
      this.tokensMatched(this.readTokensForElement(element));
    }
    elementAttributeValueChanged(element) {
      const [unmatchedTokens, matchedTokens] = this.refreshTokensForElement(element);
      this.tokensUnmatched(unmatchedTokens);
      this.tokensMatched(matchedTokens);
    }
    elementUnmatchedAttribute(element) {
      this.tokensUnmatched(this.tokensByElement.getValuesForKey(element));
    }
    tokensMatched(tokens) {
      tokens.forEach((token) => this.tokenMatched(token));
    }
    tokensUnmatched(tokens) {
      tokens.forEach((token) => this.tokenUnmatched(token));
    }
    tokenMatched(token) {
      this.delegate.tokenMatched(token);
      this.tokensByElement.add(token.element, token);
    }
    tokenUnmatched(token) {
      this.delegate.tokenUnmatched(token);
      this.tokensByElement.delete(token.element, token);
    }
    refreshTokensForElement(element) {
      const previousTokens = this.tokensByElement.getValuesForKey(element);
      const currentTokens = this.readTokensForElement(element);
      const firstDifferingIndex = zip(previousTokens, currentTokens).findIndex(([previousToken, currentToken]) => !tokensAreEqual(previousToken, currentToken));
      if (firstDifferingIndex == -1) {
        return [[], []];
      } else {
        return [previousTokens.slice(firstDifferingIndex), currentTokens.slice(firstDifferingIndex)];
      }
    }
    readTokensForElement(element) {
      const attributeName = this.attributeName;
      const tokenString = element.getAttribute(attributeName) || "";
      return parseTokenString(tokenString, element, attributeName);
    }
  };
  function parseTokenString(tokenString, element, attributeName) {
    return tokenString.trim().split(/\s+/).filter((content) => content.length).map((content, index) => ({ element, attributeName, content, index }));
  }
  function zip(left, right) {
    const length = Math.max(left.length, right.length);
    return Array.from({ length }, (_2, index) => [left[index], right[index]]);
  }
  function tokensAreEqual(left, right) {
    return left && right && left.index == right.index && left.content == right.content;
  }
  var ValueListObserver = class {
    constructor(element, attributeName, delegate) {
      this.tokenListObserver = new TokenListObserver(element, attributeName, this);
      this.delegate = delegate;
      this.parseResultsByToken = /* @__PURE__ */ new WeakMap();
      this.valuesByTokenByElement = /* @__PURE__ */ new WeakMap();
    }
    get started() {
      return this.tokenListObserver.started;
    }
    start() {
      this.tokenListObserver.start();
    }
    stop() {
      this.tokenListObserver.stop();
    }
    refresh() {
      this.tokenListObserver.refresh();
    }
    get element() {
      return this.tokenListObserver.element;
    }
    get attributeName() {
      return this.tokenListObserver.attributeName;
    }
    tokenMatched(token) {
      const { element } = token;
      const { value } = this.fetchParseResultForToken(token);
      if (value) {
        this.fetchValuesByTokenForElement(element).set(token, value);
        this.delegate.elementMatchedValue(element, value);
      }
    }
    tokenUnmatched(token) {
      const { element } = token;
      const { value } = this.fetchParseResultForToken(token);
      if (value) {
        this.fetchValuesByTokenForElement(element).delete(token);
        this.delegate.elementUnmatchedValue(element, value);
      }
    }
    fetchParseResultForToken(token) {
      let parseResult = this.parseResultsByToken.get(token);
      if (!parseResult) {
        parseResult = this.parseToken(token);
        this.parseResultsByToken.set(token, parseResult);
      }
      return parseResult;
    }
    fetchValuesByTokenForElement(element) {
      let valuesByToken = this.valuesByTokenByElement.get(element);
      if (!valuesByToken) {
        valuesByToken = /* @__PURE__ */ new Map();
        this.valuesByTokenByElement.set(element, valuesByToken);
      }
      return valuesByToken;
    }
    parseToken(token) {
      try {
        const value = this.delegate.parseValueForToken(token);
        return { value };
      } catch (error2) {
        return { error: error2 };
      }
    }
  };
  var BindingObserver = class {
    constructor(context, delegate) {
      this.context = context;
      this.delegate = delegate;
      this.bindingsByAction = /* @__PURE__ */ new Map();
    }
    start() {
      if (!this.valueListObserver) {
        this.valueListObserver = new ValueListObserver(this.element, this.actionAttribute, this);
        this.valueListObserver.start();
      }
    }
    stop() {
      if (this.valueListObserver) {
        this.valueListObserver.stop();
        delete this.valueListObserver;
        this.disconnectAllActions();
      }
    }
    get element() {
      return this.context.element;
    }
    get identifier() {
      return this.context.identifier;
    }
    get actionAttribute() {
      return this.schema.actionAttribute;
    }
    get schema() {
      return this.context.schema;
    }
    get bindings() {
      return Array.from(this.bindingsByAction.values());
    }
    connectAction(action) {
      const binding = new Binding(this.context, action);
      this.bindingsByAction.set(action, binding);
      this.delegate.bindingConnected(binding);
    }
    disconnectAction(action) {
      const binding = this.bindingsByAction.get(action);
      if (binding) {
        this.bindingsByAction.delete(action);
        this.delegate.bindingDisconnected(binding);
      }
    }
    disconnectAllActions() {
      this.bindings.forEach((binding) => this.delegate.bindingDisconnected(binding));
      this.bindingsByAction.clear();
    }
    parseValueForToken(token) {
      const action = Action.forToken(token);
      if (action.identifier == this.identifier) {
        return action;
      }
    }
    elementMatchedValue(element, action) {
      this.connectAction(action);
    }
    elementUnmatchedValue(element, action) {
      this.disconnectAction(action);
    }
  };
  var ValueObserver = class {
    constructor(context, receiver) {
      this.context = context;
      this.receiver = receiver;
      this.stringMapObserver = new StringMapObserver(this.element, this);
      this.valueDescriptorMap = this.controller.valueDescriptorMap;
      this.invokeChangedCallbacksForDefaultValues();
    }
    start() {
      this.stringMapObserver.start();
    }
    stop() {
      this.stringMapObserver.stop();
    }
    get element() {
      return this.context.element;
    }
    get controller() {
      return this.context.controller;
    }
    getStringMapKeyForAttribute(attributeName) {
      if (attributeName in this.valueDescriptorMap) {
        return this.valueDescriptorMap[attributeName].name;
      }
    }
    stringMapKeyAdded(key, attributeName) {
      const descriptor = this.valueDescriptorMap[attributeName];
      if (!this.hasValue(key)) {
        this.invokeChangedCallback(key, descriptor.writer(this.receiver[key]), descriptor.writer(descriptor.defaultValue));
      }
    }
    stringMapValueChanged(value, name, oldValue) {
      const descriptor = this.valueDescriptorNameMap[name];
      if (value === null)
        return;
      if (oldValue === null) {
        oldValue = descriptor.writer(descriptor.defaultValue);
      }
      this.invokeChangedCallback(name, value, oldValue);
    }
    stringMapKeyRemoved(key, attributeName, oldValue) {
      const descriptor = this.valueDescriptorNameMap[key];
      if (this.hasValue(key)) {
        this.invokeChangedCallback(key, descriptor.writer(this.receiver[key]), oldValue);
      } else {
        this.invokeChangedCallback(key, descriptor.writer(descriptor.defaultValue), oldValue);
      }
    }
    invokeChangedCallbacksForDefaultValues() {
      for (const { key, name, defaultValue, writer } of this.valueDescriptors) {
        if (defaultValue != void 0 && !this.controller.data.has(key)) {
          this.invokeChangedCallback(name, writer(defaultValue), void 0);
        }
      }
    }
    invokeChangedCallback(name, rawValue, rawOldValue) {
      const changedMethodName = `${name}Changed`;
      const changedMethod = this.receiver[changedMethodName];
      if (typeof changedMethod == "function") {
        const descriptor = this.valueDescriptorNameMap[name];
        const value = descriptor.reader(rawValue);
        let oldValue = rawOldValue;
        if (rawOldValue) {
          oldValue = descriptor.reader(rawOldValue);
        }
        changedMethod.call(this.receiver, value, oldValue);
      }
    }
    get valueDescriptors() {
      const { valueDescriptorMap } = this;
      return Object.keys(valueDescriptorMap).map((key) => valueDescriptorMap[key]);
    }
    get valueDescriptorNameMap() {
      const descriptors = {};
      Object.keys(this.valueDescriptorMap).forEach((key) => {
        const descriptor = this.valueDescriptorMap[key];
        descriptors[descriptor.name] = descriptor;
      });
      return descriptors;
    }
    hasValue(attributeName) {
      const descriptor = this.valueDescriptorNameMap[attributeName];
      const hasMethodName = `has${capitalize(descriptor.name)}`;
      return this.receiver[hasMethodName];
    }
  };
  var TargetObserver = class {
    constructor(context, delegate) {
      this.context = context;
      this.delegate = delegate;
      this.targetsByName = new Multimap();
    }
    start() {
      if (!this.tokenListObserver) {
        this.tokenListObserver = new TokenListObserver(this.element, this.attributeName, this);
        this.tokenListObserver.start();
      }
    }
    stop() {
      if (this.tokenListObserver) {
        this.disconnectAllTargets();
        this.tokenListObserver.stop();
        delete this.tokenListObserver;
      }
    }
    tokenMatched({ element, content: name }) {
      if (this.scope.containsElement(element)) {
        this.connectTarget(element, name);
      }
    }
    tokenUnmatched({ element, content: name }) {
      this.disconnectTarget(element, name);
    }
    connectTarget(element, name) {
      var _a;
      if (!this.targetsByName.has(name, element)) {
        this.targetsByName.add(name, element);
        (_a = this.tokenListObserver) === null || _a === void 0 ? void 0 : _a.pause(() => this.delegate.targetConnected(element, name));
      }
    }
    disconnectTarget(element, name) {
      var _a;
      if (this.targetsByName.has(name, element)) {
        this.targetsByName.delete(name, element);
        (_a = this.tokenListObserver) === null || _a === void 0 ? void 0 : _a.pause(() => this.delegate.targetDisconnected(element, name));
      }
    }
    disconnectAllTargets() {
      for (const name of this.targetsByName.keys) {
        for (const element of this.targetsByName.getValuesForKey(name)) {
          this.disconnectTarget(element, name);
        }
      }
    }
    get attributeName() {
      return `data-${this.context.identifier}-target`;
    }
    get element() {
      return this.context.element;
    }
    get scope() {
      return this.context.scope;
    }
  };
  var Context = class {
    constructor(module, scope) {
      this.logDebugActivity = (functionName, detail = {}) => {
        const { identifier, controller, element } = this;
        detail = Object.assign({ identifier, controller, element }, detail);
        this.application.logDebugActivity(this.identifier, functionName, detail);
      };
      this.module = module;
      this.scope = scope;
      this.controller = new module.controllerConstructor(this);
      this.bindingObserver = new BindingObserver(this, this.dispatcher);
      this.valueObserver = new ValueObserver(this, this.controller);
      this.targetObserver = new TargetObserver(this, this);
      try {
        this.controller.initialize();
        this.logDebugActivity("initialize");
      } catch (error2) {
        this.handleError(error2, "initializing controller");
      }
    }
    connect() {
      this.bindingObserver.start();
      this.valueObserver.start();
      this.targetObserver.start();
      try {
        this.controller.connect();
        this.logDebugActivity("connect");
      } catch (error2) {
        this.handleError(error2, "connecting controller");
      }
    }
    disconnect() {
      try {
        this.controller.disconnect();
        this.logDebugActivity("disconnect");
      } catch (error2) {
        this.handleError(error2, "disconnecting controller");
      }
      this.targetObserver.stop();
      this.valueObserver.stop();
      this.bindingObserver.stop();
    }
    get application() {
      return this.module.application;
    }
    get identifier() {
      return this.module.identifier;
    }
    get schema() {
      return this.application.schema;
    }
    get dispatcher() {
      return this.application.dispatcher;
    }
    get element() {
      return this.scope.element;
    }
    get parentElement() {
      return this.element.parentElement;
    }
    handleError(error2, message, detail = {}) {
      const { identifier, controller, element } = this;
      detail = Object.assign({ identifier, controller, element }, detail);
      this.application.handleError(error2, `Error ${message}`, detail);
    }
    targetConnected(element, name) {
      this.invokeControllerMethod(`${name}TargetConnected`, element);
    }
    targetDisconnected(element, name) {
      this.invokeControllerMethod(`${name}TargetDisconnected`, element);
    }
    invokeControllerMethod(methodName, ...args) {
      const controller = this.controller;
      if (typeof controller[methodName] == "function") {
        controller[methodName](...args);
      }
    }
  };
  function readInheritableStaticArrayValues(constructor, propertyName) {
    const ancestors = getAncestorsForConstructor(constructor);
    return Array.from(ancestors.reduce((values, constructor2) => {
      getOwnStaticArrayValues(constructor2, propertyName).forEach((name) => values.add(name));
      return values;
    }, /* @__PURE__ */ new Set()));
  }
  function readInheritableStaticObjectPairs(constructor, propertyName) {
    const ancestors = getAncestorsForConstructor(constructor);
    return ancestors.reduce((pairs, constructor2) => {
      pairs.push(...getOwnStaticObjectPairs(constructor2, propertyName));
      return pairs;
    }, []);
  }
  function getAncestorsForConstructor(constructor) {
    const ancestors = [];
    while (constructor) {
      ancestors.push(constructor);
      constructor = Object.getPrototypeOf(constructor);
    }
    return ancestors.reverse();
  }
  function getOwnStaticArrayValues(constructor, propertyName) {
    const definition = constructor[propertyName];
    return Array.isArray(definition) ? definition : [];
  }
  function getOwnStaticObjectPairs(constructor, propertyName) {
    const definition = constructor[propertyName];
    return definition ? Object.keys(definition).map((key) => [key, definition[key]]) : [];
  }
  function bless(constructor) {
    return shadow(constructor, getBlessedProperties(constructor));
  }
  function shadow(constructor, properties) {
    const shadowConstructor = extend2(constructor);
    const shadowProperties = getShadowProperties(constructor.prototype, properties);
    Object.defineProperties(shadowConstructor.prototype, shadowProperties);
    return shadowConstructor;
  }
  function getBlessedProperties(constructor) {
    const blessings = readInheritableStaticArrayValues(constructor, "blessings");
    return blessings.reduce((blessedProperties, blessing) => {
      const properties = blessing(constructor);
      for (const key in properties) {
        const descriptor = blessedProperties[key] || {};
        blessedProperties[key] = Object.assign(descriptor, properties[key]);
      }
      return blessedProperties;
    }, {});
  }
  function getShadowProperties(prototype, properties) {
    return getOwnKeys(properties).reduce((shadowProperties, key) => {
      const descriptor = getShadowedDescriptor(prototype, properties, key);
      if (descriptor) {
        Object.assign(shadowProperties, { [key]: descriptor });
      }
      return shadowProperties;
    }, {});
  }
  function getShadowedDescriptor(prototype, properties, key) {
    const shadowingDescriptor = Object.getOwnPropertyDescriptor(prototype, key);
    const shadowedByValue = shadowingDescriptor && "value" in shadowingDescriptor;
    if (!shadowedByValue) {
      const descriptor = Object.getOwnPropertyDescriptor(properties, key).value;
      if (shadowingDescriptor) {
        descriptor.get = shadowingDescriptor.get || descriptor.get;
        descriptor.set = shadowingDescriptor.set || descriptor.set;
      }
      return descriptor;
    }
  }
  var getOwnKeys = (() => {
    if (typeof Object.getOwnPropertySymbols == "function") {
      return (object) => [
        ...Object.getOwnPropertyNames(object),
        ...Object.getOwnPropertySymbols(object)
      ];
    } else {
      return Object.getOwnPropertyNames;
    }
  })();
  var extend2 = (() => {
    function extendWithReflect(constructor) {
      function extended() {
        return Reflect.construct(constructor, arguments, new.target);
      }
      extended.prototype = Object.create(constructor.prototype, {
        constructor: { value: extended }
      });
      Reflect.setPrototypeOf(extended, constructor);
      return extended;
    }
    function testReflectExtension() {
      const a = function() {
        this.a.call(this);
      };
      const b = extendWithReflect(a);
      b.prototype.a = function() {
      };
      return new b();
    }
    try {
      testReflectExtension();
      return extendWithReflect;
    } catch (error2) {
      return (constructor) => class extended extends constructor {
      };
    }
  })();
  function blessDefinition(definition) {
    return {
      identifier: definition.identifier,
      controllerConstructor: bless(definition.controllerConstructor)
    };
  }
  var Module = class {
    constructor(application2, definition) {
      this.application = application2;
      this.definition = blessDefinition(definition);
      this.contextsByScope = /* @__PURE__ */ new WeakMap();
      this.connectedContexts = /* @__PURE__ */ new Set();
    }
    get identifier() {
      return this.definition.identifier;
    }
    get controllerConstructor() {
      return this.definition.controllerConstructor;
    }
    get contexts() {
      return Array.from(this.connectedContexts);
    }
    connectContextForScope(scope) {
      const context = this.fetchContextForScope(scope);
      this.connectedContexts.add(context);
      context.connect();
    }
    disconnectContextForScope(scope) {
      const context = this.contextsByScope.get(scope);
      if (context) {
        this.connectedContexts.delete(context);
        context.disconnect();
      }
    }
    fetchContextForScope(scope) {
      let context = this.contextsByScope.get(scope);
      if (!context) {
        context = new Context(this, scope);
        this.contextsByScope.set(scope, context);
      }
      return context;
    }
  };
  var ClassMap = class {
    constructor(scope) {
      this.scope = scope;
    }
    has(name) {
      return this.data.has(this.getDataKey(name));
    }
    get(name) {
      return this.getAll(name)[0];
    }
    getAll(name) {
      const tokenString = this.data.get(this.getDataKey(name)) || "";
      return tokenize(tokenString);
    }
    getAttributeName(name) {
      return this.data.getAttributeNameForKey(this.getDataKey(name));
    }
    getDataKey(name) {
      return `${name}-class`;
    }
    get data() {
      return this.scope.data;
    }
  };
  var DataMap = class {
    constructor(scope) {
      this.scope = scope;
    }
    get element() {
      return this.scope.element;
    }
    get identifier() {
      return this.scope.identifier;
    }
    get(key) {
      const name = this.getAttributeNameForKey(key);
      return this.element.getAttribute(name);
    }
    set(key, value) {
      const name = this.getAttributeNameForKey(key);
      this.element.setAttribute(name, value);
      return this.get(key);
    }
    has(key) {
      const name = this.getAttributeNameForKey(key);
      return this.element.hasAttribute(name);
    }
    delete(key) {
      if (this.has(key)) {
        const name = this.getAttributeNameForKey(key);
        this.element.removeAttribute(name);
        return true;
      } else {
        return false;
      }
    }
    getAttributeNameForKey(key) {
      return `data-${this.identifier}-${dasherize(key)}`;
    }
  };
  var Guide = class {
    constructor(logger2) {
      this.warnedKeysByObject = /* @__PURE__ */ new WeakMap();
      this.logger = logger2;
    }
    warn(object, key, message) {
      let warnedKeys = this.warnedKeysByObject.get(object);
      if (!warnedKeys) {
        warnedKeys = /* @__PURE__ */ new Set();
        this.warnedKeysByObject.set(object, warnedKeys);
      }
      if (!warnedKeys.has(key)) {
        warnedKeys.add(key);
        this.logger.warn(message, object);
      }
    }
  };
  function attributeValueContainsToken(attributeName, token) {
    return `[${attributeName}~="${token}"]`;
  }
  var TargetSet = class {
    constructor(scope) {
      this.scope = scope;
    }
    get element() {
      return this.scope.element;
    }
    get identifier() {
      return this.scope.identifier;
    }
    get schema() {
      return this.scope.schema;
    }
    has(targetName) {
      return this.find(targetName) != null;
    }
    find(...targetNames) {
      return targetNames.reduce((target, targetName) => target || this.findTarget(targetName) || this.findLegacyTarget(targetName), void 0);
    }
    findAll(...targetNames) {
      return targetNames.reduce((targets, targetName) => [
        ...targets,
        ...this.findAllTargets(targetName),
        ...this.findAllLegacyTargets(targetName)
      ], []);
    }
    findTarget(targetName) {
      const selector = this.getSelectorForTargetName(targetName);
      return this.scope.findElement(selector);
    }
    findAllTargets(targetName) {
      const selector = this.getSelectorForTargetName(targetName);
      return this.scope.findAllElements(selector);
    }
    getSelectorForTargetName(targetName) {
      const attributeName = this.schema.targetAttributeForScope(this.identifier);
      return attributeValueContainsToken(attributeName, targetName);
    }
    findLegacyTarget(targetName) {
      const selector = this.getLegacySelectorForTargetName(targetName);
      return this.deprecate(this.scope.findElement(selector), targetName);
    }
    findAllLegacyTargets(targetName) {
      const selector = this.getLegacySelectorForTargetName(targetName);
      return this.scope.findAllElements(selector).map((element) => this.deprecate(element, targetName));
    }
    getLegacySelectorForTargetName(targetName) {
      const targetDescriptor = `${this.identifier}.${targetName}`;
      return attributeValueContainsToken(this.schema.targetAttribute, targetDescriptor);
    }
    deprecate(element, targetName) {
      if (element) {
        const { identifier } = this;
        const attributeName = this.schema.targetAttribute;
        const revisedAttributeName = this.schema.targetAttributeForScope(identifier);
        this.guide.warn(element, `target:${targetName}`, `Please replace ${attributeName}="${identifier}.${targetName}" with ${revisedAttributeName}="${targetName}". The ${attributeName} attribute is deprecated and will be removed in a future version of Stimulus.`);
      }
      return element;
    }
    get guide() {
      return this.scope.guide;
    }
  };
  var Scope = class {
    constructor(schema, element, identifier, logger2) {
      this.targets = new TargetSet(this);
      this.classes = new ClassMap(this);
      this.data = new DataMap(this);
      this.containsElement = (element2) => {
        return element2.closest(this.controllerSelector) === this.element;
      };
      this.schema = schema;
      this.element = element;
      this.identifier = identifier;
      this.guide = new Guide(logger2);
    }
    findElement(selector) {
      return this.element.matches(selector) ? this.element : this.queryElements(selector).find(this.containsElement);
    }
    findAllElements(selector) {
      return [
        ...this.element.matches(selector) ? [this.element] : [],
        ...this.queryElements(selector).filter(this.containsElement)
      ];
    }
    queryElements(selector) {
      return Array.from(this.element.querySelectorAll(selector));
    }
    get controllerSelector() {
      return attributeValueContainsToken(this.schema.controllerAttribute, this.identifier);
    }
  };
  var ScopeObserver = class {
    constructor(element, schema, delegate) {
      this.element = element;
      this.schema = schema;
      this.delegate = delegate;
      this.valueListObserver = new ValueListObserver(this.element, this.controllerAttribute, this);
      this.scopesByIdentifierByElement = /* @__PURE__ */ new WeakMap();
      this.scopeReferenceCounts = /* @__PURE__ */ new WeakMap();
    }
    start() {
      this.valueListObserver.start();
    }
    stop() {
      this.valueListObserver.stop();
    }
    get controllerAttribute() {
      return this.schema.controllerAttribute;
    }
    parseValueForToken(token) {
      const { element, content: identifier } = token;
      const scopesByIdentifier = this.fetchScopesByIdentifierForElement(element);
      let scope = scopesByIdentifier.get(identifier);
      if (!scope) {
        scope = this.delegate.createScopeForElementAndIdentifier(element, identifier);
        scopesByIdentifier.set(identifier, scope);
      }
      return scope;
    }
    elementMatchedValue(element, value) {
      const referenceCount = (this.scopeReferenceCounts.get(value) || 0) + 1;
      this.scopeReferenceCounts.set(value, referenceCount);
      if (referenceCount == 1) {
        this.delegate.scopeConnected(value);
      }
    }
    elementUnmatchedValue(element, value) {
      const referenceCount = this.scopeReferenceCounts.get(value);
      if (referenceCount) {
        this.scopeReferenceCounts.set(value, referenceCount - 1);
        if (referenceCount == 1) {
          this.delegate.scopeDisconnected(value);
        }
      }
    }
    fetchScopesByIdentifierForElement(element) {
      let scopesByIdentifier = this.scopesByIdentifierByElement.get(element);
      if (!scopesByIdentifier) {
        scopesByIdentifier = /* @__PURE__ */ new Map();
        this.scopesByIdentifierByElement.set(element, scopesByIdentifier);
      }
      return scopesByIdentifier;
    }
  };
  var Router = class {
    constructor(application2) {
      this.application = application2;
      this.scopeObserver = new ScopeObserver(this.element, this.schema, this);
      this.scopesByIdentifier = new Multimap();
      this.modulesByIdentifier = /* @__PURE__ */ new Map();
    }
    get element() {
      return this.application.element;
    }
    get schema() {
      return this.application.schema;
    }
    get logger() {
      return this.application.logger;
    }
    get controllerAttribute() {
      return this.schema.controllerAttribute;
    }
    get modules() {
      return Array.from(this.modulesByIdentifier.values());
    }
    get contexts() {
      return this.modules.reduce((contexts, module) => contexts.concat(module.contexts), []);
    }
    start() {
      this.scopeObserver.start();
    }
    stop() {
      this.scopeObserver.stop();
    }
    loadDefinition(definition) {
      this.unloadIdentifier(definition.identifier);
      const module = new Module(this.application, definition);
      this.connectModule(module);
    }
    unloadIdentifier(identifier) {
      const module = this.modulesByIdentifier.get(identifier);
      if (module) {
        this.disconnectModule(module);
      }
    }
    getContextForElementAndIdentifier(element, identifier) {
      const module = this.modulesByIdentifier.get(identifier);
      if (module) {
        return module.contexts.find((context) => context.element == element);
      }
    }
    handleError(error2, message, detail) {
      this.application.handleError(error2, message, detail);
    }
    createScopeForElementAndIdentifier(element, identifier) {
      return new Scope(this.schema, element, identifier, this.logger);
    }
    scopeConnected(scope) {
      this.scopesByIdentifier.add(scope.identifier, scope);
      const module = this.modulesByIdentifier.get(scope.identifier);
      if (module) {
        module.connectContextForScope(scope);
      }
    }
    scopeDisconnected(scope) {
      this.scopesByIdentifier.delete(scope.identifier, scope);
      const module = this.modulesByIdentifier.get(scope.identifier);
      if (module) {
        module.disconnectContextForScope(scope);
      }
    }
    connectModule(module) {
      this.modulesByIdentifier.set(module.identifier, module);
      const scopes = this.scopesByIdentifier.getValuesForKey(module.identifier);
      scopes.forEach((scope) => module.connectContextForScope(scope));
    }
    disconnectModule(module) {
      this.modulesByIdentifier.delete(module.identifier);
      const scopes = this.scopesByIdentifier.getValuesForKey(module.identifier);
      scopes.forEach((scope) => module.disconnectContextForScope(scope));
    }
  };
  var defaultSchema = {
    controllerAttribute: "data-controller",
    actionAttribute: "data-action",
    targetAttribute: "data-target",
    targetAttributeForScope: (identifier) => `data-${identifier}-target`
  };
  var Application = class _Application {
    constructor(element = document.documentElement, schema = defaultSchema) {
      this.logger = console;
      this.debug = false;
      this.logDebugActivity = (identifier, functionName, detail = {}) => {
        if (this.debug) {
          this.logFormattedMessage(identifier, functionName, detail);
        }
      };
      this.element = element;
      this.schema = schema;
      this.dispatcher = new Dispatcher(this);
      this.router = new Router(this);
    }
    static start(element, schema) {
      const application2 = new _Application(element, schema);
      application2.start();
      return application2;
    }
    async start() {
      await domReady();
      this.logDebugActivity("application", "starting");
      this.dispatcher.start();
      this.router.start();
      this.logDebugActivity("application", "start");
    }
    stop() {
      this.logDebugActivity("application", "stopping");
      this.dispatcher.stop();
      this.router.stop();
      this.logDebugActivity("application", "stop");
    }
    register(identifier, controllerConstructor) {
      if (controllerConstructor.shouldLoad) {
        this.load({ identifier, controllerConstructor });
      }
    }
    load(head, ...rest) {
      const definitions = Array.isArray(head) ? head : [head, ...rest];
      definitions.forEach((definition) => this.router.loadDefinition(definition));
    }
    unload(head, ...rest) {
      const identifiers = Array.isArray(head) ? head : [head, ...rest];
      identifiers.forEach((identifier) => this.router.unloadIdentifier(identifier));
    }
    get controllers() {
      return this.router.contexts.map((context) => context.controller);
    }
    getControllerForElementAndIdentifier(element, identifier) {
      const context = this.router.getContextForElementAndIdentifier(element, identifier);
      return context ? context.controller : null;
    }
    handleError(error2, message, detail) {
      var _a;
      this.logger.error(`%s

%o

%o`, message, error2, detail);
      (_a = window.onerror) === null || _a === void 0 ? void 0 : _a.call(window, message, "", 0, 0, error2);
    }
    logFormattedMessage(identifier, functionName, detail = {}) {
      detail = Object.assign({ application: this }, detail);
      this.logger.groupCollapsed(`${identifier} #${functionName}`);
      this.logger.log("details:", Object.assign({}, detail));
      this.logger.groupEnd();
    }
  };
  function domReady() {
    return new Promise((resolve) => {
      if (document.readyState == "loading") {
        document.addEventListener("DOMContentLoaded", () => resolve());
      } else {
        resolve();
      }
    });
  }
  function ClassPropertiesBlessing(constructor) {
    const classes = readInheritableStaticArrayValues(constructor, "classes");
    return classes.reduce((properties, classDefinition) => {
      return Object.assign(properties, propertiesForClassDefinition(classDefinition));
    }, {});
  }
  function propertiesForClassDefinition(key) {
    return {
      [`${key}Class`]: {
        get() {
          const { classes } = this;
          if (classes.has(key)) {
            return classes.get(key);
          } else {
            const attribute = classes.getAttributeName(key);
            throw new Error(`Missing attribute "${attribute}"`);
          }
        }
      },
      [`${key}Classes`]: {
        get() {
          return this.classes.getAll(key);
        }
      },
      [`has${capitalize(key)}Class`]: {
        get() {
          return this.classes.has(key);
        }
      }
    };
  }
  function TargetPropertiesBlessing(constructor) {
    const targets = readInheritableStaticArrayValues(constructor, "targets");
    return targets.reduce((properties, targetDefinition) => {
      return Object.assign(properties, propertiesForTargetDefinition(targetDefinition));
    }, {});
  }
  function propertiesForTargetDefinition(name) {
    return {
      [`${name}Target`]: {
        get() {
          const target = this.targets.find(name);
          if (target) {
            return target;
          } else {
            throw new Error(`Missing target element "${name}" for "${this.identifier}" controller`);
          }
        }
      },
      [`${name}Targets`]: {
        get() {
          return this.targets.findAll(name);
        }
      },
      [`has${capitalize(name)}Target`]: {
        get() {
          return this.targets.has(name);
        }
      }
    };
  }
  function ValuePropertiesBlessing(constructor) {
    const valueDefinitionPairs = readInheritableStaticObjectPairs(constructor, "values");
    const propertyDescriptorMap = {
      valueDescriptorMap: {
        get() {
          return valueDefinitionPairs.reduce((result, valueDefinitionPair) => {
            const valueDescriptor = parseValueDefinitionPair(valueDefinitionPair);
            const attributeName = this.data.getAttributeNameForKey(valueDescriptor.key);
            return Object.assign(result, { [attributeName]: valueDescriptor });
          }, {});
        }
      }
    };
    return valueDefinitionPairs.reduce((properties, valueDefinitionPair) => {
      return Object.assign(properties, propertiesForValueDefinitionPair(valueDefinitionPair));
    }, propertyDescriptorMap);
  }
  function propertiesForValueDefinitionPair(valueDefinitionPair) {
    const definition = parseValueDefinitionPair(valueDefinitionPair);
    const { key, name, reader: read, writer: write } = definition;
    return {
      [name]: {
        get() {
          const value = this.data.get(key);
          if (value !== null) {
            return read(value);
          } else {
            return definition.defaultValue;
          }
        },
        set(value) {
          if (value === void 0) {
            this.data.delete(key);
          } else {
            this.data.set(key, write(value));
          }
        }
      },
      [`has${capitalize(name)}`]: {
        get() {
          return this.data.has(key) || definition.hasCustomDefaultValue;
        }
      }
    };
  }
  function parseValueDefinitionPair([token, typeDefinition]) {
    return valueDescriptorForTokenAndTypeDefinition(token, typeDefinition);
  }
  function parseValueTypeConstant(constant) {
    switch (constant) {
      case Array:
        return "array";
      case Boolean:
        return "boolean";
      case Number:
        return "number";
      case Object:
        return "object";
      case String:
        return "string";
    }
  }
  function parseValueTypeDefault(defaultValue) {
    switch (typeof defaultValue) {
      case "boolean":
        return "boolean";
      case "number":
        return "number";
      case "string":
        return "string";
    }
    if (Array.isArray(defaultValue))
      return "array";
    if (Object.prototype.toString.call(defaultValue) === "[object Object]")
      return "object";
  }
  function parseValueTypeObject(typeObject) {
    const typeFromObject = parseValueTypeConstant(typeObject.type);
    if (typeFromObject) {
      const defaultValueType = parseValueTypeDefault(typeObject.default);
      if (typeFromObject !== defaultValueType) {
        throw new Error(`Type "${typeFromObject}" must match the type of the default value. Given default value: "${typeObject.default}" as "${defaultValueType}"`);
      }
      return typeFromObject;
    }
  }
  function parseValueTypeDefinition(typeDefinition) {
    const typeFromObject = parseValueTypeObject(typeDefinition);
    const typeFromDefaultValue = parseValueTypeDefault(typeDefinition);
    const typeFromConstant = parseValueTypeConstant(typeDefinition);
    const type = typeFromObject || typeFromDefaultValue || typeFromConstant;
    if (type)
      return type;
    throw new Error(`Unknown value type "${typeDefinition}"`);
  }
  function defaultValueForDefinition(typeDefinition) {
    const constant = parseValueTypeConstant(typeDefinition);
    if (constant)
      return defaultValuesByType[constant];
    const defaultValue = typeDefinition.default;
    if (defaultValue !== void 0)
      return defaultValue;
    return typeDefinition;
  }
  function valueDescriptorForTokenAndTypeDefinition(token, typeDefinition) {
    const key = `${dasherize(token)}-value`;
    const type = parseValueTypeDefinition(typeDefinition);
    return {
      type,
      key,
      name: camelize(key),
      get defaultValue() {
        return defaultValueForDefinition(typeDefinition);
      },
      get hasCustomDefaultValue() {
        return parseValueTypeDefault(typeDefinition) !== void 0;
      },
      reader: readers[type],
      writer: writers[type] || writers.default
    };
  }
  var defaultValuesByType = {
    get array() {
      return [];
    },
    boolean: false,
    number: 0,
    get object() {
      return {};
    },
    string: ""
  };
  var readers = {
    array(value) {
      const array = JSON.parse(value);
      if (!Array.isArray(array)) {
        throw new TypeError("Expected array");
      }
      return array;
    },
    boolean(value) {
      return !(value == "0" || value == "false");
    },
    number(value) {
      return Number(value);
    },
    object(value) {
      const object = JSON.parse(value);
      if (object === null || typeof object != "object" || Array.isArray(object)) {
        throw new TypeError("Expected object");
      }
      return object;
    },
    string(value) {
      return value;
    }
  };
  var writers = {
    default: writeString,
    array: writeJSON,
    object: writeJSON
  };
  function writeJSON(value) {
    return JSON.stringify(value);
  }
  function writeString(value) {
    return `${value}`;
  }
  var Controller = class {
    constructor(context) {
      this.context = context;
    }
    static get shouldLoad() {
      return true;
    }
    get application() {
      return this.context.application;
    }
    get scope() {
      return this.context.scope;
    }
    get element() {
      return this.scope.element;
    }
    get identifier() {
      return this.scope.identifier;
    }
    get targets() {
      return this.scope.targets;
    }
    get classes() {
      return this.scope.classes;
    }
    get data() {
      return this.scope.data;
    }
    initialize() {
    }
    connect() {
    }
    disconnect() {
    }
    dispatch(eventName, { target = this.element, detail = {}, prefix = this.identifier, bubbles = true, cancelable = true } = {}) {
      const type = prefix ? `${prefix}:${eventName}` : eventName;
      const event = new CustomEvent(type, { detail, bubbles, cancelable });
      target.dispatchEvent(event);
      return event;
    }
  };
  Controller.blessings = [ClassPropertiesBlessing, TargetPropertiesBlessing, ValuePropertiesBlessing];
  Controller.targets = [];
  Controller.values = {};

  // app/javascript/controllers/application.js
  var application = Application.start();
  application.debug = false;
  window.Stimulus = application;

  // app/javascript/controllers/dashboard_controller.js
  var dashboard_controller_default = class extends Controller {
    static targets = ["details"];
    click(e) {
      const detailsId = e.currentTarget.dataset.dashboardDetailsId;
      const details = this.detailsTargets;
      for (const row of details) {
        if (row.dataset.detailsId === detailsId) {
          row.classList.toggle("hidden");
        } else {
          row.classList.add("hidden");
        }
      }
    }
  };

  // app/javascript/controllers/home_controller.js
  var home_controller_default = class extends Controller {
    static targets = ["languageSelect", "languageSelector", "languageModalWindow", "languageModalWindowText"];
    static values = { lang: { type: String, default: "EN" } };
    initialize() {
      this.languageModalWindowTarget.hidden = true;
    }
    toggleLanguageSelect() {
      const menu = this.element.querySelector(".absolute");
      if (menu.style.display === "none") {
        menu.style.display = "block";
      } else {
        menu.style.display = "none";
      }
    }
    changeLanguage() {
      let text = "";
      switch (this.languageSelectorTarget.selectedOptions[0].text) {
        case "RU":
          text = "\u042F\u0437\u044B\u043A \u0443\u0441\u043F\u0435\u0448\u043D\u043E \u0438\u0437\u043C\u0435\u043D\u0451\u043D";
          break;
        default:
          text = "Language successfully changed";
      }
      this.languageModalWindowTextTarget.textContent = text;
      this.languageModalWindowTarget.hidden = false;
    }
    closeLanguageModalWindow() {
      this.languageModalWindowTarget.hidden = true;
    }
  };

  // app/javascript/controllers/material_form_controller.js
  var material_form_controller_default = class extends Controller {
    static targets = [
      "selectedType",
      "isotropicSection",
      "anisotropicSection",
      "acousticLiquidSection"
    ];
    select_type(e) {
      const selected = this.selectedTypeTarget.value;
      switch (selected) {
        case "Isotropic":
          this.isotropicSectionTarget.classList.remove("hidden");
          this.anisotropicSectionTarget.classList.add("hidden");
          this.acousticLiquidSectionTarget.classList.add("hidden");
          break;
        case "Anisotropic":
          this.isotropicSectionTarget.classList.add("hidden");
          this.anisotropicSectionTarget.classList.remove("hidden");
          this.acousticLiquidSectionTarget.classList.add("hidden");
          break;
        case "Acoustic Liquid":
          this.isotropicSectionTarget.classList.add("hidden");
          this.anisotropicSectionTarget.classList.add("hidden");
          this.acousticLiquidSectionTarget.classList.remove("hidden");
          break;
      }
    }
  };

  // app/javascript/controllers/materials_controller.js
  var materials_controller_default = class extends Controller {
    static targets = ["details"];
    click(e) {
      const detailsId = e.currentTarget.dataset.materialsDetailsId;
      const details = this.detailsTargets;
      for (const row of details) {
        if (row.dataset.detailsId === detailsId) {
          row.classList.toggle("hidden");
        } else {
          row.classList.add("hidden");
        }
      }
    }
  };

  // app/javascript/controllers/script_controller.js
  var import_editorjs = __toESM(require_editor());

  // app/javascript/editor/acelan_script/acelan_script.js
  var import_ace = __toESM(require_ace());

  // app/javascript/editor/helpers/suggestions.js
  async function Suggestions() {
    return fetch("/api/suggestions").then((response) => response.json());
  }

  // app/javascript/editor/acelan_script/acelan_script.js
  require_ext_language_tools();
  var AcelanScript = class {
    constructor({ data }) {
      this.data = data;
    }
    static get toolbox() {
      return {
        title: "Script",
        icon: '<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">\n  <path fill-rule="evenodd" d="M10.478 1.647a.5.5 0 1 0-.956-.294l-4 13a.5.5 0 0 0 .956.294l4-13zM4.854 4.146a.5.5 0 0 1 0 .708L1.707 8l3.147 3.146a.5.5 0 0 1-.708.708l-3.5-3.5a.5.5 0 0 1 0-.708l3.5-3.5a.5.5 0 0 1 .708 0zm6.292 0a.5.5 0 0 0 0 .708L14.293 8l-3.147 3.146a.5.5 0 0 0 .708.708l3.5-3.5a.5.5 0 0 0 0-.708l-3.5-3.5a.5.5 0 0 0-.708 0z" clip-rule="evenodd" />\n</svg>'
      };
    }
    render() {
      const scriptInput = document.createElement("div");
      scriptInput.style.weight = "100em";
      scriptInput.style.zIndex = "0";
      scriptInput.classList.add("h-48");
      import_ace.default.config.set("basePath", "/vendor/ace/");
      const editor = import_ace.default.edit(scriptInput);
      editor.getSession().setMode("ace/mode/ruby");
      editor.setTheme("ace/theme/github");
      import_ace.default.require("ace/ext/language_tools");
      Suggestions().then((suggestions) => editor.setOptions({
        enableBasicAutocompletion: [{
          getCompletions: (editor2, session2, pos, prefix, callback) => {
            callback(null, suggestions);
          }
        }],
        enableLiveAutocompletion: true,
        showFoldedAnnotations: true
      }));
      if (this.data.script) {
        editor.setValue(this.data.script);
      }
      return scriptInput;
    }
    save(blockContent) {
      return {
        script: blockContent.innerText
      };
    }
  };

  // app/javascript/editor/helpers/network_helper.js
  var NetworkHelper = class {
    performScript(script, key) {
      return fetch("/perform", {
        method: "POST",
        headers: {
          "Accept": "application/json",
          "Content-Type": "application/json"
        },
        body: JSON.stringify({ script, key })
      }).then((response) => response.json()).then((data) => {
        return data;
      });
    }
  };

  // node_modules/three/build/three.module.js
  var REVISION = "139";
  var MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 };
  var TOUCH = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 };
  var CullFaceNone = 0;
  var CullFaceBack = 1;
  var CullFaceFront = 2;
  var PCFShadowMap = 1;
  var PCFSoftShadowMap = 2;
  var VSMShadowMap = 3;
  var FrontSide = 0;
  var BackSide = 1;
  var DoubleSide = 2;
  var FlatShading = 1;
  var NoBlending = 0;
  var NormalBlending = 1;
  var AdditiveBlending = 2;
  var SubtractiveBlending = 3;
  var MultiplyBlending = 4;
  var CustomBlending = 5;
  var AddEquation = 100;
  var SubtractEquation = 101;
  var ReverseSubtractEquation = 102;
  var MinEquation = 103;
  var MaxEquation = 104;
  var ZeroFactor = 200;
  var OneFactor = 201;
  var SrcColorFactor = 202;
  var OneMinusSrcColorFactor = 203;
  var SrcAlphaFactor = 204;
  var OneMinusSrcAlphaFactor = 205;
  var DstAlphaFactor = 206;
  var OneMinusDstAlphaFactor = 207;
  var DstColorFactor = 208;
  var OneMinusDstColorFactor = 209;
  var SrcAlphaSaturateFactor = 210;
  var NeverDepth = 0;
  var AlwaysDepth = 1;
  var LessDepth = 2;
  var LessEqualDepth = 3;
  var EqualDepth = 4;
  var GreaterEqualDepth = 5;
  var GreaterDepth = 6;
  var NotEqualDepth = 7;
  var MultiplyOperation = 0;
  var MixOperation = 1;
  var AddOperation = 2;
  var NoToneMapping = 0;
  var LinearToneMapping = 1;
  var ReinhardToneMapping = 2;
  var CineonToneMapping = 3;
  var ACESFilmicToneMapping = 4;
  var CustomToneMapping = 5;
  var UVMapping = 300;
  var CubeReflectionMapping = 301;
  var CubeRefractionMapping = 302;
  var EquirectangularReflectionMapping = 303;
  var EquirectangularRefractionMapping = 304;
  var CubeUVReflectionMapping = 306;
  var RepeatWrapping = 1e3;
  var ClampToEdgeWrapping = 1001;
  var MirroredRepeatWrapping = 1002;
  var NearestFilter = 1003;
  var NearestMipmapNearestFilter = 1004;
  var NearestMipmapLinearFilter = 1005;
  var LinearFilter = 1006;
  var LinearMipmapNearestFilter = 1007;
  var LinearMipmapLinearFilter = 1008;
  var UnsignedByteType = 1009;
  var ByteType = 1010;
  var ShortType = 1011;
  var UnsignedShortType = 1012;
  var IntType = 1013;
  var UnsignedIntType = 1014;
  var FloatType = 1015;
  var HalfFloatType = 1016;
  var UnsignedShort4444Type = 1017;
  var UnsignedShort5551Type = 1018;
  var UnsignedInt248Type = 1020;
  var AlphaFormat = 1021;
  var RGBFormat = 1022;
  var RGBAFormat = 1023;
  var LuminanceFormat = 1024;
  var LuminanceAlphaFormat = 1025;
  var DepthFormat = 1026;
  var DepthStencilFormat = 1027;
  var RedFormat = 1028;
  var RedIntegerFormat = 1029;
  var RGFormat = 1030;
  var RGIntegerFormat = 1031;
  var RGBAIntegerFormat = 1033;
  var RGB_S3TC_DXT1_Format = 33776;
  var RGBA_S3TC_DXT1_Format = 33777;
  var RGBA_S3TC_DXT3_Format = 33778;
  var RGBA_S3TC_DXT5_Format = 33779;
  var RGB_PVRTC_4BPPV1_Format = 35840;
  var RGB_PVRTC_2BPPV1_Format = 35841;
  var RGBA_PVRTC_4BPPV1_Format = 35842;
  var RGBA_PVRTC_2BPPV1_Format = 35843;
  var RGB_ETC1_Format = 36196;
  var RGB_ETC2_Format = 37492;
  var RGBA_ETC2_EAC_Format = 37496;
  var RGBA_ASTC_4x4_Format = 37808;
  var RGBA_ASTC_5x4_Format = 37809;
  var RGBA_ASTC_5x5_Format = 37810;
  var RGBA_ASTC_6x5_Format = 37811;
  var RGBA_ASTC_6x6_Format = 37812;
  var RGBA_ASTC_8x5_Format = 37813;
  var RGBA_ASTC_8x6_Format = 37814;
  var RGBA_ASTC_8x8_Format = 37815;
  var RGBA_ASTC_10x5_Format = 37816;
  var RGBA_ASTC_10x6_Format = 37817;
  var RGBA_ASTC_10x8_Format = 37818;
  var RGBA_ASTC_10x10_Format = 37819;
  var RGBA_ASTC_12x10_Format = 37820;
  var RGBA_ASTC_12x12_Format = 37821;
  var RGBA_BPTC_Format = 36492;
  var LoopOnce = 2200;
  var LoopRepeat = 2201;
  var LoopPingPong = 2202;
  var InterpolateDiscrete = 2300;
  var InterpolateLinear = 2301;
  var InterpolateSmooth = 2302;
  var ZeroCurvatureEnding = 2400;
  var ZeroSlopeEnding = 2401;
  var WrapAroundEnding = 2402;
  var NormalAnimationBlendMode = 2500;
  var AdditiveAnimationBlendMode = 2501;
  var TrianglesDrawMode = 0;
  var LinearEncoding = 3e3;
  var sRGBEncoding = 3001;
  var BasicDepthPacking = 3200;
  var RGBADepthPacking = 3201;
  var TangentSpaceNormalMap = 0;
  var ObjectSpaceNormalMap = 1;
  var SRGBColorSpace = "srgb";
  var LinearSRGBColorSpace = "srgb-linear";
  var KeepStencilOp = 7680;
  var AlwaysStencilFunc = 519;
  var StaticDrawUsage = 35044;
  var DynamicDrawUsage = 35048;
  var GLSL3 = "300 es";
  var _SRGBAFormat = 1035;
  var EventDispatcher = class {
    addEventListener(type, listener) {
      if (this._listeners === void 0)
        this._listeners = {};
      const listeners = this._listeners;
      if (listeners[type] === void 0) {
        listeners[type] = [];
      }
      if (listeners[type].indexOf(listener) === -1) {
        listeners[type].push(listener);
      }
    }
    hasEventListener(type, listener) {
      if (this._listeners === void 0)
        return false;
      const listeners = this._listeners;
      return listeners[type] !== void 0 && listeners[type].indexOf(listener) !== -1;
    }
    removeEventListener(type, listener) {
      if (this._listeners === void 0)
        return;
      const listeners = this._listeners;
      const listenerArray = listeners[type];
      if (listenerArray !== void 0) {
        const index = listenerArray.indexOf(listener);
        if (index !== -1) {
          listenerArray.splice(index, 1);
        }
      }
    }
    dispatchEvent(event) {
      if (this._listeners === void 0)
        return;
      const listeners = this._listeners;
      const listenerArray = listeners[event.type];
      if (listenerArray !== void 0) {
        event.target = this;
        const array = listenerArray.slice(0);
        for (let i = 0, l = array.length; i < l; i++) {
          array[i].call(this, event);
        }
        event.target = null;
      }
    }
  };
  var _lut = [];
  for (let i = 0; i < 256; i++) {
    _lut[i] = (i < 16 ? "0" : "") + i.toString(16);
  }
  var DEG2RAD = Math.PI / 180;
  var RAD2DEG = 180 / Math.PI;
  function generateUUID() {
    const d0 = Math.random() * 4294967295 | 0;
    const d1 = Math.random() * 4294967295 | 0;
    const d2 = Math.random() * 4294967295 | 0;
    const d3 = Math.random() * 4294967295 | 0;
    const uuid2 = _lut[d0 & 255] + _lut[d0 >> 8 & 255] + _lut[d0 >> 16 & 255] + _lut[d0 >> 24 & 255] + "-" + _lut[d1 & 255] + _lut[d1 >> 8 & 255] + "-" + _lut[d1 >> 16 & 15 | 64] + _lut[d1 >> 24 & 255] + "-" + _lut[d2 & 63 | 128] + _lut[d2 >> 8 & 255] + "-" + _lut[d2 >> 16 & 255] + _lut[d2 >> 24 & 255] + _lut[d3 & 255] + _lut[d3 >> 8 & 255] + _lut[d3 >> 16 & 255] + _lut[d3 >> 24 & 255];
    return uuid2.toLowerCase();
  }
  function clamp(value, min, max) {
    return Math.max(min, Math.min(max, value));
  }
  function euclideanModulo(n, m) {
    return (n % m + m) % m;
  }
  function lerp(x, y, t) {
    return (1 - t) * x + t * y;
  }
  function isPowerOfTwo(value) {
    return (value & value - 1) === 0 && value !== 0;
  }
  function floorPowerOfTwo(value) {
    return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));
  }
  var Vector2 = class {
    constructor(x = 0, y = 0) {
      this.x = x;
      this.y = y;
    }
    get width() {
      return this.x;
    }
    set width(value) {
      this.x = value;
    }
    get height() {
      return this.y;
    }
    set height(value) {
      this.y = value;
    }
    set(x, y) {
      this.x = x;
      this.y = y;
      return this;
    }
    setScalar(scalar) {
      this.x = scalar;
      this.y = scalar;
      return this;
    }
    setX(x) {
      this.x = x;
      return this;
    }
    setY(y) {
      this.y = y;
      return this;
    }
    setComponent(index, value) {
      switch (index) {
        case 0:
          this.x = value;
          break;
        case 1:
          this.y = value;
          break;
        default:
          throw new Error("index is out of range: " + index);
      }
      return this;
    }
    getComponent(index) {
      switch (index) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        default:
          throw new Error("index is out of range: " + index);
      }
    }
    clone() {
      return new this.constructor(this.x, this.y);
    }
    copy(v) {
      this.x = v.x;
      this.y = v.y;
      return this;
    }
    add(v, w) {
      if (w !== void 0) {
        console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
        return this.addVectors(v, w);
      }
      this.x += v.x;
      this.y += v.y;
      return this;
    }
    addScalar(s) {
      this.x += s;
      this.y += s;
      return this;
    }
    addVectors(a, b) {
      this.x = a.x + b.x;
      this.y = a.y + b.y;
      return this;
    }
    addScaledVector(v, s) {
      this.x += v.x * s;
      this.y += v.y * s;
      return this;
    }
    sub(v, w) {
      if (w !== void 0) {
        console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
        return this.subVectors(v, w);
      }
      this.x -= v.x;
      this.y -= v.y;
      return this;
    }
    subScalar(s) {
      this.x -= s;
      this.y -= s;
      return this;
    }
    subVectors(a, b) {
      this.x = a.x - b.x;
      this.y = a.y - b.y;
      return this;
    }
    multiply(v) {
      this.x *= v.x;
      this.y *= v.y;
      return this;
    }
    multiplyScalar(scalar) {
      this.x *= scalar;
      this.y *= scalar;
      return this;
    }
    divide(v) {
      this.x /= v.x;
      this.y /= v.y;
      return this;
    }
    divideScalar(scalar) {
      return this.multiplyScalar(1 / scalar);
    }
    applyMatrix3(m) {
      const x = this.x, y = this.y;
      const e = m.elements;
      this.x = e[0] * x + e[3] * y + e[6];
      this.y = e[1] * x + e[4] * y + e[7];
      return this;
    }
    min(v) {
      this.x = Math.min(this.x, v.x);
      this.y = Math.min(this.y, v.y);
      return this;
    }
    max(v) {
      this.x = Math.max(this.x, v.x);
      this.y = Math.max(this.y, v.y);
      return this;
    }
    clamp(min, max) {
      this.x = Math.max(min.x, Math.min(max.x, this.x));
      this.y = Math.max(min.y, Math.min(max.y, this.y));
      return this;
    }
    clampScalar(minVal, maxVal) {
      this.x = Math.max(minVal, Math.min(maxVal, this.x));
      this.y = Math.max(minVal, Math.min(maxVal, this.y));
      return this;
    }
    clampLength(min, max) {
      const length = this.length();
      return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
    }
    floor() {
      this.x = Math.floor(this.x);
      this.y = Math.floor(this.y);
      return this;
    }
    ceil() {
      this.x = Math.ceil(this.x);
      this.y = Math.ceil(this.y);
      return this;
    }
    round() {
      this.x = Math.round(this.x);
      this.y = Math.round(this.y);
      return this;
    }
    roundToZero() {
      this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
      this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
      return this;
    }
    negate() {
      this.x = -this.x;
      this.y = -this.y;
      return this;
    }
    dot(v) {
      return this.x * v.x + this.y * v.y;
    }
    cross(v) {
      return this.x * v.y - this.y * v.x;
    }
    lengthSq() {
      return this.x * this.x + this.y * this.y;
    }
    length() {
      return Math.sqrt(this.x * this.x + this.y * this.y);
    }
    manhattanLength() {
      return Math.abs(this.x) + Math.abs(this.y);
    }
    normalize() {
      return this.divideScalar(this.length() || 1);
    }
    angle() {
      const angle = Math.atan2(-this.y, -this.x) + Math.PI;
      return angle;
    }
    distanceTo(v) {
      return Math.sqrt(this.distanceToSquared(v));
    }
    distanceToSquared(v) {
      const dx = this.x - v.x, dy = this.y - v.y;
      return dx * dx + dy * dy;
    }
    manhattanDistanceTo(v) {
      return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);
    }
    setLength(length) {
      return this.normalize().multiplyScalar(length);
    }
    lerp(v, alpha) {
      this.x += (v.x - this.x) * alpha;
      this.y += (v.y - this.y) * alpha;
      return this;
    }
    lerpVectors(v1, v2, alpha) {
      this.x = v1.x + (v2.x - v1.x) * alpha;
      this.y = v1.y + (v2.y - v1.y) * alpha;
      return this;
    }
    equals(v) {
      return v.x === this.x && v.y === this.y;
    }
    fromArray(array, offset = 0) {
      this.x = array[offset];
      this.y = array[offset + 1];
      return this;
    }
    toArray(array = [], offset = 0) {
      array[offset] = this.x;
      array[offset + 1] = this.y;
      return array;
    }
    fromBufferAttribute(attribute, index, offset) {
      if (offset !== void 0) {
        console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute().");
      }
      this.x = attribute.getX(index);
      this.y = attribute.getY(index);
      return this;
    }
    rotateAround(center, angle) {
      const c = Math.cos(angle), s = Math.sin(angle);
      const x = this.x - center.x;
      const y = this.y - center.y;
      this.x = x * c - y * s + center.x;
      this.y = x * s + y * c + center.y;
      return this;
    }
    random() {
      this.x = Math.random();
      this.y = Math.random();
      return this;
    }
    *[Symbol.iterator]() {
      yield this.x;
      yield this.y;
    }
  };
  Vector2.prototype.isVector2 = true;
  var Matrix3 = class {
    constructor() {
      this.elements = [
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1
      ];
      if (arguments.length > 0) {
        console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.");
      }
    }
    set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
      const te = this.elements;
      te[0] = n11;
      te[1] = n21;
      te[2] = n31;
      te[3] = n12;
      te[4] = n22;
      te[5] = n32;
      te[6] = n13;
      te[7] = n23;
      te[8] = n33;
      return this;
    }
    identity() {
      this.set(
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1
      );
      return this;
    }
    copy(m) {
      const te = this.elements;
      const me = m.elements;
      te[0] = me[0];
      te[1] = me[1];
      te[2] = me[2];
      te[3] = me[3];
      te[4] = me[4];
      te[5] = me[5];
      te[6] = me[6];
      te[7] = me[7];
      te[8] = me[8];
      return this;
    }
    extractBasis(xAxis, yAxis, zAxis) {
      xAxis.setFromMatrix3Column(this, 0);
      yAxis.setFromMatrix3Column(this, 1);
      zAxis.setFromMatrix3Column(this, 2);
      return this;
    }
    setFromMatrix4(m) {
      const me = m.elements;
      this.set(
        me[0],
        me[4],
        me[8],
        me[1],
        me[5],
        me[9],
        me[2],
        me[6],
        me[10]
      );
      return this;
    }
    multiply(m) {
      return this.multiplyMatrices(this, m);
    }
    premultiply(m) {
      return this.multiplyMatrices(m, this);
    }
    multiplyMatrices(a, b) {
      const ae = a.elements;
      const be = b.elements;
      const te = this.elements;
      const a11 = ae[0], a12 = ae[3], a13 = ae[6];
      const a21 = ae[1], a22 = ae[4], a23 = ae[7];
      const a31 = ae[2], a32 = ae[5], a33 = ae[8];
      const b11 = be[0], b12 = be[3], b13 = be[6];
      const b21 = be[1], b22 = be[4], b23 = be[7];
      const b31 = be[2], b32 = be[5], b33 = be[8];
      te[0] = a11 * b11 + a12 * b21 + a13 * b31;
      te[3] = a11 * b12 + a12 * b22 + a13 * b32;
      te[6] = a11 * b13 + a12 * b23 + a13 * b33;
      te[1] = a21 * b11 + a22 * b21 + a23 * b31;
      te[4] = a21 * b12 + a22 * b22 + a23 * b32;
      te[7] = a21 * b13 + a22 * b23 + a23 * b33;
      te[2] = a31 * b11 + a32 * b21 + a33 * b31;
      te[5] = a31 * b12 + a32 * b22 + a33 * b32;
      te[8] = a31 * b13 + a32 * b23 + a33 * b33;
      return this;
    }
    multiplyScalar(s) {
      const te = this.elements;
      te[0] *= s;
      te[3] *= s;
      te[6] *= s;
      te[1] *= s;
      te[4] *= s;
      te[7] *= s;
      te[2] *= s;
      te[5] *= s;
      te[8] *= s;
      return this;
    }
    determinant() {
      const te = this.elements;
      const a = te[0], b = te[1], c = te[2], d = te[3], e = te[4], f = te[5], g = te[6], h = te[7], i = te[8];
      return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;
    }
    invert() {
      const te = this.elements, n11 = te[0], n21 = te[1], n31 = te[2], n12 = te[3], n22 = te[4], n32 = te[5], n13 = te[6], n23 = te[7], n33 = te[8], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, det = n11 * t11 + n21 * t12 + n31 * t13;
      if (det === 0)
        return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
      const detInv = 1 / det;
      te[0] = t11 * detInv;
      te[1] = (n31 * n23 - n33 * n21) * detInv;
      te[2] = (n32 * n21 - n31 * n22) * detInv;
      te[3] = t12 * detInv;
      te[4] = (n33 * n11 - n31 * n13) * detInv;
      te[5] = (n31 * n12 - n32 * n11) * detInv;
      te[6] = t13 * detInv;
      te[7] = (n21 * n13 - n23 * n11) * detInv;
      te[8] = (n22 * n11 - n21 * n12) * detInv;
      return this;
    }
    transpose() {
      let tmp2;
      const m = this.elements;
      tmp2 = m[1];
      m[1] = m[3];
      m[3] = tmp2;
      tmp2 = m[2];
      m[2] = m[6];
      m[6] = tmp2;
      tmp2 = m[5];
      m[5] = m[7];
      m[7] = tmp2;
      return this;
    }
    getNormalMatrix(matrix4) {
      return this.setFromMatrix4(matrix4).invert().transpose();
    }
    transposeIntoArray(r) {
      const m = this.elements;
      r[0] = m[0];
      r[1] = m[3];
      r[2] = m[6];
      r[3] = m[1];
      r[4] = m[4];
      r[5] = m[7];
      r[6] = m[2];
      r[7] = m[5];
      r[8] = m[8];
      return this;
    }
    setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {
      const c = Math.cos(rotation);
      const s = Math.sin(rotation);
      this.set(
        sx * c,
        sx * s,
        -sx * (c * cx + s * cy) + cx + tx,
        -sy * s,
        sy * c,
        -sy * (-s * cx + c * cy) + cy + ty,
        0,
        0,
        1
      );
      return this;
    }
    scale(sx, sy) {
      const te = this.elements;
      te[0] *= sx;
      te[3] *= sx;
      te[6] *= sx;
      te[1] *= sy;
      te[4] *= sy;
      te[7] *= sy;
      return this;
    }
    rotate(theta) {
      const c = Math.cos(theta);
      const s = Math.sin(theta);
      const te = this.elements;
      const a11 = te[0], a12 = te[3], a13 = te[6];
      const a21 = te[1], a22 = te[4], a23 = te[7];
      te[0] = c * a11 + s * a21;
      te[3] = c * a12 + s * a22;
      te[6] = c * a13 + s * a23;
      te[1] = -s * a11 + c * a21;
      te[4] = -s * a12 + c * a22;
      te[7] = -s * a13 + c * a23;
      return this;
    }
    translate(tx, ty) {
      const te = this.elements;
      te[0] += tx * te[2];
      te[3] += tx * te[5];
      te[6] += tx * te[8];
      te[1] += ty * te[2];
      te[4] += ty * te[5];
      te[7] += ty * te[8];
      return this;
    }
    equals(matrix) {
      const te = this.elements;
      const me = matrix.elements;
      for (let i = 0; i < 9; i++) {
        if (te[i] !== me[i])
          return false;
      }
      return true;
    }
    fromArray(array, offset = 0) {
      for (let i = 0; i < 9; i++) {
        this.elements[i] = array[i + offset];
      }
      return this;
    }
    toArray(array = [], offset = 0) {
      const te = this.elements;
      array[offset] = te[0];
      array[offset + 1] = te[1];
      array[offset + 2] = te[2];
      array[offset + 3] = te[3];
      array[offset + 4] = te[4];
      array[offset + 5] = te[5];
      array[offset + 6] = te[6];
      array[offset + 7] = te[7];
      array[offset + 8] = te[8];
      return array;
    }
    clone() {
      return new this.constructor().fromArray(this.elements);
    }
  };
  Matrix3.prototype.isMatrix3 = true;
  function arrayNeedsUint32(array) {
    for (let i = array.length - 1; i >= 0; --i) {
      if (array[i] > 65535)
        return true;
    }
    return false;
  }
  function createElementNS(name) {
    return document.createElementNS("http://www.w3.org/1999/xhtml", name);
  }
  function SRGBToLinear(c) {
    return c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);
  }
  function LinearToSRGB(c) {
    return c < 31308e-7 ? c * 12.92 : 1.055 * Math.pow(c, 0.41666) - 0.055;
  }
  var FN = {
    [SRGBColorSpace]: { [LinearSRGBColorSpace]: SRGBToLinear },
    [LinearSRGBColorSpace]: { [SRGBColorSpace]: LinearToSRGB }
  };
  var ColorManagement = {
    legacyMode: true,
    get workingColorSpace() {
      return LinearSRGBColorSpace;
    },
    set workingColorSpace(colorSpace) {
      console.warn("THREE.ColorManagement: .workingColorSpace is readonly.");
    },
    convert: function(color, sourceColorSpace, targetColorSpace) {
      if (this.legacyMode || sourceColorSpace === targetColorSpace || !sourceColorSpace || !targetColorSpace) {
        return color;
      }
      if (FN[sourceColorSpace] && FN[sourceColorSpace][targetColorSpace] !== void 0) {
        const fn = FN[sourceColorSpace][targetColorSpace];
        color.r = fn(color.r);
        color.g = fn(color.g);
        color.b = fn(color.b);
        return color;
      }
      throw new Error("Unsupported color space conversion.");
    },
    fromWorkingColorSpace: function(color, targetColorSpace) {
      return this.convert(color, this.workingColorSpace, targetColorSpace);
    },
    toWorkingColorSpace: function(color, sourceColorSpace) {
      return this.convert(color, sourceColorSpace, this.workingColorSpace);
    }
  };
  var _colorKeywords = {
    "aliceblue": 15792383,
    "antiquewhite": 16444375,
    "aqua": 65535,
    "aquamarine": 8388564,
    "azure": 15794175,
    "beige": 16119260,
    "bisque": 16770244,
    "black": 0,
    "blanchedalmond": 16772045,
    "blue": 255,
    "blueviolet": 9055202,
    "brown": 10824234,
    "burlywood": 14596231,
    "cadetblue": 6266528,
    "chartreuse": 8388352,
    "chocolate": 13789470,
    "coral": 16744272,
    "cornflowerblue": 6591981,
    "cornsilk": 16775388,
    "crimson": 14423100,
    "cyan": 65535,
    "darkblue": 139,
    "darkcyan": 35723,
    "darkgoldenrod": 12092939,
    "darkgray": 11119017,
    "darkgreen": 25600,
    "darkgrey": 11119017,
    "darkkhaki": 12433259,
    "darkmagenta": 9109643,
    "darkolivegreen": 5597999,
    "darkorange": 16747520,
    "darkorchid": 10040012,
    "darkred": 9109504,
    "darksalmon": 15308410,
    "darkseagreen": 9419919,
    "darkslateblue": 4734347,
    "darkslategray": 3100495,
    "darkslategrey": 3100495,
    "darkturquoise": 52945,
    "darkviolet": 9699539,
    "deeppink": 16716947,
    "deepskyblue": 49151,
    "dimgray": 6908265,
    "dimgrey": 6908265,
    "dodgerblue": 2003199,
    "firebrick": 11674146,
    "floralwhite": 16775920,
    "forestgreen": 2263842,
    "fuchsia": 16711935,
    "gainsboro": 14474460,
    "ghostwhite": 16316671,
    "gold": 16766720,
    "goldenrod": 14329120,
    "gray": 8421504,
    "green": 32768,
    "greenyellow": 11403055,
    "grey": 8421504,
    "honeydew": 15794160,
    "hotpink": 16738740,
    "indianred": 13458524,
    "indigo": 4915330,
    "ivory": 16777200,
    "khaki": 15787660,
    "lavender": 15132410,
    "lavenderblush": 16773365,
    "lawngreen": 8190976,
    "lemonchiffon": 16775885,
    "lightblue": 11393254,
    "lightcoral": 15761536,
    "lightcyan": 14745599,
    "lightgoldenrodyellow": 16448210,
    "lightgray": 13882323,
    "lightgreen": 9498256,
    "lightgrey": 13882323,
    "lightpink": 16758465,
    "lightsalmon": 16752762,
    "lightseagreen": 2142890,
    "lightskyblue": 8900346,
    "lightslategray": 7833753,
    "lightslategrey": 7833753,
    "lightsteelblue": 11584734,
    "lightyellow": 16777184,
    "lime": 65280,
    "limegreen": 3329330,
    "linen": 16445670,
    "magenta": 16711935,
    "maroon": 8388608,
    "mediumaquamarine": 6737322,
    "mediumblue": 205,
    "mediumorchid": 12211667,
    "mediumpurple": 9662683,
    "mediumseagreen": 3978097,
    "mediumslateblue": 8087790,
    "mediumspringgreen": 64154,
    "mediumturquoise": 4772300,
    "mediumvioletred": 13047173,
    "midnightblue": 1644912,
    "mintcream": 16121850,
    "mistyrose": 16770273,
    "moccasin": 16770229,
    "navajowhite": 16768685,
    "navy": 128,
    "oldlace": 16643558,
    "olive": 8421376,
    "olivedrab": 7048739,
    "orange": 16753920,
    "orangered": 16729344,
    "orchid": 14315734,
    "palegoldenrod": 15657130,
    "palegreen": 10025880,
    "paleturquoise": 11529966,
    "palevioletred": 14381203,
    "papayawhip": 16773077,
    "peachpuff": 16767673,
    "peru": 13468991,
    "pink": 16761035,
    "plum": 14524637,
    "powderblue": 11591910,
    "purple": 8388736,
    "rebeccapurple": 6697881,
    "red": 16711680,
    "rosybrown": 12357519,
    "royalblue": 4286945,
    "saddlebrown": 9127187,
    "salmon": 16416882,
    "sandybrown": 16032864,
    "seagreen": 3050327,
    "seashell": 16774638,
    "sienna": 10506797,
    "silver": 12632256,
    "skyblue": 8900331,
    "slateblue": 6970061,
    "slategray": 7372944,
    "slategrey": 7372944,
    "snow": 16775930,
    "springgreen": 65407,
    "steelblue": 4620980,
    "tan": 13808780,
    "teal": 32896,
    "thistle": 14204888,
    "tomato": 16737095,
    "turquoise": 4251856,
    "violet": 15631086,
    "wheat": 16113331,
    "white": 16777215,
    "whitesmoke": 16119285,
    "yellow": 16776960,
    "yellowgreen": 10145074
  };
  var _rgb = { r: 0, g: 0, b: 0 };
  var _hslA = { h: 0, s: 0, l: 0 };
  var _hslB = { h: 0, s: 0, l: 0 };
  function hue2rgb(p, q, t) {
    if (t < 0)
      t += 1;
    if (t > 1)
      t -= 1;
    if (t < 1 / 6)
      return p + (q - p) * 6 * t;
    if (t < 1 / 2)
      return q;
    if (t < 2 / 3)
      return p + (q - p) * 6 * (2 / 3 - t);
    return p;
  }
  function toComponents(source, target) {
    target.r = source.r;
    target.g = source.g;
    target.b = source.b;
    return target;
  }
  var Color = class {
    constructor(r, g, b) {
      if (g === void 0 && b === void 0) {
        return this.set(r);
      }
      return this.setRGB(r, g, b);
    }
    set(value) {
      if (value && value.isColor) {
        this.copy(value);
      } else if (typeof value === "number") {
        this.setHex(value);
      } else if (typeof value === "string") {
        this.setStyle(value);
      }
      return this;
    }
    setScalar(scalar) {
      this.r = scalar;
      this.g = scalar;
      this.b = scalar;
      return this;
    }
    setHex(hex, colorSpace = SRGBColorSpace) {
      hex = Math.floor(hex);
      this.r = (hex >> 16 & 255) / 255;
      this.g = (hex >> 8 & 255) / 255;
      this.b = (hex & 255) / 255;
      ColorManagement.toWorkingColorSpace(this, colorSpace);
      return this;
    }
    setRGB(r, g, b, colorSpace = LinearSRGBColorSpace) {
      this.r = r;
      this.g = g;
      this.b = b;
      ColorManagement.toWorkingColorSpace(this, colorSpace);
      return this;
    }
    setHSL(h, s, l, colorSpace = LinearSRGBColorSpace) {
      h = euclideanModulo(h, 1);
      s = clamp(s, 0, 1);
      l = clamp(l, 0, 1);
      if (s === 0) {
        this.r = this.g = this.b = l;
      } else {
        const p = l <= 0.5 ? l * (1 + s) : l + s - l * s;
        const q = 2 * l - p;
        this.r = hue2rgb(q, p, h + 1 / 3);
        this.g = hue2rgb(q, p, h);
        this.b = hue2rgb(q, p, h - 1 / 3);
      }
      ColorManagement.toWorkingColorSpace(this, colorSpace);
      return this;
    }
    setStyle(style, colorSpace = SRGBColorSpace) {
      function handleAlpha(string) {
        if (string === void 0)
          return;
        if (parseFloat(string) < 1) {
          console.warn("THREE.Color: Alpha component of " + style + " will be ignored.");
        }
      }
      let m;
      if (m = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(style)) {
        let color;
        const name = m[1];
        const components = m[2];
        switch (name) {
          case "rgb":
          case "rgba":
            if (color = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
              this.r = Math.min(255, parseInt(color[1], 10)) / 255;
              this.g = Math.min(255, parseInt(color[2], 10)) / 255;
              this.b = Math.min(255, parseInt(color[3], 10)) / 255;
              ColorManagement.toWorkingColorSpace(this, colorSpace);
              handleAlpha(color[4]);
              return this;
            }
            if (color = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
              this.r = Math.min(100, parseInt(color[1], 10)) / 100;
              this.g = Math.min(100, parseInt(color[2], 10)) / 100;
              this.b = Math.min(100, parseInt(color[3], 10)) / 100;
              ColorManagement.toWorkingColorSpace(this, colorSpace);
              handleAlpha(color[4]);
              return this;
            }
            break;
          case "hsl":
          case "hsla":
            if (color = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
              const h = parseFloat(color[1]) / 360;
              const s = parseInt(color[2], 10) / 100;
              const l = parseInt(color[3], 10) / 100;
              handleAlpha(color[4]);
              return this.setHSL(h, s, l, colorSpace);
            }
            break;
        }
      } else if (m = /^\#([A-Fa-f\d]+)$/.exec(style)) {
        const hex = m[1];
        const size = hex.length;
        if (size === 3) {
          this.r = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255;
          this.g = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255;
          this.b = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255;
          ColorManagement.toWorkingColorSpace(this, colorSpace);
          return this;
        } else if (size === 6) {
          this.r = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255;
          this.g = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255;
          this.b = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255;
          ColorManagement.toWorkingColorSpace(this, colorSpace);
          return this;
        }
      }
      if (style && style.length > 0) {
        return this.setColorName(style, colorSpace);
      }
      return this;
    }
    setColorName(style, colorSpace = SRGBColorSpace) {
      const hex = _colorKeywords[style.toLowerCase()];
      if (hex !== void 0) {
        this.setHex(hex, colorSpace);
      } else {
        console.warn("THREE.Color: Unknown color " + style);
      }
      return this;
    }
    clone() {
      return new this.constructor(this.r, this.g, this.b);
    }
    copy(color) {
      this.r = color.r;
      this.g = color.g;
      this.b = color.b;
      return this;
    }
    copySRGBToLinear(color) {
      this.r = SRGBToLinear(color.r);
      this.g = SRGBToLinear(color.g);
      this.b = SRGBToLinear(color.b);
      return this;
    }
    copyLinearToSRGB(color) {
      this.r = LinearToSRGB(color.r);
      this.g = LinearToSRGB(color.g);
      this.b = LinearToSRGB(color.b);
      return this;
    }
    convertSRGBToLinear() {
      this.copySRGBToLinear(this);
      return this;
    }
    convertLinearToSRGB() {
      this.copyLinearToSRGB(this);
      return this;
    }
    getHex(colorSpace = SRGBColorSpace) {
      ColorManagement.fromWorkingColorSpace(toComponents(this, _rgb), colorSpace);
      return clamp(_rgb.r * 255, 0, 255) << 16 ^ clamp(_rgb.g * 255, 0, 255) << 8 ^ clamp(_rgb.b * 255, 0, 255) << 0;
    }
    getHexString(colorSpace = SRGBColorSpace) {
      return ("000000" + this.getHex(colorSpace).toString(16)).slice(-6);
    }
    getHSL(target, colorSpace = LinearSRGBColorSpace) {
      ColorManagement.fromWorkingColorSpace(toComponents(this, _rgb), colorSpace);
      const r = _rgb.r, g = _rgb.g, b = _rgb.b;
      const max = Math.max(r, g, b);
      const min = Math.min(r, g, b);
      let hue, saturation;
      const lightness = (min + max) / 2;
      if (min === max) {
        hue = 0;
        saturation = 0;
      } else {
        const delta = max - min;
        saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);
        switch (max) {
          case r:
            hue = (g - b) / delta + (g < b ? 6 : 0);
            break;
          case g:
            hue = (b - r) / delta + 2;
            break;
          case b:
            hue = (r - g) / delta + 4;
            break;
        }
        hue /= 6;
      }
      target.h = hue;
      target.s = saturation;
      target.l = lightness;
      return target;
    }
    getRGB(target, colorSpace = LinearSRGBColorSpace) {
      ColorManagement.fromWorkingColorSpace(toComponents(this, _rgb), colorSpace);
      target.r = _rgb.r;
      target.g = _rgb.g;
      target.b = _rgb.b;
      return target;
    }
    getStyle(colorSpace = SRGBColorSpace) {
      ColorManagement.fromWorkingColorSpace(toComponents(this, _rgb), colorSpace);
      if (colorSpace !== SRGBColorSpace) {
        return `color(${colorSpace} ${_rgb.r} ${_rgb.g} ${_rgb.b})`;
      }
      return `rgb(${_rgb.r * 255 | 0},${_rgb.g * 255 | 0},${_rgb.b * 255 | 0})`;
    }
    offsetHSL(h, s, l) {
      this.getHSL(_hslA);
      _hslA.h += h;
      _hslA.s += s;
      _hslA.l += l;
      this.setHSL(_hslA.h, _hslA.s, _hslA.l);
      return this;
    }
    add(color) {
      this.r += color.r;
      this.g += color.g;
      this.b += color.b;
      return this;
    }
    addColors(color1, color2) {
      this.r = color1.r + color2.r;
      this.g = color1.g + color2.g;
      this.b = color1.b + color2.b;
      return this;
    }
    addScalar(s) {
      this.r += s;
      this.g += s;
      this.b += s;
      return this;
    }
    sub(color) {
      this.r = Math.max(0, this.r - color.r);
      this.g = Math.max(0, this.g - color.g);
      this.b = Math.max(0, this.b - color.b);
      return this;
    }
    multiply(color) {
      this.r *= color.r;
      this.g *= color.g;
      this.b *= color.b;
      return this;
    }
    multiplyScalar(s) {
      this.r *= s;
      this.g *= s;
      this.b *= s;
      return this;
    }
    lerp(color, alpha) {
      this.r += (color.r - this.r) * alpha;
      this.g += (color.g - this.g) * alpha;
      this.b += (color.b - this.b) * alpha;
      return this;
    }
    lerpColors(color1, color2, alpha) {
      this.r = color1.r + (color2.r - color1.r) * alpha;
      this.g = color1.g + (color2.g - color1.g) * alpha;
      this.b = color1.b + (color2.b - color1.b) * alpha;
      return this;
    }
    lerpHSL(color, alpha) {
      this.getHSL(_hslA);
      color.getHSL(_hslB);
      const h = lerp(_hslA.h, _hslB.h, alpha);
      const s = lerp(_hslA.s, _hslB.s, alpha);
      const l = lerp(_hslA.l, _hslB.l, alpha);
      this.setHSL(h, s, l);
      return this;
    }
    equals(c) {
      return c.r === this.r && c.g === this.g && c.b === this.b;
    }
    fromArray(array, offset = 0) {
      this.r = array[offset];
      this.g = array[offset + 1];
      this.b = array[offset + 2];
      return this;
    }
    toArray(array = [], offset = 0) {
      array[offset] = this.r;
      array[offset + 1] = this.g;
      array[offset + 2] = this.b;
      return array;
    }
    fromBufferAttribute(attribute, index) {
      this.r = attribute.getX(index);
      this.g = attribute.getY(index);
      this.b = attribute.getZ(index);
      if (attribute.normalized === true) {
        this.r /= 255;
        this.g /= 255;
        this.b /= 255;
      }
      return this;
    }
    toJSON() {
      return this.getHex();
    }
  };
  Color.NAMES = _colorKeywords;
  Color.prototype.isColor = true;
  Color.prototype.r = 1;
  Color.prototype.g = 1;
  Color.prototype.b = 1;
  var _canvas;
  var ImageUtils = class {
    static getDataURL(image) {
      if (/^data:/i.test(image.src)) {
        return image.src;
      }
      if (typeof HTMLCanvasElement == "undefined") {
        return image.src;
      }
      let canvas;
      if (image instanceof HTMLCanvasElement) {
        canvas = image;
      } else {
        if (_canvas === void 0)
          _canvas = createElementNS("canvas");
        _canvas.width = image.width;
        _canvas.height = image.height;
        const context = _canvas.getContext("2d");
        if (image instanceof ImageData) {
          context.putImageData(image, 0, 0);
        } else {
          context.drawImage(image, 0, 0, image.width, image.height);
        }
        canvas = _canvas;
      }
      if (canvas.width > 2048 || canvas.height > 2048) {
        console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", image);
        return canvas.toDataURL("image/jpeg", 0.6);
      } else {
        return canvas.toDataURL("image/png");
      }
    }
    static sRGBToLinear(image) {
      if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
        const canvas = createElementNS("canvas");
        canvas.width = image.width;
        canvas.height = image.height;
        const context = canvas.getContext("2d");
        context.drawImage(image, 0, 0, image.width, image.height);
        const imageData = context.getImageData(0, 0, image.width, image.height);
        const data = imageData.data;
        for (let i = 0; i < data.length; i++) {
          data[i] = SRGBToLinear(data[i] / 255) * 255;
        }
        context.putImageData(imageData, 0, 0);
        return canvas;
      } else if (image.data) {
        const data = image.data.slice(0);
        for (let i = 0; i < data.length; i++) {
          if (data instanceof Uint8Array || data instanceof Uint8ClampedArray) {
            data[i] = Math.floor(SRGBToLinear(data[i] / 255) * 255);
          } else {
            data[i] = SRGBToLinear(data[i]);
          }
        }
        return {
          data,
          width: image.width,
          height: image.height
        };
      } else {
        console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied.");
        return image;
      }
    }
  };
  var Source = class {
    constructor(data = null) {
      this.uuid = generateUUID();
      this.data = data;
      this.version = 0;
    }
    set needsUpdate(value) {
      if (value === true)
        this.version++;
    }
    toJSON(meta) {
      const isRootObject = meta === void 0 || typeof meta === "string";
      if (!isRootObject && meta.images[this.uuid] !== void 0) {
        return meta.images[this.uuid];
      }
      const output = {
        uuid: this.uuid,
        url: ""
      };
      const data = this.data;
      if (data !== null) {
        let url;
        if (Array.isArray(data)) {
          url = [];
          for (let i = 0, l = data.length; i < l; i++) {
            if (data[i].isDataTexture) {
              url.push(serializeImage(data[i].image));
            } else {
              url.push(serializeImage(data[i]));
            }
          }
        } else {
          url = serializeImage(data);
        }
        output.url = url;
      }
      if (!isRootObject) {
        meta.images[this.uuid] = output;
      }
      return output;
    }
  };
  function serializeImage(image) {
    if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
      return ImageUtils.getDataURL(image);
    } else {
      if (image.data) {
        return {
          data: Array.prototype.slice.call(image.data),
          width: image.width,
          height: image.height,
          type: image.data.constructor.name
        };
      } else {
        console.warn("THREE.Texture: Unable to serialize Texture.");
        return {};
      }
    }
  }
  Source.prototype.isSource = true;
  var textureId = 0;
  var Texture = class _Texture extends EventDispatcher {
    constructor(image = _Texture.DEFAULT_IMAGE, mapping = _Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format = RGBAFormat, type = UnsignedByteType, anisotropy = 1, encoding = LinearEncoding) {
      super();
      Object.defineProperty(this, "id", { value: textureId++ });
      this.uuid = generateUUID();
      this.name = "";
      this.source = new Source(image);
      this.mipmaps = [];
      this.mapping = mapping;
      this.wrapS = wrapS;
      this.wrapT = wrapT;
      this.magFilter = magFilter;
      this.minFilter = minFilter;
      this.anisotropy = anisotropy;
      this.format = format;
      this.internalFormat = null;
      this.type = type;
      this.offset = new Vector2(0, 0);
      this.repeat = new Vector2(1, 1);
      this.center = new Vector2(0, 0);
      this.rotation = 0;
      this.matrixAutoUpdate = true;
      this.matrix = new Matrix3();
      this.generateMipmaps = true;
      this.premultiplyAlpha = false;
      this.flipY = true;
      this.unpackAlignment = 4;
      this.encoding = encoding;
      this.userData = {};
      this.version = 0;
      this.onUpdate = null;
      this.isRenderTargetTexture = false;
      this.needsPMREMUpdate = false;
    }
    get image() {
      return this.source.data;
    }
    set image(value) {
      this.source.data = value;
    }
    updateMatrix() {
      this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(source) {
      this.name = source.name;
      this.source = source.source;
      this.mipmaps = source.mipmaps.slice(0);
      this.mapping = source.mapping;
      this.wrapS = source.wrapS;
      this.wrapT = source.wrapT;
      this.magFilter = source.magFilter;
      this.minFilter = source.minFilter;
      this.anisotropy = source.anisotropy;
      this.format = source.format;
      this.internalFormat = source.internalFormat;
      this.type = source.type;
      this.offset.copy(source.offset);
      this.repeat.copy(source.repeat);
      this.center.copy(source.center);
      this.rotation = source.rotation;
      this.matrixAutoUpdate = source.matrixAutoUpdate;
      this.matrix.copy(source.matrix);
      this.generateMipmaps = source.generateMipmaps;
      this.premultiplyAlpha = source.premultiplyAlpha;
      this.flipY = source.flipY;
      this.unpackAlignment = source.unpackAlignment;
      this.encoding = source.encoding;
      this.userData = JSON.parse(JSON.stringify(source.userData));
      this.needsUpdate = true;
      return this;
    }
    toJSON(meta) {
      const isRootObject = meta === void 0 || typeof meta === "string";
      if (!isRootObject && meta.textures[this.uuid] !== void 0) {
        return meta.textures[this.uuid];
      }
      const output = {
        metadata: {
          version: 4.5,
          type: "Texture",
          generator: "Texture.toJSON"
        },
        uuid: this.uuid,
        name: this.name,
        image: this.source.toJSON(meta).uuid,
        mapping: this.mapping,
        repeat: [this.repeat.x, this.repeat.y],
        offset: [this.offset.x, this.offset.y],
        center: [this.center.x, this.center.y],
        rotation: this.rotation,
        wrap: [this.wrapS, this.wrapT],
        format: this.format,
        type: this.type,
        encoding: this.encoding,
        minFilter: this.minFilter,
        magFilter: this.magFilter,
        anisotropy: this.anisotropy,
        flipY: this.flipY,
        premultiplyAlpha: this.premultiplyAlpha,
        unpackAlignment: this.unpackAlignment
      };
      if (JSON.stringify(this.userData) !== "{}")
        output.userData = this.userData;
      if (!isRootObject) {
        meta.textures[this.uuid] = output;
      }
      return output;
    }
    dispose() {
      this.dispatchEvent({ type: "dispose" });
    }
    transformUv(uv) {
      if (this.mapping !== UVMapping)
        return uv;
      uv.applyMatrix3(this.matrix);
      if (uv.x < 0 || uv.x > 1) {
        switch (this.wrapS) {
          case RepeatWrapping:
            uv.x = uv.x - Math.floor(uv.x);
            break;
          case ClampToEdgeWrapping:
            uv.x = uv.x < 0 ? 0 : 1;
            break;
          case MirroredRepeatWrapping:
            if (Math.abs(Math.floor(uv.x) % 2) === 1) {
              uv.x = Math.ceil(uv.x) - uv.x;
            } else {
              uv.x = uv.x - Math.floor(uv.x);
            }
            break;
        }
      }
      if (uv.y < 0 || uv.y > 1) {
        switch (this.wrapT) {
          case RepeatWrapping:
            uv.y = uv.y - Math.floor(uv.y);
            break;
          case ClampToEdgeWrapping:
            uv.y = uv.y < 0 ? 0 : 1;
            break;
          case MirroredRepeatWrapping:
            if (Math.abs(Math.floor(uv.y) % 2) === 1) {
              uv.y = Math.ceil(uv.y) - uv.y;
            } else {
              uv.y = uv.y - Math.floor(uv.y);
            }
            break;
        }
      }
      if (this.flipY) {
        uv.y = 1 - uv.y;
      }
      return uv;
    }
    set needsUpdate(value) {
      if (value === true) {
        this.version++;
        this.source.needsUpdate = true;
      }
    }
  };
  Texture.DEFAULT_IMAGE = null;
  Texture.DEFAULT_MAPPING = UVMapping;
  Texture.prototype.isTexture = true;
  var Vector4 = class {
    constructor(x = 0, y = 0, z = 0, w = 1) {
      this.x = x;
      this.y = y;
      this.z = z;
      this.w = w;
    }
    get width() {
      return this.z;
    }
    set width(value) {
      this.z = value;
    }
    get height() {
      return this.w;
    }
    set height(value) {
      this.w = value;
    }
    set(x, y, z, w) {
      this.x = x;
      this.y = y;
      this.z = z;
      this.w = w;
      return this;
    }
    setScalar(scalar) {
      this.x = scalar;
      this.y = scalar;
      this.z = scalar;
      this.w = scalar;
      return this;
    }
    setX(x) {
      this.x = x;
      return this;
    }
    setY(y) {
      this.y = y;
      return this;
    }
    setZ(z) {
      this.z = z;
      return this;
    }
    setW(w) {
      this.w = w;
      return this;
    }
    setComponent(index, value) {
      switch (index) {
        case 0:
          this.x = value;
          break;
        case 1:
          this.y = value;
          break;
        case 2:
          this.z = value;
          break;
        case 3:
          this.w = value;
          break;
        default:
          throw new Error("index is out of range: " + index);
      }
      return this;
    }
    getComponent(index) {
      switch (index) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        case 2:
          return this.z;
        case 3:
          return this.w;
        default:
          throw new Error("index is out of range: " + index);
      }
    }
    clone() {
      return new this.constructor(this.x, this.y, this.z, this.w);
    }
    copy(v) {
      this.x = v.x;
      this.y = v.y;
      this.z = v.z;
      this.w = v.w !== void 0 ? v.w : 1;
      return this;
    }
    add(v, w) {
      if (w !== void 0) {
        console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
        return this.addVectors(v, w);
      }
      this.x += v.x;
      this.y += v.y;
      this.z += v.z;
      this.w += v.w;
      return this;
    }
    addScalar(s) {
      this.x += s;
      this.y += s;
      this.z += s;
      this.w += s;
      return this;
    }
    addVectors(a, b) {
      this.x = a.x + b.x;
      this.y = a.y + b.y;
      this.z = a.z + b.z;
      this.w = a.w + b.w;
      return this;
    }
    addScaledVector(v, s) {
      this.x += v.x * s;
      this.y += v.y * s;
      this.z += v.z * s;
      this.w += v.w * s;
      return this;
    }
    sub(v, w) {
      if (w !== void 0) {
        console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
        return this.subVectors(v, w);
      }
      this.x -= v.x;
      this.y -= v.y;
      this.z -= v.z;
      this.w -= v.w;
      return this;
    }
    subScalar(s) {
      this.x -= s;
      this.y -= s;
      this.z -= s;
      this.w -= s;
      return this;
    }
    subVectors(a, b) {
      this.x = a.x - b.x;
      this.y = a.y - b.y;
      this.z = a.z - b.z;
      this.w = a.w - b.w;
      return this;
    }
    multiply(v) {
      this.x *= v.x;
      this.y *= v.y;
      this.z *= v.z;
      this.w *= v.w;
      return this;
    }
    multiplyScalar(scalar) {
      this.x *= scalar;
      this.y *= scalar;
      this.z *= scalar;
      this.w *= scalar;
      return this;
    }
    applyMatrix4(m) {
      const x = this.x, y = this.y, z = this.z, w = this.w;
      const e = m.elements;
      this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;
      this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;
      this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;
      this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;
      return this;
    }
    divideScalar(scalar) {
      return this.multiplyScalar(1 / scalar);
    }
    setAxisAngleFromQuaternion(q) {
      this.w = 2 * Math.acos(q.w);
      const s = Math.sqrt(1 - q.w * q.w);
      if (s < 1e-4) {
        this.x = 1;
        this.y = 0;
        this.z = 0;
      } else {
        this.x = q.x / s;
        this.y = q.y / s;
        this.z = q.z / s;
      }
      return this;
    }
    setAxisAngleFromRotationMatrix(m) {
      let angle, x, y, z;
      const epsilon = 0.01, epsilon2 = 0.1, te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10];
      if (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {
        if (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) {
          this.set(1, 0, 0, 0);
          return this;
        }
        angle = Math.PI;
        const xx = (m11 + 1) / 2;
        const yy = (m22 + 1) / 2;
        const zz = (m33 + 1) / 2;
        const xy = (m12 + m21) / 4;
        const xz = (m13 + m31) / 4;
        const yz = (m23 + m32) / 4;
        if (xx > yy && xx > zz) {
          if (xx < epsilon) {
            x = 0;
            y = 0.707106781;
            z = 0.707106781;
          } else {
            x = Math.sqrt(xx);
            y = xy / x;
            z = xz / x;
          }
        } else if (yy > zz) {
          if (yy < epsilon) {
            x = 0.707106781;
            y = 0;
            z = 0.707106781;
          } else {
            y = Math.sqrt(yy);
            x = xy / y;
            z = yz / y;
          }
        } else {
          if (zz < epsilon) {
            x = 0.707106781;
            y = 0.707106781;
            z = 0;
          } else {
            z = Math.sqrt(zz);
            x = xz / z;
            y = yz / z;
          }
        }
        this.set(x, y, z, angle);
        return this;
      }
      let s = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12));
      if (Math.abs(s) < 1e-3)
        s = 1;
      this.x = (m32 - m23) / s;
      this.y = (m13 - m31) / s;
      this.z = (m21 - m12) / s;
      this.w = Math.acos((m11 + m22 + m33 - 1) / 2);
      return this;
    }
    min(v) {
      this.x = Math.min(this.x, v.x);
      this.y = Math.min(this.y, v.y);
      this.z = Math.min(this.z, v.z);
      this.w = Math.min(this.w, v.w);
      return this;
    }
    max(v) {
      this.x = Math.max(this.x, v.x);
      this.y = Math.max(this.y, v.y);
      this.z = Math.max(this.z, v.z);
      this.w = Math.max(this.w, v.w);
      return this;
    }
    clamp(min, max) {
      this.x = Math.max(min.x, Math.min(max.x, this.x));
      this.y = Math.max(min.y, Math.min(max.y, this.y));
      this.z = Math.max(min.z, Math.min(max.z, this.z));
      this.w = Math.max(min.w, Math.min(max.w, this.w));
      return this;
    }
    clampScalar(minVal, maxVal) {
      this.x = Math.max(minVal, Math.min(maxVal, this.x));
      this.y = Math.max(minVal, Math.min(maxVal, this.y));
      this.z = Math.max(minVal, Math.min(maxVal, this.z));
      this.w = Math.max(minVal, Math.min(maxVal, this.w));
      return this;
    }
    clampLength(min, max) {
      const length = this.length();
      return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
    }
    floor() {
      this.x = Math.floor(this.x);
      this.y = Math.floor(this.y);
      this.z = Math.floor(this.z);
      this.w = Math.floor(this.w);
      return this;
    }
    ceil() {
      this.x = Math.ceil(this.x);
      this.y = Math.ceil(this.y);
      this.z = Math.ceil(this.z);
      this.w = Math.ceil(this.w);
      return this;
    }
    round() {
      this.x = Math.round(this.x);
      this.y = Math.round(this.y);
      this.z = Math.round(this.z);
      this.w = Math.round(this.w);
      return this;
    }
    roundToZero() {
      this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
      this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
      this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
      this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w);
      return this;
    }
    negate() {
      this.x = -this.x;
      this.y = -this.y;
      this.z = -this.z;
      this.w = -this.w;
      return this;
    }
    dot(v) {
      return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
    }
    lengthSq() {
      return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
    }
    length() {
      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
    }
    manhattanLength() {
      return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
    }
    normalize() {
      return this.divideScalar(this.length() || 1);
    }
    setLength(length) {
      return this.normalize().multiplyScalar(length);
    }
    lerp(v, alpha) {
      this.x += (v.x - this.x) * alpha;
      this.y += (v.y - this.y) * alpha;
      this.z += (v.z - this.z) * alpha;
      this.w += (v.w - this.w) * alpha;
      return this;
    }
    lerpVectors(v1, v2, alpha) {
      this.x = v1.x + (v2.x - v1.x) * alpha;
      this.y = v1.y + (v2.y - v1.y) * alpha;
      this.z = v1.z + (v2.z - v1.z) * alpha;
      this.w = v1.w + (v2.w - v1.w) * alpha;
      return this;
    }
    equals(v) {
      return v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w;
    }
    fromArray(array, offset = 0) {
      this.x = array[offset];
      this.y = array[offset + 1];
      this.z = array[offset + 2];
      this.w = array[offset + 3];
      return this;
    }
    toArray(array = [], offset = 0) {
      array[offset] = this.x;
      array[offset + 1] = this.y;
      array[offset + 2] = this.z;
      array[offset + 3] = this.w;
      return array;
    }
    fromBufferAttribute(attribute, index, offset) {
      if (offset !== void 0) {
        console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute().");
      }
      this.x = attribute.getX(index);
      this.y = attribute.getY(index);
      this.z = attribute.getZ(index);
      this.w = attribute.getW(index);
      return this;
    }
    random() {
      this.x = Math.random();
      this.y = Math.random();
      this.z = Math.random();
      this.w = Math.random();
      return this;
    }
    *[Symbol.iterator]() {
      yield this.x;
      yield this.y;
      yield this.z;
      yield this.w;
    }
  };
  Vector4.prototype.isVector4 = true;
  var WebGLRenderTarget = class extends EventDispatcher {
    constructor(width, height, options = {}) {
      super();
      this.width = width;
      this.height = height;
      this.depth = 1;
      this.scissor = new Vector4(0, 0, width, height);
      this.scissorTest = false;
      this.viewport = new Vector4(0, 0, width, height);
      const image = { width, height, depth: 1 };
      this.texture = new Texture(image, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);
      this.texture.isRenderTargetTexture = true;
      this.texture.flipY = false;
      this.texture.generateMipmaps = options.generateMipmaps !== void 0 ? options.generateMipmaps : false;
      this.texture.internalFormat = options.internalFormat !== void 0 ? options.internalFormat : null;
      this.texture.minFilter = options.minFilter !== void 0 ? options.minFilter : LinearFilter;
      this.depthBuffer = options.depthBuffer !== void 0 ? options.depthBuffer : true;
      this.stencilBuffer = options.stencilBuffer !== void 0 ? options.stencilBuffer : false;
      this.depthTexture = options.depthTexture !== void 0 ? options.depthTexture : null;
      this.samples = options.samples !== void 0 ? options.samples : 0;
    }
    setSize(width, height, depth = 1) {
      if (this.width !== width || this.height !== height || this.depth !== depth) {
        this.width = width;
        this.height = height;
        this.depth = depth;
        this.texture.image.width = width;
        this.texture.image.height = height;
        this.texture.image.depth = depth;
        this.dispose();
      }
      this.viewport.set(0, 0, width, height);
      this.scissor.set(0, 0, width, height);
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(source) {
      this.width = source.width;
      this.height = source.height;
      this.depth = source.depth;
      this.viewport.copy(source.viewport);
      this.texture = source.texture.clone();
      this.texture.isRenderTargetTexture = true;
      this.texture.image = Object.assign({}, source.texture.image);
      this.depthBuffer = source.depthBuffer;
      this.stencilBuffer = source.stencilBuffer;
      if (source.depthTexture !== null)
        this.depthTexture = source.depthTexture.clone();
      this.samples = source.samples;
      return this;
    }
    dispose() {
      this.dispatchEvent({ type: "dispose" });
    }
  };
  WebGLRenderTarget.prototype.isWebGLRenderTarget = true;
  var DataArrayTexture = class extends Texture {
    constructor(data = null, width = 1, height = 1, depth = 1) {
      super(null);
      this.image = { data, width, height, depth };
      this.magFilter = NearestFilter;
      this.minFilter = NearestFilter;
      this.wrapR = ClampToEdgeWrapping;
      this.generateMipmaps = false;
      this.flipY = false;
      this.unpackAlignment = 1;
    }
  };
  DataArrayTexture.prototype.isDataArrayTexture = true;
  var WebGLArrayRenderTarget = class extends WebGLRenderTarget {
    constructor(width, height, depth) {
      super(width, height);
      this.depth = depth;
      this.texture = new DataArrayTexture(null, width, height, depth);
      this.texture.isRenderTargetTexture = true;
    }
  };
  WebGLArrayRenderTarget.prototype.isWebGLArrayRenderTarget = true;
  var Data3DTexture = class extends Texture {
    constructor(data = null, width = 1, height = 1, depth = 1) {
      super(null);
      this.image = { data, width, height, depth };
      this.magFilter = NearestFilter;
      this.minFilter = NearestFilter;
      this.wrapR = ClampToEdgeWrapping;
      this.generateMipmaps = false;
      this.flipY = false;
      this.unpackAlignment = 1;
    }
  };
  Data3DTexture.prototype.isData3DTexture = true;
  var WebGL3DRenderTarget = class extends WebGLRenderTarget {
    constructor(width, height, depth) {
      super(width, height);
      this.depth = depth;
      this.texture = new Data3DTexture(null, width, height, depth);
      this.texture.isRenderTargetTexture = true;
    }
  };
  WebGL3DRenderTarget.prototype.isWebGL3DRenderTarget = true;
  var WebGLMultipleRenderTargets = class extends WebGLRenderTarget {
    constructor(width, height, count, options = {}) {
      super(width, height, options);
      const texture = this.texture;
      this.texture = [];
      for (let i = 0; i < count; i++) {
        this.texture[i] = texture.clone();
        this.texture[i].isRenderTargetTexture = true;
      }
    }
    setSize(width, height, depth = 1) {
      if (this.width !== width || this.height !== height || this.depth !== depth) {
        this.width = width;
        this.height = height;
        this.depth = depth;
        for (let i = 0, il = this.texture.length; i < il; i++) {
          this.texture[i].image.width = width;
          this.texture[i].image.height = height;
          this.texture[i].image.depth = depth;
        }
        this.dispose();
      }
      this.viewport.set(0, 0, width, height);
      this.scissor.set(0, 0, width, height);
      return this;
    }
    copy(source) {
      this.dispose();
      this.width = source.width;
      this.height = source.height;
      this.depth = source.depth;
      this.viewport.set(0, 0, this.width, this.height);
      this.scissor.set(0, 0, this.width, this.height);
      this.depthBuffer = source.depthBuffer;
      this.stencilBuffer = source.stencilBuffer;
      this.depthTexture = source.depthTexture;
      this.texture.length = 0;
      for (let i = 0, il = source.texture.length; i < il; i++) {
        this.texture[i] = source.texture[i].clone();
      }
      return this;
    }
  };
  WebGLMultipleRenderTargets.prototype.isWebGLMultipleRenderTargets = true;
  var Quaternion = class {
    constructor(x = 0, y = 0, z = 0, w = 1) {
      this._x = x;
      this._y = y;
      this._z = z;
      this._w = w;
    }
    static slerp(qa, qb, qm, t) {
      console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead.");
      return qm.slerpQuaternions(qa, qb, t);
    }
    static slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {
      let x0 = src0[srcOffset0 + 0], y0 = src0[srcOffset0 + 1], z0 = src0[srcOffset0 + 2], w0 = src0[srcOffset0 + 3];
      const x1 = src1[srcOffset1 + 0], y1 = src1[srcOffset1 + 1], z1 = src1[srcOffset1 + 2], w1 = src1[srcOffset1 + 3];
      if (t === 0) {
        dst[dstOffset + 0] = x0;
        dst[dstOffset + 1] = y0;
        dst[dstOffset + 2] = z0;
        dst[dstOffset + 3] = w0;
        return;
      }
      if (t === 1) {
        dst[dstOffset + 0] = x1;
        dst[dstOffset + 1] = y1;
        dst[dstOffset + 2] = z1;
        dst[dstOffset + 3] = w1;
        return;
      }
      if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
        let s = 1 - t;
        const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1, dir = cos >= 0 ? 1 : -1, sqrSin = 1 - cos * cos;
        if (sqrSin > Number.EPSILON) {
          const sin = Math.sqrt(sqrSin), len = Math.atan2(sin, cos * dir);
          s = Math.sin(s * len) / sin;
          t = Math.sin(t * len) / sin;
        }
        const tDir = t * dir;
        x0 = x0 * s + x1 * tDir;
        y0 = y0 * s + y1 * tDir;
        z0 = z0 * s + z1 * tDir;
        w0 = w0 * s + w1 * tDir;
        if (s === 1 - t) {
          const f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
          x0 *= f;
          y0 *= f;
          z0 *= f;
          w0 *= f;
        }
      }
      dst[dstOffset] = x0;
      dst[dstOffset + 1] = y0;
      dst[dstOffset + 2] = z0;
      dst[dstOffset + 3] = w0;
    }
    static multiplyQuaternionsFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1) {
      const x0 = src0[srcOffset0];
      const y0 = src0[srcOffset0 + 1];
      const z0 = src0[srcOffset0 + 2];
      const w0 = src0[srcOffset0 + 3];
      const x1 = src1[srcOffset1];
      const y1 = src1[srcOffset1 + 1];
      const z1 = src1[srcOffset1 + 2];
      const w1 = src1[srcOffset1 + 3];
      dst[dstOffset] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
      dst[dstOffset + 1] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
      dst[dstOffset + 2] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
      dst[dstOffset + 3] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;
      return dst;
    }
    get x() {
      return this._x;
    }
    set x(value) {
      this._x = value;
      this._onChangeCallback();
    }
    get y() {
      return this._y;
    }
    set y(value) {
      this._y = value;
      this._onChangeCallback();
    }
    get z() {
      return this._z;
    }
    set z(value) {
      this._z = value;
      this._onChangeCallback();
    }
    get w() {
      return this._w;
    }
    set w(value) {
      this._w = value;
      this._onChangeCallback();
    }
    set(x, y, z, w) {
      this._x = x;
      this._y = y;
      this._z = z;
      this._w = w;
      this._onChangeCallback();
      return this;
    }
    clone() {
      return new this.constructor(this._x, this._y, this._z, this._w);
    }
    copy(quaternion) {
      this._x = quaternion.x;
      this._y = quaternion.y;
      this._z = quaternion.z;
      this._w = quaternion.w;
      this._onChangeCallback();
      return this;
    }
    setFromEuler(euler, update) {
      if (!(euler && euler.isEuler)) {
        throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
      }
      const x = euler._x, y = euler._y, z = euler._z, order = euler._order;
      const cos = Math.cos;
      const sin = Math.sin;
      const c1 = cos(x / 2);
      const c2 = cos(y / 2);
      const c3 = cos(z / 2);
      const s1 = sin(x / 2);
      const s2 = sin(y / 2);
      const s3 = sin(z / 2);
      switch (order) {
        case "XYZ":
          this._x = s1 * c2 * c3 + c1 * s2 * s3;
          this._y = c1 * s2 * c3 - s1 * c2 * s3;
          this._z = c1 * c2 * s3 + s1 * s2 * c3;
          this._w = c1 * c2 * c3 - s1 * s2 * s3;
          break;
        case "YXZ":
          this._x = s1 * c2 * c3 + c1 * s2 * s3;
          this._y = c1 * s2 * c3 - s1 * c2 * s3;
          this._z = c1 * c2 * s3 - s1 * s2 * c3;
          this._w = c1 * c2 * c3 + s1 * s2 * s3;
          break;
        case "ZXY":
          this._x = s1 * c2 * c3 - c1 * s2 * s3;
          this._y = c1 * s2 * c3 + s1 * c2 * s3;
          this._z = c1 * c2 * s3 + s1 * s2 * c3;
          this._w = c1 * c2 * c3 - s1 * s2 * s3;
          break;
        case "ZYX":
          this._x = s1 * c2 * c3 - c1 * s2 * s3;
          this._y = c1 * s2 * c3 + s1 * c2 * s3;
          this._z = c1 * c2 * s3 - s1 * s2 * c3;
          this._w = c1 * c2 * c3 + s1 * s2 * s3;
          break;
        case "YZX":
          this._x = s1 * c2 * c3 + c1 * s2 * s3;
          this._y = c1 * s2 * c3 + s1 * c2 * s3;
          this._z = c1 * c2 * s3 - s1 * s2 * c3;
          this._w = c1 * c2 * c3 - s1 * s2 * s3;
          break;
        case "XZY":
          this._x = s1 * c2 * c3 - c1 * s2 * s3;
          this._y = c1 * s2 * c3 - s1 * c2 * s3;
          this._z = c1 * c2 * s3 + s1 * s2 * c3;
          this._w = c1 * c2 * c3 + s1 * s2 * s3;
          break;
        default:
          console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + order);
      }
      if (update !== false)
        this._onChangeCallback();
      return this;
    }
    setFromAxisAngle(axis, angle) {
      const halfAngle = angle / 2, s = Math.sin(halfAngle);
      this._x = axis.x * s;
      this._y = axis.y * s;
      this._z = axis.z * s;
      this._w = Math.cos(halfAngle);
      this._onChangeCallback();
      return this;
    }
    setFromRotationMatrix(m) {
      const te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10], trace = m11 + m22 + m33;
      if (trace > 0) {
        const s = 0.5 / Math.sqrt(trace + 1);
        this._w = 0.25 / s;
        this._x = (m32 - m23) * s;
        this._y = (m13 - m31) * s;
        this._z = (m21 - m12) * s;
      } else if (m11 > m22 && m11 > m33) {
        const s = 2 * Math.sqrt(1 + m11 - m22 - m33);
        this._w = (m32 - m23) / s;
        this._x = 0.25 * s;
        this._y = (m12 + m21) / s;
        this._z = (m13 + m31) / s;
      } else if (m22 > m33) {
        const s = 2 * Math.sqrt(1 + m22 - m11 - m33);
        this._w = (m13 - m31) / s;
        this._x = (m12 + m21) / s;
        this._y = 0.25 * s;
        this._z = (m23 + m32) / s;
      } else {
        const s = 2 * Math.sqrt(1 + m33 - m11 - m22);
        this._w = (m21 - m12) / s;
        this._x = (m13 + m31) / s;
        this._y = (m23 + m32) / s;
        this._z = 0.25 * s;
      }
      this._onChangeCallback();
      return this;
    }
    setFromUnitVectors(vFrom, vTo) {
      let r = vFrom.dot(vTo) + 1;
      if (r < Number.EPSILON) {
        r = 0;
        if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
          this._x = -vFrom.y;
          this._y = vFrom.x;
          this._z = 0;
          this._w = r;
        } else {
          this._x = 0;
          this._y = -vFrom.z;
          this._z = vFrom.y;
          this._w = r;
        }
      } else {
        this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
        this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
        this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
        this._w = r;
      }
      return this.normalize();
    }
    angleTo(q) {
      return 2 * Math.acos(Math.abs(clamp(this.dot(q), -1, 1)));
    }
    rotateTowards(q, step) {
      const angle = this.angleTo(q);
      if (angle === 0)
        return this;
      const t = Math.min(1, step / angle);
      this.slerp(q, t);
      return this;
    }
    identity() {
      return this.set(0, 0, 0, 1);
    }
    invert() {
      return this.conjugate();
    }
    conjugate() {
      this._x *= -1;
      this._y *= -1;
      this._z *= -1;
      this._onChangeCallback();
      return this;
    }
    dot(v) {
      return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
    }
    lengthSq() {
      return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
    }
    length() {
      return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
    }
    normalize() {
      let l = this.length();
      if (l === 0) {
        this._x = 0;
        this._y = 0;
        this._z = 0;
        this._w = 1;
      } else {
        l = 1 / l;
        this._x = this._x * l;
        this._y = this._y * l;
        this._z = this._z * l;
        this._w = this._w * l;
      }
      this._onChangeCallback();
      return this;
    }
    multiply(q, p) {
      if (p !== void 0) {
        console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.");
        return this.multiplyQuaternions(q, p);
      }
      return this.multiplyQuaternions(this, q);
    }
    premultiply(q) {
      return this.multiplyQuaternions(q, this);
    }
    multiplyQuaternions(a, b) {
      const qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
      const qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;
      this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
      this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
      this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
      this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
      this._onChangeCallback();
      return this;
    }
    slerp(qb, t) {
      if (t === 0)
        return this;
      if (t === 1)
        return this.copy(qb);
      const x = this._x, y = this._y, z = this._z, w = this._w;
      let cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;
      if (cosHalfTheta < 0) {
        this._w = -qb._w;
        this._x = -qb._x;
        this._y = -qb._y;
        this._z = -qb._z;
        cosHalfTheta = -cosHalfTheta;
      } else {
        this.copy(qb);
      }
      if (cosHalfTheta >= 1) {
        this._w = w;
        this._x = x;
        this._y = y;
        this._z = z;
        return this;
      }
      const sqrSinHalfTheta = 1 - cosHalfTheta * cosHalfTheta;
      if (sqrSinHalfTheta <= Number.EPSILON) {
        const s = 1 - t;
        this._w = s * w + t * this._w;
        this._x = s * x + t * this._x;
        this._y = s * y + t * this._y;
        this._z = s * z + t * this._z;
        this.normalize();
        this._onChangeCallback();
        return this;
      }
      const sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
      const halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
      const ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta, ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
      this._w = w * ratioA + this._w * ratioB;
      this._x = x * ratioA + this._x * ratioB;
      this._y = y * ratioA + this._y * ratioB;
      this._z = z * ratioA + this._z * ratioB;
      this._onChangeCallback();
      return this;
    }
    slerpQuaternions(qa, qb, t) {
      return this.copy(qa).slerp(qb, t);
    }
    random() {
      const u1 = Math.random();
      const sqrt1u1 = Math.sqrt(1 - u1);
      const sqrtu1 = Math.sqrt(u1);
      const u2 = 2 * Math.PI * Math.random();
      const u3 = 2 * Math.PI * Math.random();
      return this.set(
        sqrt1u1 * Math.cos(u2),
        sqrtu1 * Math.sin(u3),
        sqrtu1 * Math.cos(u3),
        sqrt1u1 * Math.sin(u2)
      );
    }
    equals(quaternion) {
      return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;
    }
    fromArray(array, offset = 0) {
      this._x = array[offset];
      this._y = array[offset + 1];
      this._z = array[offset + 2];
      this._w = array[offset + 3];
      this._onChangeCallback();
      return this;
    }
    toArray(array = [], offset = 0) {
      array[offset] = this._x;
      array[offset + 1] = this._y;
      array[offset + 2] = this._z;
      array[offset + 3] = this._w;
      return array;
    }
    fromBufferAttribute(attribute, index) {
      this._x = attribute.getX(index);
      this._y = attribute.getY(index);
      this._z = attribute.getZ(index);
      this._w = attribute.getW(index);
      return this;
    }
    _onChange(callback) {
      this._onChangeCallback = callback;
      return this;
    }
    _onChangeCallback() {
    }
  };
  Quaternion.prototype.isQuaternion = true;
  var Vector3 = class {
    constructor(x = 0, y = 0, z = 0) {
      this.x = x;
      this.y = y;
      this.z = z;
    }
    set(x, y, z) {
      if (z === void 0)
        z = this.z;
      this.x = x;
      this.y = y;
      this.z = z;
      return this;
    }
    setScalar(scalar) {
      this.x = scalar;
      this.y = scalar;
      this.z = scalar;
      return this;
    }
    setX(x) {
      this.x = x;
      return this;
    }
    setY(y) {
      this.y = y;
      return this;
    }
    setZ(z) {
      this.z = z;
      return this;
    }
    setComponent(index, value) {
      switch (index) {
        case 0:
          this.x = value;
          break;
        case 1:
          this.y = value;
          break;
        case 2:
          this.z = value;
          break;
        default:
          throw new Error("index is out of range: " + index);
      }
      return this;
    }
    getComponent(index) {
      switch (index) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        case 2:
          return this.z;
        default:
          throw new Error("index is out of range: " + index);
      }
    }
    clone() {
      return new this.constructor(this.x, this.y, this.z);
    }
    copy(v) {
      this.x = v.x;
      this.y = v.y;
      this.z = v.z;
      return this;
    }
    add(v, w) {
      if (w !== void 0) {
        console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
        return this.addVectors(v, w);
      }
      this.x += v.x;
      this.y += v.y;
      this.z += v.z;
      return this;
    }
    addScalar(s) {
      this.x += s;
      this.y += s;
      this.z += s;
      return this;
    }
    addVectors(a, b) {
      this.x = a.x + b.x;
      this.y = a.y + b.y;
      this.z = a.z + b.z;
      return this;
    }
    addScaledVector(v, s) {
      this.x += v.x * s;
      this.y += v.y * s;
      this.z += v.z * s;
      return this;
    }
    sub(v, w) {
      if (w !== void 0) {
        console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
        return this.subVectors(v, w);
      }
      this.x -= v.x;
      this.y -= v.y;
      this.z -= v.z;
      return this;
    }
    subScalar(s) {
      this.x -= s;
      this.y -= s;
      this.z -= s;
      return this;
    }
    subVectors(a, b) {
      this.x = a.x - b.x;
      this.y = a.y - b.y;
      this.z = a.z - b.z;
      return this;
    }
    multiply(v, w) {
      if (w !== void 0) {
        console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.");
        return this.multiplyVectors(v, w);
      }
      this.x *= v.x;
      this.y *= v.y;
      this.z *= v.z;
      return this;
    }
    multiplyScalar(scalar) {
      this.x *= scalar;
      this.y *= scalar;
      this.z *= scalar;
      return this;
    }
    multiplyVectors(a, b) {
      this.x = a.x * b.x;
      this.y = a.y * b.y;
      this.z = a.z * b.z;
      return this;
    }
    applyEuler(euler) {
      if (!(euler && euler.isEuler)) {
        console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.");
      }
      return this.applyQuaternion(_quaternion$4.setFromEuler(euler));
    }
    applyAxisAngle(axis, angle) {
      return this.applyQuaternion(_quaternion$4.setFromAxisAngle(axis, angle));
    }
    applyMatrix3(m) {
      const x = this.x, y = this.y, z = this.z;
      const e = m.elements;
      this.x = e[0] * x + e[3] * y + e[6] * z;
      this.y = e[1] * x + e[4] * y + e[7] * z;
      this.z = e[2] * x + e[5] * y + e[8] * z;
      return this;
    }
    applyNormalMatrix(m) {
      return this.applyMatrix3(m).normalize();
    }
    applyMatrix4(m) {
      const x = this.x, y = this.y, z = this.z;
      const e = m.elements;
      const w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);
      this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w;
      this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w;
      this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w;
      return this;
    }
    applyQuaternion(q) {
      const x = this.x, y = this.y, z = this.z;
      const qx = q.x, qy = q.y, qz = q.z, qw = q.w;
      const ix = qw * x + qy * z - qz * y;
      const iy = qw * y + qz * x - qx * z;
      const iz = qw * z + qx * y - qy * x;
      const iw = -qx * x - qy * y - qz * z;
      this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
      this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
      this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
      return this;
    }
    project(camera) {
      return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);
    }
    unproject(camera) {
      return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);
    }
    transformDirection(m) {
      const x = this.x, y = this.y, z = this.z;
      const e = m.elements;
      this.x = e[0] * x + e[4] * y + e[8] * z;
      this.y = e[1] * x + e[5] * y + e[9] * z;
      this.z = e[2] * x + e[6] * y + e[10] * z;
      return this.normalize();
    }
    divide(v) {
      this.x /= v.x;
      this.y /= v.y;
      this.z /= v.z;
      return this;
    }
    divideScalar(scalar) {
      return this.multiplyScalar(1 / scalar);
    }
    min(v) {
      this.x = Math.min(this.x, v.x);
      this.y = Math.min(this.y, v.y);
      this.z = Math.min(this.z, v.z);
      return this;
    }
    max(v) {
      this.x = Math.max(this.x, v.x);
      this.y = Math.max(this.y, v.y);
      this.z = Math.max(this.z, v.z);
      return this;
    }
    clamp(min, max) {
      this.x = Math.max(min.x, Math.min(max.x, this.x));
      this.y = Math.max(min.y, Math.min(max.y, this.y));
      this.z = Math.max(min.z, Math.min(max.z, this.z));
      return this;
    }
    clampScalar(minVal, maxVal) {
      this.x = Math.max(minVal, Math.min(maxVal, this.x));
      this.y = Math.max(minVal, Math.min(maxVal, this.y));
      this.z = Math.max(minVal, Math.min(maxVal, this.z));
      return this;
    }
    clampLength(min, max) {
      const length = this.length();
      return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
    }
    floor() {
      this.x = Math.floor(this.x);
      this.y = Math.floor(this.y);
      this.z = Math.floor(this.z);
      return this;
    }
    ceil() {
      this.x = Math.ceil(this.x);
      this.y = Math.ceil(this.y);
      this.z = Math.ceil(this.z);
      return this;
    }
    round() {
      this.x = Math.round(this.x);
      this.y = Math.round(this.y);
      this.z = Math.round(this.z);
      return this;
    }
    roundToZero() {
      this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
      this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
      this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
      return this;
    }
    negate() {
      this.x = -this.x;
      this.y = -this.y;
      this.z = -this.z;
      return this;
    }
    dot(v) {
      return this.x * v.x + this.y * v.y + this.z * v.z;
    }
    // TODO lengthSquared?
    lengthSq() {
      return this.x * this.x + this.y * this.y + this.z * this.z;
    }
    length() {
      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
    }
    manhattanLength() {
      return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
    }
    normalize() {
      return this.divideScalar(this.length() || 1);
    }
    setLength(length) {
      return this.normalize().multiplyScalar(length);
    }
    lerp(v, alpha) {
      this.x += (v.x - this.x) * alpha;
      this.y += (v.y - this.y) * alpha;
      this.z += (v.z - this.z) * alpha;
      return this;
    }
    lerpVectors(v1, v2, alpha) {
      this.x = v1.x + (v2.x - v1.x) * alpha;
      this.y = v1.y + (v2.y - v1.y) * alpha;
      this.z = v1.z + (v2.z - v1.z) * alpha;
      return this;
    }
    cross(v, w) {
      if (w !== void 0) {
        console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.");
        return this.crossVectors(v, w);
      }
      return this.crossVectors(this, v);
    }
    crossVectors(a, b) {
      const ax = a.x, ay = a.y, az = a.z;
      const bx = b.x, by = b.y, bz = b.z;
      this.x = ay * bz - az * by;
      this.y = az * bx - ax * bz;
      this.z = ax * by - ay * bx;
      return this;
    }
    projectOnVector(v) {
      const denominator = v.lengthSq();
      if (denominator === 0)
        return this.set(0, 0, 0);
      const scalar = v.dot(this) / denominator;
      return this.copy(v).multiplyScalar(scalar);
    }
    projectOnPlane(planeNormal) {
      _vector$c.copy(this).projectOnVector(planeNormal);
      return this.sub(_vector$c);
    }
    reflect(normal) {
      return this.sub(_vector$c.copy(normal).multiplyScalar(2 * this.dot(normal)));
    }
    angleTo(v) {
      const denominator = Math.sqrt(this.lengthSq() * v.lengthSq());
      if (denominator === 0)
        return Math.PI / 2;
      const theta = this.dot(v) / denominator;
      return Math.acos(clamp(theta, -1, 1));
    }
    distanceTo(v) {
      return Math.sqrt(this.distanceToSquared(v));
    }
    distanceToSquared(v) {
      const dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;
      return dx * dx + dy * dy + dz * dz;
    }
    manhattanDistanceTo(v) {
      return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);
    }
    setFromSpherical(s) {
      return this.setFromSphericalCoords(s.radius, s.phi, s.theta);
    }
    setFromSphericalCoords(radius, phi, theta) {
      const sinPhiRadius = Math.sin(phi) * radius;
      this.x = sinPhiRadius * Math.sin(theta);
      this.y = Math.cos(phi) * radius;
      this.z = sinPhiRadius * Math.cos(theta);
      return this;
    }
    setFromCylindrical(c) {
      return this.setFromCylindricalCoords(c.radius, c.theta, c.y);
    }
    setFromCylindricalCoords(radius, theta, y) {
      this.x = radius * Math.sin(theta);
      this.y = y;
      this.z = radius * Math.cos(theta);
      return this;
    }
    setFromMatrixPosition(m) {
      const e = m.elements;
      this.x = e[12];
      this.y = e[13];
      this.z = e[14];
      return this;
    }
    setFromMatrixScale(m) {
      const sx = this.setFromMatrixColumn(m, 0).length();
      const sy = this.setFromMatrixColumn(m, 1).length();
      const sz = this.setFromMatrixColumn(m, 2).length();
      this.x = sx;
      this.y = sy;
      this.z = sz;
      return this;
    }
    setFromMatrixColumn(m, index) {
      return this.fromArray(m.elements, index * 4);
    }
    setFromMatrix3Column(m, index) {
      return this.fromArray(m.elements, index * 3);
    }
    setFromEuler(e) {
      this.x = e._x;
      this.y = e._y;
      this.z = e._z;
      return this;
    }
    equals(v) {
      return v.x === this.x && v.y === this.y && v.z === this.z;
    }
    fromArray(array, offset = 0) {
      this.x = array[offset];
      this.y = array[offset + 1];
      this.z = array[offset + 2];
      return this;
    }
    toArray(array = [], offset = 0) {
      array[offset] = this.x;
      array[offset + 1] = this.y;
      array[offset + 2] = this.z;
      return array;
    }
    fromBufferAttribute(attribute, index, offset) {
      if (offset !== void 0) {
        console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute().");
      }
      this.x = attribute.getX(index);
      this.y = attribute.getY(index);
      this.z = attribute.getZ(index);
      return this;
    }
    random() {
      this.x = Math.random();
      this.y = Math.random();
      this.z = Math.random();
      return this;
    }
    randomDirection() {
      const u = (Math.random() - 0.5) * 2;
      const t = Math.random() * Math.PI * 2;
      const f = Math.sqrt(1 - u ** 2);
      this.x = f * Math.cos(t);
      this.y = f * Math.sin(t);
      this.z = u;
      return this;
    }
    *[Symbol.iterator]() {
      yield this.x;
      yield this.y;
      yield this.z;
    }
  };
  Vector3.prototype.isVector3 = true;
  var _vector$c = /* @__PURE__ */ new Vector3();
  var _quaternion$4 = /* @__PURE__ */ new Quaternion();
  var Box3 = class {
    constructor(min = new Vector3(Infinity, Infinity, Infinity), max = new Vector3(-Infinity, -Infinity, -Infinity)) {
      this.min = min;
      this.max = max;
    }
    set(min, max) {
      this.min.copy(min);
      this.max.copy(max);
      return this;
    }
    setFromArray(array) {
      let minX = Infinity;
      let minY = Infinity;
      let minZ = Infinity;
      let maxX = -Infinity;
      let maxY = -Infinity;
      let maxZ = -Infinity;
      for (let i = 0, l = array.length; i < l; i += 3) {
        const x = array[i];
        const y = array[i + 1];
        const z = array[i + 2];
        if (x < minX)
          minX = x;
        if (y < minY)
          minY = y;
        if (z < minZ)
          minZ = z;
        if (x > maxX)
          maxX = x;
        if (y > maxY)
          maxY = y;
        if (z > maxZ)
          maxZ = z;
      }
      this.min.set(minX, minY, minZ);
      this.max.set(maxX, maxY, maxZ);
      return this;
    }
    setFromBufferAttribute(attribute) {
      let minX = Infinity;
      let minY = Infinity;
      let minZ = Infinity;
      let maxX = -Infinity;
      let maxY = -Infinity;
      let maxZ = -Infinity;
      for (let i = 0, l = attribute.count; i < l; i++) {
        const x = attribute.getX(i);
        const y = attribute.getY(i);
        const z = attribute.getZ(i);
        if (x < minX)
          minX = x;
        if (y < minY)
          minY = y;
        if (z < minZ)
          minZ = z;
        if (x > maxX)
          maxX = x;
        if (y > maxY)
          maxY = y;
        if (z > maxZ)
          maxZ = z;
      }
      this.min.set(minX, minY, minZ);
      this.max.set(maxX, maxY, maxZ);
      return this;
    }
    setFromPoints(points) {
      this.makeEmpty();
      for (let i = 0, il = points.length; i < il; i++) {
        this.expandByPoint(points[i]);
      }
      return this;
    }
    setFromCenterAndSize(center, size) {
      const halfSize = _vector$b.copy(size).multiplyScalar(0.5);
      this.min.copy(center).sub(halfSize);
      this.max.copy(center).add(halfSize);
      return this;
    }
    setFromObject(object, precise = false) {
      this.makeEmpty();
      return this.expandByObject(object, precise);
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(box) {
      this.min.copy(box.min);
      this.max.copy(box.max);
      return this;
    }
    makeEmpty() {
      this.min.x = this.min.y = this.min.z = Infinity;
      this.max.x = this.max.y = this.max.z = -Infinity;
      return this;
    }
    isEmpty() {
      return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
    }
    getCenter(target) {
      return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
    }
    getSize(target) {
      return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);
    }
    expandByPoint(point) {
      this.min.min(point);
      this.max.max(point);
      return this;
    }
    expandByVector(vector) {
      this.min.sub(vector);
      this.max.add(vector);
      return this;
    }
    expandByScalar(scalar) {
      this.min.addScalar(-scalar);
      this.max.addScalar(scalar);
      return this;
    }
    expandByObject(object, precise = false) {
      object.updateWorldMatrix(false, false);
      const geometry = object.geometry;
      if (geometry !== void 0) {
        if (precise && geometry.attributes != void 0 && geometry.attributes.position !== void 0) {
          const position = geometry.attributes.position;
          for (let i = 0, l = position.count; i < l; i++) {
            _vector$b.fromBufferAttribute(position, i).applyMatrix4(object.matrixWorld);
            this.expandByPoint(_vector$b);
          }
        } else {
          if (geometry.boundingBox === null) {
            geometry.computeBoundingBox();
          }
          _box$3.copy(geometry.boundingBox);
          _box$3.applyMatrix4(object.matrixWorld);
          this.union(_box$3);
        }
      }
      const children = object.children;
      for (let i = 0, l = children.length; i < l; i++) {
        this.expandByObject(children[i], precise);
      }
      return this;
    }
    containsPoint(point) {
      return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y || point.z < this.min.z || point.z > this.max.z ? false : true;
    }
    containsBox(box) {
      return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;
    }
    getParameter(point, target) {
      return target.set(
        (point.x - this.min.x) / (this.max.x - this.min.x),
        (point.y - this.min.y) / (this.max.y - this.min.y),
        (point.z - this.min.z) / (this.max.z - this.min.z)
      );
    }
    intersectsBox(box) {
      return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z ? false : true;
    }
    intersectsSphere(sphere) {
      this.clampPoint(sphere.center, _vector$b);
      return _vector$b.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;
    }
    intersectsPlane(plane) {
      let min, max;
      if (plane.normal.x > 0) {
        min = plane.normal.x * this.min.x;
        max = plane.normal.x * this.max.x;
      } else {
        min = plane.normal.x * this.max.x;
        max = plane.normal.x * this.min.x;
      }
      if (plane.normal.y > 0) {
        min += plane.normal.y * this.min.y;
        max += plane.normal.y * this.max.y;
      } else {
        min += plane.normal.y * this.max.y;
        max += plane.normal.y * this.min.y;
      }
      if (plane.normal.z > 0) {
        min += plane.normal.z * this.min.z;
        max += plane.normal.z * this.max.z;
      } else {
        min += plane.normal.z * this.max.z;
        max += plane.normal.z * this.min.z;
      }
      return min <= -plane.constant && max >= -plane.constant;
    }
    intersectsTriangle(triangle) {
      if (this.isEmpty()) {
        return false;
      }
      this.getCenter(_center);
      _extents.subVectors(this.max, _center);
      _v0$2.subVectors(triangle.a, _center);
      _v1$7.subVectors(triangle.b, _center);
      _v2$3.subVectors(triangle.c, _center);
      _f0.subVectors(_v1$7, _v0$2);
      _f1.subVectors(_v2$3, _v1$7);
      _f2.subVectors(_v0$2, _v2$3);
      let axes = [
        0,
        -_f0.z,
        _f0.y,
        0,
        -_f1.z,
        _f1.y,
        0,
        -_f2.z,
        _f2.y,
        _f0.z,
        0,
        -_f0.x,
        _f1.z,
        0,
        -_f1.x,
        _f2.z,
        0,
        -_f2.x,
        -_f0.y,
        _f0.x,
        0,
        -_f1.y,
        _f1.x,
        0,
        -_f2.y,
        _f2.x,
        0
      ];
      if (!satForAxes(axes, _v0$2, _v1$7, _v2$3, _extents)) {
        return false;
      }
      axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];
      if (!satForAxes(axes, _v0$2, _v1$7, _v2$3, _extents)) {
        return false;
      }
      _triangleNormal.crossVectors(_f0, _f1);
      axes = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z];
      return satForAxes(axes, _v0$2, _v1$7, _v2$3, _extents);
    }
    clampPoint(point, target) {
      return target.copy(point).clamp(this.min, this.max);
    }
    distanceToPoint(point) {
      const clampedPoint = _vector$b.copy(point).clamp(this.min, this.max);
      return clampedPoint.sub(point).length();
    }
    getBoundingSphere(target) {
      this.getCenter(target.center);
      target.radius = this.getSize(_vector$b).length() * 0.5;
      return target;
    }
    intersect(box) {
      this.min.max(box.min);
      this.max.min(box.max);
      if (this.isEmpty())
        this.makeEmpty();
      return this;
    }
    union(box) {
      this.min.min(box.min);
      this.max.max(box.max);
      return this;
    }
    applyMatrix4(matrix) {
      if (this.isEmpty())
        return this;
      _points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix);
      _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix);
      _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix);
      _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix);
      _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix);
      _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix);
      _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix);
      _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix);
      this.setFromPoints(_points);
      return this;
    }
    translate(offset) {
      this.min.add(offset);
      this.max.add(offset);
      return this;
    }
    equals(box) {
      return box.min.equals(this.min) && box.max.equals(this.max);
    }
  };
  Box3.prototype.isBox3 = true;
  var _points = [
    /* @__PURE__ */ new Vector3(),
    /* @__PURE__ */ new Vector3(),
    /* @__PURE__ */ new Vector3(),
    /* @__PURE__ */ new Vector3(),
    /* @__PURE__ */ new Vector3(),
    /* @__PURE__ */ new Vector3(),
    /* @__PURE__ */ new Vector3(),
    /* @__PURE__ */ new Vector3()
  ];
  var _vector$b = /* @__PURE__ */ new Vector3();
  var _box$3 = /* @__PURE__ */ new Box3();
  var _v0$2 = /* @__PURE__ */ new Vector3();
  var _v1$7 = /* @__PURE__ */ new Vector3();
  var _v2$3 = /* @__PURE__ */ new Vector3();
  var _f0 = /* @__PURE__ */ new Vector3();
  var _f1 = /* @__PURE__ */ new Vector3();
  var _f2 = /* @__PURE__ */ new Vector3();
  var _center = /* @__PURE__ */ new Vector3();
  var _extents = /* @__PURE__ */ new Vector3();
  var _triangleNormal = /* @__PURE__ */ new Vector3();
  var _testAxis = /* @__PURE__ */ new Vector3();
  function satForAxes(axes, v0, v1, v2, extents) {
    for (let i = 0, j = axes.length - 3; i <= j; i += 3) {
      _testAxis.fromArray(axes, i);
      const r = extents.x * Math.abs(_testAxis.x) + extents.y * Math.abs(_testAxis.y) + extents.z * Math.abs(_testAxis.z);
      const p0 = v0.dot(_testAxis);
      const p1 = v1.dot(_testAxis);
      const p2 = v2.dot(_testAxis);
      if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) {
        return false;
      }
    }
    return true;
  }
  var _box$2 = /* @__PURE__ */ new Box3();
  var _v1$6 = /* @__PURE__ */ new Vector3();
  var _toFarthestPoint = /* @__PURE__ */ new Vector3();
  var _toPoint = /* @__PURE__ */ new Vector3();
  var Sphere = class {
    constructor(center = new Vector3(), radius = -1) {
      this.center = center;
      this.radius = radius;
    }
    set(center, radius) {
      this.center.copy(center);
      this.radius = radius;
      return this;
    }
    setFromPoints(points, optionalCenter) {
      const center = this.center;
      if (optionalCenter !== void 0) {
        center.copy(optionalCenter);
      } else {
        _box$2.setFromPoints(points).getCenter(center);
      }
      let maxRadiusSq = 0;
      for (let i = 0, il = points.length; i < il; i++) {
        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));
      }
      this.radius = Math.sqrt(maxRadiusSq);
      return this;
    }
    copy(sphere) {
      this.center.copy(sphere.center);
      this.radius = sphere.radius;
      return this;
    }
    isEmpty() {
      return this.radius < 0;
    }
    makeEmpty() {
      this.center.set(0, 0, 0);
      this.radius = -1;
      return this;
    }
    containsPoint(point) {
      return point.distanceToSquared(this.center) <= this.radius * this.radius;
    }
    distanceToPoint(point) {
      return point.distanceTo(this.center) - this.radius;
    }
    intersectsSphere(sphere) {
      const radiusSum = this.radius + sphere.radius;
      return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;
    }
    intersectsBox(box) {
      return box.intersectsSphere(this);
    }
    intersectsPlane(plane) {
      return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;
    }
    clampPoint(point, target) {
      const deltaLengthSq = this.center.distanceToSquared(point);
      target.copy(point);
      if (deltaLengthSq > this.radius * this.radius) {
        target.sub(this.center).normalize();
        target.multiplyScalar(this.radius).add(this.center);
      }
      return target;
    }
    getBoundingBox(target) {
      if (this.isEmpty()) {
        target.makeEmpty();
        return target;
      }
      target.set(this.center, this.center);
      target.expandByScalar(this.radius);
      return target;
    }
    applyMatrix4(matrix) {
      this.center.applyMatrix4(matrix);
      this.radius = this.radius * matrix.getMaxScaleOnAxis();
      return this;
    }
    translate(offset) {
      this.center.add(offset);
      return this;
    }
    expandByPoint(point) {
      _toPoint.subVectors(point, this.center);
      const lengthSq = _toPoint.lengthSq();
      if (lengthSq > this.radius * this.radius) {
        const length = Math.sqrt(lengthSq);
        const missingRadiusHalf = (length - this.radius) * 0.5;
        this.center.add(_toPoint.multiplyScalar(missingRadiusHalf / length));
        this.radius += missingRadiusHalf;
      }
      return this;
    }
    union(sphere) {
      if (this.center.equals(sphere.center) === true) {
        _toFarthestPoint.set(0, 0, 1).multiplyScalar(sphere.radius);
      } else {
        _toFarthestPoint.subVectors(sphere.center, this.center).normalize().multiplyScalar(sphere.radius);
      }
      this.expandByPoint(_v1$6.copy(sphere.center).add(_toFarthestPoint));
      this.expandByPoint(_v1$6.copy(sphere.center).sub(_toFarthestPoint));
      return this;
    }
    equals(sphere) {
      return sphere.center.equals(this.center) && sphere.radius === this.radius;
    }
    clone() {
      return new this.constructor().copy(this);
    }
  };
  var _vector$a = /* @__PURE__ */ new Vector3();
  var _segCenter = /* @__PURE__ */ new Vector3();
  var _segDir = /* @__PURE__ */ new Vector3();
  var _diff = /* @__PURE__ */ new Vector3();
  var _edge1 = /* @__PURE__ */ new Vector3();
  var _edge2 = /* @__PURE__ */ new Vector3();
  var _normal$1 = /* @__PURE__ */ new Vector3();
  var Ray = class {
    constructor(origin = new Vector3(), direction = new Vector3(0, 0, -1)) {
      this.origin = origin;
      this.direction = direction;
    }
    set(origin, direction) {
      this.origin.copy(origin);
      this.direction.copy(direction);
      return this;
    }
    copy(ray) {
      this.origin.copy(ray.origin);
      this.direction.copy(ray.direction);
      return this;
    }
    at(t, target) {
      return target.copy(this.direction).multiplyScalar(t).add(this.origin);
    }
    lookAt(v) {
      this.direction.copy(v).sub(this.origin).normalize();
      return this;
    }
    recast(t) {
      this.origin.copy(this.at(t, _vector$a));
      return this;
    }
    closestPointToPoint(point, target) {
      target.subVectors(point, this.origin);
      const directionDistance = target.dot(this.direction);
      if (directionDistance < 0) {
        return target.copy(this.origin);
      }
      return target.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
    }
    distanceToPoint(point) {
      return Math.sqrt(this.distanceSqToPoint(point));
    }
    distanceSqToPoint(point) {
      const directionDistance = _vector$a.subVectors(point, this.origin).dot(this.direction);
      if (directionDistance < 0) {
        return this.origin.distanceToSquared(point);
      }
      _vector$a.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
      return _vector$a.distanceToSquared(point);
    }
    distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {
      _segCenter.copy(v0).add(v1).multiplyScalar(0.5);
      _segDir.copy(v1).sub(v0).normalize();
      _diff.copy(this.origin).sub(_segCenter);
      const segExtent = v0.distanceTo(v1) * 0.5;
      const a01 = -this.direction.dot(_segDir);
      const b0 = _diff.dot(this.direction);
      const b1 = -_diff.dot(_segDir);
      const c = _diff.lengthSq();
      const det = Math.abs(1 - a01 * a01);
      let s0, s1, sqrDist, extDet;
      if (det > 0) {
        s0 = a01 * b1 - b0;
        s1 = a01 * b0 - b1;
        extDet = segExtent * det;
        if (s0 >= 0) {
          if (s1 >= -extDet) {
            if (s1 <= extDet) {
              const invDet = 1 / det;
              s0 *= invDet;
              s1 *= invDet;
              sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;
            } else {
              s1 = segExtent;
              s0 = Math.max(0, -(a01 * s1 + b0));
              sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
            }
          } else {
            s1 = -segExtent;
            s0 = Math.max(0, -(a01 * s1 + b0));
            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
          }
        } else {
          if (s1 <= -extDet) {
            s0 = Math.max(0, -(-a01 * segExtent + b0));
            s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
          } else if (s1 <= extDet) {
            s0 = 0;
            s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
            sqrDist = s1 * (s1 + 2 * b1) + c;
          } else {
            s0 = Math.max(0, -(a01 * segExtent + b0));
            s1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
          }
        }
      } else {
        s1 = a01 > 0 ? -segExtent : segExtent;
        s0 = Math.max(0, -(a01 * s1 + b0));
        sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
      }
      if (optionalPointOnRay) {
        optionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);
      }
      if (optionalPointOnSegment) {
        optionalPointOnSegment.copy(_segDir).multiplyScalar(s1).add(_segCenter);
      }
      return sqrDist;
    }
    intersectSphere(sphere, target) {
      _vector$a.subVectors(sphere.center, this.origin);
      const tca = _vector$a.dot(this.direction);
      const d2 = _vector$a.dot(_vector$a) - tca * tca;
      const radius2 = sphere.radius * sphere.radius;
      if (d2 > radius2)
        return null;
      const thc = Math.sqrt(radius2 - d2);
      const t0 = tca - thc;
      const t1 = tca + thc;
      if (t0 < 0 && t1 < 0)
        return null;
      if (t0 < 0)
        return this.at(t1, target);
      return this.at(t0, target);
    }
    intersectsSphere(sphere) {
      return this.distanceSqToPoint(sphere.center) <= sphere.radius * sphere.radius;
    }
    distanceToPlane(plane) {
      const denominator = plane.normal.dot(this.direction);
      if (denominator === 0) {
        if (plane.distanceToPoint(this.origin) === 0) {
          return 0;
        }
        return null;
      }
      const t = -(this.origin.dot(plane.normal) + plane.constant) / denominator;
      return t >= 0 ? t : null;
    }
    intersectPlane(plane, target) {
      const t = this.distanceToPlane(plane);
      if (t === null) {
        return null;
      }
      return this.at(t, target);
    }
    intersectsPlane(plane) {
      const distToPoint = plane.distanceToPoint(this.origin);
      if (distToPoint === 0) {
        return true;
      }
      const denominator = plane.normal.dot(this.direction);
      if (denominator * distToPoint < 0) {
        return true;
      }
      return false;
    }
    intersectBox(box, target) {
      let tmin, tmax, tymin, tymax, tzmin, tzmax;
      const invdirx = 1 / this.direction.x, invdiry = 1 / this.direction.y, invdirz = 1 / this.direction.z;
      const origin = this.origin;
      if (invdirx >= 0) {
        tmin = (box.min.x - origin.x) * invdirx;
        tmax = (box.max.x - origin.x) * invdirx;
      } else {
        tmin = (box.max.x - origin.x) * invdirx;
        tmax = (box.min.x - origin.x) * invdirx;
      }
      if (invdiry >= 0) {
        tymin = (box.min.y - origin.y) * invdiry;
        tymax = (box.max.y - origin.y) * invdiry;
      } else {
        tymin = (box.max.y - origin.y) * invdiry;
        tymax = (box.min.y - origin.y) * invdiry;
      }
      if (tmin > tymax || tymin > tmax)
        return null;
      if (tymin > tmin || tmin !== tmin)
        tmin = tymin;
      if (tymax < tmax || tmax !== tmax)
        tmax = tymax;
      if (invdirz >= 0) {
        tzmin = (box.min.z - origin.z) * invdirz;
        tzmax = (box.max.z - origin.z) * invdirz;
      } else {
        tzmin = (box.max.z - origin.z) * invdirz;
        tzmax = (box.min.z - origin.z) * invdirz;
      }
      if (tmin > tzmax || tzmin > tmax)
        return null;
      if (tzmin > tmin || tmin !== tmin)
        tmin = tzmin;
      if (tzmax < tmax || tmax !== tmax)
        tmax = tzmax;
      if (tmax < 0)
        return null;
      return this.at(tmin >= 0 ? tmin : tmax, target);
    }
    intersectsBox(box) {
      return this.intersectBox(box, _vector$a) !== null;
    }
    intersectTriangle(a, b, c, backfaceCulling, target) {
      _edge1.subVectors(b, a);
      _edge2.subVectors(c, a);
      _normal$1.crossVectors(_edge1, _edge2);
      let DdN = this.direction.dot(_normal$1);
      let sign2;
      if (DdN > 0) {
        if (backfaceCulling)
          return null;
        sign2 = 1;
      } else if (DdN < 0) {
        sign2 = -1;
        DdN = -DdN;
      } else {
        return null;
      }
      _diff.subVectors(this.origin, a);
      const DdQxE2 = sign2 * this.direction.dot(_edge2.crossVectors(_diff, _edge2));
      if (DdQxE2 < 0) {
        return null;
      }
      const DdE1xQ = sign2 * this.direction.dot(_edge1.cross(_diff));
      if (DdE1xQ < 0) {
        return null;
      }
      if (DdQxE2 + DdE1xQ > DdN) {
        return null;
      }
      const QdN = -sign2 * _diff.dot(_normal$1);
      if (QdN < 0) {
        return null;
      }
      return this.at(QdN / DdN, target);
    }
    applyMatrix4(matrix4) {
      this.origin.applyMatrix4(matrix4);
      this.direction.transformDirection(matrix4);
      return this;
    }
    equals(ray) {
      return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);
    }
    clone() {
      return new this.constructor().copy(this);
    }
  };
  var Matrix4 = class _Matrix4 {
    constructor() {
      this.elements = [
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1
      ];
      if (arguments.length > 0) {
        console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.");
      }
    }
    set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
      const te = this.elements;
      te[0] = n11;
      te[4] = n12;
      te[8] = n13;
      te[12] = n14;
      te[1] = n21;
      te[5] = n22;
      te[9] = n23;
      te[13] = n24;
      te[2] = n31;
      te[6] = n32;
      te[10] = n33;
      te[14] = n34;
      te[3] = n41;
      te[7] = n42;
      te[11] = n43;
      te[15] = n44;
      return this;
    }
    identity() {
      this.set(
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1
      );
      return this;
    }
    clone() {
      return new _Matrix4().fromArray(this.elements);
    }
    copy(m) {
      const te = this.elements;
      const me = m.elements;
      te[0] = me[0];
      te[1] = me[1];
      te[2] = me[2];
      te[3] = me[3];
      te[4] = me[4];
      te[5] = me[5];
      te[6] = me[6];
      te[7] = me[7];
      te[8] = me[8];
      te[9] = me[9];
      te[10] = me[10];
      te[11] = me[11];
      te[12] = me[12];
      te[13] = me[13];
      te[14] = me[14];
      te[15] = me[15];
      return this;
    }
    copyPosition(m) {
      const te = this.elements, me = m.elements;
      te[12] = me[12];
      te[13] = me[13];
      te[14] = me[14];
      return this;
    }
    setFromMatrix3(m) {
      const me = m.elements;
      this.set(
        me[0],
        me[3],
        me[6],
        0,
        me[1],
        me[4],
        me[7],
        0,
        me[2],
        me[5],
        me[8],
        0,
        0,
        0,
        0,
        1
      );
      return this;
    }
    extractBasis(xAxis, yAxis, zAxis) {
      xAxis.setFromMatrixColumn(this, 0);
      yAxis.setFromMatrixColumn(this, 1);
      zAxis.setFromMatrixColumn(this, 2);
      return this;
    }
    makeBasis(xAxis, yAxis, zAxis) {
      this.set(
        xAxis.x,
        yAxis.x,
        zAxis.x,
        0,
        xAxis.y,
        yAxis.y,
        zAxis.y,
        0,
        xAxis.z,
        yAxis.z,
        zAxis.z,
        0,
        0,
        0,
        0,
        1
      );
      return this;
    }
    extractRotation(m) {
      const te = this.elements;
      const me = m.elements;
      const scaleX = 1 / _v1$5.setFromMatrixColumn(m, 0).length();
      const scaleY = 1 / _v1$5.setFromMatrixColumn(m, 1).length();
      const scaleZ = 1 / _v1$5.setFromMatrixColumn(m, 2).length();
      te[0] = me[0] * scaleX;
      te[1] = me[1] * scaleX;
      te[2] = me[2] * scaleX;
      te[3] = 0;
      te[4] = me[4] * scaleY;
      te[5] = me[5] * scaleY;
      te[6] = me[6] * scaleY;
      te[7] = 0;
      te[8] = me[8] * scaleZ;
      te[9] = me[9] * scaleZ;
      te[10] = me[10] * scaleZ;
      te[11] = 0;
      te[12] = 0;
      te[13] = 0;
      te[14] = 0;
      te[15] = 1;
      return this;
    }
    makeRotationFromEuler(euler) {
      if (!(euler && euler.isEuler)) {
        console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
      }
      const te = this.elements;
      const x = euler.x, y = euler.y, z = euler.z;
      const a = Math.cos(x), b = Math.sin(x);
      const c = Math.cos(y), d = Math.sin(y);
      const e = Math.cos(z), f = Math.sin(z);
      if (euler.order === "XYZ") {
        const ae = a * e, af = a * f, be = b * e, bf = b * f;
        te[0] = c * e;
        te[4] = -c * f;
        te[8] = d;
        te[1] = af + be * d;
        te[5] = ae - bf * d;
        te[9] = -b * c;
        te[2] = bf - ae * d;
        te[6] = be + af * d;
        te[10] = a * c;
      } else if (euler.order === "YXZ") {
        const ce = c * e, cf = c * f, de = d * e, df = d * f;
        te[0] = ce + df * b;
        te[4] = de * b - cf;
        te[8] = a * d;
        te[1] = a * f;
        te[5] = a * e;
        te[9] = -b;
        te[2] = cf * b - de;
        te[6] = df + ce * b;
        te[10] = a * c;
      } else if (euler.order === "ZXY") {
        const ce = c * e, cf = c * f, de = d * e, df = d * f;
        te[0] = ce - df * b;
        te[4] = -a * f;
        te[8] = de + cf * b;
        te[1] = cf + de * b;
        te[5] = a * e;
        te[9] = df - ce * b;
        te[2] = -a * d;
        te[6] = b;
        te[10] = a * c;
      } else if (euler.order === "ZYX") {
        const ae = a * e, af = a * f, be = b * e, bf = b * f;
        te[0] = c * e;
        te[4] = be * d - af;
        te[8] = ae * d + bf;
        te[1] = c * f;
        te[5] = bf * d + ae;
        te[9] = af * d - be;
        te[2] = -d;
        te[6] = b * c;
        te[10] = a * c;
      } else if (euler.order === "YZX") {
        const ac = a * c, ad = a * d, bc = b * c, bd = b * d;
        te[0] = c * e;
        te[4] = bd - ac * f;
        te[8] = bc * f + ad;
        te[1] = f;
        te[5] = a * e;
        te[9] = -b * e;
        te[2] = -d * e;
        te[6] = ad * f + bc;
        te[10] = ac - bd * f;
      } else if (euler.order === "XZY") {
        const ac = a * c, ad = a * d, bc = b * c, bd = b * d;
        te[0] = c * e;
        te[4] = -f;
        te[8] = d * e;
        te[1] = ac * f + bd;
        te[5] = a * e;
        te[9] = ad * f - bc;
        te[2] = bc * f - ad;
        te[6] = b * e;
        te[10] = bd * f + ac;
      }
      te[3] = 0;
      te[7] = 0;
      te[11] = 0;
      te[12] = 0;
      te[13] = 0;
      te[14] = 0;
      te[15] = 1;
      return this;
    }
    makeRotationFromQuaternion(q) {
      return this.compose(_zero, q, _one);
    }
    lookAt(eye, target, up) {
      const te = this.elements;
      _z.subVectors(eye, target);
      if (_z.lengthSq() === 0) {
        _z.z = 1;
      }
      _z.normalize();
      _x.crossVectors(up, _z);
      if (_x.lengthSq() === 0) {
        if (Math.abs(up.z) === 1) {
          _z.x += 1e-4;
        } else {
          _z.z += 1e-4;
        }
        _z.normalize();
        _x.crossVectors(up, _z);
      }
      _x.normalize();
      _y.crossVectors(_z, _x);
      te[0] = _x.x;
      te[4] = _y.x;
      te[8] = _z.x;
      te[1] = _x.y;
      te[5] = _y.y;
      te[9] = _z.y;
      te[2] = _x.z;
      te[6] = _y.z;
      te[10] = _z.z;
      return this;
    }
    multiply(m, n) {
      if (n !== void 0) {
        console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.");
        return this.multiplyMatrices(m, n);
      }
      return this.multiplyMatrices(this, m);
    }
    premultiply(m) {
      return this.multiplyMatrices(m, this);
    }
    multiplyMatrices(a, b) {
      const ae = a.elements;
      const be = b.elements;
      const te = this.elements;
      const a11 = ae[0], a12 = ae[4], a13 = ae[8], a14 = ae[12];
      const a21 = ae[1], a22 = ae[5], a23 = ae[9], a24 = ae[13];
      const a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14];
      const a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15];
      const b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12];
      const b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13];
      const b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14];
      const b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];
      te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
      te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
      te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
      te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
      te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
      te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
      te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
      te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
      te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
      te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
      te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
      te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
      te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
      te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
      te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
      te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
      return this;
    }
    multiplyScalar(s) {
      const te = this.elements;
      te[0] *= s;
      te[4] *= s;
      te[8] *= s;
      te[12] *= s;
      te[1] *= s;
      te[5] *= s;
      te[9] *= s;
      te[13] *= s;
      te[2] *= s;
      te[6] *= s;
      te[10] *= s;
      te[14] *= s;
      te[3] *= s;
      te[7] *= s;
      te[11] *= s;
      te[15] *= s;
      return this;
    }
    determinant() {
      const te = this.elements;
      const n11 = te[0], n12 = te[4], n13 = te[8], n14 = te[12];
      const n21 = te[1], n22 = te[5], n23 = te[9], n24 = te[13];
      const n31 = te[2], n32 = te[6], n33 = te[10], n34 = te[14];
      const n41 = te[3], n42 = te[7], n43 = te[11], n44 = te[15];
      return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);
    }
    transpose() {
      const te = this.elements;
      let tmp2;
      tmp2 = te[1];
      te[1] = te[4];
      te[4] = tmp2;
      tmp2 = te[2];
      te[2] = te[8];
      te[8] = tmp2;
      tmp2 = te[6];
      te[6] = te[9];
      te[9] = tmp2;
      tmp2 = te[3];
      te[3] = te[12];
      te[12] = tmp2;
      tmp2 = te[7];
      te[7] = te[13];
      te[13] = tmp2;
      tmp2 = te[11];
      te[11] = te[14];
      te[14] = tmp2;
      return this;
    }
    setPosition(x, y, z) {
      const te = this.elements;
      if (x.isVector3) {
        te[12] = x.x;
        te[13] = x.y;
        te[14] = x.z;
      } else {
        te[12] = x;
        te[13] = y;
        te[14] = z;
      }
      return this;
    }
    invert() {
      const te = this.elements, n11 = te[0], n21 = te[1], n31 = te[2], n41 = te[3], n12 = te[4], n22 = te[5], n32 = te[6], n42 = te[7], n13 = te[8], n23 = te[9], n33 = te[10], n43 = te[11], n14 = te[12], n24 = te[13], n34 = te[14], n44 = te[15], t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44, t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44, t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44, t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
      const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
      if (det === 0)
        return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
      const detInv = 1 / det;
      te[0] = t11 * detInv;
      te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
      te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
      te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
      te[4] = t12 * detInv;
      te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
      te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
      te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
      te[8] = t13 * detInv;
      te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
      te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
      te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
      te[12] = t14 * detInv;
      te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
      te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
      te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
      return this;
    }
    scale(v) {
      const te = this.elements;
      const x = v.x, y = v.y, z = v.z;
      te[0] *= x;
      te[4] *= y;
      te[8] *= z;
      te[1] *= x;
      te[5] *= y;
      te[9] *= z;
      te[2] *= x;
      te[6] *= y;
      te[10] *= z;
      te[3] *= x;
      te[7] *= y;
      te[11] *= z;
      return this;
    }
    getMaxScaleOnAxis() {
      const te = this.elements;
      const scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
      const scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
      const scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
      return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
    }
    makeTranslation(x, y, z) {
      this.set(
        1,
        0,
        0,
        x,
        0,
        1,
        0,
        y,
        0,
        0,
        1,
        z,
        0,
        0,
        0,
        1
      );
      return this;
    }
    makeRotationX(theta) {
      const c = Math.cos(theta), s = Math.sin(theta);
      this.set(
        1,
        0,
        0,
        0,
        0,
        c,
        -s,
        0,
        0,
        s,
        c,
        0,
        0,
        0,
        0,
        1
      );
      return this;
    }
    makeRotationY(theta) {
      const c = Math.cos(theta), s = Math.sin(theta);
      this.set(
        c,
        0,
        s,
        0,
        0,
        1,
        0,
        0,
        -s,
        0,
        c,
        0,
        0,
        0,
        0,
        1
      );
      return this;
    }
    makeRotationZ(theta) {
      const c = Math.cos(theta), s = Math.sin(theta);
      this.set(
        c,
        -s,
        0,
        0,
        s,
        c,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1
      );
      return this;
    }
    makeRotationAxis(axis, angle) {
      const c = Math.cos(angle);
      const s = Math.sin(angle);
      const t = 1 - c;
      const x = axis.x, y = axis.y, z = axis.z;
      const tx = t * x, ty = t * y;
      this.set(
        tx * x + c,
        tx * y - s * z,
        tx * z + s * y,
        0,
        tx * y + s * z,
        ty * y + c,
        ty * z - s * x,
        0,
        tx * z - s * y,
        ty * z + s * x,
        t * z * z + c,
        0,
        0,
        0,
        0,
        1
      );
      return this;
    }
    makeScale(x, y, z) {
      this.set(
        x,
        0,
        0,
        0,
        0,
        y,
        0,
        0,
        0,
        0,
        z,
        0,
        0,
        0,
        0,
        1
      );
      return this;
    }
    makeShear(xy, xz, yx, yz, zx, zy) {
      this.set(
        1,
        yx,
        zx,
        0,
        xy,
        1,
        zy,
        0,
        xz,
        yz,
        1,
        0,
        0,
        0,
        0,
        1
      );
      return this;
    }
    compose(position, quaternion, scale) {
      const te = this.elements;
      const x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;
      const x2 = x + x, y2 = y + y, z2 = z + z;
      const xx = x * x2, xy = x * y2, xz = x * z2;
      const yy = y * y2, yz = y * z2, zz = z * z2;
      const wx = w * x2, wy = w * y2, wz = w * z2;
      const sx = scale.x, sy = scale.y, sz = scale.z;
      te[0] = (1 - (yy + zz)) * sx;
      te[1] = (xy + wz) * sx;
      te[2] = (xz - wy) * sx;
      te[3] = 0;
      te[4] = (xy - wz) * sy;
      te[5] = (1 - (xx + zz)) * sy;
      te[6] = (yz + wx) * sy;
      te[7] = 0;
      te[8] = (xz + wy) * sz;
      te[9] = (yz - wx) * sz;
      te[10] = (1 - (xx + yy)) * sz;
      te[11] = 0;
      te[12] = position.x;
      te[13] = position.y;
      te[14] = position.z;
      te[15] = 1;
      return this;
    }
    decompose(position, quaternion, scale) {
      const te = this.elements;
      let sx = _v1$5.set(te[0], te[1], te[2]).length();
      const sy = _v1$5.set(te[4], te[5], te[6]).length();
      const sz = _v1$5.set(te[8], te[9], te[10]).length();
      const det = this.determinant();
      if (det < 0)
        sx = -sx;
      position.x = te[12];
      position.y = te[13];
      position.z = te[14];
      _m1$2.copy(this);
      const invSX = 1 / sx;
      const invSY = 1 / sy;
      const invSZ = 1 / sz;
      _m1$2.elements[0] *= invSX;
      _m1$2.elements[1] *= invSX;
      _m1$2.elements[2] *= invSX;
      _m1$2.elements[4] *= invSY;
      _m1$2.elements[5] *= invSY;
      _m1$2.elements[6] *= invSY;
      _m1$2.elements[8] *= invSZ;
      _m1$2.elements[9] *= invSZ;
      _m1$2.elements[10] *= invSZ;
      quaternion.setFromRotationMatrix(_m1$2);
      scale.x = sx;
      scale.y = sy;
      scale.z = sz;
      return this;
    }
    makePerspective(left, right, top, bottom, near, far) {
      if (far === void 0) {
        console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
      }
      const te = this.elements;
      const x = 2 * near / (right - left);
      const y = 2 * near / (top - bottom);
      const a = (right + left) / (right - left);
      const b = (top + bottom) / (top - bottom);
      const c = -(far + near) / (far - near);
      const d = -2 * far * near / (far - near);
      te[0] = x;
      te[4] = 0;
      te[8] = a;
      te[12] = 0;
      te[1] = 0;
      te[5] = y;
      te[9] = b;
      te[13] = 0;
      te[2] = 0;
      te[6] = 0;
      te[10] = c;
      te[14] = d;
      te[3] = 0;
      te[7] = 0;
      te[11] = -1;
      te[15] = 0;
      return this;
    }
    makeOrthographic(left, right, top, bottom, near, far) {
      const te = this.elements;
      const w = 1 / (right - left);
      const h = 1 / (top - bottom);
      const p = 1 / (far - near);
      const x = (right + left) * w;
      const y = (top + bottom) * h;
      const z = (far + near) * p;
      te[0] = 2 * w;
      te[4] = 0;
      te[8] = 0;
      te[12] = -x;
      te[1] = 0;
      te[5] = 2 * h;
      te[9] = 0;
      te[13] = -y;
      te[2] = 0;
      te[6] = 0;
      te[10] = -2 * p;
      te[14] = -z;
      te[3] = 0;
      te[7] = 0;
      te[11] = 0;
      te[15] = 1;
      return this;
    }
    equals(matrix) {
      const te = this.elements;
      const me = matrix.elements;
      for (let i = 0; i < 16; i++) {
        if (te[i] !== me[i])
          return false;
      }
      return true;
    }
    fromArray(array, offset = 0) {
      for (let i = 0; i < 16; i++) {
        this.elements[i] = array[i + offset];
      }
      return this;
    }
    toArray(array = [], offset = 0) {
      const te = this.elements;
      array[offset] = te[0];
      array[offset + 1] = te[1];
      array[offset + 2] = te[2];
      array[offset + 3] = te[3];
      array[offset + 4] = te[4];
      array[offset + 5] = te[5];
      array[offset + 6] = te[6];
      array[offset + 7] = te[7];
      array[offset + 8] = te[8];
      array[offset + 9] = te[9];
      array[offset + 10] = te[10];
      array[offset + 11] = te[11];
      array[offset + 12] = te[12];
      array[offset + 13] = te[13];
      array[offset + 14] = te[14];
      array[offset + 15] = te[15];
      return array;
    }
  };
  Matrix4.prototype.isMatrix4 = true;
  var _v1$5 = /* @__PURE__ */ new Vector3();
  var _m1$2 = /* @__PURE__ */ new Matrix4();
  var _zero = /* @__PURE__ */ new Vector3(0, 0, 0);
  var _one = /* @__PURE__ */ new Vector3(1, 1, 1);
  var _x = /* @__PURE__ */ new Vector3();
  var _y = /* @__PURE__ */ new Vector3();
  var _z = /* @__PURE__ */ new Vector3();
  var _matrix$1 = /* @__PURE__ */ new Matrix4();
  var _quaternion$3 = /* @__PURE__ */ new Quaternion();
  var Euler = class _Euler {
    constructor(x = 0, y = 0, z = 0, order = _Euler.DefaultOrder) {
      this._x = x;
      this._y = y;
      this._z = z;
      this._order = order;
    }
    get x() {
      return this._x;
    }
    set x(value) {
      this._x = value;
      this._onChangeCallback();
    }
    get y() {
      return this._y;
    }
    set y(value) {
      this._y = value;
      this._onChangeCallback();
    }
    get z() {
      return this._z;
    }
    set z(value) {
      this._z = value;
      this._onChangeCallback();
    }
    get order() {
      return this._order;
    }
    set order(value) {
      this._order = value;
      this._onChangeCallback();
    }
    set(x, y, z, order = this._order) {
      this._x = x;
      this._y = y;
      this._z = z;
      this._order = order;
      this._onChangeCallback();
      return this;
    }
    clone() {
      return new this.constructor(this._x, this._y, this._z, this._order);
    }
    copy(euler) {
      this._x = euler._x;
      this._y = euler._y;
      this._z = euler._z;
      this._order = euler._order;
      this._onChangeCallback();
      return this;
    }
    setFromRotationMatrix(m, order = this._order, update = true) {
      const te = m.elements;
      const m11 = te[0], m12 = te[4], m13 = te[8];
      const m21 = te[1], m22 = te[5], m23 = te[9];
      const m31 = te[2], m32 = te[6], m33 = te[10];
      switch (order) {
        case "XYZ":
          this._y = Math.asin(clamp(m13, -1, 1));
          if (Math.abs(m13) < 0.9999999) {
            this._x = Math.atan2(-m23, m33);
            this._z = Math.atan2(-m12, m11);
          } else {
            this._x = Math.atan2(m32, m22);
            this._z = 0;
          }
          break;
        case "YXZ":
          this._x = Math.asin(-clamp(m23, -1, 1));
          if (Math.abs(m23) < 0.9999999) {
            this._y = Math.atan2(m13, m33);
            this._z = Math.atan2(m21, m22);
          } else {
            this._y = Math.atan2(-m31, m11);
            this._z = 0;
          }
          break;
        case "ZXY":
          this._x = Math.asin(clamp(m32, -1, 1));
          if (Math.abs(m32) < 0.9999999) {
            this._y = Math.atan2(-m31, m33);
            this._z = Math.atan2(-m12, m22);
          } else {
            this._y = 0;
            this._z = Math.atan2(m21, m11);
          }
          break;
        case "ZYX":
          this._y = Math.asin(-clamp(m31, -1, 1));
          if (Math.abs(m31) < 0.9999999) {
            this._x = Math.atan2(m32, m33);
            this._z = Math.atan2(m21, m11);
          } else {
            this._x = 0;
            this._z = Math.atan2(-m12, m22);
          }
          break;
        case "YZX":
          this._z = Math.asin(clamp(m21, -1, 1));
          if (Math.abs(m21) < 0.9999999) {
            this._x = Math.atan2(-m23, m22);
            this._y = Math.atan2(-m31, m11);
          } else {
            this._x = 0;
            this._y = Math.atan2(m13, m33);
          }
          break;
        case "XZY":
          this._z = Math.asin(-clamp(m12, -1, 1));
          if (Math.abs(m12) < 0.9999999) {
            this._x = Math.atan2(m32, m22);
            this._y = Math.atan2(m13, m11);
          } else {
            this._x = Math.atan2(-m23, m33);
            this._y = 0;
          }
          break;
        default:
          console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + order);
      }
      this._order = order;
      if (update === true)
        this._onChangeCallback();
      return this;
    }
    setFromQuaternion(q, order, update) {
      _matrix$1.makeRotationFromQuaternion(q);
      return this.setFromRotationMatrix(_matrix$1, order, update);
    }
    setFromVector3(v, order = this._order) {
      return this.set(v.x, v.y, v.z, order);
    }
    reorder(newOrder) {
      _quaternion$3.setFromEuler(this);
      return this.setFromQuaternion(_quaternion$3, newOrder);
    }
    equals(euler) {
      return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;
    }
    fromArray(array) {
      this._x = array[0];
      this._y = array[1];
      this._z = array[2];
      if (array[3] !== void 0)
        this._order = array[3];
      this._onChangeCallback();
      return this;
    }
    toArray(array = [], offset = 0) {
      array[offset] = this._x;
      array[offset + 1] = this._y;
      array[offset + 2] = this._z;
      array[offset + 3] = this._order;
      return array;
    }
    _onChange(callback) {
      this._onChangeCallback = callback;
      return this;
    }
    _onChangeCallback() {
    }
  };
  Euler.prototype.isEuler = true;
  Euler.DefaultOrder = "XYZ";
  Euler.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
  var Layers = class {
    constructor() {
      this.mask = 1 | 0;
    }
    set(channel) {
      this.mask = (1 << channel | 0) >>> 0;
    }
    enable(channel) {
      this.mask |= 1 << channel | 0;
    }
    enableAll() {
      this.mask = 4294967295 | 0;
    }
    toggle(channel) {
      this.mask ^= 1 << channel | 0;
    }
    disable(channel) {
      this.mask &= ~(1 << channel | 0);
    }
    disableAll() {
      this.mask = 0;
    }
    test(layers) {
      return (this.mask & layers.mask) !== 0;
    }
    isEnabled(channel) {
      return (this.mask & (1 << channel | 0)) !== 0;
    }
  };
  var _object3DId = 0;
  var _v1$4 = /* @__PURE__ */ new Vector3();
  var _q1 = /* @__PURE__ */ new Quaternion();
  var _m1$1 = /* @__PURE__ */ new Matrix4();
  var _target = /* @__PURE__ */ new Vector3();
  var _position$3 = /* @__PURE__ */ new Vector3();
  var _scale$2 = /* @__PURE__ */ new Vector3();
  var _quaternion$2 = /* @__PURE__ */ new Quaternion();
  var _xAxis = /* @__PURE__ */ new Vector3(1, 0, 0);
  var _yAxis = /* @__PURE__ */ new Vector3(0, 1, 0);
  var _zAxis = /* @__PURE__ */ new Vector3(0, 0, 1);
  var _addedEvent = { type: "added" };
  var _removedEvent = { type: "removed" };
  var Object3D = class _Object3D extends EventDispatcher {
    constructor() {
      super();
      Object.defineProperty(this, "id", { value: _object3DId++ });
      this.uuid = generateUUID();
      this.name = "";
      this.type = "Object3D";
      this.parent = null;
      this.children = [];
      this.up = _Object3D.DefaultUp.clone();
      const position = new Vector3();
      const rotation = new Euler();
      const quaternion = new Quaternion();
      const scale = new Vector3(1, 1, 1);
      function onRotationChange() {
        quaternion.setFromEuler(rotation, false);
      }
      function onQuaternionChange() {
        rotation.setFromQuaternion(quaternion, void 0, false);
      }
      rotation._onChange(onRotationChange);
      quaternion._onChange(onQuaternionChange);
      Object.defineProperties(this, {
        position: {
          configurable: true,
          enumerable: true,
          value: position
        },
        rotation: {
          configurable: true,
          enumerable: true,
          value: rotation
        },
        quaternion: {
          configurable: true,
          enumerable: true,
          value: quaternion
        },
        scale: {
          configurable: true,
          enumerable: true,
          value: scale
        },
        modelViewMatrix: {
          value: new Matrix4()
        },
        normalMatrix: {
          value: new Matrix3()
        }
      });
      this.matrix = new Matrix4();
      this.matrixWorld = new Matrix4();
      this.matrixAutoUpdate = _Object3D.DefaultMatrixAutoUpdate;
      this.matrixWorldNeedsUpdate = false;
      this.layers = new Layers();
      this.visible = true;
      this.castShadow = false;
      this.receiveShadow = false;
      this.frustumCulled = true;
      this.renderOrder = 0;
      this.animations = [];
      this.userData = {};
    }
    onBeforeRender() {
    }
    onAfterRender() {
    }
    applyMatrix4(matrix) {
      if (this.matrixAutoUpdate)
        this.updateMatrix();
      this.matrix.premultiply(matrix);
      this.matrix.decompose(this.position, this.quaternion, this.scale);
    }
    applyQuaternion(q) {
      this.quaternion.premultiply(q);
      return this;
    }
    setRotationFromAxisAngle(axis, angle) {
      this.quaternion.setFromAxisAngle(axis, angle);
    }
    setRotationFromEuler(euler) {
      this.quaternion.setFromEuler(euler, true);
    }
    setRotationFromMatrix(m) {
      this.quaternion.setFromRotationMatrix(m);
    }
    setRotationFromQuaternion(q) {
      this.quaternion.copy(q);
    }
    rotateOnAxis(axis, angle) {
      _q1.setFromAxisAngle(axis, angle);
      this.quaternion.multiply(_q1);
      return this;
    }
    rotateOnWorldAxis(axis, angle) {
      _q1.setFromAxisAngle(axis, angle);
      this.quaternion.premultiply(_q1);
      return this;
    }
    rotateX(angle) {
      return this.rotateOnAxis(_xAxis, angle);
    }
    rotateY(angle) {
      return this.rotateOnAxis(_yAxis, angle);
    }
    rotateZ(angle) {
      return this.rotateOnAxis(_zAxis, angle);
    }
    translateOnAxis(axis, distance) {
      _v1$4.copy(axis).applyQuaternion(this.quaternion);
      this.position.add(_v1$4.multiplyScalar(distance));
      return this;
    }
    translateX(distance) {
      return this.translateOnAxis(_xAxis, distance);
    }
    translateY(distance) {
      return this.translateOnAxis(_yAxis, distance);
    }
    translateZ(distance) {
      return this.translateOnAxis(_zAxis, distance);
    }
    localToWorld(vector) {
      return vector.applyMatrix4(this.matrixWorld);
    }
    worldToLocal(vector) {
      return vector.applyMatrix4(_m1$1.copy(this.matrixWorld).invert());
    }
    lookAt(x, y, z) {
      if (x.isVector3) {
        _target.copy(x);
      } else {
        _target.set(x, y, z);
      }
      const parent = this.parent;
      this.updateWorldMatrix(true, false);
      _position$3.setFromMatrixPosition(this.matrixWorld);
      if (this.isCamera || this.isLight) {
        _m1$1.lookAt(_position$3, _target, this.up);
      } else {
        _m1$1.lookAt(_target, _position$3, this.up);
      }
      this.quaternion.setFromRotationMatrix(_m1$1);
      if (parent) {
        _m1$1.extractRotation(parent.matrixWorld);
        _q1.setFromRotationMatrix(_m1$1);
        this.quaternion.premultiply(_q1.invert());
      }
    }
    add(object) {
      if (arguments.length > 1) {
        for (let i = 0; i < arguments.length; i++) {
          this.add(arguments[i]);
        }
        return this;
      }
      if (object === this) {
        console.error("THREE.Object3D.add: object can't be added as a child of itself.", object);
        return this;
      }
      if (object && object.isObject3D) {
        if (object.parent !== null) {
          object.parent.remove(object);
        }
        object.parent = this;
        this.children.push(object);
        object.dispatchEvent(_addedEvent);
      } else {
        console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", object);
      }
      return this;
    }
    remove(object) {
      if (arguments.length > 1) {
        for (let i = 0; i < arguments.length; i++) {
          this.remove(arguments[i]);
        }
        return this;
      }
      const index = this.children.indexOf(object);
      if (index !== -1) {
        object.parent = null;
        this.children.splice(index, 1);
        object.dispatchEvent(_removedEvent);
      }
      return this;
    }
    removeFromParent() {
      const parent = this.parent;
      if (parent !== null) {
        parent.remove(this);
      }
      return this;
    }
    clear() {
      for (let i = 0; i < this.children.length; i++) {
        const object = this.children[i];
        object.parent = null;
        object.dispatchEvent(_removedEvent);
      }
      this.children.length = 0;
      return this;
    }
    attach(object) {
      this.updateWorldMatrix(true, false);
      _m1$1.copy(this.matrixWorld).invert();
      if (object.parent !== null) {
        object.parent.updateWorldMatrix(true, false);
        _m1$1.multiply(object.parent.matrixWorld);
      }
      object.applyMatrix4(_m1$1);
      this.add(object);
      object.updateWorldMatrix(false, true);
      return this;
    }
    getObjectById(id) {
      return this.getObjectByProperty("id", id);
    }
    getObjectByName(name) {
      return this.getObjectByProperty("name", name);
    }
    getObjectByProperty(name, value) {
      if (this[name] === value)
        return this;
      for (let i = 0, l = this.children.length; i < l; i++) {
        const child = this.children[i];
        const object = child.getObjectByProperty(name, value);
        if (object !== void 0) {
          return object;
        }
      }
      return void 0;
    }
    getWorldPosition(target) {
      this.updateWorldMatrix(true, false);
      return target.setFromMatrixPosition(this.matrixWorld);
    }
    getWorldQuaternion(target) {
      this.updateWorldMatrix(true, false);
      this.matrixWorld.decompose(_position$3, target, _scale$2);
      return target;
    }
    getWorldScale(target) {
      this.updateWorldMatrix(true, false);
      this.matrixWorld.decompose(_position$3, _quaternion$2, target);
      return target;
    }
    getWorldDirection(target) {
      this.updateWorldMatrix(true, false);
      const e = this.matrixWorld.elements;
      return target.set(e[8], e[9], e[10]).normalize();
    }
    raycast() {
    }
    traverse(callback) {
      callback(this);
      const children = this.children;
      for (let i = 0, l = children.length; i < l; i++) {
        children[i].traverse(callback);
      }
    }
    traverseVisible(callback) {
      if (this.visible === false)
        return;
      callback(this);
      const children = this.children;
      for (let i = 0, l = children.length; i < l; i++) {
        children[i].traverseVisible(callback);
      }
    }
    traverseAncestors(callback) {
      const parent = this.parent;
      if (parent !== null) {
        callback(parent);
        parent.traverseAncestors(callback);
      }
    }
    updateMatrix() {
      this.matrix.compose(this.position, this.quaternion, this.scale);
      this.matrixWorldNeedsUpdate = true;
    }
    updateMatrixWorld(force) {
      if (this.matrixAutoUpdate)
        this.updateMatrix();
      if (this.matrixWorldNeedsUpdate || force) {
        if (this.parent === null) {
          this.matrixWorld.copy(this.matrix);
        } else {
          this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
        }
        this.matrixWorldNeedsUpdate = false;
        force = true;
      }
      const children = this.children;
      for (let i = 0, l = children.length; i < l; i++) {
        children[i].updateMatrixWorld(force);
      }
    }
    updateWorldMatrix(updateParents, updateChildren) {
      const parent = this.parent;
      if (updateParents === true && parent !== null) {
        parent.updateWorldMatrix(true, false);
      }
      if (this.matrixAutoUpdate)
        this.updateMatrix();
      if (this.parent === null) {
        this.matrixWorld.copy(this.matrix);
      } else {
        this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
      }
      if (updateChildren === true) {
        const children = this.children;
        for (let i = 0, l = children.length; i < l; i++) {
          children[i].updateWorldMatrix(false, true);
        }
      }
    }
    toJSON(meta) {
      const isRootObject = meta === void 0 || typeof meta === "string";
      const output = {};
      if (isRootObject) {
        meta = {
          geometries: {},
          materials: {},
          textures: {},
          images: {},
          shapes: {},
          skeletons: {},
          animations: {},
          nodes: {}
        };
        output.metadata = {
          version: 4.5,
          type: "Object",
          generator: "Object3D.toJSON"
        };
      }
      const object = {};
      object.uuid = this.uuid;
      object.type = this.type;
      if (this.name !== "")
        object.name = this.name;
      if (this.castShadow === true)
        object.castShadow = true;
      if (this.receiveShadow === true)
        object.receiveShadow = true;
      if (this.visible === false)
        object.visible = false;
      if (this.frustumCulled === false)
        object.frustumCulled = false;
      if (this.renderOrder !== 0)
        object.renderOrder = this.renderOrder;
      if (JSON.stringify(this.userData) !== "{}")
        object.userData = this.userData;
      object.layers = this.layers.mask;
      object.matrix = this.matrix.toArray();
      if (this.matrixAutoUpdate === false)
        object.matrixAutoUpdate = false;
      if (this.isInstancedMesh) {
        object.type = "InstancedMesh";
        object.count = this.count;
        object.instanceMatrix = this.instanceMatrix.toJSON();
        if (this.instanceColor !== null)
          object.instanceColor = this.instanceColor.toJSON();
      }
      function serialize(library, element) {
        if (library[element.uuid] === void 0) {
          library[element.uuid] = element.toJSON(meta);
        }
        return element.uuid;
      }
      if (this.isScene) {
        if (this.background) {
          if (this.background.isColor) {
            object.background = this.background.toJSON();
          } else if (this.background.isTexture) {
            object.background = this.background.toJSON(meta).uuid;
          }
        }
        if (this.environment && this.environment.isTexture) {
          object.environment = this.environment.toJSON(meta).uuid;
        }
      } else if (this.isMesh || this.isLine || this.isPoints) {
        object.geometry = serialize(meta.geometries, this.geometry);
        const parameters = this.geometry.parameters;
        if (parameters !== void 0 && parameters.shapes !== void 0) {
          const shapes = parameters.shapes;
          if (Array.isArray(shapes)) {
            for (let i = 0, l = shapes.length; i < l; i++) {
              const shape = shapes[i];
              serialize(meta.shapes, shape);
            }
          } else {
            serialize(meta.shapes, shapes);
          }
        }
      }
      if (this.isSkinnedMesh) {
        object.bindMode = this.bindMode;
        object.bindMatrix = this.bindMatrix.toArray();
        if (this.skeleton !== void 0) {
          serialize(meta.skeletons, this.skeleton);
          object.skeleton = this.skeleton.uuid;
        }
      }
      if (this.material !== void 0) {
        if (Array.isArray(this.material)) {
          const uuids = [];
          for (let i = 0, l = this.material.length; i < l; i++) {
            uuids.push(serialize(meta.materials, this.material[i]));
          }
          object.material = uuids;
        } else {
          object.material = serialize(meta.materials, this.material);
        }
      }
      if (this.children.length > 0) {
        object.children = [];
        for (let i = 0; i < this.children.length; i++) {
          object.children.push(this.children[i].toJSON(meta).object);
        }
      }
      if (this.animations.length > 0) {
        object.animations = [];
        for (let i = 0; i < this.animations.length; i++) {
          const animation = this.animations[i];
          object.animations.push(serialize(meta.animations, animation));
        }
      }
      if (isRootObject) {
        const geometries = extractFromCache(meta.geometries);
        const materials = extractFromCache(meta.materials);
        const textures = extractFromCache(meta.textures);
        const images = extractFromCache(meta.images);
        const shapes = extractFromCache(meta.shapes);
        const skeletons = extractFromCache(meta.skeletons);
        const animations = extractFromCache(meta.animations);
        const nodes = extractFromCache(meta.nodes);
        if (geometries.length > 0)
          output.geometries = geometries;
        if (materials.length > 0)
          output.materials = materials;
        if (textures.length > 0)
          output.textures = textures;
        if (images.length > 0)
          output.images = images;
        if (shapes.length > 0)
          output.shapes = shapes;
        if (skeletons.length > 0)
          output.skeletons = skeletons;
        if (animations.length > 0)
          output.animations = animations;
        if (nodes.length > 0)
          output.nodes = nodes;
      }
      output.object = object;
      return output;
      function extractFromCache(cache) {
        const values = [];
        for (const key in cache) {
          const data = cache[key];
          delete data.metadata;
          values.push(data);
        }
        return values;
      }
    }
    clone(recursive) {
      return new this.constructor().copy(this, recursive);
    }
    copy(source, recursive = true) {
      this.name = source.name;
      this.up.copy(source.up);
      this.position.copy(source.position);
      this.rotation.order = source.rotation.order;
      this.quaternion.copy(source.quaternion);
      this.scale.copy(source.scale);
      this.matrix.copy(source.matrix);
      this.matrixWorld.copy(source.matrixWorld);
      this.matrixAutoUpdate = source.matrixAutoUpdate;
      this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
      this.layers.mask = source.layers.mask;
      this.visible = source.visible;
      this.castShadow = source.castShadow;
      this.receiveShadow = source.receiveShadow;
      this.frustumCulled = source.frustumCulled;
      this.renderOrder = source.renderOrder;
      this.userData = JSON.parse(JSON.stringify(source.userData));
      if (recursive === true) {
        for (let i = 0; i < source.children.length; i++) {
          const child = source.children[i];
          this.add(child.clone());
        }
      }
      return this;
    }
  };
  Object3D.DefaultUp = new Vector3(0, 1, 0);
  Object3D.DefaultMatrixAutoUpdate = true;
  Object3D.prototype.isObject3D = true;
  var _v0$1 = /* @__PURE__ */ new Vector3();
  var _v1$3 = /* @__PURE__ */ new Vector3();
  var _v2$2 = /* @__PURE__ */ new Vector3();
  var _v3$1 = /* @__PURE__ */ new Vector3();
  var _vab = /* @__PURE__ */ new Vector3();
  var _vac = /* @__PURE__ */ new Vector3();
  var _vbc = /* @__PURE__ */ new Vector3();
  var _vap = /* @__PURE__ */ new Vector3();
  var _vbp = /* @__PURE__ */ new Vector3();
  var _vcp = /* @__PURE__ */ new Vector3();
  var Triangle = class _Triangle {
    constructor(a = new Vector3(), b = new Vector3(), c = new Vector3()) {
      this.a = a;
      this.b = b;
      this.c = c;
    }
    static getNormal(a, b, c, target) {
      target.subVectors(c, b);
      _v0$1.subVectors(a, b);
      target.cross(_v0$1);
      const targetLengthSq = target.lengthSq();
      if (targetLengthSq > 0) {
        return target.multiplyScalar(1 / Math.sqrt(targetLengthSq));
      }
      return target.set(0, 0, 0);
    }
    // static/instance method to calculate barycentric coordinates
    // based on: http://www.blackpawn.com/texts/pointinpoly/default.html
    static getBarycoord(point, a, b, c, target) {
      _v0$1.subVectors(c, a);
      _v1$3.subVectors(b, a);
      _v2$2.subVectors(point, a);
      const dot00 = _v0$1.dot(_v0$1);
      const dot01 = _v0$1.dot(_v1$3);
      const dot02 = _v0$1.dot(_v2$2);
      const dot11 = _v1$3.dot(_v1$3);
      const dot12 = _v1$3.dot(_v2$2);
      const denom = dot00 * dot11 - dot01 * dot01;
      if (denom === 0) {
        return target.set(-2, -1, -1);
      }
      const invDenom = 1 / denom;
      const u = (dot11 * dot02 - dot01 * dot12) * invDenom;
      const v = (dot00 * dot12 - dot01 * dot02) * invDenom;
      return target.set(1 - u - v, v, u);
    }
    static containsPoint(point, a, b, c) {
      this.getBarycoord(point, a, b, c, _v3$1);
      return _v3$1.x >= 0 && _v3$1.y >= 0 && _v3$1.x + _v3$1.y <= 1;
    }
    static getUV(point, p1, p2, p3, uv1, uv2, uv3, target) {
      this.getBarycoord(point, p1, p2, p3, _v3$1);
      target.set(0, 0);
      target.addScaledVector(uv1, _v3$1.x);
      target.addScaledVector(uv2, _v3$1.y);
      target.addScaledVector(uv3, _v3$1.z);
      return target;
    }
    static isFrontFacing(a, b, c, direction) {
      _v0$1.subVectors(c, b);
      _v1$3.subVectors(a, b);
      return _v0$1.cross(_v1$3).dot(direction) < 0 ? true : false;
    }
    set(a, b, c) {
      this.a.copy(a);
      this.b.copy(b);
      this.c.copy(c);
      return this;
    }
    setFromPointsAndIndices(points, i0, i1, i2) {
      this.a.copy(points[i0]);
      this.b.copy(points[i1]);
      this.c.copy(points[i2]);
      return this;
    }
    setFromAttributeAndIndices(attribute, i0, i1, i2) {
      this.a.fromBufferAttribute(attribute, i0);
      this.b.fromBufferAttribute(attribute, i1);
      this.c.fromBufferAttribute(attribute, i2);
      return this;
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(triangle) {
      this.a.copy(triangle.a);
      this.b.copy(triangle.b);
      this.c.copy(triangle.c);
      return this;
    }
    getArea() {
      _v0$1.subVectors(this.c, this.b);
      _v1$3.subVectors(this.a, this.b);
      return _v0$1.cross(_v1$3).length() * 0.5;
    }
    getMidpoint(target) {
      return target.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
    }
    getNormal(target) {
      return _Triangle.getNormal(this.a, this.b, this.c, target);
    }
    getPlane(target) {
      return target.setFromCoplanarPoints(this.a, this.b, this.c);
    }
    getBarycoord(point, target) {
      return _Triangle.getBarycoord(point, this.a, this.b, this.c, target);
    }
    getUV(point, uv1, uv2, uv3, target) {
      return _Triangle.getUV(point, this.a, this.b, this.c, uv1, uv2, uv3, target);
    }
    containsPoint(point) {
      return _Triangle.containsPoint(point, this.a, this.b, this.c);
    }
    isFrontFacing(direction) {
      return _Triangle.isFrontFacing(this.a, this.b, this.c, direction);
    }
    intersectsBox(box) {
      return box.intersectsTriangle(this);
    }
    closestPointToPoint(p, target) {
      const a = this.a, b = this.b, c = this.c;
      let v, w;
      _vab.subVectors(b, a);
      _vac.subVectors(c, a);
      _vap.subVectors(p, a);
      const d1 = _vab.dot(_vap);
      const d2 = _vac.dot(_vap);
      if (d1 <= 0 && d2 <= 0) {
        return target.copy(a);
      }
      _vbp.subVectors(p, b);
      const d3 = _vab.dot(_vbp);
      const d4 = _vac.dot(_vbp);
      if (d3 >= 0 && d4 <= d3) {
        return target.copy(b);
      }
      const vc = d1 * d4 - d3 * d2;
      if (vc <= 0 && d1 >= 0 && d3 <= 0) {
        v = d1 / (d1 - d3);
        return target.copy(a).addScaledVector(_vab, v);
      }
      _vcp.subVectors(p, c);
      const d5 = _vab.dot(_vcp);
      const d6 = _vac.dot(_vcp);
      if (d6 >= 0 && d5 <= d6) {
        return target.copy(c);
      }
      const vb = d5 * d2 - d1 * d6;
      if (vb <= 0 && d2 >= 0 && d6 <= 0) {
        w = d2 / (d2 - d6);
        return target.copy(a).addScaledVector(_vac, w);
      }
      const va = d3 * d6 - d5 * d4;
      if (va <= 0 && d4 - d3 >= 0 && d5 - d6 >= 0) {
        _vbc.subVectors(c, b);
        w = (d4 - d3) / (d4 - d3 + (d5 - d6));
        return target.copy(b).addScaledVector(_vbc, w);
      }
      const denom = 1 / (va + vb + vc);
      v = vb * denom;
      w = vc * denom;
      return target.copy(a).addScaledVector(_vab, v).addScaledVector(_vac, w);
    }
    equals(triangle) {
      return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);
    }
  };
  var materialId = 0;
  var Material = class extends EventDispatcher {
    constructor() {
      super();
      Object.defineProperty(this, "id", { value: materialId++ });
      this.uuid = generateUUID();
      this.name = "";
      this.type = "Material";
      this.fog = true;
      this.blending = NormalBlending;
      this.side = FrontSide;
      this.vertexColors = false;
      this.opacity = 1;
      this.transparent = false;
      this.blendSrc = SrcAlphaFactor;
      this.blendDst = OneMinusSrcAlphaFactor;
      this.blendEquation = AddEquation;
      this.blendSrcAlpha = null;
      this.blendDstAlpha = null;
      this.blendEquationAlpha = null;
      this.depthFunc = LessEqualDepth;
      this.depthTest = true;
      this.depthWrite = true;
      this.stencilWriteMask = 255;
      this.stencilFunc = AlwaysStencilFunc;
      this.stencilRef = 0;
      this.stencilFuncMask = 255;
      this.stencilFail = KeepStencilOp;
      this.stencilZFail = KeepStencilOp;
      this.stencilZPass = KeepStencilOp;
      this.stencilWrite = false;
      this.clippingPlanes = null;
      this.clipIntersection = false;
      this.clipShadows = false;
      this.shadowSide = null;
      this.colorWrite = true;
      this.precision = null;
      this.polygonOffset = false;
      this.polygonOffsetFactor = 0;
      this.polygonOffsetUnits = 0;
      this.dithering = false;
      this.alphaToCoverage = false;
      this.premultipliedAlpha = false;
      this.visible = true;
      this.toneMapped = true;
      this.userData = {};
      this.version = 0;
      this._alphaTest = 0;
    }
    get alphaTest() {
      return this._alphaTest;
    }
    set alphaTest(value) {
      if (this._alphaTest > 0 !== value > 0) {
        this.version++;
      }
      this._alphaTest = value;
    }
    onBuild() {
    }
    onBeforeRender() {
    }
    onBeforeCompile() {
    }
    customProgramCacheKey() {
      return this.onBeforeCompile.toString();
    }
    setValues(values) {
      if (values === void 0)
        return;
      for (const key in values) {
        const newValue = values[key];
        if (newValue === void 0) {
          console.warn("THREE.Material: '" + key + "' parameter is undefined.");
          continue;
        }
        if (key === "shading") {
          console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
          this.flatShading = newValue === FlatShading ? true : false;
          continue;
        }
        const currentValue = this[key];
        if (currentValue === void 0) {
          console.warn("THREE." + this.type + ": '" + key + "' is not a property of this material.");
          continue;
        }
        if (currentValue && currentValue.isColor) {
          currentValue.set(newValue);
        } else if (currentValue && currentValue.isVector3 && (newValue && newValue.isVector3)) {
          currentValue.copy(newValue);
        } else {
          this[key] = newValue;
        }
      }
    }
    toJSON(meta) {
      const isRootObject = meta === void 0 || typeof meta === "string";
      if (isRootObject) {
        meta = {
          textures: {},
          images: {}
        };
      }
      const data = {
        metadata: {
          version: 4.5,
          type: "Material",
          generator: "Material.toJSON"
        }
      };
      data.uuid = this.uuid;
      data.type = this.type;
      if (this.name !== "")
        data.name = this.name;
      if (this.color && this.color.isColor)
        data.color = this.color.getHex();
      if (this.roughness !== void 0)
        data.roughness = this.roughness;
      if (this.metalness !== void 0)
        data.metalness = this.metalness;
      if (this.sheen !== void 0)
        data.sheen = this.sheen;
      if (this.sheenColor && this.sheenColor.isColor)
        data.sheenColor = this.sheenColor.getHex();
      if (this.sheenRoughness !== void 0)
        data.sheenRoughness = this.sheenRoughness;
      if (this.emissive && this.emissive.isColor)
        data.emissive = this.emissive.getHex();
      if (this.emissiveIntensity && this.emissiveIntensity !== 1)
        data.emissiveIntensity = this.emissiveIntensity;
      if (this.specular && this.specular.isColor)
        data.specular = this.specular.getHex();
      if (this.specularIntensity !== void 0)
        data.specularIntensity = this.specularIntensity;
      if (this.specularColor && this.specularColor.isColor)
        data.specularColor = this.specularColor.getHex();
      if (this.shininess !== void 0)
        data.shininess = this.shininess;
      if (this.clearcoat !== void 0)
        data.clearcoat = this.clearcoat;
      if (this.clearcoatRoughness !== void 0)
        data.clearcoatRoughness = this.clearcoatRoughness;
      if (this.clearcoatMap && this.clearcoatMap.isTexture) {
        data.clearcoatMap = this.clearcoatMap.toJSON(meta).uuid;
      }
      if (this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture) {
        data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(meta).uuid;
      }
      if (this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture) {
        data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(meta).uuid;
        data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();
      }
      if (this.map && this.map.isTexture)
        data.map = this.map.toJSON(meta).uuid;
      if (this.matcap && this.matcap.isTexture)
        data.matcap = this.matcap.toJSON(meta).uuid;
      if (this.alphaMap && this.alphaMap.isTexture)
        data.alphaMap = this.alphaMap.toJSON(meta).uuid;
      if (this.lightMap && this.lightMap.isTexture) {
        data.lightMap = this.lightMap.toJSON(meta).uuid;
        data.lightMapIntensity = this.lightMapIntensity;
      }
      if (this.aoMap && this.aoMap.isTexture) {
        data.aoMap = this.aoMap.toJSON(meta).uuid;
        data.aoMapIntensity = this.aoMapIntensity;
      }
      if (this.bumpMap && this.bumpMap.isTexture) {
        data.bumpMap = this.bumpMap.toJSON(meta).uuid;
        data.bumpScale = this.bumpScale;
      }
      if (this.normalMap && this.normalMap.isTexture) {
        data.normalMap = this.normalMap.toJSON(meta).uuid;
        data.normalMapType = this.normalMapType;
        data.normalScale = this.normalScale.toArray();
      }
      if (this.displacementMap && this.displacementMap.isTexture) {
        data.displacementMap = this.displacementMap.toJSON(meta).uuid;
        data.displacementScale = this.displacementScale;
        data.displacementBias = this.displacementBias;
      }
      if (this.roughnessMap && this.roughnessMap.isTexture)
        data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;
      if (this.metalnessMap && this.metalnessMap.isTexture)
        data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;
      if (this.emissiveMap && this.emissiveMap.isTexture)
        data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;
      if (this.specularMap && this.specularMap.isTexture)
        data.specularMap = this.specularMap.toJSON(meta).uuid;
      if (this.specularIntensityMap && this.specularIntensityMap.isTexture)
        data.specularIntensityMap = this.specularIntensityMap.toJSON(meta).uuid;
      if (this.specularColorMap && this.specularColorMap.isTexture)
        data.specularColorMap = this.specularColorMap.toJSON(meta).uuid;
      if (this.envMap && this.envMap.isTexture) {
        data.envMap = this.envMap.toJSON(meta).uuid;
        if (this.combine !== void 0)
          data.combine = this.combine;
      }
      if (this.envMapIntensity !== void 0)
        data.envMapIntensity = this.envMapIntensity;
      if (this.reflectivity !== void 0)
        data.reflectivity = this.reflectivity;
      if (this.refractionRatio !== void 0)
        data.refractionRatio = this.refractionRatio;
      if (this.gradientMap && this.gradientMap.isTexture) {
        data.gradientMap = this.gradientMap.toJSON(meta).uuid;
      }
      if (this.transmission !== void 0)
        data.transmission = this.transmission;
      if (this.transmissionMap && this.transmissionMap.isTexture)
        data.transmissionMap = this.transmissionMap.toJSON(meta).uuid;
      if (this.thickness !== void 0)
        data.thickness = this.thickness;
      if (this.thicknessMap && this.thicknessMap.isTexture)
        data.thicknessMap = this.thicknessMap.toJSON(meta).uuid;
      if (this.attenuationDistance !== void 0)
        data.attenuationDistance = this.attenuationDistance;
      if (this.attenuationColor !== void 0)
        data.attenuationColor = this.attenuationColor.getHex();
      if (this.size !== void 0)
        data.size = this.size;
      if (this.shadowSide !== null)
        data.shadowSide = this.shadowSide;
      if (this.sizeAttenuation !== void 0)
        data.sizeAttenuation = this.sizeAttenuation;
      if (this.blending !== NormalBlending)
        data.blending = this.blending;
      if (this.side !== FrontSide)
        data.side = this.side;
      if (this.vertexColors)
        data.vertexColors = true;
      if (this.opacity < 1)
        data.opacity = this.opacity;
      if (this.transparent === true)
        data.transparent = this.transparent;
      data.depthFunc = this.depthFunc;
      data.depthTest = this.depthTest;
      data.depthWrite = this.depthWrite;
      data.colorWrite = this.colorWrite;
      data.stencilWrite = this.stencilWrite;
      data.stencilWriteMask = this.stencilWriteMask;
      data.stencilFunc = this.stencilFunc;
      data.stencilRef = this.stencilRef;
      data.stencilFuncMask = this.stencilFuncMask;
      data.stencilFail = this.stencilFail;
      data.stencilZFail = this.stencilZFail;
      data.stencilZPass = this.stencilZPass;
      if (this.rotation !== void 0 && this.rotation !== 0)
        data.rotation = this.rotation;
      if (this.polygonOffset === true)
        data.polygonOffset = true;
      if (this.polygonOffsetFactor !== 0)
        data.polygonOffsetFactor = this.polygonOffsetFactor;
      if (this.polygonOffsetUnits !== 0)
        data.polygonOffsetUnits = this.polygonOffsetUnits;
      if (this.linewidth !== void 0 && this.linewidth !== 1)
        data.linewidth = this.linewidth;
      if (this.dashSize !== void 0)
        data.dashSize = this.dashSize;
      if (this.gapSize !== void 0)
        data.gapSize = this.gapSize;
      if (this.scale !== void 0)
        data.scale = this.scale;
      if (this.dithering === true)
        data.dithering = true;
      if (this.alphaTest > 0)
        data.alphaTest = this.alphaTest;
      if (this.alphaToCoverage === true)
        data.alphaToCoverage = this.alphaToCoverage;
      if (this.premultipliedAlpha === true)
        data.premultipliedAlpha = this.premultipliedAlpha;
      if (this.wireframe === true)
        data.wireframe = this.wireframe;
      if (this.wireframeLinewidth > 1)
        data.wireframeLinewidth = this.wireframeLinewidth;
      if (this.wireframeLinecap !== "round")
        data.wireframeLinecap = this.wireframeLinecap;
      if (this.wireframeLinejoin !== "round")
        data.wireframeLinejoin = this.wireframeLinejoin;
      if (this.flatShading === true)
        data.flatShading = this.flatShading;
      if (this.visible === false)
        data.visible = false;
      if (this.toneMapped === false)
        data.toneMapped = false;
      if (JSON.stringify(this.userData) !== "{}")
        data.userData = this.userData;
      function extractFromCache(cache) {
        const values = [];
        for (const key in cache) {
          const data2 = cache[key];
          delete data2.metadata;
          values.push(data2);
        }
        return values;
      }
      if (isRootObject) {
        const textures = extractFromCache(meta.textures);
        const images = extractFromCache(meta.images);
        if (textures.length > 0)
          data.textures = textures;
        if (images.length > 0)
          data.images = images;
      }
      return data;
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(source) {
      this.name = source.name;
      this.fog = source.fog;
      this.blending = source.blending;
      this.side = source.side;
      this.vertexColors = source.vertexColors;
      this.opacity = source.opacity;
      this.transparent = source.transparent;
      this.blendSrc = source.blendSrc;
      this.blendDst = source.blendDst;
      this.blendEquation = source.blendEquation;
      this.blendSrcAlpha = source.blendSrcAlpha;
      this.blendDstAlpha = source.blendDstAlpha;
      this.blendEquationAlpha = source.blendEquationAlpha;
      this.depthFunc = source.depthFunc;
      this.depthTest = source.depthTest;
      this.depthWrite = source.depthWrite;
      this.stencilWriteMask = source.stencilWriteMask;
      this.stencilFunc = source.stencilFunc;
      this.stencilRef = source.stencilRef;
      this.stencilFuncMask = source.stencilFuncMask;
      this.stencilFail = source.stencilFail;
      this.stencilZFail = source.stencilZFail;
      this.stencilZPass = source.stencilZPass;
      this.stencilWrite = source.stencilWrite;
      const srcPlanes = source.clippingPlanes;
      let dstPlanes = null;
      if (srcPlanes !== null) {
        const n = srcPlanes.length;
        dstPlanes = new Array(n);
        for (let i = 0; i !== n; ++i) {
          dstPlanes[i] = srcPlanes[i].clone();
        }
      }
      this.clippingPlanes = dstPlanes;
      this.clipIntersection = source.clipIntersection;
      this.clipShadows = source.clipShadows;
      this.shadowSide = source.shadowSide;
      this.colorWrite = source.colorWrite;
      this.precision = source.precision;
      this.polygonOffset = source.polygonOffset;
      this.polygonOffsetFactor = source.polygonOffsetFactor;
      this.polygonOffsetUnits = source.polygonOffsetUnits;
      this.dithering = source.dithering;
      this.alphaTest = source.alphaTest;
      this.alphaToCoverage = source.alphaToCoverage;
      this.premultipliedAlpha = source.premultipliedAlpha;
      this.visible = source.visible;
      this.toneMapped = source.toneMapped;
      this.userData = JSON.parse(JSON.stringify(source.userData));
      return this;
    }
    dispose() {
      this.dispatchEvent({ type: "dispose" });
    }
    set needsUpdate(value) {
      if (value === true)
        this.version++;
    }
  };
  Material.prototype.isMaterial = true;
  Material.fromType = function() {
    return null;
  };
  var MeshBasicMaterial = class extends Material {
    constructor(parameters) {
      super();
      this.type = "MeshBasicMaterial";
      this.color = new Color(16777215);
      this.map = null;
      this.lightMap = null;
      this.lightMapIntensity = 1;
      this.aoMap = null;
      this.aoMapIntensity = 1;
      this.specularMap = null;
      this.alphaMap = null;
      this.envMap = null;
      this.combine = MultiplyOperation;
      this.reflectivity = 1;
      this.refractionRatio = 0.98;
      this.wireframe = false;
      this.wireframeLinewidth = 1;
      this.wireframeLinecap = "round";
      this.wireframeLinejoin = "round";
      this.setValues(parameters);
    }
    copy(source) {
      super.copy(source);
      this.color.copy(source.color);
      this.map = source.map;
      this.lightMap = source.lightMap;
      this.lightMapIntensity = source.lightMapIntensity;
      this.aoMap = source.aoMap;
      this.aoMapIntensity = source.aoMapIntensity;
      this.specularMap = source.specularMap;
      this.alphaMap = source.alphaMap;
      this.envMap = source.envMap;
      this.combine = source.combine;
      this.reflectivity = source.reflectivity;
      this.refractionRatio = source.refractionRatio;
      this.wireframe = source.wireframe;
      this.wireframeLinewidth = source.wireframeLinewidth;
      this.wireframeLinecap = source.wireframeLinecap;
      this.wireframeLinejoin = source.wireframeLinejoin;
      return this;
    }
  };
  MeshBasicMaterial.prototype.isMeshBasicMaterial = true;
  var _vector$9 = /* @__PURE__ */ new Vector3();
  var _vector2$1 = /* @__PURE__ */ new Vector2();
  var BufferAttribute = class {
    constructor(array, itemSize, normalized) {
      if (Array.isArray(array)) {
        throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
      }
      this.name = "";
      this.array = array;
      this.itemSize = itemSize;
      this.count = array !== void 0 ? array.length / itemSize : 0;
      this.normalized = normalized === true;
      this.usage = StaticDrawUsage;
      this.updateRange = { offset: 0, count: -1 };
      this.version = 0;
    }
    onUploadCallback() {
    }
    set needsUpdate(value) {
      if (value === true)
        this.version++;
    }
    setUsage(value) {
      this.usage = value;
      return this;
    }
    copy(source) {
      this.name = source.name;
      this.array = new source.array.constructor(source.array);
      this.itemSize = source.itemSize;
      this.count = source.count;
      this.normalized = source.normalized;
      this.usage = source.usage;
      return this;
    }
    copyAt(index1, attribute, index2) {
      index1 *= this.itemSize;
      index2 *= attribute.itemSize;
      for (let i = 0, l = this.itemSize; i < l; i++) {
        this.array[index1 + i] = attribute.array[index2 + i];
      }
      return this;
    }
    copyArray(array) {
      this.array.set(array);
      return this;
    }
    copyColorsArray(colors) {
      const array = this.array;
      let offset = 0;
      for (let i = 0, l = colors.length; i < l; i++) {
        let color = colors[i];
        if (color === void 0) {
          console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", i);
          color = new Color();
        }
        array[offset++] = color.r;
        array[offset++] = color.g;
        array[offset++] = color.b;
      }
      return this;
    }
    copyVector2sArray(vectors) {
      const array = this.array;
      let offset = 0;
      for (let i = 0, l = vectors.length; i < l; i++) {
        let vector = vectors[i];
        if (vector === void 0) {
          console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", i);
          vector = new Vector2();
        }
        array[offset++] = vector.x;
        array[offset++] = vector.y;
      }
      return this;
    }
    copyVector3sArray(vectors) {
      const array = this.array;
      let offset = 0;
      for (let i = 0, l = vectors.length; i < l; i++) {
        let vector = vectors[i];
        if (vector === void 0) {
          console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", i);
          vector = new Vector3();
        }
        array[offset++] = vector.x;
        array[offset++] = vector.y;
        array[offset++] = vector.z;
      }
      return this;
    }
    copyVector4sArray(vectors) {
      const array = this.array;
      let offset = 0;
      for (let i = 0, l = vectors.length; i < l; i++) {
        let vector = vectors[i];
        if (vector === void 0) {
          console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", i);
          vector = new Vector4();
        }
        array[offset++] = vector.x;
        array[offset++] = vector.y;
        array[offset++] = vector.z;
        array[offset++] = vector.w;
      }
      return this;
    }
    applyMatrix3(m) {
      if (this.itemSize === 2) {
        for (let i = 0, l = this.count; i < l; i++) {
          _vector2$1.fromBufferAttribute(this, i);
          _vector2$1.applyMatrix3(m);
          this.setXY(i, _vector2$1.x, _vector2$1.y);
        }
      } else if (this.itemSize === 3) {
        for (let i = 0, l = this.count; i < l; i++) {
          _vector$9.fromBufferAttribute(this, i);
          _vector$9.applyMatrix3(m);
          this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
        }
      }
      return this;
    }
    applyMatrix4(m) {
      for (let i = 0, l = this.count; i < l; i++) {
        _vector$9.fromBufferAttribute(this, i);
        _vector$9.applyMatrix4(m);
        this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
      }
      return this;
    }
    applyNormalMatrix(m) {
      for (let i = 0, l = this.count; i < l; i++) {
        _vector$9.fromBufferAttribute(this, i);
        _vector$9.applyNormalMatrix(m);
        this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
      }
      return this;
    }
    transformDirection(m) {
      for (let i = 0, l = this.count; i < l; i++) {
        _vector$9.fromBufferAttribute(this, i);
        _vector$9.transformDirection(m);
        this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
      }
      return this;
    }
    set(value, offset = 0) {
      this.array.set(value, offset);
      return this;
    }
    getX(index) {
      return this.array[index * this.itemSize];
    }
    setX(index, x) {
      this.array[index * this.itemSize] = x;
      return this;
    }
    getY(index) {
      return this.array[index * this.itemSize + 1];
    }
    setY(index, y) {
      this.array[index * this.itemSize + 1] = y;
      return this;
    }
    getZ(index) {
      return this.array[index * this.itemSize + 2];
    }
    setZ(index, z) {
      this.array[index * this.itemSize + 2] = z;
      return this;
    }
    getW(index) {
      return this.array[index * this.itemSize + 3];
    }
    setW(index, w) {
      this.array[index * this.itemSize + 3] = w;
      return this;
    }
    setXY(index, x, y) {
      index *= this.itemSize;
      this.array[index + 0] = x;
      this.array[index + 1] = y;
      return this;
    }
    setXYZ(index, x, y, z) {
      index *= this.itemSize;
      this.array[index + 0] = x;
      this.array[index + 1] = y;
      this.array[index + 2] = z;
      return this;
    }
    setXYZW(index, x, y, z, w) {
      index *= this.itemSize;
      this.array[index + 0] = x;
      this.array[index + 1] = y;
      this.array[index + 2] = z;
      this.array[index + 3] = w;
      return this;
    }
    onUpload(callback) {
      this.onUploadCallback = callback;
      return this;
    }
    clone() {
      return new this.constructor(this.array, this.itemSize).copy(this);
    }
    toJSON() {
      const data = {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: Array.prototype.slice.call(this.array),
        normalized: this.normalized
      };
      if (this.name !== "")
        data.name = this.name;
      if (this.usage !== StaticDrawUsage)
        data.usage = this.usage;
      if (this.updateRange.offset !== 0 || this.updateRange.count !== -1)
        data.updateRange = this.updateRange;
      return data;
    }
  };
  BufferAttribute.prototype.isBufferAttribute = true;
  var Uint16BufferAttribute = class extends BufferAttribute {
    constructor(array, itemSize, normalized) {
      super(new Uint16Array(array), itemSize, normalized);
    }
  };
  var Uint32BufferAttribute = class extends BufferAttribute {
    constructor(array, itemSize, normalized) {
      super(new Uint32Array(array), itemSize, normalized);
    }
  };
  var Float16BufferAttribute = class extends BufferAttribute {
    constructor(array, itemSize, normalized) {
      super(new Uint16Array(array), itemSize, normalized);
    }
  };
  Float16BufferAttribute.prototype.isFloat16BufferAttribute = true;
  var Float32BufferAttribute = class extends BufferAttribute {
    constructor(array, itemSize, normalized) {
      super(new Float32Array(array), itemSize, normalized);
    }
  };
  var _id$1 = 0;
  var _m1 = /* @__PURE__ */ new Matrix4();
  var _obj = /* @__PURE__ */ new Object3D();
  var _offset = /* @__PURE__ */ new Vector3();
  var _box$1 = /* @__PURE__ */ new Box3();
  var _boxMorphTargets = /* @__PURE__ */ new Box3();
  var _vector$8 = /* @__PURE__ */ new Vector3();
  var BufferGeometry = class _BufferGeometry extends EventDispatcher {
    constructor() {
      super();
      Object.defineProperty(this, "id", { value: _id$1++ });
      this.uuid = generateUUID();
      this.name = "";
      this.type = "BufferGeometry";
      this.index = null;
      this.attributes = {};
      this.morphAttributes = {};
      this.morphTargetsRelative = false;
      this.groups = [];
      this.boundingBox = null;
      this.boundingSphere = null;
      this.drawRange = { start: 0, count: Infinity };
      this.userData = {};
    }
    getIndex() {
      return this.index;
    }
    setIndex(index) {
      if (Array.isArray(index)) {
        this.index = new (arrayNeedsUint32(index) ? Uint32BufferAttribute : Uint16BufferAttribute)(index, 1);
      } else {
        this.index = index;
      }
      return this;
    }
    getAttribute(name) {
      return this.attributes[name];
    }
    setAttribute(name, attribute) {
      this.attributes[name] = attribute;
      return this;
    }
    deleteAttribute(name) {
      delete this.attributes[name];
      return this;
    }
    hasAttribute(name) {
      return this.attributes[name] !== void 0;
    }
    addGroup(start2, count, materialIndex = 0) {
      this.groups.push({
        start: start2,
        count,
        materialIndex
      });
    }
    clearGroups() {
      this.groups = [];
    }
    setDrawRange(start2, count) {
      this.drawRange.start = start2;
      this.drawRange.count = count;
    }
    applyMatrix4(matrix) {
      const position = this.attributes.position;
      if (position !== void 0) {
        position.applyMatrix4(matrix);
        position.needsUpdate = true;
      }
      const normal = this.attributes.normal;
      if (normal !== void 0) {
        const normalMatrix = new Matrix3().getNormalMatrix(matrix);
        normal.applyNormalMatrix(normalMatrix);
        normal.needsUpdate = true;
      }
      const tangent = this.attributes.tangent;
      if (tangent !== void 0) {
        tangent.transformDirection(matrix);
        tangent.needsUpdate = true;
      }
      if (this.boundingBox !== null) {
        this.computeBoundingBox();
      }
      if (this.boundingSphere !== null) {
        this.computeBoundingSphere();
      }
      return this;
    }
    applyQuaternion(q) {
      _m1.makeRotationFromQuaternion(q);
      this.applyMatrix4(_m1);
      return this;
    }
    rotateX(angle) {
      _m1.makeRotationX(angle);
      this.applyMatrix4(_m1);
      return this;
    }
    rotateY(angle) {
      _m1.makeRotationY(angle);
      this.applyMatrix4(_m1);
      return this;
    }
    rotateZ(angle) {
      _m1.makeRotationZ(angle);
      this.applyMatrix4(_m1);
      return this;
    }
    translate(x, y, z) {
      _m1.makeTranslation(x, y, z);
      this.applyMatrix4(_m1);
      return this;
    }
    scale(x, y, z) {
      _m1.makeScale(x, y, z);
      this.applyMatrix4(_m1);
      return this;
    }
    lookAt(vector) {
      _obj.lookAt(vector);
      _obj.updateMatrix();
      this.applyMatrix4(_obj.matrix);
      return this;
    }
    center() {
      this.computeBoundingBox();
      this.boundingBox.getCenter(_offset).negate();
      this.translate(_offset.x, _offset.y, _offset.z);
      return this;
    }
    setFromPoints(points) {
      const position = [];
      for (let i = 0, l = points.length; i < l; i++) {
        const point = points[i];
        position.push(point.x, point.y, point.z || 0);
      }
      this.setAttribute("position", new Float32BufferAttribute(position, 3));
      return this;
    }
    computeBoundingBox() {
      if (this.boundingBox === null) {
        this.boundingBox = new Box3();
      }
      const position = this.attributes.position;
      const morphAttributesPosition = this.morphAttributes.position;
      if (position && position.isGLBufferAttribute) {
        console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this);
        this.boundingBox.set(
          new Vector3(-Infinity, -Infinity, -Infinity),
          new Vector3(Infinity, Infinity, Infinity)
        );
        return;
      }
      if (position !== void 0) {
        this.boundingBox.setFromBufferAttribute(position);
        if (morphAttributesPosition) {
          for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
            const morphAttribute = morphAttributesPosition[i];
            _box$1.setFromBufferAttribute(morphAttribute);
            if (this.morphTargetsRelative) {
              _vector$8.addVectors(this.boundingBox.min, _box$1.min);
              this.boundingBox.expandByPoint(_vector$8);
              _vector$8.addVectors(this.boundingBox.max, _box$1.max);
              this.boundingBox.expandByPoint(_vector$8);
            } else {
              this.boundingBox.expandByPoint(_box$1.min);
              this.boundingBox.expandByPoint(_box$1.max);
            }
          }
        }
      } else {
        this.boundingBox.makeEmpty();
      }
      if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {
        console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
      }
    }
    computeBoundingSphere() {
      if (this.boundingSphere === null) {
        this.boundingSphere = new Sphere();
      }
      const position = this.attributes.position;
      const morphAttributesPosition = this.morphAttributes.position;
      if (position && position.isGLBufferAttribute) {
        console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this);
        this.boundingSphere.set(new Vector3(), Infinity);
        return;
      }
      if (position) {
        const center = this.boundingSphere.center;
        _box$1.setFromBufferAttribute(position);
        if (morphAttributesPosition) {
          for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
            const morphAttribute = morphAttributesPosition[i];
            _boxMorphTargets.setFromBufferAttribute(morphAttribute);
            if (this.morphTargetsRelative) {
              _vector$8.addVectors(_box$1.min, _boxMorphTargets.min);
              _box$1.expandByPoint(_vector$8);
              _vector$8.addVectors(_box$1.max, _boxMorphTargets.max);
              _box$1.expandByPoint(_vector$8);
            } else {
              _box$1.expandByPoint(_boxMorphTargets.min);
              _box$1.expandByPoint(_boxMorphTargets.max);
            }
          }
        }
        _box$1.getCenter(center);
        let maxRadiusSq = 0;
        for (let i = 0, il = position.count; i < il; i++) {
          _vector$8.fromBufferAttribute(position, i);
          maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));
        }
        if (morphAttributesPosition) {
          for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
            const morphAttribute = morphAttributesPosition[i];
            const morphTargetsRelative = this.morphTargetsRelative;
            for (let j = 0, jl = morphAttribute.count; j < jl; j++) {
              _vector$8.fromBufferAttribute(morphAttribute, j);
              if (morphTargetsRelative) {
                _offset.fromBufferAttribute(position, j);
                _vector$8.add(_offset);
              }
              maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));
            }
          }
        }
        this.boundingSphere.radius = Math.sqrt(maxRadiusSq);
        if (isNaN(this.boundingSphere.radius)) {
          console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
        }
      }
    }
    computeTangents() {
      const index = this.index;
      const attributes = this.attributes;
      if (index === null || attributes.position === void 0 || attributes.normal === void 0 || attributes.uv === void 0) {
        console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
        return;
      }
      const indices = index.array;
      const positions = attributes.position.array;
      const normals = attributes.normal.array;
      const uvs = attributes.uv.array;
      const nVertices = positions.length / 3;
      if (this.hasAttribute("tangent") === false) {
        this.setAttribute("tangent", new BufferAttribute(new Float32Array(4 * nVertices), 4));
      }
      const tangents = this.getAttribute("tangent").array;
      const tan1 = [], tan2 = [];
      for (let i = 0; i < nVertices; i++) {
        tan1[i] = new Vector3();
        tan2[i] = new Vector3();
      }
      const vA = new Vector3(), vB = new Vector3(), vC = new Vector3(), uvA = new Vector2(), uvB = new Vector2(), uvC = new Vector2(), sdir = new Vector3(), tdir = new Vector3();
      function handleTriangle(a, b, c) {
        vA.fromArray(positions, a * 3);
        vB.fromArray(positions, b * 3);
        vC.fromArray(positions, c * 3);
        uvA.fromArray(uvs, a * 2);
        uvB.fromArray(uvs, b * 2);
        uvC.fromArray(uvs, c * 2);
        vB.sub(vA);
        vC.sub(vA);
        uvB.sub(uvA);
        uvC.sub(uvA);
        const r = 1 / (uvB.x * uvC.y - uvC.x * uvB.y);
        if (!isFinite(r))
          return;
        sdir.copy(vB).multiplyScalar(uvC.y).addScaledVector(vC, -uvB.y).multiplyScalar(r);
        tdir.copy(vC).multiplyScalar(uvB.x).addScaledVector(vB, -uvC.x).multiplyScalar(r);
        tan1[a].add(sdir);
        tan1[b].add(sdir);
        tan1[c].add(sdir);
        tan2[a].add(tdir);
        tan2[b].add(tdir);
        tan2[c].add(tdir);
      }
      let groups = this.groups;
      if (groups.length === 0) {
        groups = [{
          start: 0,
          count: indices.length
        }];
      }
      for (let i = 0, il = groups.length; i < il; ++i) {
        const group = groups[i];
        const start2 = group.start;
        const count = group.count;
        for (let j = start2, jl = start2 + count; j < jl; j += 3) {
          handleTriangle(
            indices[j + 0],
            indices[j + 1],
            indices[j + 2]
          );
        }
      }
      const tmp2 = new Vector3(), tmp22 = new Vector3();
      const n = new Vector3(), n2 = new Vector3();
      function handleVertex(v) {
        n.fromArray(normals, v * 3);
        n2.copy(n);
        const t = tan1[v];
        tmp2.copy(t);
        tmp2.sub(n.multiplyScalar(n.dot(t))).normalize();
        tmp22.crossVectors(n2, t);
        const test = tmp22.dot(tan2[v]);
        const w = test < 0 ? -1 : 1;
        tangents[v * 4] = tmp2.x;
        tangents[v * 4 + 1] = tmp2.y;
        tangents[v * 4 + 2] = tmp2.z;
        tangents[v * 4 + 3] = w;
      }
      for (let i = 0, il = groups.length; i < il; ++i) {
        const group = groups[i];
        const start2 = group.start;
        const count = group.count;
        for (let j = start2, jl = start2 + count; j < jl; j += 3) {
          handleVertex(indices[j + 0]);
          handleVertex(indices[j + 1]);
          handleVertex(indices[j + 2]);
        }
      }
    }
    computeVertexNormals() {
      const index = this.index;
      const positionAttribute = this.getAttribute("position");
      if (positionAttribute !== void 0) {
        let normalAttribute = this.getAttribute("normal");
        if (normalAttribute === void 0) {
          normalAttribute = new BufferAttribute(new Float32Array(positionAttribute.count * 3), 3);
          this.setAttribute("normal", normalAttribute);
        } else {
          for (let i = 0, il = normalAttribute.count; i < il; i++) {
            normalAttribute.setXYZ(i, 0, 0, 0);
          }
        }
        const pA = new Vector3(), pB = new Vector3(), pC = new Vector3();
        const nA = new Vector3(), nB = new Vector3(), nC = new Vector3();
        const cb = new Vector3(), ab = new Vector3();
        if (index) {
          for (let i = 0, il = index.count; i < il; i += 3) {
            const vA = index.getX(i + 0);
            const vB = index.getX(i + 1);
            const vC = index.getX(i + 2);
            pA.fromBufferAttribute(positionAttribute, vA);
            pB.fromBufferAttribute(positionAttribute, vB);
            pC.fromBufferAttribute(positionAttribute, vC);
            cb.subVectors(pC, pB);
            ab.subVectors(pA, pB);
            cb.cross(ab);
            nA.fromBufferAttribute(normalAttribute, vA);
            nB.fromBufferAttribute(normalAttribute, vB);
            nC.fromBufferAttribute(normalAttribute, vC);
            nA.add(cb);
            nB.add(cb);
            nC.add(cb);
            normalAttribute.setXYZ(vA, nA.x, nA.y, nA.z);
            normalAttribute.setXYZ(vB, nB.x, nB.y, nB.z);
            normalAttribute.setXYZ(vC, nC.x, nC.y, nC.z);
          }
        } else {
          for (let i = 0, il = positionAttribute.count; i < il; i += 3) {
            pA.fromBufferAttribute(positionAttribute, i + 0);
            pB.fromBufferAttribute(positionAttribute, i + 1);
            pC.fromBufferAttribute(positionAttribute, i + 2);
            cb.subVectors(pC, pB);
            ab.subVectors(pA, pB);
            cb.cross(ab);
            normalAttribute.setXYZ(i + 0, cb.x, cb.y, cb.z);
            normalAttribute.setXYZ(i + 1, cb.x, cb.y, cb.z);
            normalAttribute.setXYZ(i + 2, cb.x, cb.y, cb.z);
          }
        }
        this.normalizeNormals();
        normalAttribute.needsUpdate = true;
      }
    }
    merge(geometry, offset) {
      if (!(geometry && geometry.isBufferGeometry)) {
        console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", geometry);
        return;
      }
      if (offset === void 0) {
        offset = 0;
        console.warn(
          "THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."
        );
      }
      const attributes = this.attributes;
      for (const key in attributes) {
        if (geometry.attributes[key] === void 0)
          continue;
        const attribute1 = attributes[key];
        const attributeArray1 = attribute1.array;
        const attribute2 = geometry.attributes[key];
        const attributeArray2 = attribute2.array;
        const attributeOffset = attribute2.itemSize * offset;
        const length = Math.min(attributeArray2.length, attributeArray1.length - attributeOffset);
        for (let i = 0, j = attributeOffset; i < length; i++, j++) {
          attributeArray1[j] = attributeArray2[i];
        }
      }
      return this;
    }
    normalizeNormals() {
      const normals = this.attributes.normal;
      for (let i = 0, il = normals.count; i < il; i++) {
        _vector$8.fromBufferAttribute(normals, i);
        _vector$8.normalize();
        normals.setXYZ(i, _vector$8.x, _vector$8.y, _vector$8.z);
      }
    }
    toNonIndexed() {
      function convertBufferAttribute(attribute, indices2) {
        const array = attribute.array;
        const itemSize = attribute.itemSize;
        const normalized = attribute.normalized;
        const array2 = new array.constructor(indices2.length * itemSize);
        let index = 0, index2 = 0;
        for (let i = 0, l = indices2.length; i < l; i++) {
          if (attribute.isInterleavedBufferAttribute) {
            index = indices2[i] * attribute.data.stride + attribute.offset;
          } else {
            index = indices2[i] * itemSize;
          }
          for (let j = 0; j < itemSize; j++) {
            array2[index2++] = array[index++];
          }
        }
        return new BufferAttribute(array2, itemSize, normalized);
      }
      if (this.index === null) {
        console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.");
        return this;
      }
      const geometry2 = new _BufferGeometry();
      const indices = this.index.array;
      const attributes = this.attributes;
      for (const name in attributes) {
        const attribute = attributes[name];
        const newAttribute = convertBufferAttribute(attribute, indices);
        geometry2.setAttribute(name, newAttribute);
      }
      const morphAttributes = this.morphAttributes;
      for (const name in morphAttributes) {
        const morphArray = [];
        const morphAttribute = morphAttributes[name];
        for (let i = 0, il = morphAttribute.length; i < il; i++) {
          const attribute = morphAttribute[i];
          const newAttribute = convertBufferAttribute(attribute, indices);
          morphArray.push(newAttribute);
        }
        geometry2.morphAttributes[name] = morphArray;
      }
      geometry2.morphTargetsRelative = this.morphTargetsRelative;
      const groups = this.groups;
      for (let i = 0, l = groups.length; i < l; i++) {
        const group = groups[i];
        geometry2.addGroup(group.start, group.count, group.materialIndex);
      }
      return geometry2;
    }
    toJSON() {
      const data = {
        metadata: {
          version: 4.5,
          type: "BufferGeometry",
          generator: "BufferGeometry.toJSON"
        }
      };
      data.uuid = this.uuid;
      data.type = this.type;
      if (this.name !== "")
        data.name = this.name;
      if (Object.keys(this.userData).length > 0)
        data.userData = this.userData;
      if (this.parameters !== void 0) {
        const parameters = this.parameters;
        for (const key in parameters) {
          if (parameters[key] !== void 0)
            data[key] = parameters[key];
        }
        return data;
      }
      data.data = { attributes: {} };
      const index = this.index;
      if (index !== null) {
        data.data.index = {
          type: index.array.constructor.name,
          array: Array.prototype.slice.call(index.array)
        };
      }
      const attributes = this.attributes;
      for (const key in attributes) {
        const attribute = attributes[key];
        data.data.attributes[key] = attribute.toJSON(data.data);
      }
      const morphAttributes = {};
      let hasMorphAttributes = false;
      for (const key in this.morphAttributes) {
        const attributeArray = this.morphAttributes[key];
        const array = [];
        for (let i = 0, il = attributeArray.length; i < il; i++) {
          const attribute = attributeArray[i];
          array.push(attribute.toJSON(data.data));
        }
        if (array.length > 0) {
          morphAttributes[key] = array;
          hasMorphAttributes = true;
        }
      }
      if (hasMorphAttributes) {
        data.data.morphAttributes = morphAttributes;
        data.data.morphTargetsRelative = this.morphTargetsRelative;
      }
      const groups = this.groups;
      if (groups.length > 0) {
        data.data.groups = JSON.parse(JSON.stringify(groups));
      }
      const boundingSphere = this.boundingSphere;
      if (boundingSphere !== null) {
        data.data.boundingSphere = {
          center: boundingSphere.center.toArray(),
          radius: boundingSphere.radius
        };
      }
      return data;
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(source) {
      this.index = null;
      this.attributes = {};
      this.morphAttributes = {};
      this.groups = [];
      this.boundingBox = null;
      this.boundingSphere = null;
      const data = {};
      this.name = source.name;
      const index = source.index;
      if (index !== null) {
        this.setIndex(index.clone(data));
      }
      const attributes = source.attributes;
      for (const name in attributes) {
        const attribute = attributes[name];
        this.setAttribute(name, attribute.clone(data));
      }
      const morphAttributes = source.morphAttributes;
      for (const name in morphAttributes) {
        const array = [];
        const morphAttribute = morphAttributes[name];
        for (let i = 0, l = morphAttribute.length; i < l; i++) {
          array.push(morphAttribute[i].clone(data));
        }
        this.morphAttributes[name] = array;
      }
      this.morphTargetsRelative = source.morphTargetsRelative;
      const groups = source.groups;
      for (let i = 0, l = groups.length; i < l; i++) {
        const group = groups[i];
        this.addGroup(group.start, group.count, group.materialIndex);
      }
      const boundingBox = source.boundingBox;
      if (boundingBox !== null) {
        this.boundingBox = boundingBox.clone();
      }
      const boundingSphere = source.boundingSphere;
      if (boundingSphere !== null) {
        this.boundingSphere = boundingSphere.clone();
      }
      this.drawRange.start = source.drawRange.start;
      this.drawRange.count = source.drawRange.count;
      this.userData = source.userData;
      if (source.parameters !== void 0)
        this.parameters = Object.assign({}, source.parameters);
      return this;
    }
    dispose() {
      this.dispatchEvent({ type: "dispose" });
    }
  };
  BufferGeometry.prototype.isBufferGeometry = true;
  var _inverseMatrix$2 = /* @__PURE__ */ new Matrix4();
  var _ray$2 = /* @__PURE__ */ new Ray();
  var _sphere$3 = /* @__PURE__ */ new Sphere();
  var _vA$1 = /* @__PURE__ */ new Vector3();
  var _vB$1 = /* @__PURE__ */ new Vector3();
  var _vC$1 = /* @__PURE__ */ new Vector3();
  var _tempA = /* @__PURE__ */ new Vector3();
  var _tempB = /* @__PURE__ */ new Vector3();
  var _tempC = /* @__PURE__ */ new Vector3();
  var _morphA = /* @__PURE__ */ new Vector3();
  var _morphB = /* @__PURE__ */ new Vector3();
  var _morphC = /* @__PURE__ */ new Vector3();
  var _uvA$1 = /* @__PURE__ */ new Vector2();
  var _uvB$1 = /* @__PURE__ */ new Vector2();
  var _uvC$1 = /* @__PURE__ */ new Vector2();
  var _intersectionPoint = /* @__PURE__ */ new Vector3();
  var _intersectionPointWorld = /* @__PURE__ */ new Vector3();
  var Mesh = class extends Object3D {
    constructor(geometry = new BufferGeometry(), material = new MeshBasicMaterial()) {
      super();
      this.type = "Mesh";
      this.geometry = geometry;
      this.material = material;
      this.updateMorphTargets();
    }
    copy(source) {
      super.copy(source);
      if (source.morphTargetInfluences !== void 0) {
        this.morphTargetInfluences = source.morphTargetInfluences.slice();
      }
      if (source.morphTargetDictionary !== void 0) {
        this.morphTargetDictionary = Object.assign({}, source.morphTargetDictionary);
      }
      this.material = source.material;
      this.geometry = source.geometry;
      return this;
    }
    updateMorphTargets() {
      const geometry = this.geometry;
      if (geometry.isBufferGeometry) {
        const morphAttributes = geometry.morphAttributes;
        const keys = Object.keys(morphAttributes);
        if (keys.length > 0) {
          const morphAttribute = morphAttributes[keys[0]];
          if (morphAttribute !== void 0) {
            this.morphTargetInfluences = [];
            this.morphTargetDictionary = {};
            for (let m = 0, ml = morphAttribute.length; m < ml; m++) {
              const name = morphAttribute[m].name || String(m);
              this.morphTargetInfluences.push(0);
              this.morphTargetDictionary[name] = m;
            }
          }
        }
      } else {
        const morphTargets = geometry.morphTargets;
        if (morphTargets !== void 0 && morphTargets.length > 0) {
          console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
        }
      }
    }
    raycast(raycaster, intersects2) {
      const geometry = this.geometry;
      const material = this.material;
      const matrixWorld = this.matrixWorld;
      if (material === void 0)
        return;
      if (geometry.boundingSphere === null)
        geometry.computeBoundingSphere();
      _sphere$3.copy(geometry.boundingSphere);
      _sphere$3.applyMatrix4(matrixWorld);
      if (raycaster.ray.intersectsSphere(_sphere$3) === false)
        return;
      _inverseMatrix$2.copy(matrixWorld).invert();
      _ray$2.copy(raycaster.ray).applyMatrix4(_inverseMatrix$2);
      if (geometry.boundingBox !== null) {
        if (_ray$2.intersectsBox(geometry.boundingBox) === false)
          return;
      }
      let intersection;
      if (geometry.isBufferGeometry) {
        const index = geometry.index;
        const position = geometry.attributes.position;
        const morphPosition = geometry.morphAttributes.position;
        const morphTargetsRelative = geometry.morphTargetsRelative;
        const uv = geometry.attributes.uv;
        const uv2 = geometry.attributes.uv2;
        const groups = geometry.groups;
        const drawRange = geometry.drawRange;
        if (index !== null) {
          if (Array.isArray(material)) {
            for (let i = 0, il = groups.length; i < il; i++) {
              const group = groups[i];
              const groupMaterial = material[group.materialIndex];
              const start2 = Math.max(group.start, drawRange.start);
              const end = Math.min(index.count, Math.min(group.start + group.count, drawRange.start + drawRange.count));
              for (let j = start2, jl = end; j < jl; j += 3) {
                const a = index.getX(j);
                const b = index.getX(j + 1);
                const c = index.getX(j + 2);
                intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);
                if (intersection) {
                  intersection.faceIndex = Math.floor(j / 3);
                  intersection.face.materialIndex = group.materialIndex;
                  intersects2.push(intersection);
                }
              }
            }
          } else {
            const start2 = Math.max(0, drawRange.start);
            const end = Math.min(index.count, drawRange.start + drawRange.count);
            for (let i = start2, il = end; i < il; i += 3) {
              const a = index.getX(i);
              const b = index.getX(i + 1);
              const c = index.getX(i + 2);
              intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);
              if (intersection) {
                intersection.faceIndex = Math.floor(i / 3);
                intersects2.push(intersection);
              }
            }
          }
        } else if (position !== void 0) {
          if (Array.isArray(material)) {
            for (let i = 0, il = groups.length; i < il; i++) {
              const group = groups[i];
              const groupMaterial = material[group.materialIndex];
              const start2 = Math.max(group.start, drawRange.start);
              const end = Math.min(position.count, Math.min(group.start + group.count, drawRange.start + drawRange.count));
              for (let j = start2, jl = end; j < jl; j += 3) {
                const a = j;
                const b = j + 1;
                const c = j + 2;
                intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);
                if (intersection) {
                  intersection.faceIndex = Math.floor(j / 3);
                  intersection.face.materialIndex = group.materialIndex;
                  intersects2.push(intersection);
                }
              }
            }
          } else {
            const start2 = Math.max(0, drawRange.start);
            const end = Math.min(position.count, drawRange.start + drawRange.count);
            for (let i = start2, il = end; i < il; i += 3) {
              const a = i;
              const b = i + 1;
              const c = i + 2;
              intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);
              if (intersection) {
                intersection.faceIndex = Math.floor(i / 3);
                intersects2.push(intersection);
              }
            }
          }
        }
      } else if (geometry.isGeometry) {
        console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
      }
    }
  };
  Mesh.prototype.isMesh = true;
  function checkIntersection(object, material, raycaster, ray, pA, pB, pC, point) {
    let intersect;
    if (material.side === BackSide) {
      intersect = ray.intersectTriangle(pC, pB, pA, true, point);
    } else {
      intersect = ray.intersectTriangle(pA, pB, pC, material.side !== DoubleSide, point);
    }
    if (intersect === null)
      return null;
    _intersectionPointWorld.copy(point);
    _intersectionPointWorld.applyMatrix4(object.matrixWorld);
    const distance = raycaster.ray.origin.distanceTo(_intersectionPointWorld);
    if (distance < raycaster.near || distance > raycaster.far)
      return null;
    return {
      distance,
      point: _intersectionPointWorld.clone(),
      object
    };
  }
  function checkBufferGeometryIntersection(object, material, raycaster, ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c) {
    _vA$1.fromBufferAttribute(position, a);
    _vB$1.fromBufferAttribute(position, b);
    _vC$1.fromBufferAttribute(position, c);
    const morphInfluences = object.morphTargetInfluences;
    if (morphPosition && morphInfluences) {
      _morphA.set(0, 0, 0);
      _morphB.set(0, 0, 0);
      _morphC.set(0, 0, 0);
      for (let i = 0, il = morphPosition.length; i < il; i++) {
        const influence = morphInfluences[i];
        const morphAttribute = morphPosition[i];
        if (influence === 0)
          continue;
        _tempA.fromBufferAttribute(morphAttribute, a);
        _tempB.fromBufferAttribute(morphAttribute, b);
        _tempC.fromBufferAttribute(morphAttribute, c);
        if (morphTargetsRelative) {
          _morphA.addScaledVector(_tempA, influence);
          _morphB.addScaledVector(_tempB, influence);
          _morphC.addScaledVector(_tempC, influence);
        } else {
          _morphA.addScaledVector(_tempA.sub(_vA$1), influence);
          _morphB.addScaledVector(_tempB.sub(_vB$1), influence);
          _morphC.addScaledVector(_tempC.sub(_vC$1), influence);
        }
      }
      _vA$1.add(_morphA);
      _vB$1.add(_morphB);
      _vC$1.add(_morphC);
    }
    if (object.isSkinnedMesh) {
      object.boneTransform(a, _vA$1);
      object.boneTransform(b, _vB$1);
      object.boneTransform(c, _vC$1);
    }
    const intersection = checkIntersection(object, material, raycaster, ray, _vA$1, _vB$1, _vC$1, _intersectionPoint);
    if (intersection) {
      if (uv) {
        _uvA$1.fromBufferAttribute(uv, a);
        _uvB$1.fromBufferAttribute(uv, b);
        _uvC$1.fromBufferAttribute(uv, c);
        intersection.uv = Triangle.getUV(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2());
      }
      if (uv2) {
        _uvA$1.fromBufferAttribute(uv2, a);
        _uvB$1.fromBufferAttribute(uv2, b);
        _uvC$1.fromBufferAttribute(uv2, c);
        intersection.uv2 = Triangle.getUV(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2());
      }
      const face = {
        a,
        b,
        c,
        normal: new Vector3(),
        materialIndex: 0
      };
      Triangle.getNormal(_vA$1, _vB$1, _vC$1, face.normal);
      intersection.face = face;
    }
    return intersection;
  }
  var BoxGeometry = class _BoxGeometry extends BufferGeometry {
    constructor(width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1) {
      super();
      this.type = "BoxGeometry";
      this.parameters = {
        width,
        height,
        depth,
        widthSegments,
        heightSegments,
        depthSegments
      };
      const scope = this;
      widthSegments = Math.floor(widthSegments);
      heightSegments = Math.floor(heightSegments);
      depthSegments = Math.floor(depthSegments);
      const indices = [];
      const vertices = [];
      const normals = [];
      const uvs = [];
      let numberOfVertices = 0;
      let groupStart = 0;
      buildPlane("z", "y", "x", -1, -1, depth, height, width, depthSegments, heightSegments, 0);
      buildPlane("z", "y", "x", 1, -1, depth, height, -width, depthSegments, heightSegments, 1);
      buildPlane("x", "z", "y", 1, 1, width, depth, height, widthSegments, depthSegments, 2);
      buildPlane("x", "z", "y", 1, -1, width, depth, -height, widthSegments, depthSegments, 3);
      buildPlane("x", "y", "z", 1, -1, width, height, depth, widthSegments, heightSegments, 4);
      buildPlane("x", "y", "z", -1, -1, width, height, -depth, widthSegments, heightSegments, 5);
      this.setIndex(indices);
      this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
      this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
      this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
      function buildPlane(u, v, w, udir, vdir, width2, height2, depth2, gridX, gridY, materialIndex) {
        const segmentWidth = width2 / gridX;
        const segmentHeight = height2 / gridY;
        const widthHalf = width2 / 2;
        const heightHalf = height2 / 2;
        const depthHalf = depth2 / 2;
        const gridX1 = gridX + 1;
        const gridY1 = gridY + 1;
        let vertexCounter = 0;
        let groupCount = 0;
        const vector = new Vector3();
        for (let iy = 0; iy < gridY1; iy++) {
          const y = iy * segmentHeight - heightHalf;
          for (let ix = 0; ix < gridX1; ix++) {
            const x = ix * segmentWidth - widthHalf;
            vector[u] = x * udir;
            vector[v] = y * vdir;
            vector[w] = depthHalf;
            vertices.push(vector.x, vector.y, vector.z);
            vector[u] = 0;
            vector[v] = 0;
            vector[w] = depth2 > 0 ? 1 : -1;
            normals.push(vector.x, vector.y, vector.z);
            uvs.push(ix / gridX);
            uvs.push(1 - iy / gridY);
            vertexCounter += 1;
          }
        }
        for (let iy = 0; iy < gridY; iy++) {
          for (let ix = 0; ix < gridX; ix++) {
            const a = numberOfVertices + ix + gridX1 * iy;
            const b = numberOfVertices + ix + gridX1 * (iy + 1);
            const c = numberOfVertices + (ix + 1) + gridX1 * (iy + 1);
            const d = numberOfVertices + (ix + 1) + gridX1 * iy;
            indices.push(a, b, d);
            indices.push(b, c, d);
            groupCount += 6;
          }
        }
        scope.addGroup(groupStart, groupCount, materialIndex);
        groupStart += groupCount;
        numberOfVertices += vertexCounter;
      }
    }
    static fromJSON(data) {
      return new _BoxGeometry(data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments);
    }
  };
  function cloneUniforms(src) {
    const dst = {};
    for (const u in src) {
      dst[u] = {};
      for (const p in src[u]) {
        const property = src[u][p];
        if (property && (property.isColor || property.isMatrix3 || property.isMatrix4 || property.isVector2 || property.isVector3 || property.isVector4 || property.isTexture || property.isQuaternion)) {
          dst[u][p] = property.clone();
        } else if (Array.isArray(property)) {
          dst[u][p] = property.slice();
        } else {
          dst[u][p] = property;
        }
      }
    }
    return dst;
  }
  function mergeUniforms(uniforms) {
    const merged = {};
    for (let u = 0; u < uniforms.length; u++) {
      const tmp2 = cloneUniforms(uniforms[u]);
      for (const p in tmp2) {
        merged[p] = tmp2[p];
      }
    }
    return merged;
  }
  var UniformsUtils = { clone: cloneUniforms, merge: mergeUniforms };
  var default_vertex = "void main() {\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";
  var default_fragment = "void main() {\n	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";
  var ShaderMaterial = class extends Material {
    constructor(parameters) {
      super();
      this.type = "ShaderMaterial";
      this.defines = {};
      this.uniforms = {};
      this.vertexShader = default_vertex;
      this.fragmentShader = default_fragment;
      this.linewidth = 1;
      this.wireframe = false;
      this.wireframeLinewidth = 1;
      this.fog = false;
      this.lights = false;
      this.clipping = false;
      this.extensions = {
        derivatives: false,
        // set to use derivatives
        fragDepth: false,
        // set to use fragment depth values
        drawBuffers: false,
        // set to use draw buffers
        shaderTextureLOD: false
        // set to use shader texture LOD
      };
      this.defaultAttributeValues = {
        "color": [1, 1, 1],
        "uv": [0, 0],
        "uv2": [0, 0]
      };
      this.index0AttributeName = void 0;
      this.uniformsNeedUpdate = false;
      this.glslVersion = null;
      if (parameters !== void 0) {
        if (parameters.attributes !== void 0) {
          console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.");
        }
        this.setValues(parameters);
      }
    }
    copy(source) {
      super.copy(source);
      this.fragmentShader = source.fragmentShader;
      this.vertexShader = source.vertexShader;
      this.uniforms = cloneUniforms(source.uniforms);
      this.defines = Object.assign({}, source.defines);
      this.wireframe = source.wireframe;
      this.wireframeLinewidth = source.wireframeLinewidth;
      this.lights = source.lights;
      this.clipping = source.clipping;
      this.extensions = Object.assign({}, source.extensions);
      this.glslVersion = source.glslVersion;
      return this;
    }
    toJSON(meta) {
      const data = super.toJSON(meta);
      data.glslVersion = this.glslVersion;
      data.uniforms = {};
      for (const name in this.uniforms) {
        const uniform = this.uniforms[name];
        const value = uniform.value;
        if (value && value.isTexture) {
          data.uniforms[name] = {
            type: "t",
            value: value.toJSON(meta).uuid
          };
        } else if (value && value.isColor) {
          data.uniforms[name] = {
            type: "c",
            value: value.getHex()
          };
        } else if (value && value.isVector2) {
          data.uniforms[name] = {
            type: "v2",
            value: value.toArray()
          };
        } else if (value && value.isVector3) {
          data.uniforms[name] = {
            type: "v3",
            value: value.toArray()
          };
        } else if (value && value.isVector4) {
          data.uniforms[name] = {
            type: "v4",
            value: value.toArray()
          };
        } else if (value && value.isMatrix3) {
          data.uniforms[name] = {
            type: "m3",
            value: value.toArray()
          };
        } else if (value && value.isMatrix4) {
          data.uniforms[name] = {
            type: "m4",
            value: value.toArray()
          };
        } else {
          data.uniforms[name] = {
            value
          };
        }
      }
      if (Object.keys(this.defines).length > 0)
        data.defines = this.defines;
      data.vertexShader = this.vertexShader;
      data.fragmentShader = this.fragmentShader;
      const extensions = {};
      for (const key in this.extensions) {
        if (this.extensions[key] === true)
          extensions[key] = true;
      }
      if (Object.keys(extensions).length > 0)
        data.extensions = extensions;
      return data;
    }
  };
  ShaderMaterial.prototype.isShaderMaterial = true;
  var Camera = class extends Object3D {
    constructor() {
      super();
      this.type = "Camera";
      this.matrixWorldInverse = new Matrix4();
      this.projectionMatrix = new Matrix4();
      this.projectionMatrixInverse = new Matrix4();
    }
    copy(source, recursive) {
      super.copy(source, recursive);
      this.matrixWorldInverse.copy(source.matrixWorldInverse);
      this.projectionMatrix.copy(source.projectionMatrix);
      this.projectionMatrixInverse.copy(source.projectionMatrixInverse);
      return this;
    }
    getWorldDirection(target) {
      this.updateWorldMatrix(true, false);
      const e = this.matrixWorld.elements;
      return target.set(-e[8], -e[9], -e[10]).normalize();
    }
    updateMatrixWorld(force) {
      super.updateMatrixWorld(force);
      this.matrixWorldInverse.copy(this.matrixWorld).invert();
    }
    updateWorldMatrix(updateParents, updateChildren) {
      super.updateWorldMatrix(updateParents, updateChildren);
      this.matrixWorldInverse.copy(this.matrixWorld).invert();
    }
    clone() {
      return new this.constructor().copy(this);
    }
  };
  Camera.prototype.isCamera = true;
  var PerspectiveCamera = class extends Camera {
    constructor(fov2 = 50, aspect2 = 1, near = 0.1, far = 2e3) {
      super();
      this.type = "PerspectiveCamera";
      this.fov = fov2;
      this.zoom = 1;
      this.near = near;
      this.far = far;
      this.focus = 10;
      this.aspect = aspect2;
      this.view = null;
      this.filmGauge = 35;
      this.filmOffset = 0;
      this.updateProjectionMatrix();
    }
    copy(source, recursive) {
      super.copy(source, recursive);
      this.fov = source.fov;
      this.zoom = source.zoom;
      this.near = source.near;
      this.far = source.far;
      this.focus = source.focus;
      this.aspect = source.aspect;
      this.view = source.view === null ? null : Object.assign({}, source.view);
      this.filmGauge = source.filmGauge;
      this.filmOffset = source.filmOffset;
      return this;
    }
    /**
     * Sets the FOV by focal length in respect to the current .filmGauge.
     *
     * The default film gauge is 35, so that the focal length can be specified for
     * a 35mm (full frame) camera.
     *
     * Values for focal length and film gauge must have the same unit.
     */
    setFocalLength(focalLength) {
      const vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;
      this.fov = RAD2DEG * 2 * Math.atan(vExtentSlope);
      this.updateProjectionMatrix();
    }
    /**
     * Calculates the focal length from the current .fov and .filmGauge.
     */
    getFocalLength() {
      const vExtentSlope = Math.tan(DEG2RAD * 0.5 * this.fov);
      return 0.5 * this.getFilmHeight() / vExtentSlope;
    }
    getEffectiveFOV() {
      return RAD2DEG * 2 * Math.atan(
        Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom
      );
    }
    getFilmWidth() {
      return this.filmGauge * Math.min(this.aspect, 1);
    }
    getFilmHeight() {
      return this.filmGauge / Math.max(this.aspect, 1);
    }
    /**
     * Sets an offset in a larger frustum. This is useful for multi-window or
     * multi-monitor/multi-machine setups.
     *
     * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
     * the monitors are in grid like this
     *
     *   +---+---+---+
     *   | A | B | C |
     *   +---+---+---+
     *   | D | E | F |
     *   +---+---+---+
     *
     * then for each monitor you would call it like this
     *
     *   const w = 1920;
     *   const h = 1080;
     *   const fullWidth = w * 3;
     *   const fullHeight = h * 2;
     *
     *   --A--
     *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
     *   --B--
     *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
     *   --C--
     *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
     *   --D--
     *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
     *   --E--
     *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
     *   --F--
     *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
     *
     *   Note there is no reason monitors have to be the same size or in a grid.
     */
    setViewOffset(fullWidth, fullHeight, x, y, width, height) {
      this.aspect = fullWidth / fullHeight;
      if (this.view === null) {
        this.view = {
          enabled: true,
          fullWidth: 1,
          fullHeight: 1,
          offsetX: 0,
          offsetY: 0,
          width: 1,
          height: 1
        };
      }
      this.view.enabled = true;
      this.view.fullWidth = fullWidth;
      this.view.fullHeight = fullHeight;
      this.view.offsetX = x;
      this.view.offsetY = y;
      this.view.width = width;
      this.view.height = height;
      this.updateProjectionMatrix();
    }
    clearViewOffset() {
      if (this.view !== null) {
        this.view.enabled = false;
      }
      this.updateProjectionMatrix();
    }
    updateProjectionMatrix() {
      const near = this.near;
      let top = near * Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom;
      let height = 2 * top;
      let width = this.aspect * height;
      let left = -0.5 * width;
      const view = this.view;
      if (this.view !== null && this.view.enabled) {
        const fullWidth = view.fullWidth, fullHeight = view.fullHeight;
        left += view.offsetX * width / fullWidth;
        top -= view.offsetY * height / fullHeight;
        width *= view.width / fullWidth;
        height *= view.height / fullHeight;
      }
      const skew = this.filmOffset;
      if (skew !== 0)
        left += near * skew / this.getFilmWidth();
      this.projectionMatrix.makePerspective(left, left + width, top, top - height, near, this.far);
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
    }
    toJSON(meta) {
      const data = super.toJSON(meta);
      data.object.fov = this.fov;
      data.object.zoom = this.zoom;
      data.object.near = this.near;
      data.object.far = this.far;
      data.object.focus = this.focus;
      data.object.aspect = this.aspect;
      if (this.view !== null)
        data.object.view = Object.assign({}, this.view);
      data.object.filmGauge = this.filmGauge;
      data.object.filmOffset = this.filmOffset;
      return data;
    }
  };
  PerspectiveCamera.prototype.isPerspectiveCamera = true;
  var fov = 90;
  var aspect = 1;
  var CubeCamera = class extends Object3D {
    constructor(near, far, renderTarget) {
      super();
      this.type = "CubeCamera";
      if (renderTarget.isWebGLCubeRenderTarget !== true) {
        console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");
        return;
      }
      this.renderTarget = renderTarget;
      const cameraPX = new PerspectiveCamera(fov, aspect, near, far);
      cameraPX.layers = this.layers;
      cameraPX.up.set(0, -1, 0);
      cameraPX.lookAt(new Vector3(1, 0, 0));
      this.add(cameraPX);
      const cameraNX = new PerspectiveCamera(fov, aspect, near, far);
      cameraNX.layers = this.layers;
      cameraNX.up.set(0, -1, 0);
      cameraNX.lookAt(new Vector3(-1, 0, 0));
      this.add(cameraNX);
      const cameraPY = new PerspectiveCamera(fov, aspect, near, far);
      cameraPY.layers = this.layers;
      cameraPY.up.set(0, 0, 1);
      cameraPY.lookAt(new Vector3(0, 1, 0));
      this.add(cameraPY);
      const cameraNY = new PerspectiveCamera(fov, aspect, near, far);
      cameraNY.layers = this.layers;
      cameraNY.up.set(0, 0, -1);
      cameraNY.lookAt(new Vector3(0, -1, 0));
      this.add(cameraNY);
      const cameraPZ = new PerspectiveCamera(fov, aspect, near, far);
      cameraPZ.layers = this.layers;
      cameraPZ.up.set(0, -1, 0);
      cameraPZ.lookAt(new Vector3(0, 0, 1));
      this.add(cameraPZ);
      const cameraNZ = new PerspectiveCamera(fov, aspect, near, far);
      cameraNZ.layers = this.layers;
      cameraNZ.up.set(0, -1, 0);
      cameraNZ.lookAt(new Vector3(0, 0, -1));
      this.add(cameraNZ);
    }
    update(renderer, scene) {
      if (this.parent === null)
        this.updateMatrixWorld();
      const renderTarget = this.renderTarget;
      const [cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ] = this.children;
      const currentRenderTarget = renderer.getRenderTarget();
      const currentOutputEncoding = renderer.outputEncoding;
      const currentToneMapping = renderer.toneMapping;
      const currentXrEnabled = renderer.xr.enabled;
      renderer.outputEncoding = LinearEncoding;
      renderer.toneMapping = NoToneMapping;
      renderer.xr.enabled = false;
      const generateMipmaps = renderTarget.texture.generateMipmaps;
      renderTarget.texture.generateMipmaps = false;
      renderer.setRenderTarget(renderTarget, 0);
      renderer.render(scene, cameraPX);
      renderer.setRenderTarget(renderTarget, 1);
      renderer.render(scene, cameraNX);
      renderer.setRenderTarget(renderTarget, 2);
      renderer.render(scene, cameraPY);
      renderer.setRenderTarget(renderTarget, 3);
      renderer.render(scene, cameraNY);
      renderer.setRenderTarget(renderTarget, 4);
      renderer.render(scene, cameraPZ);
      renderTarget.texture.generateMipmaps = generateMipmaps;
      renderer.setRenderTarget(renderTarget, 5);
      renderer.render(scene, cameraNZ);
      renderer.setRenderTarget(currentRenderTarget);
      renderer.outputEncoding = currentOutputEncoding;
      renderer.toneMapping = currentToneMapping;
      renderer.xr.enabled = currentXrEnabled;
      renderTarget.texture.needsPMREMUpdate = true;
    }
  };
  var CubeTexture = class extends Texture {
    constructor(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {
      images = images !== void 0 ? images : [];
      mapping = mapping !== void 0 ? mapping : CubeReflectionMapping;
      super(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
      this.flipY = false;
    }
    get images() {
      return this.image;
    }
    set images(value) {
      this.image = value;
    }
  };
  CubeTexture.prototype.isCubeTexture = true;
  var WebGLCubeRenderTarget = class extends WebGLRenderTarget {
    constructor(size, options = {}) {
      super(size, size, options);
      const image = { width: size, height: size, depth: 1 };
      const images = [image, image, image, image, image, image];
      this.texture = new CubeTexture(images, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);
      this.texture.isRenderTargetTexture = true;
      this.texture.generateMipmaps = options.generateMipmaps !== void 0 ? options.generateMipmaps : false;
      this.texture.minFilter = options.minFilter !== void 0 ? options.minFilter : LinearFilter;
    }
    fromEquirectangularTexture(renderer, texture) {
      this.texture.type = texture.type;
      this.texture.encoding = texture.encoding;
      this.texture.generateMipmaps = texture.generateMipmaps;
      this.texture.minFilter = texture.minFilter;
      this.texture.magFilter = texture.magFilter;
      const shader = {
        uniforms: {
          tEquirect: { value: null }
        },
        vertexShader: (
          /* glsl */
          `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`
        ),
        fragmentShader: (
          /* glsl */
          `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
        )
      };
      const geometry = new BoxGeometry(5, 5, 5);
      const material = new ShaderMaterial({
        name: "CubemapFromEquirect",
        uniforms: cloneUniforms(shader.uniforms),
        vertexShader: shader.vertexShader,
        fragmentShader: shader.fragmentShader,
        side: BackSide,
        blending: NoBlending
      });
      material.uniforms.tEquirect.value = texture;
      const mesh = new Mesh(geometry, material);
      const currentMinFilter = texture.minFilter;
      if (texture.minFilter === LinearMipmapLinearFilter)
        texture.minFilter = LinearFilter;
      const camera = new CubeCamera(1, 10, this);
      camera.update(renderer, mesh);
      texture.minFilter = currentMinFilter;
      mesh.geometry.dispose();
      mesh.material.dispose();
      return this;
    }
    clear(renderer, color, depth, stencil) {
      const currentRenderTarget = renderer.getRenderTarget();
      for (let i = 0; i < 6; i++) {
        renderer.setRenderTarget(this, i);
        renderer.clear(color, depth, stencil);
      }
      renderer.setRenderTarget(currentRenderTarget);
    }
  };
  WebGLCubeRenderTarget.prototype.isWebGLCubeRenderTarget = true;
  var _vector1 = /* @__PURE__ */ new Vector3();
  var _vector2 = /* @__PURE__ */ new Vector3();
  var _normalMatrix = /* @__PURE__ */ new Matrix3();
  var Plane = class {
    constructor(normal = new Vector3(1, 0, 0), constant = 0) {
      this.normal = normal;
      this.constant = constant;
    }
    set(normal, constant) {
      this.normal.copy(normal);
      this.constant = constant;
      return this;
    }
    setComponents(x, y, z, w) {
      this.normal.set(x, y, z);
      this.constant = w;
      return this;
    }
    setFromNormalAndCoplanarPoint(normal, point) {
      this.normal.copy(normal);
      this.constant = -point.dot(this.normal);
      return this;
    }
    setFromCoplanarPoints(a, b, c) {
      const normal = _vector1.subVectors(c, b).cross(_vector2.subVectors(a, b)).normalize();
      this.setFromNormalAndCoplanarPoint(normal, a);
      return this;
    }
    copy(plane) {
      this.normal.copy(plane.normal);
      this.constant = plane.constant;
      return this;
    }
    normalize() {
      const inverseNormalLength = 1 / this.normal.length();
      this.normal.multiplyScalar(inverseNormalLength);
      this.constant *= inverseNormalLength;
      return this;
    }
    negate() {
      this.constant *= -1;
      this.normal.negate();
      return this;
    }
    distanceToPoint(point) {
      return this.normal.dot(point) + this.constant;
    }
    distanceToSphere(sphere) {
      return this.distanceToPoint(sphere.center) - sphere.radius;
    }
    projectPoint(point, target) {
      return target.copy(this.normal).multiplyScalar(-this.distanceToPoint(point)).add(point);
    }
    intersectLine(line, target) {
      const direction = line.delta(_vector1);
      const denominator = this.normal.dot(direction);
      if (denominator === 0) {
        if (this.distanceToPoint(line.start) === 0) {
          return target.copy(line.start);
        }
        return null;
      }
      const t = -(line.start.dot(this.normal) + this.constant) / denominator;
      if (t < 0 || t > 1) {
        return null;
      }
      return target.copy(direction).multiplyScalar(t).add(line.start);
    }
    intersectsLine(line) {
      const startSign = this.distanceToPoint(line.start);
      const endSign = this.distanceToPoint(line.end);
      return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;
    }
    intersectsBox(box) {
      return box.intersectsPlane(this);
    }
    intersectsSphere(sphere) {
      return sphere.intersectsPlane(this);
    }
    coplanarPoint(target) {
      return target.copy(this.normal).multiplyScalar(-this.constant);
    }
    applyMatrix4(matrix, optionalNormalMatrix) {
      const normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix(matrix);
      const referencePoint = this.coplanarPoint(_vector1).applyMatrix4(matrix);
      const normal = this.normal.applyMatrix3(normalMatrix).normalize();
      this.constant = -referencePoint.dot(normal);
      return this;
    }
    translate(offset) {
      this.constant -= offset.dot(this.normal);
      return this;
    }
    equals(plane) {
      return plane.normal.equals(this.normal) && plane.constant === this.constant;
    }
    clone() {
      return new this.constructor().copy(this);
    }
  };
  Plane.prototype.isPlane = true;
  var _sphere$2 = /* @__PURE__ */ new Sphere();
  var _vector$7 = /* @__PURE__ */ new Vector3();
  var Frustum = class {
    constructor(p0 = new Plane(), p1 = new Plane(), p2 = new Plane(), p3 = new Plane(), p4 = new Plane(), p5 = new Plane()) {
      this.planes = [p0, p1, p2, p3, p4, p5];
    }
    set(p0, p1, p2, p3, p4, p5) {
      const planes = this.planes;
      planes[0].copy(p0);
      planes[1].copy(p1);
      planes[2].copy(p2);
      planes[3].copy(p3);
      planes[4].copy(p4);
      planes[5].copy(p5);
      return this;
    }
    copy(frustum) {
      const planes = this.planes;
      for (let i = 0; i < 6; i++) {
        planes[i].copy(frustum.planes[i]);
      }
      return this;
    }
    setFromProjectionMatrix(m) {
      const planes = this.planes;
      const me = m.elements;
      const me0 = me[0], me1 = me[1], me2 = me[2], me3 = me[3];
      const me4 = me[4], me5 = me[5], me6 = me[6], me7 = me[7];
      const me8 = me[8], me9 = me[9], me10 = me[10], me11 = me[11];
      const me12 = me[12], me13 = me[13], me14 = me[14], me15 = me[15];
      planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();
      planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();
      planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
      planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
      planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();
      planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();
      return this;
    }
    intersectsObject(object) {
      const geometry = object.geometry;
      if (geometry.boundingSphere === null)
        geometry.computeBoundingSphere();
      _sphere$2.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);
      return this.intersectsSphere(_sphere$2);
    }
    intersectsSprite(sprite) {
      _sphere$2.center.set(0, 0, 0);
      _sphere$2.radius = 0.7071067811865476;
      _sphere$2.applyMatrix4(sprite.matrixWorld);
      return this.intersectsSphere(_sphere$2);
    }
    intersectsSphere(sphere) {
      const planes = this.planes;
      const center = sphere.center;
      const negRadius = -sphere.radius;
      for (let i = 0; i < 6; i++) {
        const distance = planes[i].distanceToPoint(center);
        if (distance < negRadius) {
          return false;
        }
      }
      return true;
    }
    intersectsBox(box) {
      const planes = this.planes;
      for (let i = 0; i < 6; i++) {
        const plane = planes[i];
        _vector$7.x = plane.normal.x > 0 ? box.max.x : box.min.x;
        _vector$7.y = plane.normal.y > 0 ? box.max.y : box.min.y;
        _vector$7.z = plane.normal.z > 0 ? box.max.z : box.min.z;
        if (plane.distanceToPoint(_vector$7) < 0) {
          return false;
        }
      }
      return true;
    }
    containsPoint(point) {
      const planes = this.planes;
      for (let i = 0; i < 6; i++) {
        if (planes[i].distanceToPoint(point) < 0) {
          return false;
        }
      }
      return true;
    }
    clone() {
      return new this.constructor().copy(this);
    }
  };
  function WebGLAnimation() {
    let context = null;
    let isAnimating = false;
    let animationLoop = null;
    let requestId = null;
    function onAnimationFrame(time, frame) {
      animationLoop(time, frame);
      requestId = context.requestAnimationFrame(onAnimationFrame);
    }
    return {
      start: function() {
        if (isAnimating === true)
          return;
        if (animationLoop === null)
          return;
        requestId = context.requestAnimationFrame(onAnimationFrame);
        isAnimating = true;
      },
      stop: function() {
        context.cancelAnimationFrame(requestId);
        isAnimating = false;
      },
      setAnimationLoop: function(callback) {
        animationLoop = callback;
      },
      setContext: function(value) {
        context = value;
      }
    };
  }
  function WebGLAttributes(gl, capabilities) {
    const isWebGL2 = capabilities.isWebGL2;
    const buffers = /* @__PURE__ */ new WeakMap();
    function createBuffer(attribute, bufferType) {
      const array = attribute.array;
      const usage = attribute.usage;
      const buffer = gl.createBuffer();
      gl.bindBuffer(bufferType, buffer);
      gl.bufferData(bufferType, array, usage);
      attribute.onUploadCallback();
      let type;
      if (array instanceof Float32Array) {
        type = 5126;
      } else if (array instanceof Uint16Array) {
        if (attribute.isFloat16BufferAttribute) {
          if (isWebGL2) {
            type = 5131;
          } else {
            throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");
          }
        } else {
          type = 5123;
        }
      } else if (array instanceof Int16Array) {
        type = 5122;
      } else if (array instanceof Uint32Array) {
        type = 5125;
      } else if (array instanceof Int32Array) {
        type = 5124;
      } else if (array instanceof Int8Array) {
        type = 5120;
      } else if (array instanceof Uint8Array) {
        type = 5121;
      } else if (array instanceof Uint8ClampedArray) {
        type = 5121;
      } else {
        throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + array);
      }
      return {
        buffer,
        type,
        bytesPerElement: array.BYTES_PER_ELEMENT,
        version: attribute.version
      };
    }
    function updateBuffer(buffer, attribute, bufferType) {
      const array = attribute.array;
      const updateRange = attribute.updateRange;
      gl.bindBuffer(bufferType, buffer);
      if (updateRange.count === -1) {
        gl.bufferSubData(bufferType, 0, array);
      } else {
        if (isWebGL2) {
          gl.bufferSubData(
            bufferType,
            updateRange.offset * array.BYTES_PER_ELEMENT,
            array,
            updateRange.offset,
            updateRange.count
          );
        } else {
          gl.bufferSubData(
            bufferType,
            updateRange.offset * array.BYTES_PER_ELEMENT,
            array.subarray(updateRange.offset, updateRange.offset + updateRange.count)
          );
        }
        updateRange.count = -1;
      }
    }
    function get(attribute) {
      if (attribute.isInterleavedBufferAttribute)
        attribute = attribute.data;
      return buffers.get(attribute);
    }
    function remove(attribute) {
      if (attribute.isInterleavedBufferAttribute)
        attribute = attribute.data;
      const data = buffers.get(attribute);
      if (data) {
        gl.deleteBuffer(data.buffer);
        buffers.delete(attribute);
      }
    }
    function update(attribute, bufferType) {
      if (attribute.isGLBufferAttribute) {
        const cached = buffers.get(attribute);
        if (!cached || cached.version < attribute.version) {
          buffers.set(attribute, {
            buffer: attribute.buffer,
            type: attribute.type,
            bytesPerElement: attribute.elementSize,
            version: attribute.version
          });
        }
        return;
      }
      if (attribute.isInterleavedBufferAttribute)
        attribute = attribute.data;
      const data = buffers.get(attribute);
      if (data === void 0) {
        buffers.set(attribute, createBuffer(attribute, bufferType));
      } else if (data.version < attribute.version) {
        updateBuffer(data.buffer, attribute, bufferType);
        data.version = attribute.version;
      }
    }
    return {
      get,
      remove,
      update
    };
  }
  var PlaneGeometry = class _PlaneGeometry extends BufferGeometry {
    constructor(width = 1, height = 1, widthSegments = 1, heightSegments = 1) {
      super();
      this.type = "PlaneGeometry";
      this.parameters = {
        width,
        height,
        widthSegments,
        heightSegments
      };
      const width_half = width / 2;
      const height_half = height / 2;
      const gridX = Math.floor(widthSegments);
      const gridY = Math.floor(heightSegments);
      const gridX1 = gridX + 1;
      const gridY1 = gridY + 1;
      const segment_width = width / gridX;
      const segment_height = height / gridY;
      const indices = [];
      const vertices = [];
      const normals = [];
      const uvs = [];
      for (let iy = 0; iy < gridY1; iy++) {
        const y = iy * segment_height - height_half;
        for (let ix = 0; ix < gridX1; ix++) {
          const x = ix * segment_width - width_half;
          vertices.push(x, -y, 0);
          normals.push(0, 0, 1);
          uvs.push(ix / gridX);
          uvs.push(1 - iy / gridY);
        }
      }
      for (let iy = 0; iy < gridY; iy++) {
        for (let ix = 0; ix < gridX; ix++) {
          const a = ix + gridX1 * iy;
          const b = ix + gridX1 * (iy + 1);
          const c = ix + 1 + gridX1 * (iy + 1);
          const d = ix + 1 + gridX1 * iy;
          indices.push(a, b, d);
          indices.push(b, c, d);
        }
      }
      this.setIndex(indices);
      this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
      this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
      this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    }
    static fromJSON(data) {
      return new _PlaneGeometry(data.width, data.height, data.widthSegments, data.heightSegments);
    }
  };
  var alphamap_fragment = "#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif";
  var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif";
  var alphatest_fragment = "#ifdef USE_ALPHATEST\n	if ( diffuseColor.a < alphaTest ) discard;\n#endif";
  var alphatest_pars_fragment = "#ifdef USE_ALPHATEST\n	uniform float alphaTest;\n#endif";
  var aomap_fragment = "#ifdef USE_AOMAP\n	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n	reflectedLight.indirectDiffuse *= ambientOcclusion;\n	#if defined( USE_ENVMAP ) && defined( STANDARD )\n		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n	#endif\n#endif";
  var aomap_pars_fragment = "#ifdef USE_AOMAP\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n#endif";
  var begin_vertex = "vec3 transformed = vec3( position );";
  var beginnormal_vertex = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n	vec3 objectTangent = vec3( tangent.xyz );\n#endif";
  var bsdfs = "vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n	return RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	return 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n	float a2 = pow2( alpha );\n	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n	return RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n	float alpha = pow2( roughness );\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = F_Schlick( f0, f90, dotVH );\n	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n	float D = D_GGX( alpha, dotNH );\n	return F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n	const float LUT_SIZE = 64.0;\n	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n	const float LUT_BIAS = 0.5 / LUT_SIZE;\n	float dotNV = saturate( dot( N, V ) );\n	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n	uv = uv * LUT_SCALE + LUT_BIAS;\n	return uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n	float l = length( f );\n	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n	float x = dot( v1, v2 );\n	float y = abs( x );\n	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n	float b = 3.4175940 + ( 4.1616724 + y ) * y;\n	float v = a / b;\n	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n	return cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n	vec3 lightNormal = cross( v1, v2 );\n	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n	vec3 T1, T2;\n	T1 = normalize( V - N * dot( V, N ) );\n	T2 = - cross( N, T1 );\n	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n	vec3 coords[ 4 ];\n	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n	coords[ 0 ] = normalize( coords[ 0 ] );\n	coords[ 1 ] = normalize( coords[ 1 ] );\n	coords[ 2 ] = normalize( coords[ 2 ] );\n	coords[ 3 ] = normalize( coords[ 3 ] );\n	vec3 vectorFormFactor = vec3( 0.0 );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n	return vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n	return 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = F_Schlick( specularColor, 1.0, dotVH );\n	float G = G_BlinnPhong_Implicit( );\n	float D = D_BlinnPhong( shininess, dotNH );\n	return F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n	float alpha = pow2( roughness );\n	float invAlpha = 1.0 / alpha;\n	float cos2h = dotNH * dotNH;\n	float sin2h = max( 1.0 - cos2h, 0.0078125 );\n	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float D = D_Charlie( sheenRoughness, dotNH );\n	float V = V_Neubelt( dotNV, dotNL );\n	return sheenColor * ( D * V );\n}\n#endif";
  var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n	vec2 dHdxy_fwd() {\n		vec2 dSTdx = dFdx( vUv );\n		vec2 dSTdy = dFdy( vUv );\n		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n		return vec2( dBx, dBy );\n	}\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n		vec3 vN = surf_norm;\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n		float fDet = dot( vSigmaX, R1 ) * faceDirection;\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n	}\n#endif";
  var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n	vec4 plane;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n		plane = clippingPlanes[ i ];\n		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n	}\n	#pragma unroll_loop_end\n	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n		bool clipped = true;\n		#pragma unroll_loop_start\n		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n			plane = clippingPlanes[ i ];\n			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n		}\n		#pragma unroll_loop_end\n		if ( clipped ) discard;\n	#endif\n#endif";
  var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";
  var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n#endif";
  var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0\n	vClipPosition = - mvPosition.xyz;\n#endif";
  var color_fragment = "#if defined( USE_COLOR_ALPHA )\n	diffuseColor *= vColor;\n#elif defined( USE_COLOR )\n	diffuseColor.rgb *= vColor;\n#endif";
  var color_pars_fragment = "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR )\n	varying vec3 vColor;\n#endif";
  var color_pars_vertex = "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	varying vec3 vColor;\n#endif";
  var color_vertex = "#if defined( USE_COLOR_ALPHA )\n	vColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	vColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n	vColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n	vColor.xyz *= instanceColor.xyz;\n#endif";
  var common = "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n	const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n	return fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n	float precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n	float precisionSafeLength( vec3 v ) {\n		float maxComponent = max3( abs( v ) );\n		return length( v / maxComponent ) * maxComponent;\n	}\n#endif\nstruct IncidentLight {\n	vec3 color;\n	vec3 direction;\n	bool visible;\n};\nstruct ReflectedLight {\n	vec3 directDiffuse;\n	vec3 directSpecular;\n	vec3 indirectDiffuse;\n	vec3 indirectSpecular;\n};\nstruct GeometricContext {\n	vec3 position;\n	vec3 normal;\n	vec3 viewDir;\n#ifdef USE_CLEARCOAT\n	vec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n	mat3 tmp;\n	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n	return tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n	return dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n	return m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n	return vec2( u, v );\n}";
  var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n	#define cubeUV_minMipLevel 4.0\n	#define cubeUV_minTileSize 16.0\n	float getFace( vec3 direction ) {\n		vec3 absDirection = abs( direction );\n		float face = - 1.0;\n		if ( absDirection.x > absDirection.z ) {\n			if ( absDirection.x > absDirection.y )\n				face = direction.x > 0.0 ? 0.0 : 3.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		} else {\n			if ( absDirection.z > absDirection.y )\n				face = direction.z > 0.0 ? 2.0 : 5.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		}\n		return face;\n	}\n	vec2 getUV( vec3 direction, float face ) {\n		vec2 uv;\n		if ( face == 0.0 ) {\n			uv = vec2( direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 1.0 ) {\n			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n		} else if ( face == 2.0 ) {\n			uv = vec2( - direction.x, direction.y ) / abs( direction.z );\n		} else if ( face == 3.0 ) {\n			uv = vec2( - direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 4.0 ) {\n			uv = vec2( - direction.x, direction.z ) / abs( direction.y );\n		} else {\n			uv = vec2( direction.x, direction.y ) / abs( direction.z );\n		}\n		return 0.5 * ( uv + 1.0 );\n	}\n	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n		float face = getFace( direction );\n		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n		mipInt = max( mipInt, cubeUV_minMipLevel );\n		float faceSize = exp2( mipInt );\n		vec2 uv = getUV( direction, face ) * ( faceSize - 1.0 ) + 0.5;\n		if ( face > 2.0 ) {\n			uv.y += faceSize;\n			face -= 3.0;\n		}\n		uv.x += face * faceSize;\n		uv.x += filterInt * 3.0 * cubeUV_minTileSize;\n		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n		uv.x *= CUBEUV_TEXEL_WIDTH;\n		uv.y *= CUBEUV_TEXEL_HEIGHT;\n		#ifdef texture2DGradEXT\n			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n		#else\n			return texture2D( envMap, uv ).rgb;\n		#endif\n	}\n	#define r0 1.0\n	#define v0 0.339\n	#define m0 - 2.0\n	#define r1 0.8\n	#define v1 0.276\n	#define m1 - 1.0\n	#define r4 0.4\n	#define v4 0.046\n	#define m4 2.0\n	#define r5 0.305\n	#define v5 0.016\n	#define m5 3.0\n	#define r6 0.21\n	#define v6 0.0038\n	#define m6 4.0\n	float roughnessToMip( float roughness ) {\n		float mip = 0.0;\n		if ( roughness >= r1 ) {\n			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n		} else if ( roughness >= r4 ) {\n			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n		} else if ( roughness >= r5 ) {\n			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n		} else if ( roughness >= r6 ) {\n			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n		} else {\n			mip = - 2.0 * log2( 1.16 * roughness );		}\n		return mip;\n	}\n	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n		float mip = clamp( roughnessToMip( roughness ), m0, CUBEUV_MAX_MIP );\n		float mipF = fract( mip );\n		float mipInt = floor( mip );\n		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n		if ( mipF == 0.0 ) {\n			return vec4( color0, 1.0 );\n		} else {\n			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n			return vec4( mix( color0, color1, mipF ), 1.0 );\n		}\n	}\n#endif";
  var defaultnormal_vertex = "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n	mat3 m = mat3( instanceMatrix );\n	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n	transformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n	transformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#ifdef FLIP_SIDED\n		transformedTangent = - transformedTangent;\n	#endif\n#endif";
  var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n#endif";
  var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif";
  var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n	vec4 emissiveColor = texture2D( emissiveMap, vUv );\n	totalEmissiveRadiance *= emissiveColor.rgb;\n#endif";
  var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n	uniform sampler2D emissiveMap;\n#endif";
  var encodings_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );";
  var encodings_pars_fragment = "vec4 LinearToLinear( in vec4 value ) {\n	return value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}";
  var envmap_fragment = "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vec3 cameraToFrag;\n		if ( isOrthographic ) {\n			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToFrag = normalize( vWorldPosition - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( cameraToFrag, worldNormal );\n		#else\n			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n		#endif\n	#else\n		vec3 reflectVec = vReflect;\n	#endif\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n	#elif defined( ENVMAP_TYPE_CUBE_UV )\n		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n	#else\n		vec4 envColor = vec4( 0.0 );\n	#endif\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_MIX )\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_ADD )\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n	#endif\n#endif";
  var envmap_common_pars_fragment = "#ifdef USE_ENVMAP\n	uniform float envMapIntensity;\n	uniform float flipEnvMap;\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	\n#endif";
  var envmap_pars_fragment = "#ifdef USE_ENVMAP\n	uniform float reflectivity;\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		varying vec3 vWorldPosition;\n		uniform float refractionRatio;\n	#else\n		varying vec3 vReflect;\n	#endif\n#endif";
  var envmap_pars_vertex = "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		\n		varying vec3 vWorldPosition;\n	#else\n		varying vec3 vReflect;\n		uniform float refractionRatio;\n	#endif\n#endif";
  var envmap_vertex = "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vWorldPosition = worldPosition.xyz;\n	#else\n		vec3 cameraToVertex;\n		if ( isOrthographic ) {\n			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vReflect = reflect( cameraToVertex, worldNormal );\n		#else\n			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n		#endif\n	#endif\n#endif";
  var fog_vertex = "#ifdef USE_FOG\n	vFogDepth = - mvPosition.z;\n#endif";
  var fog_pars_vertex = "#ifdef USE_FOG\n	varying float vFogDepth;\n#endif";
  var fog_fragment = "#ifdef USE_FOG\n	#ifdef FOG_EXP2\n		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n	#else\n		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n	#endif\n	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";
  var fog_pars_fragment = "#ifdef USE_FOG\n	uniform vec3 fogColor;\n	varying float vFogDepth;\n	#ifdef FOG_EXP2\n		uniform float fogDensity;\n	#else\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n#endif";
  var gradientmap_pars_fragment = "#ifdef USE_GRADIENTMAP\n	uniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n	float dotNL = dot( normal, lightDirection );\n	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n	#ifdef USE_GRADIENTMAP\n		return vec3( texture2D( gradientMap, coord ).r );\n	#else\n		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n	#endif\n}";
  var lightmap_fragment = "#ifdef USE_LIGHTMAP\n	vec4 lightMapTexel = texture2D( lightMap, vUv2 );\n	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n	reflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif";
  var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n#endif";
  var lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n	vLightBack = vec3( 0.0 );\n	vIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );\n#ifdef DOUBLE_SIDED\n	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );\n#endif\n#if NUM_POINT_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		getPointLightInfo( pointLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		getSpotLightInfo( spotLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		getDirectionalLightInfo( directionalLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n		#ifdef DOUBLE_SIDED\n			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif";
  var lights_pars_begin = "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n	float x = normal.x, y = normal.y, z = normal.z;\n	vec3 result = shCoefficients[ 0 ] * 0.886227;\n	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n	return result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n	return irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n	vec3 irradiance = ambientLightColor;\n	return irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n	#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n		if ( cutoffDistance > 0.0 ) {\n			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n		}\n		return distanceFalloff;\n	#else\n		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n		}\n		return 1.0;\n	#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n	return smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n	struct DirectionalLight {\n		vec3 direction;\n		vec3 color;\n	};\n	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n		light.color = directionalLight.color;\n		light.direction = directionalLight.direction;\n		light.visible = true;\n	}\n#endif\n#if NUM_POINT_LIGHTS > 0\n	struct PointLight {\n		vec3 position;\n		vec3 color;\n		float distance;\n		float decay;\n	};\n	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n		vec3 lVector = pointLight.position - geometry.position;\n		light.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		light.color = pointLight.color;\n		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n		light.visible = ( light.color != vec3( 0.0 ) );\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	struct SpotLight {\n		vec3 position;\n		vec3 direction;\n		vec3 color;\n		float distance;\n		float decay;\n		float coneCos;\n		float penumbraCos;\n	};\n	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n		vec3 lVector = spotLight.position - geometry.position;\n		light.direction = normalize( lVector );\n		float angleCos = dot( light.direction, spotLight.direction );\n		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n		if ( spotAttenuation > 0.0 ) {\n			float lightDistance = length( lVector );\n			light.color = spotLight.color * spotAttenuation;\n			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n			light.visible = ( light.color != vec3( 0.0 ) );\n		} else {\n			light.color = vec3( 0.0 );\n			light.visible = false;\n		}\n	}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n	struct RectAreaLight {\n		vec3 color;\n		vec3 position;\n		vec3 halfWidth;\n		vec3 halfHeight;\n	};\n	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;\n	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	struct HemisphereLight {\n		vec3 direction;\n		vec3 skyColor;\n		vec3 groundColor;\n	};\n	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n		float dotNL = dot( normal, hemiLight.direction );\n		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n		return irradiance;\n	}\n#endif";
  var envmap_physical_pars_fragment = "#if defined( USE_ENVMAP )\n	vec3 getIBLIrradiance( const in vec3 normal ) {\n		#if defined( ENVMAP_TYPE_CUBE_UV )\n			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n			return PI * envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n		#if defined( ENVMAP_TYPE_CUBE_UV )\n			vec3 reflectVec = reflect( - viewDir, normal );\n			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n			return envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n#endif";
  var lights_toon_fragment = "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;";
  var lights_toon_pars_fragment = "varying vec3 vViewPosition;\nstruct ToonMaterial {\n	vec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_Toon\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )	(0)";
  var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";
  var lights_phong_pars_fragment = "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n	vec3 diffuseColor;\n	vec3 specularColor;\n	float specularShininess;\n	float specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_BlinnPhong\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )	(0)";
  var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n	#ifdef SPECULAR\n		float specularIntensityFactor = specularIntensity;\n		vec3 specularColorFactor = specularColor;\n		#ifdef USE_SPECULARINTENSITYMAP\n			specularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n		#endif\n		#ifdef USE_SPECULARCOLORMAP\n			specularColorFactor *= texture2D( specularColorMap, vUv ).rgb;\n		#endif\n		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n	#else\n		float specularIntensityFactor = 1.0;\n		vec3 specularColorFactor = vec3( 1.0 );\n		material.specularF90 = 1.0;\n	#endif\n	material.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n	material.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n	material.clearcoat = clearcoat;\n	material.clearcoatRoughness = clearcoatRoughness;\n	material.clearcoatF0 = vec3( 0.04 );\n	material.clearcoatF90 = 1.0;\n	#ifdef USE_CLEARCOATMAP\n		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n	#endif\n	#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n	#endif\n	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n	material.clearcoatRoughness += geometryRoughness;\n	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n	material.sheenColor = sheenColor;\n	#ifdef USE_SHEENCOLORMAP\n		material.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;\n	#endif\n	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n	#ifdef USE_SHEENROUGHNESSMAP\n		material.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;\n	#endif\n#endif";
  var lights_physical_pars_fragment = "struct PhysicalMaterial {\n	vec3 diffuseColor;\n	float roughness;\n	vec3 specularColor;\n	float specularF90;\n	#ifdef USE_CLEARCOAT\n		float clearcoat;\n		float clearcoatRoughness;\n		vec3 clearcoatF0;\n		float clearcoatF90;\n	#endif\n	#ifdef USE_SHEEN\n		vec3 sheenColor;\n		float sheenRoughness;\n	#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec3 sheenSpecular = vec3( 0.0 );\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float r2 = roughness * roughness;\n	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n	return saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n	vec4 r = roughness * c0 + c1;\n	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n	return fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	return specularColor * fab.x + specularF90 * fab.y;\n}\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	vec3 FssEss = specularColor * fab.x + specularF90 * fab.y;\n	float Ess = fab.x + fab.y;\n	float Ems = 1.0 - Ess;\n	vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n	singleScatter += FssEss;\n	multiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n		vec3 normal = geometry.normal;\n		vec3 viewDir = geometry.viewDir;\n		vec3 position = geometry.position;\n		vec3 lightPos = rectAreaLight.position;\n		vec3 halfWidth = rectAreaLight.halfWidth;\n		vec3 halfHeight = rectAreaLight.halfHeight;\n		vec3 lightColor = rectAreaLight.color;\n		float roughness = material.roughness;\n		vec3 rectCoords[ 4 ];\n		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n		vec2 uv = LTC_Uv( normal, viewDir, roughness );\n		vec4 t1 = texture2D( ltc_1, uv );\n		vec4 t2 = texture2D( ltc_2, uv );\n		mat3 mInv = mat3(\n			vec3( t1.x, 0, t1.y ),\n			vec3(    0, 1,    0 ),\n			vec3( t1.z, 0, t1.w )\n		);\n		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n	}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifdef USE_CLEARCOAT\n		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n		vec3 ccIrradiance = dotNLcc * directLight.color;\n		clearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n	#endif\n	#ifdef USE_SHEEN\n		sheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n	#endif\n	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n	#ifdef USE_CLEARCOAT\n		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n	#endif\n	#ifdef USE_SHEEN\n		sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );\n	#endif\n	vec3 singleScattering = vec3( 0.0 );\n	vec3 multiScattering = vec3( 0.0 );\n	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n	computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n	vec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n	reflectedLight.indirectSpecular += radiance * singleScattering;\n	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct				RE_Direct_Physical\n#define RE_Direct_RectArea		RE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular		RE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";
  var lights_fragment_begin = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n	geometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n	PointLight pointLight;\n	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		getPointLightInfo( pointLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n		pointLightShadow = pointLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n	SpotLight spotLight;\n	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		getSpotLightInfo( spotLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n		spotLightShadow = spotLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n	DirectionalLight directionalLight;\n	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		getDirectionalLightInfo( directionalLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n		directionalLightShadow = directionalLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n	RectAreaLight rectAreaLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n		rectAreaLight = rectAreaLights[ i ];\n		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n	vec3 iblIrradiance = vec3( 0.0 );\n	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n	#if ( NUM_HEMI_LIGHTS > 0 )\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n		}\n		#pragma unroll_loop_end\n	#endif\n#endif\n#if defined( RE_IndirectSpecular )\n	vec3 radiance = vec3( 0.0 );\n	vec3 clearcoatRadiance = vec3( 0.0 );\n#endif";
  var lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel = texture2D( lightMap, vUv2 );\n		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n		irradiance += lightMapIrradiance;\n	#endif\n	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n		iblIrradiance += getIBLIrradiance( geometry.normal );\n	#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n	radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n	#ifdef USE_CLEARCOAT\n		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n	#endif\n#endif";
  var lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif";
  var logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";
  var logdepthbuf_pars_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	uniform float logDepthBufFC;\n	varying float vFragDepth;\n	varying float vIsPerspective;\n#endif";
  var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		varying float vFragDepth;\n		varying float vIsPerspective;\n	#else\n		uniform float logDepthBufFC;\n	#endif\n#endif";
  var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		vFragDepth = 1.0 + gl_Position.w;\n		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n	#else\n		if ( isPerspectiveMatrix( projectionMatrix ) ) {\n			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n			gl_Position.z *= gl_Position.w;\n		}\n	#endif\n#endif";
  var map_fragment = "#ifdef USE_MAP\n	vec4 sampledDiffuseColor = texture2D( map, vUv );\n	#ifdef DECODE_VIDEO_TEXTURE\n		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n	#endif\n	diffuseColor *= sampledDiffuseColor;\n#endif";
  var map_pars_fragment = "#ifdef USE_MAP\n	uniform sampler2D map;\n#endif";
  var map_particle_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n	diffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif";
  var map_particle_pars_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	uniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n	uniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif";
  var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n	vec4 texelMetalness = texture2D( metalnessMap, vUv );\n	metalnessFactor *= texelMetalness.b;\n#endif";
  var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n	uniform sampler2D metalnessMap;\n#endif";
  var morphcolor_vertex = "#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n	vColor *= morphTargetBaseInfluence;\n	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n		#if defined( USE_COLOR_ALPHA )\n			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n		#elif defined( USE_COLOR )\n			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n		#endif\n	}\n#endif";
  var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n	objectNormal *= morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n		}\n	#else\n		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n	#endif\n#endif";
  var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n	uniform float morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n		uniform sampler2DArray morphTargetsTexture;\n		uniform ivec2 morphTargetsTextureSize;\n		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n			int y = texelIndex / morphTargetsTextureSize.x;\n			int x = texelIndex - y * morphTargetsTextureSize.x;\n			ivec3 morphUV = ivec3( x, y, morphTargetIndex );\n			return texelFetch( morphTargetsTexture, morphUV, 0 );\n		}\n	#else\n		#ifndef USE_MORPHNORMALS\n			uniform float morphTargetInfluences[ 8 ];\n		#else\n			uniform float morphTargetInfluences[ 4 ];\n		#endif\n	#endif\n#endif";
  var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n	transformed *= morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n		}\n	#else\n		transformed += morphTarget0 * morphTargetInfluences[ 0 ];\n		transformed += morphTarget1 * morphTargetInfluences[ 1 ];\n		transformed += morphTarget2 * morphTargetInfluences[ 2 ];\n		transformed += morphTarget3 * morphTargetInfluences[ 3 ];\n		#ifndef USE_MORPHNORMALS\n			transformed += morphTarget4 * morphTargetInfluences[ 4 ];\n			transformed += morphTarget5 * morphTargetInfluences[ 5 ];\n			transformed += morphTarget6 * morphTargetInfluences[ 6 ];\n			transformed += morphTarget7 * morphTargetInfluences[ 7 ];\n		#endif\n	#endif\n#endif";
  var normal_fragment_begin = "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n#else\n	vec3 normal = normalize( vNormal );\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	#ifdef USE_TANGENT\n		vec3 tangent = normalize( vTangent );\n		vec3 bitangent = normalize( vBitangent );\n		#ifdef DOUBLE_SIDED\n			tangent = tangent * faceDirection;\n			bitangent = bitangent * faceDirection;\n		#endif\n		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n			mat3 vTBN = mat3( tangent, bitangent, normal );\n		#endif\n	#endif\n#endif\nvec3 geometryNormal = normal;";
  var normal_fragment_maps = "#ifdef OBJECTSPACE_NORMALMAP\n	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n	#ifdef FLIP_SIDED\n		normal = - normal;\n	#endif\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	normal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n	mapN.xy *= normalScale;\n	#ifdef USE_TANGENT\n		normal = normalize( vTBN * mapN );\n	#else\n		normal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n	#endif\n#elif defined( USE_BUMPMAP )\n	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif";
  var normal_pars_fragment = "#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif";
  var normal_pars_vertex = "#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif";
  var normal_vertex = "#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n	#ifdef USE_TANGENT\n		vTangent = normalize( transformedTangent );\n		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n	#endif\n#endif";
  var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n	uniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n		vec2 st0 = dFdx( vUv.st );\n		vec2 st1 = dFdy( vUv.st );\n		vec3 N = surf_norm;\n		vec3 q1perp = cross( q1, N );\n		vec3 q0perp = cross( N, q0 );\n		vec3 T = q1perp * st0.x + q0perp * st1.x;\n		vec3 B = q1perp * st0.y + q0perp * st1.y;\n		float det = max( dot( T, T ), dot( B, B ) );\n		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n	}\n#endif";
  var clearcoat_normal_fragment_begin = "#ifdef USE_CLEARCOAT\n	vec3 clearcoatNormal = geometryNormal;\n#endif";
  var clearcoat_normal_fragment_maps = "#ifdef USE_CLEARCOAT_NORMALMAP\n	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n	clearcoatMapN.xy *= clearcoatNormalScale;\n	#ifdef USE_TANGENT\n		clearcoatNormal = normalize( vTBN * clearcoatMapN );\n	#else\n		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n	#endif\n#endif";
  var clearcoat_pars_fragment = "#ifdef USE_CLEARCOATMAP\n	uniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	uniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	uniform sampler2D clearcoatNormalMap;\n	uniform vec2 clearcoatNormalScale;\n#endif";
  var output_fragment = "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );";
  var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n	return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n	return 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n	vec4 r = vec4( fract( v * PackFactors ), v );\n	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n	return dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n	return linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n	return ( near * far ) / ( ( far - near ) * invClipZ - far );\n}";
  var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n	gl_FragColor.rgb *= gl_FragColor.a;\n#endif";
  var project_vertex = "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n	mvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;";
  var dithering_fragment = "#ifdef DITHERING\n	gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";
  var dithering_pars_fragment = "#ifdef DITHERING\n	vec3 dithering( vec3 color ) {\n		float grid_position = rand( gl_FragCoord.xy );\n		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n		return color + dither_shift_RGB;\n	}\n#endif";
  var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n	vec4 texelRoughness = texture2D( roughnessMap, vUv );\n	roughnessFactor *= texelRoughness.g;\n#endif";
  var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n	uniform sampler2D roughnessMap;\n#endif";
  var shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n	}\n	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n		return unpackRGBATo2Half( texture2D( shadow, uv ) );\n	}\n	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n		float occlusion = 1.0;\n		vec2 distribution = texture2DDistribution( shadow, uv );\n		float hard_shadow = step( compare , distribution.x );\n		if (hard_shadow != 1.0 ) {\n			float distance = compare - distribution.x ;\n			float variance = max( 0.00000, distribution.y * distribution.y );\n			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n		}\n		return occlusion;\n	}\n	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n		float shadow = 1.0;\n		shadowCoord.xyz /= shadowCoord.w;\n		shadowCoord.z += shadowBias;\n		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n		bool inFrustum = all( inFrustumVec );\n		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n		bool frustumTest = all( frustumTestVec );\n		if ( frustumTest ) {\n		#if defined( SHADOWMAP_TYPE_PCF )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			float dx2 = dx0 / 2.0;\n			float dy2 = dy0 / 2.0;\n			float dx3 = dx1 / 2.0;\n			float dy3 = dy1 / 2.0;\n			shadow = (\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 17.0 );\n		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx = texelSize.x;\n			float dy = texelSize.y;\n			vec2 uv = shadowCoord.xy;\n			vec2 f = fract( uv * shadowMapSize + 0.5 );\n			uv -= f * texelSize;\n			shadow = (\n				texture2DCompare( shadowMap, uv, shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n						  f.x ),\n					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n						  f.x ),\n					 f.y )\n			) * ( 1.0 / 9.0 );\n		#elif defined( SHADOWMAP_TYPE_VSM )\n			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#else\n			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#endif\n		}\n		return shadow;\n	}\n	vec2 cubeToUV( vec3 v, float texelSizeY ) {\n		vec3 absV = abs( v );\n		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n		absV *= scaleToCube;\n		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n		vec2 planar = v.xy;\n		float almostATexel = 1.5 * texelSizeY;\n		float almostOne = 1.0 - almostATexel;\n		if ( absV.z >= almostOne ) {\n			if ( v.z > 0.0 )\n				planar.x = 4.0 - v.x;\n		} else if ( absV.x >= almostOne ) {\n			float signX = sign( v.x );\n			planar.x = v.z * signX + 2.0 * signX;\n		} else if ( absV.y >= almostOne ) {\n			float signY = sign( v.y );\n			planar.x = v.x + 2.0 * signY + 2.0;\n			planar.y = v.z * signY - 2.0;\n		}\n		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n	}\n	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n		vec3 lightToPosition = shadowCoord.xyz;\n		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;\n		vec3 bd3D = normalize( lightToPosition );\n		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n			return (\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n			) * ( 1.0 / 9.0 );\n		#else\n			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n		#endif\n	}\n#endif";
  var shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n#endif";
  var shadowmap_vertex = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		vec4 shadowWorldPosition;\n	#endif\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n#endif";
  var shadowmask_pars_fragment = "float getShadowMask() {\n	float shadow = 1.0;\n	#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		directionalLight = directionalLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		spotLight = spotLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		pointLight = pointLightShadows[ i ];\n		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#endif\n	return shadow;\n}";
  var skinbase_vertex = "#ifdef USE_SKINNING\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";
  var skinning_pars_vertex = "#ifdef USE_SKINNING\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n	#ifdef BONE_TEXTURE\n		uniform highp sampler2D boneTexture;\n		uniform int boneTextureSize;\n		mat4 getBoneMatrix( const in float i ) {\n			float j = i * 4.0;\n			float x = mod( j, float( boneTextureSize ) );\n			float y = floor( j / float( boneTextureSize ) );\n			float dx = 1.0 / float( boneTextureSize );\n			float dy = 1.0 / float( boneTextureSize );\n			y = dy * ( y + 0.5 );\n			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n			mat4 bone = mat4( v1, v2, v3, v4 );\n			return bone;\n		}\n	#else\n		uniform mat4 boneMatrices[ MAX_BONES ];\n		mat4 getBoneMatrix( const in float i ) {\n			mat4 bone = boneMatrices[ int(i) ];\n			return bone;\n		}\n	#endif\n#endif";
  var skinning_vertex = "#ifdef USE_SKINNING\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	transformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";
  var skinnormal_vertex = "#ifdef USE_SKINNING\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n	#ifdef USE_TANGENT\n		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#endif\n#endif";
  var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n	vec4 texelSpecular = texture2D( specularMap, vUv );\n	specularStrength = texelSpecular.r;\n#else\n	specularStrength = 1.0;\n#endif";
  var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n	uniform sampler2D specularMap;\n#endif";
  var tonemapping_fragment = "#if defined( TONE_MAPPING )\n	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";
  var tonemapping_pars_fragment = "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n	return toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	return saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	color = max( vec3( 0.0 ), color - 0.004 );\n	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n	return a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n	const mat3 ACESInputMat = mat3(\n		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),\n		vec3( 0.04823, 0.01566, 0.83777 )\n	);\n	const mat3 ACESOutputMat = mat3(\n		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),\n		vec3( -0.07367, -0.00605,  1.07602 )\n	);\n	color *= toneMappingExposure / 0.6;\n	color = ACESInputMat * color;\n	color = RRTAndODTFit( color );\n	color = ACESOutputMat * color;\n	return saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }";
  var transmission_fragment = "#ifdef USE_TRANSMISSION\n	float transmissionAlpha = 1.0;\n	float transmissionFactor = transmission;\n	float thicknessFactor = thickness;\n	#ifdef USE_TRANSMISSIONMAP\n		transmissionFactor *= texture2D( transmissionMap, vUv ).r;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		thicknessFactor *= texture2D( thicknessMap, vUv ).g;\n	#endif\n	vec3 pos = vWorldPosition;\n	vec3 v = normalize( cameraPosition - pos );\n	vec3 n = inverseTransformDirection( normal, viewMatrix );\n	vec4 transmission = getIBLVolumeRefraction(\n		n, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,\n		pos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n		attenuationColor, attenuationDistance );\n	totalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );\n	transmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );\n#endif";
  var transmission_pars_fragment = "#ifdef USE_TRANSMISSION\n	uniform float transmission;\n	uniform float thickness;\n	uniform float attenuationDistance;\n	uniform vec3 attenuationColor;\n	#ifdef USE_TRANSMISSIONMAP\n		uniform sampler2D transmissionMap;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		uniform sampler2D thicknessMap;\n	#endif\n	uniform vec2 transmissionSamplerSize;\n	uniform sampler2D transmissionSamplerMap;\n	uniform mat4 modelMatrix;\n	uniform mat4 projectionMatrix;\n	varying vec3 vWorldPosition;\n	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n		vec3 modelScale;\n		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n		return normalize( refractionVector ) * thickness * modelScale;\n	}\n	float applyIorToRoughness( const in float roughness, const in float ior ) {\n		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n	}\n	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n		float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n		#ifdef texture2DLodEXT\n			return texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n		#else\n			return texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n		#endif\n	}\n	vec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n		if ( attenuationDistance == 0.0 ) {\n			return radiance;\n		} else {\n			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance * radiance;\n		}\n	}\n	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n		const in vec3 attenuationColor, const in float attenuationDistance ) {\n		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n		vec3 refractedRayExit = position + transmissionRay;\n		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n		vec2 refractionCoords = ndcPos.xy / ndcPos.w;\n		refractionCoords += 1.0;\n		refractionCoords /= 2.0;\n		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n		vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n		return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n	}\n#endif";
  var uv_pars_fragment = "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n	varying vec2 vUv;\n#endif";
  var uv_pars_vertex = "#ifdef USE_UV\n	#ifdef UVS_VERTEX_ONLY\n		vec2 vUv;\n	#else\n		varying vec2 vUv;\n	#endif\n	uniform mat3 uvTransform;\n#endif";
  var uv_vertex = "#ifdef USE_UV\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif";
  var uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	varying vec2 vUv2;\n#endif";
  var uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	attribute vec2 uv2;\n	varying vec2 vUv2;\n	uniform mat3 uv2Transform;\n#endif";
  var uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif";
  var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n	vec4 worldPosition = vec4( transformed, 1.0 );\n	#ifdef USE_INSTANCING\n		worldPosition = instanceMatrix * worldPosition;\n	#endif\n	worldPosition = modelMatrix * worldPosition;\n#endif";
  var vertex$g = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n	gl_Position = vec4( position.xy, 1.0, 1.0 );\n}";
  var fragment$g = "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n	gl_FragColor = texture2D( t2D, vUv );\n	#ifdef DECODE_VIDEO_TEXTURE\n		gl_FragColor = vec4( mix( pow( gl_FragColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), gl_FragColor.rgb * 0.0773993808, vec3( lessThanEqual( gl_FragColor.rgb, vec3( 0.04045 ) ) ) ), gl_FragColor.w );\n	#endif\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}";
  var vertex$f = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	gl_Position.z = gl_Position.w;\n}";
  var fragment$f = "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n	vec3 vReflect = vWorldDirection;\n	#include <envmap_fragment>\n	gl_FragColor = envColor;\n	gl_FragColor.a *= opacity;\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}";
  var vertex$e = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vHighPrecisionZW = gl_Position.zw;\n}";
  var fragment$e = "#if DEPTH_PACKING == 3200\n	uniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#if DEPTH_PACKING == 3200\n		diffuseColor.a = opacity;\n	#endif\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <logdepthbuf_fragment>\n	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n	#if DEPTH_PACKING == 3200\n		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n	#elif DEPTH_PACKING == 3201\n		gl_FragColor = packDepthToRGBA( fragCoordZ );\n	#endif\n}";
  var vertex$d = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	vWorldPosition = worldPosition.xyz;\n}";
  var fragment$d = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	float dist = length( vWorldPosition - referencePosition );\n	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n	dist = saturate( dist );\n	gl_FragColor = packDepthToRGBA( dist );\n}";
  var vertex$c = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n}";
  var fragment$c = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vec3 direction = normalize( vWorldDirection );\n	vec2 sampleUV = equirectUv( direction );\n	gl_FragColor = texture2D( tEquirect, sampleUV );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}";
  var vertex$b = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	vLineDistance = scale * lineDistance;\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}";
  var fragment$b = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	if ( mod( vLineDistance, totalSize ) > dashSize ) {\n		discard;\n	}\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <color_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}";
  var vertex$a = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinbase_vertex>\n		#include <skinnormal_vertex>\n		#include <defaultnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <fog_vertex>\n}";
  var fragment$a = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel = texture2D( lightMap, vUv2 );\n		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n	#else\n		reflectedLight.indirectDiffuse += vec3( 1.0 );\n	#endif\n	#include <aomap_fragment>\n	reflectedLight.indirectDiffuse *= diffuseColor.rgb;\n	vec3 outgoingLight = reflectedLight.indirectDiffuse;\n	#include <envmap_fragment>\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
  var vertex$9 = "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n	varying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <lights_lambert_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
  var fragment$9 = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n	varying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <emissivemap_fragment>\n	#ifdef DOUBLE_SIDED\n		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n	#else\n		reflectedLight.indirectDiffuse += vIndirectFront;\n	#endif\n	#include <lightmap_fragment>\n	reflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );\n	#ifdef DOUBLE_SIDED\n		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n	#else\n		reflectedLight.directDiffuse = vLightFront;\n	#endif\n	reflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
  var vertex$8 = "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n	vViewPosition = - mvPosition.xyz;\n}";
  var fragment$8 = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	vec3 viewDir = normalize( vViewPosition );\n	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n	vec3 y = cross( viewDir, x );\n	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n	#ifdef USE_MATCAP\n		vec4 matcapColor = texture2D( matcap, uv );\n	#else\n		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n	#endif\n	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
  var vertex$7 = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	vViewPosition = - mvPosition.xyz;\n#endif\n}";
  var fragment$7 = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n	#ifdef OPAQUE\n		gl_FragColor.a = 1.0;\n	#endif\n}";
  var vertex$6 = "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
  var fragment$6 = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_phong_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
  var vertex$5 = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n	varying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n	vWorldPosition = worldPosition.xyz;\n#endif\n}";
  var fragment$5 = "#define STANDARD\n#ifdef PHYSICAL\n	#define IOR\n	#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n	uniform float ior;\n#endif\n#ifdef SPECULAR\n	uniform float specularIntensity;\n	uniform vec3 specularColor;\n	#ifdef USE_SPECULARINTENSITYMAP\n		uniform sampler2D specularIntensityMap;\n	#endif\n	#ifdef USE_SPECULARCOLORMAP\n		uniform sampler2D specularColorMap;\n	#endif\n#endif\n#ifdef USE_CLEARCOAT\n	uniform float clearcoat;\n	uniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n	uniform vec3 sheenColor;\n	uniform float sheenRoughness;\n	#ifdef USE_SHEENCOLORMAP\n		uniform sampler2D sheenColorMap;\n	#endif\n	#ifdef USE_SHEENROUGHNESSMAP\n		uniform sampler2D sheenRoughnessMap;\n	#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <roughnessmap_fragment>\n	#include <metalnessmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <clearcoat_normal_fragment_begin>\n	#include <clearcoat_normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_physical_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n	#include <transmission_fragment>\n	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n	#ifdef USE_SHEEN\n		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;\n	#endif\n	#ifdef USE_CLEARCOAT\n		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n	#endif\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
  var vertex$4 = "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
  var fragment$4 = "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_toon_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
  var vertex$3 = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	gl_PointSize = size;\n	#ifdef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n	#endif\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <fog_vertex>\n}";
  var fragment$3 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_particle_fragment>\n	#include <color_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}";
  var vertex$2 = "#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
  var fragment$2 = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}";
  var vertex$1 = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n	vec2 scale;\n	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n	#ifndef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) scale *= - mvPosition.z;\n	#endif\n	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n	vec2 rotatedPosition;\n	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n	mvPosition.xy += rotatedPosition;\n	gl_Position = projectionMatrix * mvPosition;\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}";
  var fragment$1 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}";
  var ShaderChunk = {
    alphamap_fragment,
    alphamap_pars_fragment,
    alphatest_fragment,
    alphatest_pars_fragment,
    aomap_fragment,
    aomap_pars_fragment,
    begin_vertex,
    beginnormal_vertex,
    bsdfs,
    bumpmap_pars_fragment,
    clipping_planes_fragment,
    clipping_planes_pars_fragment,
    clipping_planes_pars_vertex,
    clipping_planes_vertex,
    color_fragment,
    color_pars_fragment,
    color_pars_vertex,
    color_vertex,
    common,
    cube_uv_reflection_fragment,
    defaultnormal_vertex,
    displacementmap_pars_vertex,
    displacementmap_vertex,
    emissivemap_fragment,
    emissivemap_pars_fragment,
    encodings_fragment,
    encodings_pars_fragment,
    envmap_fragment,
    envmap_common_pars_fragment,
    envmap_pars_fragment,
    envmap_pars_vertex,
    envmap_physical_pars_fragment,
    envmap_vertex,
    fog_vertex,
    fog_pars_vertex,
    fog_fragment,
    fog_pars_fragment,
    gradientmap_pars_fragment,
    lightmap_fragment,
    lightmap_pars_fragment,
    lights_lambert_vertex,
    lights_pars_begin,
    lights_toon_fragment,
    lights_toon_pars_fragment,
    lights_phong_fragment,
    lights_phong_pars_fragment,
    lights_physical_fragment,
    lights_physical_pars_fragment,
    lights_fragment_begin,
    lights_fragment_maps,
    lights_fragment_end,
    logdepthbuf_fragment,
    logdepthbuf_pars_fragment,
    logdepthbuf_pars_vertex,
    logdepthbuf_vertex,
    map_fragment,
    map_pars_fragment,
    map_particle_fragment,
    map_particle_pars_fragment,
    metalnessmap_fragment,
    metalnessmap_pars_fragment,
    morphcolor_vertex,
    morphnormal_vertex,
    morphtarget_pars_vertex,
    morphtarget_vertex,
    normal_fragment_begin,
    normal_fragment_maps,
    normal_pars_fragment,
    normal_pars_vertex,
    normal_vertex,
    normalmap_pars_fragment,
    clearcoat_normal_fragment_begin,
    clearcoat_normal_fragment_maps,
    clearcoat_pars_fragment,
    output_fragment,
    packing,
    premultiplied_alpha_fragment,
    project_vertex,
    dithering_fragment,
    dithering_pars_fragment,
    roughnessmap_fragment,
    roughnessmap_pars_fragment,
    shadowmap_pars_fragment,
    shadowmap_pars_vertex,
    shadowmap_vertex,
    shadowmask_pars_fragment,
    skinbase_vertex,
    skinning_pars_vertex,
    skinning_vertex,
    skinnormal_vertex,
    specularmap_fragment,
    specularmap_pars_fragment,
    tonemapping_fragment,
    tonemapping_pars_fragment,
    transmission_fragment,
    transmission_pars_fragment,
    uv_pars_fragment,
    uv_pars_vertex,
    uv_vertex,
    uv2_pars_fragment,
    uv2_pars_vertex,
    uv2_vertex,
    worldpos_vertex,
    background_vert: vertex$g,
    background_frag: fragment$g,
    cube_vert: vertex$f,
    cube_frag: fragment$f,
    depth_vert: vertex$e,
    depth_frag: fragment$e,
    distanceRGBA_vert: vertex$d,
    distanceRGBA_frag: fragment$d,
    equirect_vert: vertex$c,
    equirect_frag: fragment$c,
    linedashed_vert: vertex$b,
    linedashed_frag: fragment$b,
    meshbasic_vert: vertex$a,
    meshbasic_frag: fragment$a,
    meshlambert_vert: vertex$9,
    meshlambert_frag: fragment$9,
    meshmatcap_vert: vertex$8,
    meshmatcap_frag: fragment$8,
    meshnormal_vert: vertex$7,
    meshnormal_frag: fragment$7,
    meshphong_vert: vertex$6,
    meshphong_frag: fragment$6,
    meshphysical_vert: vertex$5,
    meshphysical_frag: fragment$5,
    meshtoon_vert: vertex$4,
    meshtoon_frag: fragment$4,
    points_vert: vertex$3,
    points_frag: fragment$3,
    shadow_vert: vertex$2,
    shadow_frag: fragment$2,
    sprite_vert: vertex$1,
    sprite_frag: fragment$1
  };
  var UniformsLib = {
    common: {
      diffuse: { value: new Color(16777215) },
      opacity: { value: 1 },
      map: { value: null },
      uvTransform: { value: new Matrix3() },
      uv2Transform: { value: new Matrix3() },
      alphaMap: { value: null },
      alphaTest: { value: 0 }
    },
    specularmap: {
      specularMap: { value: null }
    },
    envmap: {
      envMap: { value: null },
      flipEnvMap: { value: -1 },
      reflectivity: { value: 1 },
      // basic, lambert, phong
      ior: { value: 1.5 },
      // physical
      refractionRatio: { value: 0.98 }
      // basic, lambert, phong
    },
    aomap: {
      aoMap: { value: null },
      aoMapIntensity: { value: 1 }
    },
    lightmap: {
      lightMap: { value: null },
      lightMapIntensity: { value: 1 }
    },
    emissivemap: {
      emissiveMap: { value: null }
    },
    bumpmap: {
      bumpMap: { value: null },
      bumpScale: { value: 1 }
    },
    normalmap: {
      normalMap: { value: null },
      normalScale: { value: new Vector2(1, 1) }
    },
    displacementmap: {
      displacementMap: { value: null },
      displacementScale: { value: 1 },
      displacementBias: { value: 0 }
    },
    roughnessmap: {
      roughnessMap: { value: null }
    },
    metalnessmap: {
      metalnessMap: { value: null }
    },
    gradientmap: {
      gradientMap: { value: null }
    },
    fog: {
      fogDensity: { value: 25e-5 },
      fogNear: { value: 1 },
      fogFar: { value: 2e3 },
      fogColor: { value: new Color(16777215) }
    },
    lights: {
      ambientLightColor: { value: [] },
      lightProbe: { value: [] },
      directionalLights: { value: [], properties: {
        direction: {},
        color: {}
      } },
      directionalLightShadows: { value: [], properties: {
        shadowBias: {},
        shadowNormalBias: {},
        shadowRadius: {},
        shadowMapSize: {}
      } },
      directionalShadowMap: { value: [] },
      directionalShadowMatrix: { value: [] },
      spotLights: { value: [], properties: {
        color: {},
        position: {},
        direction: {},
        distance: {},
        coneCos: {},
        penumbraCos: {},
        decay: {}
      } },
      spotLightShadows: { value: [], properties: {
        shadowBias: {},
        shadowNormalBias: {},
        shadowRadius: {},
        shadowMapSize: {}
      } },
      spotShadowMap: { value: [] },
      spotShadowMatrix: { value: [] },
      pointLights: { value: [], properties: {
        color: {},
        position: {},
        decay: {},
        distance: {}
      } },
      pointLightShadows: { value: [], properties: {
        shadowBias: {},
        shadowNormalBias: {},
        shadowRadius: {},
        shadowMapSize: {},
        shadowCameraNear: {},
        shadowCameraFar: {}
      } },
      pointShadowMap: { value: [] },
      pointShadowMatrix: { value: [] },
      hemisphereLights: { value: [], properties: {
        direction: {},
        skyColor: {},
        groundColor: {}
      } },
      // TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
      rectAreaLights: { value: [], properties: {
        color: {},
        position: {},
        width: {},
        height: {}
      } },
      ltc_1: { value: null },
      ltc_2: { value: null }
    },
    points: {
      diffuse: { value: new Color(16777215) },
      opacity: { value: 1 },
      size: { value: 1 },
      scale: { value: 1 },
      map: { value: null },
      alphaMap: { value: null },
      alphaTest: { value: 0 },
      uvTransform: { value: new Matrix3() }
    },
    sprite: {
      diffuse: { value: new Color(16777215) },
      opacity: { value: 1 },
      center: { value: new Vector2(0.5, 0.5) },
      rotation: { value: 0 },
      map: { value: null },
      alphaMap: { value: null },
      alphaTest: { value: 0 },
      uvTransform: { value: new Matrix3() }
    }
  };
  var ShaderLib = {
    basic: {
      uniforms: mergeUniforms([
        UniformsLib.common,
        UniformsLib.specularmap,
        UniformsLib.envmap,
        UniformsLib.aomap,
        UniformsLib.lightmap,
        UniformsLib.fog
      ]),
      vertexShader: ShaderChunk.meshbasic_vert,
      fragmentShader: ShaderChunk.meshbasic_frag
    },
    lambert: {
      uniforms: mergeUniforms([
        UniformsLib.common,
        UniformsLib.specularmap,
        UniformsLib.envmap,
        UniformsLib.aomap,
        UniformsLib.lightmap,
        UniformsLib.emissivemap,
        UniformsLib.fog,
        UniformsLib.lights,
        {
          emissive: { value: new Color(0) }
        }
      ]),
      vertexShader: ShaderChunk.meshlambert_vert,
      fragmentShader: ShaderChunk.meshlambert_frag
    },
    phong: {
      uniforms: mergeUniforms([
        UniformsLib.common,
        UniformsLib.specularmap,
        UniformsLib.envmap,
        UniformsLib.aomap,
        UniformsLib.lightmap,
        UniformsLib.emissivemap,
        UniformsLib.bumpmap,
        UniformsLib.normalmap,
        UniformsLib.displacementmap,
        UniformsLib.fog,
        UniformsLib.lights,
        {
          emissive: { value: new Color(0) },
          specular: { value: new Color(1118481) },
          shininess: { value: 30 }
        }
      ]),
      vertexShader: ShaderChunk.meshphong_vert,
      fragmentShader: ShaderChunk.meshphong_frag
    },
    standard: {
      uniforms: mergeUniforms([
        UniformsLib.common,
        UniformsLib.envmap,
        UniformsLib.aomap,
        UniformsLib.lightmap,
        UniformsLib.emissivemap,
        UniformsLib.bumpmap,
        UniformsLib.normalmap,
        UniformsLib.displacementmap,
        UniformsLib.roughnessmap,
        UniformsLib.metalnessmap,
        UniformsLib.fog,
        UniformsLib.lights,
        {
          emissive: { value: new Color(0) },
          roughness: { value: 1 },
          metalness: { value: 0 },
          envMapIntensity: { value: 1 }
          // temporary
        }
      ]),
      vertexShader: ShaderChunk.meshphysical_vert,
      fragmentShader: ShaderChunk.meshphysical_frag
    },
    toon: {
      uniforms: mergeUniforms([
        UniformsLib.common,
        UniformsLib.aomap,
        UniformsLib.lightmap,
        UniformsLib.emissivemap,
        UniformsLib.bumpmap,
        UniformsLib.normalmap,
        UniformsLib.displacementmap,
        UniformsLib.gradientmap,
        UniformsLib.fog,
        UniformsLib.lights,
        {
          emissive: { value: new Color(0) }
        }
      ]),
      vertexShader: ShaderChunk.meshtoon_vert,
      fragmentShader: ShaderChunk.meshtoon_frag
    },
    matcap: {
      uniforms: mergeUniforms([
        UniformsLib.common,
        UniformsLib.bumpmap,
        UniformsLib.normalmap,
        UniformsLib.displacementmap,
        UniformsLib.fog,
        {
          matcap: { value: null }
        }
      ]),
      vertexShader: ShaderChunk.meshmatcap_vert,
      fragmentShader: ShaderChunk.meshmatcap_frag
    },
    points: {
      uniforms: mergeUniforms([
        UniformsLib.points,
        UniformsLib.fog
      ]),
      vertexShader: ShaderChunk.points_vert,
      fragmentShader: ShaderChunk.points_frag
    },
    dashed: {
      uniforms: mergeUniforms([
        UniformsLib.common,
        UniformsLib.fog,
        {
          scale: { value: 1 },
          dashSize: { value: 1 },
          totalSize: { value: 2 }
        }
      ]),
      vertexShader: ShaderChunk.linedashed_vert,
      fragmentShader: ShaderChunk.linedashed_frag
    },
    depth: {
      uniforms: mergeUniforms([
        UniformsLib.common,
        UniformsLib.displacementmap
      ]),
      vertexShader: ShaderChunk.depth_vert,
      fragmentShader: ShaderChunk.depth_frag
    },
    normal: {
      uniforms: mergeUniforms([
        UniformsLib.common,
        UniformsLib.bumpmap,
        UniformsLib.normalmap,
        UniformsLib.displacementmap,
        {
          opacity: { value: 1 }
        }
      ]),
      vertexShader: ShaderChunk.meshnormal_vert,
      fragmentShader: ShaderChunk.meshnormal_frag
    },
    sprite: {
      uniforms: mergeUniforms([
        UniformsLib.sprite,
        UniformsLib.fog
      ]),
      vertexShader: ShaderChunk.sprite_vert,
      fragmentShader: ShaderChunk.sprite_frag
    },
    background: {
      uniforms: {
        uvTransform: { value: new Matrix3() },
        t2D: { value: null }
      },
      vertexShader: ShaderChunk.background_vert,
      fragmentShader: ShaderChunk.background_frag
    },
    /* -------------------------------------------------------------------------
    //	Cube map shader
     ------------------------------------------------------------------------- */
    cube: {
      uniforms: mergeUniforms([
        UniformsLib.envmap,
        {
          opacity: { value: 1 }
        }
      ]),
      vertexShader: ShaderChunk.cube_vert,
      fragmentShader: ShaderChunk.cube_frag
    },
    equirect: {
      uniforms: {
        tEquirect: { value: null }
      },
      vertexShader: ShaderChunk.equirect_vert,
      fragmentShader: ShaderChunk.equirect_frag
    },
    distanceRGBA: {
      uniforms: mergeUniforms([
        UniformsLib.common,
        UniformsLib.displacementmap,
        {
          referencePosition: { value: new Vector3() },
          nearDistance: { value: 1 },
          farDistance: { value: 1e3 }
        }
      ]),
      vertexShader: ShaderChunk.distanceRGBA_vert,
      fragmentShader: ShaderChunk.distanceRGBA_frag
    },
    shadow: {
      uniforms: mergeUniforms([
        UniformsLib.lights,
        UniformsLib.fog,
        {
          color: { value: new Color(0) },
          opacity: { value: 1 }
        }
      ]),
      vertexShader: ShaderChunk.shadow_vert,
      fragmentShader: ShaderChunk.shadow_frag
    }
  };
  ShaderLib.physical = {
    uniforms: mergeUniforms([
      ShaderLib.standard.uniforms,
      {
        clearcoat: { value: 0 },
        clearcoatMap: { value: null },
        clearcoatRoughness: { value: 0 },
        clearcoatRoughnessMap: { value: null },
        clearcoatNormalScale: { value: new Vector2(1, 1) },
        clearcoatNormalMap: { value: null },
        sheen: { value: 0 },
        sheenColor: { value: new Color(0) },
        sheenColorMap: { value: null },
        sheenRoughness: { value: 1 },
        sheenRoughnessMap: { value: null },
        transmission: { value: 0 },
        transmissionMap: { value: null },
        transmissionSamplerSize: { value: new Vector2() },
        transmissionSamplerMap: { value: null },
        thickness: { value: 0 },
        thicknessMap: { value: null },
        attenuationDistance: { value: 0 },
        attenuationColor: { value: new Color(0) },
        specularIntensity: { value: 1 },
        specularIntensityMap: { value: null },
        specularColor: { value: new Color(1, 1, 1) },
        specularColorMap: { value: null }
      }
    ]),
    vertexShader: ShaderChunk.meshphysical_vert,
    fragmentShader: ShaderChunk.meshphysical_frag
  };
  function WebGLBackground(renderer, cubemaps, state, objects, alpha, premultipliedAlpha) {
    const clearColor = new Color(0);
    let clearAlpha = alpha === true ? 0 : 1;
    let planeMesh;
    let boxMesh;
    let currentBackground = null;
    let currentBackgroundVersion = 0;
    let currentTonemapping = null;
    function render(renderList, scene) {
      let forceClear = false;
      let background = scene.isScene === true ? scene.background : null;
      if (background && background.isTexture) {
        background = cubemaps.get(background);
      }
      const xr = renderer.xr;
      const session2 = xr.getSession && xr.getSession();
      if (session2 && session2.environmentBlendMode === "additive") {
        background = null;
      }
      if (background === null) {
        setClear(clearColor, clearAlpha);
      } else if (background && background.isColor) {
        setClear(background, 1);
        forceClear = true;
      }
      if (renderer.autoClear || forceClear) {
        renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
      }
      if (background && (background.isCubeTexture || background.mapping === CubeUVReflectionMapping)) {
        if (boxMesh === void 0) {
          boxMesh = new Mesh(
            new BoxGeometry(1, 1, 1),
            new ShaderMaterial({
              name: "BackgroundCubeMaterial",
              uniforms: cloneUniforms(ShaderLib.cube.uniforms),
              vertexShader: ShaderLib.cube.vertexShader,
              fragmentShader: ShaderLib.cube.fragmentShader,
              side: BackSide,
              depthTest: false,
              depthWrite: false,
              fog: false
            })
          );
          boxMesh.geometry.deleteAttribute("normal");
          boxMesh.geometry.deleteAttribute("uv");
          boxMesh.onBeforeRender = function(renderer2, scene2, camera) {
            this.matrixWorld.copyPosition(camera.matrixWorld);
          };
          Object.defineProperty(boxMesh.material, "envMap", {
            get: function() {
              return this.uniforms.envMap.value;
            }
          });
          objects.update(boxMesh);
        }
        boxMesh.material.uniforms.envMap.value = background;
        boxMesh.material.uniforms.flipEnvMap.value = background.isCubeTexture && background.isRenderTargetTexture === false ? -1 : 1;
        if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
          boxMesh.material.needsUpdate = true;
          currentBackground = background;
          currentBackgroundVersion = background.version;
          currentTonemapping = renderer.toneMapping;
        }
        renderList.unshift(boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null);
      } else if (background && background.isTexture) {
        if (planeMesh === void 0) {
          planeMesh = new Mesh(
            new PlaneGeometry(2, 2),
            new ShaderMaterial({
              name: "BackgroundMaterial",
              uniforms: cloneUniforms(ShaderLib.background.uniforms),
              vertexShader: ShaderLib.background.vertexShader,
              fragmentShader: ShaderLib.background.fragmentShader,
              side: FrontSide,
              depthTest: false,
              depthWrite: false,
              fog: false
            })
          );
          planeMesh.geometry.deleteAttribute("normal");
          Object.defineProperty(planeMesh.material, "map", {
            get: function() {
              return this.uniforms.t2D.value;
            }
          });
          objects.update(planeMesh);
        }
        planeMesh.material.uniforms.t2D.value = background;
        if (background.matrixAutoUpdate === true) {
          background.updateMatrix();
        }
        planeMesh.material.uniforms.uvTransform.value.copy(background.matrix);
        if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
          planeMesh.material.needsUpdate = true;
          currentBackground = background;
          currentBackgroundVersion = background.version;
          currentTonemapping = renderer.toneMapping;
        }
        renderList.unshift(planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null);
      }
    }
    function setClear(color, alpha2) {
      state.buffers.color.setClear(color.r, color.g, color.b, alpha2, premultipliedAlpha);
    }
    return {
      getClearColor: function() {
        return clearColor;
      },
      setClearColor: function(color, alpha2 = 1) {
        clearColor.set(color);
        clearAlpha = alpha2;
        setClear(clearColor, clearAlpha);
      },
      getClearAlpha: function() {
        return clearAlpha;
      },
      setClearAlpha: function(alpha2) {
        clearAlpha = alpha2;
        setClear(clearColor, clearAlpha);
      },
      render
    };
  }
  function WebGLBindingStates(gl, extensions, attributes, capabilities) {
    const maxVertexAttributes = gl.getParameter(34921);
    const extension = capabilities.isWebGL2 ? null : extensions.get("OES_vertex_array_object");
    const vaoAvailable = capabilities.isWebGL2 || extension !== null;
    const bindingStates = {};
    const defaultState = createBindingState(null);
    let currentState = defaultState;
    let forceUpdate = false;
    function setup(object, material, program, geometry, index) {
      let updateBuffers = false;
      if (vaoAvailable) {
        const state = getBindingState(geometry, program, material);
        if (currentState !== state) {
          currentState = state;
          bindVertexArrayObject(currentState.object);
        }
        updateBuffers = needsUpdate(geometry, index);
        if (updateBuffers)
          saveCache(geometry, index);
      } else {
        const wireframe = material.wireframe === true;
        if (currentState.geometry !== geometry.id || currentState.program !== program.id || currentState.wireframe !== wireframe) {
          currentState.geometry = geometry.id;
          currentState.program = program.id;
          currentState.wireframe = wireframe;
          updateBuffers = true;
        }
      }
      if (object.isInstancedMesh === true) {
        updateBuffers = true;
      }
      if (index !== null) {
        attributes.update(index, 34963);
      }
      if (updateBuffers || forceUpdate) {
        forceUpdate = false;
        setupVertexAttributes(object, material, program, geometry);
        if (index !== null) {
          gl.bindBuffer(34963, attributes.get(index).buffer);
        }
      }
    }
    function createVertexArrayObject() {
      if (capabilities.isWebGL2)
        return gl.createVertexArray();
      return extension.createVertexArrayOES();
    }
    function bindVertexArrayObject(vao) {
      if (capabilities.isWebGL2)
        return gl.bindVertexArray(vao);
      return extension.bindVertexArrayOES(vao);
    }
    function deleteVertexArrayObject(vao) {
      if (capabilities.isWebGL2)
        return gl.deleteVertexArray(vao);
      return extension.deleteVertexArrayOES(vao);
    }
    function getBindingState(geometry, program, material) {
      const wireframe = material.wireframe === true;
      let programMap = bindingStates[geometry.id];
      if (programMap === void 0) {
        programMap = {};
        bindingStates[geometry.id] = programMap;
      }
      let stateMap = programMap[program.id];
      if (stateMap === void 0) {
        stateMap = {};
        programMap[program.id] = stateMap;
      }
      let state = stateMap[wireframe];
      if (state === void 0) {
        state = createBindingState(createVertexArrayObject());
        stateMap[wireframe] = state;
      }
      return state;
    }
    function createBindingState(vao) {
      const newAttributes = [];
      const enabledAttributes = [];
      const attributeDivisors = [];
      for (let i = 0; i < maxVertexAttributes; i++) {
        newAttributes[i] = 0;
        enabledAttributes[i] = 0;
        attributeDivisors[i] = 0;
      }
      return {
        // for backward compatibility on non-VAO support browser
        geometry: null,
        program: null,
        wireframe: false,
        newAttributes,
        enabledAttributes,
        attributeDivisors,
        object: vao,
        attributes: {},
        index: null
      };
    }
    function needsUpdate(geometry, index) {
      const cachedAttributes = currentState.attributes;
      const geometryAttributes = geometry.attributes;
      let attributesNum = 0;
      for (const key in geometryAttributes) {
        const cachedAttribute = cachedAttributes[key];
        const geometryAttribute = geometryAttributes[key];
        if (cachedAttribute === void 0)
          return true;
        if (cachedAttribute.attribute !== geometryAttribute)
          return true;
        if (cachedAttribute.data !== geometryAttribute.data)
          return true;
        attributesNum++;
      }
      if (currentState.attributesNum !== attributesNum)
        return true;
      if (currentState.index !== index)
        return true;
      return false;
    }
    function saveCache(geometry, index) {
      const cache = {};
      const attributes2 = geometry.attributes;
      let attributesNum = 0;
      for (const key in attributes2) {
        const attribute = attributes2[key];
        const data = {};
        data.attribute = attribute;
        if (attribute.data) {
          data.data = attribute.data;
        }
        cache[key] = data;
        attributesNum++;
      }
      currentState.attributes = cache;
      currentState.attributesNum = attributesNum;
      currentState.index = index;
    }
    function initAttributes() {
      const newAttributes = currentState.newAttributes;
      for (let i = 0, il = newAttributes.length; i < il; i++) {
        newAttributes[i] = 0;
      }
    }
    function enableAttribute(attribute) {
      enableAttributeAndDivisor(attribute, 0);
    }
    function enableAttributeAndDivisor(attribute, meshPerAttribute) {
      const newAttributes = currentState.newAttributes;
      const enabledAttributes = currentState.enabledAttributes;
      const attributeDivisors = currentState.attributeDivisors;
      newAttributes[attribute] = 1;
      if (enabledAttributes[attribute] === 0) {
        gl.enableVertexAttribArray(attribute);
        enabledAttributes[attribute] = 1;
      }
      if (attributeDivisors[attribute] !== meshPerAttribute) {
        const extension2 = capabilities.isWebGL2 ? gl : extensions.get("ANGLE_instanced_arrays");
        extension2[capabilities.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](attribute, meshPerAttribute);
        attributeDivisors[attribute] = meshPerAttribute;
      }
    }
    function disableUnusedAttributes() {
      const newAttributes = currentState.newAttributes;
      const enabledAttributes = currentState.enabledAttributes;
      for (let i = 0, il = enabledAttributes.length; i < il; i++) {
        if (enabledAttributes[i] !== newAttributes[i]) {
          gl.disableVertexAttribArray(i);
          enabledAttributes[i] = 0;
        }
      }
    }
    function vertexAttribPointer(index, size, type, normalized, stride, offset) {
      if (capabilities.isWebGL2 === true && (type === 5124 || type === 5125)) {
        gl.vertexAttribIPointer(index, size, type, stride, offset);
      } else {
        gl.vertexAttribPointer(index, size, type, normalized, stride, offset);
      }
    }
    function setupVertexAttributes(object, material, program, geometry) {
      if (capabilities.isWebGL2 === false && (object.isInstancedMesh || geometry.isInstancedBufferGeometry)) {
        if (extensions.get("ANGLE_instanced_arrays") === null)
          return;
      }
      initAttributes();
      const geometryAttributes = geometry.attributes;
      const programAttributes = program.getAttributes();
      const materialDefaultAttributeValues = material.defaultAttributeValues;
      for (const name in programAttributes) {
        const programAttribute = programAttributes[name];
        if (programAttribute.location >= 0) {
          let geometryAttribute = geometryAttributes[name];
          if (geometryAttribute === void 0) {
            if (name === "instanceMatrix" && object.instanceMatrix)
              geometryAttribute = object.instanceMatrix;
            if (name === "instanceColor" && object.instanceColor)
              geometryAttribute = object.instanceColor;
          }
          if (geometryAttribute !== void 0) {
            const normalized = geometryAttribute.normalized;
            const size = geometryAttribute.itemSize;
            const attribute = attributes.get(geometryAttribute);
            if (attribute === void 0)
              continue;
            const buffer = attribute.buffer;
            const type = attribute.type;
            const bytesPerElement = attribute.bytesPerElement;
            if (geometryAttribute.isInterleavedBufferAttribute) {
              const data = geometryAttribute.data;
              const stride = data.stride;
              const offset = geometryAttribute.offset;
              if (data.isInstancedInterleavedBuffer) {
                for (let i = 0; i < programAttribute.locationSize; i++) {
                  enableAttributeAndDivisor(programAttribute.location + i, data.meshPerAttribute);
                }
                if (object.isInstancedMesh !== true && geometry._maxInstanceCount === void 0) {
                  geometry._maxInstanceCount = data.meshPerAttribute * data.count;
                }
              } else {
                for (let i = 0; i < programAttribute.locationSize; i++) {
                  enableAttribute(programAttribute.location + i);
                }
              }
              gl.bindBuffer(34962, buffer);
              for (let i = 0; i < programAttribute.locationSize; i++) {
                vertexAttribPointer(
                  programAttribute.location + i,
                  size / programAttribute.locationSize,
                  type,
                  normalized,
                  stride * bytesPerElement,
                  (offset + size / programAttribute.locationSize * i) * bytesPerElement
                );
              }
            } else {
              if (geometryAttribute.isInstancedBufferAttribute) {
                for (let i = 0; i < programAttribute.locationSize; i++) {
                  enableAttributeAndDivisor(programAttribute.location + i, geometryAttribute.meshPerAttribute);
                }
                if (object.isInstancedMesh !== true && geometry._maxInstanceCount === void 0) {
                  geometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;
                }
              } else {
                for (let i = 0; i < programAttribute.locationSize; i++) {
                  enableAttribute(programAttribute.location + i);
                }
              }
              gl.bindBuffer(34962, buffer);
              for (let i = 0; i < programAttribute.locationSize; i++) {
                vertexAttribPointer(
                  programAttribute.location + i,
                  size / programAttribute.locationSize,
                  type,
                  normalized,
                  size * bytesPerElement,
                  size / programAttribute.locationSize * i * bytesPerElement
                );
              }
            }
          } else if (materialDefaultAttributeValues !== void 0) {
            const value = materialDefaultAttributeValues[name];
            if (value !== void 0) {
              switch (value.length) {
                case 2:
                  gl.vertexAttrib2fv(programAttribute.location, value);
                  break;
                case 3:
                  gl.vertexAttrib3fv(programAttribute.location, value);
                  break;
                case 4:
                  gl.vertexAttrib4fv(programAttribute.location, value);
                  break;
                default:
                  gl.vertexAttrib1fv(programAttribute.location, value);
              }
            }
          }
        }
      }
      disableUnusedAttributes();
    }
    function dispose() {
      reset();
      for (const geometryId in bindingStates) {
        const programMap = bindingStates[geometryId];
        for (const programId in programMap) {
          const stateMap = programMap[programId];
          for (const wireframe in stateMap) {
            deleteVertexArrayObject(stateMap[wireframe].object);
            delete stateMap[wireframe];
          }
          delete programMap[programId];
        }
        delete bindingStates[geometryId];
      }
    }
    function releaseStatesOfGeometry(geometry) {
      if (bindingStates[geometry.id] === void 0)
        return;
      const programMap = bindingStates[geometry.id];
      for (const programId in programMap) {
        const stateMap = programMap[programId];
        for (const wireframe in stateMap) {
          deleteVertexArrayObject(stateMap[wireframe].object);
          delete stateMap[wireframe];
        }
        delete programMap[programId];
      }
      delete bindingStates[geometry.id];
    }
    function releaseStatesOfProgram(program) {
      for (const geometryId in bindingStates) {
        const programMap = bindingStates[geometryId];
        if (programMap[program.id] === void 0)
          continue;
        const stateMap = programMap[program.id];
        for (const wireframe in stateMap) {
          deleteVertexArrayObject(stateMap[wireframe].object);
          delete stateMap[wireframe];
        }
        delete programMap[program.id];
      }
    }
    function reset() {
      resetDefaultState();
      forceUpdate = true;
      if (currentState === defaultState)
        return;
      currentState = defaultState;
      bindVertexArrayObject(currentState.object);
    }
    function resetDefaultState() {
      defaultState.geometry = null;
      defaultState.program = null;
      defaultState.wireframe = false;
    }
    return {
      setup,
      reset,
      resetDefaultState,
      dispose,
      releaseStatesOfGeometry,
      releaseStatesOfProgram,
      initAttributes,
      enableAttribute,
      disableUnusedAttributes
    };
  }
  function WebGLBufferRenderer(gl, extensions, info, capabilities) {
    const isWebGL2 = capabilities.isWebGL2;
    let mode;
    function setMode(value) {
      mode = value;
    }
    function render(start2, count) {
      gl.drawArrays(mode, start2, count);
      info.update(count, mode, 1);
    }
    function renderInstances(start2, count, primcount) {
      if (primcount === 0)
        return;
      let extension, methodName;
      if (isWebGL2) {
        extension = gl;
        methodName = "drawArraysInstanced";
      } else {
        extension = extensions.get("ANGLE_instanced_arrays");
        methodName = "drawArraysInstancedANGLE";
        if (extension === null) {
          console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
          return;
        }
      }
      extension[methodName](mode, start2, count, primcount);
      info.update(count, mode, primcount);
    }
    this.setMode = setMode;
    this.render = render;
    this.renderInstances = renderInstances;
  }
  function WebGLCapabilities(gl, extensions, parameters) {
    let maxAnisotropy;
    function getMaxAnisotropy() {
      if (maxAnisotropy !== void 0)
        return maxAnisotropy;
      if (extensions.has("EXT_texture_filter_anisotropic") === true) {
        const extension = extensions.get("EXT_texture_filter_anisotropic");
        maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
      } else {
        maxAnisotropy = 0;
      }
      return maxAnisotropy;
    }
    function getMaxPrecision(precision2) {
      if (precision2 === "highp") {
        if (gl.getShaderPrecisionFormat(35633, 36338).precision > 0 && gl.getShaderPrecisionFormat(35632, 36338).precision > 0) {
          return "highp";
        }
        precision2 = "mediump";
      }
      if (precision2 === "mediump") {
        if (gl.getShaderPrecisionFormat(35633, 36337).precision > 0 && gl.getShaderPrecisionFormat(35632, 36337).precision > 0) {
          return "mediump";
        }
      }
      return "lowp";
    }
    const isWebGL2 = typeof WebGL2RenderingContext !== "undefined" && gl instanceof WebGL2RenderingContext || typeof WebGL2ComputeRenderingContext !== "undefined" && gl instanceof WebGL2ComputeRenderingContext;
    let precision = parameters.precision !== void 0 ? parameters.precision : "highp";
    const maxPrecision = getMaxPrecision(precision);
    if (maxPrecision !== precision) {
      console.warn("THREE.WebGLRenderer:", precision, "not supported, using", maxPrecision, "instead.");
      precision = maxPrecision;
    }
    const drawBuffers = isWebGL2 || extensions.has("WEBGL_draw_buffers");
    const logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;
    const maxTextures = gl.getParameter(34930);
    const maxVertexTextures = gl.getParameter(35660);
    const maxTextureSize = gl.getParameter(3379);
    const maxCubemapSize = gl.getParameter(34076);
    const maxAttributes = gl.getParameter(34921);
    const maxVertexUniforms = gl.getParameter(36347);
    const maxVaryings = gl.getParameter(36348);
    const maxFragmentUniforms = gl.getParameter(36349);
    const vertexTextures = maxVertexTextures > 0;
    const floatFragmentTextures = isWebGL2 || extensions.has("OES_texture_float");
    const floatVertexTextures = vertexTextures && floatFragmentTextures;
    const maxSamples = isWebGL2 ? gl.getParameter(36183) : 0;
    return {
      isWebGL2,
      drawBuffers,
      getMaxAnisotropy,
      getMaxPrecision,
      precision,
      logarithmicDepthBuffer,
      maxTextures,
      maxVertexTextures,
      maxTextureSize,
      maxCubemapSize,
      maxAttributes,
      maxVertexUniforms,
      maxVaryings,
      maxFragmentUniforms,
      vertexTextures,
      floatFragmentTextures,
      floatVertexTextures,
      maxSamples
    };
  }
  function WebGLClipping(properties) {
    const scope = this;
    let globalState = null, numGlobalPlanes = 0, localClippingEnabled = false, renderingShadows = false;
    const plane = new Plane(), viewNormalMatrix = new Matrix3(), uniform = { value: null, needsUpdate: false };
    this.uniform = uniform;
    this.numPlanes = 0;
    this.numIntersection = 0;
    this.init = function(planes, enableLocalClipping, camera) {
      const enabled = planes.length !== 0 || enableLocalClipping || // enable state of previous frame - the clipping code has to
      // run another frame in order to reset the state:
      numGlobalPlanes !== 0 || localClippingEnabled;
      localClippingEnabled = enableLocalClipping;
      globalState = projectPlanes(planes, camera, 0);
      numGlobalPlanes = planes.length;
      return enabled;
    };
    this.beginShadows = function() {
      renderingShadows = true;
      projectPlanes(null);
    };
    this.endShadows = function() {
      renderingShadows = false;
      resetGlobalState();
    };
    this.setState = function(material, camera, useCache) {
      const planes = material.clippingPlanes, clipIntersection = material.clipIntersection, clipShadows = material.clipShadows;
      const materialProperties = properties.get(material);
      if (!localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && !clipShadows) {
        if (renderingShadows) {
          projectPlanes(null);
        } else {
          resetGlobalState();
        }
      } else {
        const nGlobal = renderingShadows ? 0 : numGlobalPlanes, lGlobal = nGlobal * 4;
        let dstArray = materialProperties.clippingState || null;
        uniform.value = dstArray;
        dstArray = projectPlanes(planes, camera, lGlobal, useCache);
        for (let i = 0; i !== lGlobal; ++i) {
          dstArray[i] = globalState[i];
        }
        materialProperties.clippingState = dstArray;
        this.numIntersection = clipIntersection ? this.numPlanes : 0;
        this.numPlanes += nGlobal;
      }
    };
    function resetGlobalState() {
      if (uniform.value !== globalState) {
        uniform.value = globalState;
        uniform.needsUpdate = numGlobalPlanes > 0;
      }
      scope.numPlanes = numGlobalPlanes;
      scope.numIntersection = 0;
    }
    function projectPlanes(planes, camera, dstOffset, skipTransform) {
      const nPlanes = planes !== null ? planes.length : 0;
      let dstArray = null;
      if (nPlanes !== 0) {
        dstArray = uniform.value;
        if (skipTransform !== true || dstArray === null) {
          const flatSize = dstOffset + nPlanes * 4, viewMatrix = camera.matrixWorldInverse;
          viewNormalMatrix.getNormalMatrix(viewMatrix);
          if (dstArray === null || dstArray.length < flatSize) {
            dstArray = new Float32Array(flatSize);
          }
          for (let i = 0, i4 = dstOffset; i !== nPlanes; ++i, i4 += 4) {
            plane.copy(planes[i]).applyMatrix4(viewMatrix, viewNormalMatrix);
            plane.normal.toArray(dstArray, i4);
            dstArray[i4 + 3] = plane.constant;
          }
        }
        uniform.value = dstArray;
        uniform.needsUpdate = true;
      }
      scope.numPlanes = nPlanes;
      scope.numIntersection = 0;
      return dstArray;
    }
  }
  function WebGLCubeMaps(renderer) {
    let cubemaps = /* @__PURE__ */ new WeakMap();
    function mapTextureMapping(texture, mapping) {
      if (mapping === EquirectangularReflectionMapping) {
        texture.mapping = CubeReflectionMapping;
      } else if (mapping === EquirectangularRefractionMapping) {
        texture.mapping = CubeRefractionMapping;
      }
      return texture;
    }
    function get(texture) {
      if (texture && texture.isTexture && texture.isRenderTargetTexture === false) {
        const mapping = texture.mapping;
        if (mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping) {
          if (cubemaps.has(texture)) {
            const cubemap = cubemaps.get(texture).texture;
            return mapTextureMapping(cubemap, texture.mapping);
          } else {
            const image = texture.image;
            if (image && image.height > 0) {
              const renderTarget = new WebGLCubeRenderTarget(image.height / 2);
              renderTarget.fromEquirectangularTexture(renderer, texture);
              cubemaps.set(texture, renderTarget);
              texture.addEventListener("dispose", onTextureDispose);
              return mapTextureMapping(renderTarget.texture, texture.mapping);
            } else {
              return null;
            }
          }
        }
      }
      return texture;
    }
    function onTextureDispose(event) {
      const texture = event.target;
      texture.removeEventListener("dispose", onTextureDispose);
      const cubemap = cubemaps.get(texture);
      if (cubemap !== void 0) {
        cubemaps.delete(texture);
        cubemap.dispose();
      }
    }
    function dispose() {
      cubemaps = /* @__PURE__ */ new WeakMap();
    }
    return {
      get,
      dispose
    };
  }
  var OrthographicCamera = class extends Camera {
    constructor(left = -1, right = 1, top = 1, bottom = -1, near = 0.1, far = 2e3) {
      super();
      this.type = "OrthographicCamera";
      this.zoom = 1;
      this.view = null;
      this.left = left;
      this.right = right;
      this.top = top;
      this.bottom = bottom;
      this.near = near;
      this.far = far;
      this.updateProjectionMatrix();
    }
    copy(source, recursive) {
      super.copy(source, recursive);
      this.left = source.left;
      this.right = source.right;
      this.top = source.top;
      this.bottom = source.bottom;
      this.near = source.near;
      this.far = source.far;
      this.zoom = source.zoom;
      this.view = source.view === null ? null : Object.assign({}, source.view);
      return this;
    }
    setViewOffset(fullWidth, fullHeight, x, y, width, height) {
      if (this.view === null) {
        this.view = {
          enabled: true,
          fullWidth: 1,
          fullHeight: 1,
          offsetX: 0,
          offsetY: 0,
          width: 1,
          height: 1
        };
      }
      this.view.enabled = true;
      this.view.fullWidth = fullWidth;
      this.view.fullHeight = fullHeight;
      this.view.offsetX = x;
      this.view.offsetY = y;
      this.view.width = width;
      this.view.height = height;
      this.updateProjectionMatrix();
    }
    clearViewOffset() {
      if (this.view !== null) {
        this.view.enabled = false;
      }
      this.updateProjectionMatrix();
    }
    updateProjectionMatrix() {
      const dx = (this.right - this.left) / (2 * this.zoom);
      const dy = (this.top - this.bottom) / (2 * this.zoom);
      const cx = (this.right + this.left) / 2;
      const cy = (this.top + this.bottom) / 2;
      let left = cx - dx;
      let right = cx + dx;
      let top = cy + dy;
      let bottom = cy - dy;
      if (this.view !== null && this.view.enabled) {
        const scaleW = (this.right - this.left) / this.view.fullWidth / this.zoom;
        const scaleH = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
        left += scaleW * this.view.offsetX;
        right = left + scaleW * this.view.width;
        top -= scaleH * this.view.offsetY;
        bottom = top - scaleH * this.view.height;
      }
      this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far);
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
    }
    toJSON(meta) {
      const data = super.toJSON(meta);
      data.object.zoom = this.zoom;
      data.object.left = this.left;
      data.object.right = this.right;
      data.object.top = this.top;
      data.object.bottom = this.bottom;
      data.object.near = this.near;
      data.object.far = this.far;
      if (this.view !== null)
        data.object.view = Object.assign({}, this.view);
      return data;
    }
  };
  OrthographicCamera.prototype.isOrthographicCamera = true;
  var LOD_MIN = 4;
  var EXTRA_LOD_SIGMA = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582];
  var MAX_SAMPLES = 20;
  var _flatCamera = /* @__PURE__ */ new OrthographicCamera();
  var _clearColor = /* @__PURE__ */ new Color();
  var _oldTarget = null;
  var PHI = (1 + Math.sqrt(5)) / 2;
  var INV_PHI = 1 / PHI;
  var _axisDirections = [
    /* @__PURE__ */ new Vector3(1, 1, 1),
    /* @__PURE__ */ new Vector3(-1, 1, 1),
    /* @__PURE__ */ new Vector3(1, 1, -1),
    /* @__PURE__ */ new Vector3(-1, 1, -1),
    /* @__PURE__ */ new Vector3(0, PHI, INV_PHI),
    /* @__PURE__ */ new Vector3(0, PHI, -INV_PHI),
    /* @__PURE__ */ new Vector3(INV_PHI, 0, PHI),
    /* @__PURE__ */ new Vector3(-INV_PHI, 0, PHI),
    /* @__PURE__ */ new Vector3(PHI, INV_PHI, 0),
    /* @__PURE__ */ new Vector3(-PHI, INV_PHI, 0)
  ];
  var PMREMGenerator = class {
    constructor(renderer) {
      this._renderer = renderer;
      this._pingPongRenderTarget = null;
      this._lodMax = 0;
      this._cubeSize = 0;
      this._lodPlanes = [];
      this._sizeLods = [];
      this._sigmas = [];
      this._blurMaterial = null;
      this._cubemapMaterial = null;
      this._equirectMaterial = null;
      this._compileMaterial(this._blurMaterial);
    }
    /**
     * Generates a PMREM from a supplied Scene, which can be faster than using an
     * image if networking bandwidth is low. Optional sigma specifies a blur radius
     * in radians to be applied to the scene before PMREM generation. Optional near
     * and far planes ensure the scene is rendered in its entirety (the cubeCamera
     * is placed at the origin).
     */
    fromScene(scene, sigma = 0, near = 0.1, far = 100) {
      _oldTarget = this._renderer.getRenderTarget();
      this._setSize(256);
      const cubeUVRenderTarget = this._allocateTargets();
      cubeUVRenderTarget.depthBuffer = true;
      this._sceneToCubeUV(scene, near, far, cubeUVRenderTarget);
      if (sigma > 0) {
        this._blur(cubeUVRenderTarget, 0, 0, sigma);
      }
      this._applyPMREM(cubeUVRenderTarget);
      this._cleanup(cubeUVRenderTarget);
      return cubeUVRenderTarget;
    }
    /**
     * Generates a PMREM from an equirectangular texture, which can be either LDR
     * or HDR. The ideal input image size is 1k (1024 x 512),
     * as this matches best with the 256 x 256 cubemap output.
     */
    fromEquirectangular(equirectangular, renderTarget = null) {
      return this._fromTexture(equirectangular, renderTarget);
    }
    /**
     * Generates a PMREM from an cubemap texture, which can be either LDR
     * or HDR. The ideal input cube size is 256 x 256,
     * as this matches best with the 256 x 256 cubemap output.
     */
    fromCubemap(cubemap, renderTarget = null) {
      return this._fromTexture(cubemap, renderTarget);
    }
    /**
     * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
     * your texture's network fetch for increased concurrency.
     */
    compileCubemapShader() {
      if (this._cubemapMaterial === null) {
        this._cubemapMaterial = _getCubemapMaterial();
        this._compileMaterial(this._cubemapMaterial);
      }
    }
    /**
     * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
     * your texture's network fetch for increased concurrency.
     */
    compileEquirectangularShader() {
      if (this._equirectMaterial === null) {
        this._equirectMaterial = _getEquirectMaterial();
        this._compileMaterial(this._equirectMaterial);
      }
    }
    /**
     * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
     * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
     * one of them will cause any others to also become unusable.
     */
    dispose() {
      this._dispose();
      if (this._cubemapMaterial !== null)
        this._cubemapMaterial.dispose();
      if (this._equirectMaterial !== null)
        this._equirectMaterial.dispose();
    }
    // private interface
    _setSize(cubeSize) {
      this._lodMax = Math.floor(Math.log2(cubeSize));
      this._cubeSize = Math.pow(2, this._lodMax);
    }
    _dispose() {
      if (this._blurMaterial !== null)
        this._blurMaterial.dispose();
      if (this._pingPongRenderTarget !== null)
        this._pingPongRenderTarget.dispose();
      for (let i = 0; i < this._lodPlanes.length; i++) {
        this._lodPlanes[i].dispose();
      }
    }
    _cleanup(outputTarget) {
      this._renderer.setRenderTarget(_oldTarget);
      outputTarget.scissorTest = false;
      _setViewport(outputTarget, 0, 0, outputTarget.width, outputTarget.height);
    }
    _fromTexture(texture, renderTarget) {
      if (texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping) {
        this._setSize(texture.image.length === 0 ? 16 : texture.image[0].width || texture.image[0].image.width);
      } else {
        this._setSize(texture.image.width / 4);
      }
      _oldTarget = this._renderer.getRenderTarget();
      const cubeUVRenderTarget = renderTarget || this._allocateTargets();
      this._textureToCubeUV(texture, cubeUVRenderTarget);
      this._applyPMREM(cubeUVRenderTarget);
      this._cleanup(cubeUVRenderTarget);
      return cubeUVRenderTarget;
    }
    _allocateTargets() {
      const width = 3 * Math.max(this._cubeSize, 16 * 7);
      const height = 4 * this._cubeSize - 32;
      const params = {
        magFilter: LinearFilter,
        minFilter: LinearFilter,
        generateMipmaps: false,
        type: HalfFloatType,
        format: RGBAFormat,
        encoding: LinearEncoding,
        depthBuffer: false
      };
      const cubeUVRenderTarget = _createRenderTarget(width, height, params);
      if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== width) {
        if (this._pingPongRenderTarget !== null) {
          this._dispose();
        }
        this._pingPongRenderTarget = _createRenderTarget(width, height, params);
        const { _lodMax } = this;
        ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = _createPlanes(_lodMax));
        this._blurMaterial = _getBlurShader(_lodMax, width, height);
      }
      return cubeUVRenderTarget;
    }
    _compileMaterial(material) {
      const tmpMesh = new Mesh(this._lodPlanes[0], material);
      this._renderer.compile(tmpMesh, _flatCamera);
    }
    _sceneToCubeUV(scene, near, far, cubeUVRenderTarget) {
      const fov2 = 90;
      const aspect2 = 1;
      const cubeCamera = new PerspectiveCamera(fov2, aspect2, near, far);
      const upSign = [1, -1, 1, 1, 1, 1];
      const forwardSign = [1, 1, 1, -1, -1, -1];
      const renderer = this._renderer;
      const originalAutoClear = renderer.autoClear;
      const toneMapping = renderer.toneMapping;
      renderer.getClearColor(_clearColor);
      renderer.toneMapping = NoToneMapping;
      renderer.autoClear = false;
      const backgroundMaterial = new MeshBasicMaterial({
        name: "PMREM.Background",
        side: BackSide,
        depthWrite: false,
        depthTest: false
      });
      const backgroundBox = new Mesh(new BoxGeometry(), backgroundMaterial);
      let useSolidColor = false;
      const background = scene.background;
      if (background) {
        if (background.isColor) {
          backgroundMaterial.color.copy(background);
          scene.background = null;
          useSolidColor = true;
        }
      } else {
        backgroundMaterial.color.copy(_clearColor);
        useSolidColor = true;
      }
      for (let i = 0; i < 6; i++) {
        const col = i % 3;
        if (col === 0) {
          cubeCamera.up.set(0, upSign[i], 0);
          cubeCamera.lookAt(forwardSign[i], 0, 0);
        } else if (col === 1) {
          cubeCamera.up.set(0, 0, upSign[i]);
          cubeCamera.lookAt(0, forwardSign[i], 0);
        } else {
          cubeCamera.up.set(0, upSign[i], 0);
          cubeCamera.lookAt(0, 0, forwardSign[i]);
        }
        const size = this._cubeSize;
        _setViewport(cubeUVRenderTarget, col * size, i > 2 ? size : 0, size, size);
        renderer.setRenderTarget(cubeUVRenderTarget);
        if (useSolidColor) {
          renderer.render(backgroundBox, cubeCamera);
        }
        renderer.render(scene, cubeCamera);
      }
      backgroundBox.geometry.dispose();
      backgroundBox.material.dispose();
      renderer.toneMapping = toneMapping;
      renderer.autoClear = originalAutoClear;
      scene.background = background;
    }
    _textureToCubeUV(texture, cubeUVRenderTarget) {
      const renderer = this._renderer;
      const isCubeTexture = texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping;
      if (isCubeTexture) {
        if (this._cubemapMaterial === null) {
          this._cubemapMaterial = _getCubemapMaterial();
        }
        this._cubemapMaterial.uniforms.flipEnvMap.value = texture.isRenderTargetTexture === false ? -1 : 1;
      } else {
        if (this._equirectMaterial === null) {
          this._equirectMaterial = _getEquirectMaterial();
        }
      }
      const material = isCubeTexture ? this._cubemapMaterial : this._equirectMaterial;
      const mesh = new Mesh(this._lodPlanes[0], material);
      const uniforms = material.uniforms;
      uniforms["envMap"].value = texture;
      const size = this._cubeSize;
      _setViewport(cubeUVRenderTarget, 0, 0, 3 * size, 2 * size);
      renderer.setRenderTarget(cubeUVRenderTarget);
      renderer.render(mesh, _flatCamera);
    }
    _applyPMREM(cubeUVRenderTarget) {
      const renderer = this._renderer;
      const autoClear = renderer.autoClear;
      renderer.autoClear = false;
      for (let i = 1; i < this._lodPlanes.length; i++) {
        const sigma = Math.sqrt(this._sigmas[i] * this._sigmas[i] - this._sigmas[i - 1] * this._sigmas[i - 1]);
        const poleAxis = _axisDirections[(i - 1) % _axisDirections.length];
        this._blur(cubeUVRenderTarget, i - 1, i, sigma, poleAxis);
      }
      renderer.autoClear = autoClear;
    }
    /**
     * This is a two-pass Gaussian blur for a cubemap. Normally this is done
     * vertically and horizontally, but this breaks down on a cube. Here we apply
     * the blur latitudinally (around the poles), and then longitudinally (towards
     * the poles) to approximate the orthogonally-separable blur. It is least
     * accurate at the poles, but still does a decent job.
     */
    _blur(cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis) {
      const pingPongRenderTarget = this._pingPongRenderTarget;
      this._halfBlur(
        cubeUVRenderTarget,
        pingPongRenderTarget,
        lodIn,
        lodOut,
        sigma,
        "latitudinal",
        poleAxis
      );
      this._halfBlur(
        pingPongRenderTarget,
        cubeUVRenderTarget,
        lodOut,
        lodOut,
        sigma,
        "longitudinal",
        poleAxis
      );
    }
    _halfBlur(targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis) {
      const renderer = this._renderer;
      const blurMaterial = this._blurMaterial;
      if (direction !== "latitudinal" && direction !== "longitudinal") {
        console.error(
          "blur direction must be either latitudinal or longitudinal!"
        );
      }
      const STANDARD_DEVIATIONS = 3;
      const blurMesh = new Mesh(this._lodPlanes[lodOut], blurMaterial);
      const blurUniforms = blurMaterial.uniforms;
      const pixels = this._sizeLods[lodIn] - 1;
      const radiansPerPixel = isFinite(sigmaRadians) ? Math.PI / (2 * pixels) : 2 * Math.PI / (2 * MAX_SAMPLES - 1);
      const sigmaPixels = sigmaRadians / radiansPerPixel;
      const samples = isFinite(sigmaRadians) ? 1 + Math.floor(STANDARD_DEVIATIONS * sigmaPixels) : MAX_SAMPLES;
      if (samples > MAX_SAMPLES) {
        console.warn(`sigmaRadians, ${sigmaRadians}, is too large and will clip, as it requested ${samples} samples when the maximum is set to ${MAX_SAMPLES}`);
      }
      const weights = [];
      let sum = 0;
      for (let i = 0; i < MAX_SAMPLES; ++i) {
        const x2 = i / sigmaPixels;
        const weight = Math.exp(-x2 * x2 / 2);
        weights.push(weight);
        if (i === 0) {
          sum += weight;
        } else if (i < samples) {
          sum += 2 * weight;
        }
      }
      for (let i = 0; i < weights.length; i++) {
        weights[i] = weights[i] / sum;
      }
      blurUniforms["envMap"].value = targetIn.texture;
      blurUniforms["samples"].value = samples;
      blurUniforms["weights"].value = weights;
      blurUniforms["latitudinal"].value = direction === "latitudinal";
      if (poleAxis) {
        blurUniforms["poleAxis"].value = poleAxis;
      }
      const { _lodMax } = this;
      blurUniforms["dTheta"].value = radiansPerPixel;
      blurUniforms["mipInt"].value = _lodMax - lodIn;
      const outputSize = this._sizeLods[lodOut];
      const x = 3 * outputSize * (lodOut > _lodMax - LOD_MIN ? lodOut - _lodMax + LOD_MIN : 0);
      const y = 4 * (this._cubeSize - outputSize);
      _setViewport(targetOut, x, y, 3 * outputSize, 2 * outputSize);
      renderer.setRenderTarget(targetOut);
      renderer.render(blurMesh, _flatCamera);
    }
  };
  function _createPlanes(lodMax) {
    const lodPlanes = [];
    const sizeLods = [];
    const sigmas = [];
    let lod = lodMax;
    const totalLods = lodMax - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;
    for (let i = 0; i < totalLods; i++) {
      const sizeLod = Math.pow(2, lod);
      sizeLods.push(sizeLod);
      let sigma = 1 / sizeLod;
      if (i > lodMax - LOD_MIN) {
        sigma = EXTRA_LOD_SIGMA[i - lodMax + LOD_MIN - 1];
      } else if (i === 0) {
        sigma = 0;
      }
      sigmas.push(sigma);
      const texelSize = 1 / (sizeLod - 1);
      const min = -texelSize / 2;
      const max = 1 + texelSize / 2;
      const uv1 = [min, min, max, min, max, max, min, min, max, max, min, max];
      const cubeFaces = 6;
      const vertices = 6;
      const positionSize = 3;
      const uvSize = 2;
      const faceIndexSize = 1;
      const position = new Float32Array(positionSize * vertices * cubeFaces);
      const uv = new Float32Array(uvSize * vertices * cubeFaces);
      const faceIndex = new Float32Array(faceIndexSize * vertices * cubeFaces);
      for (let face = 0; face < cubeFaces; face++) {
        const x = face % 3 * 2 / 3 - 1;
        const y = face > 2 ? 0 : -1;
        const coordinates = [
          x,
          y,
          0,
          x + 2 / 3,
          y,
          0,
          x + 2 / 3,
          y + 1,
          0,
          x,
          y,
          0,
          x + 2 / 3,
          y + 1,
          0,
          x,
          y + 1,
          0
        ];
        position.set(coordinates, positionSize * vertices * face);
        uv.set(uv1, uvSize * vertices * face);
        const fill = [face, face, face, face, face, face];
        faceIndex.set(fill, faceIndexSize * vertices * face);
      }
      const planes = new BufferGeometry();
      planes.setAttribute("position", new BufferAttribute(position, positionSize));
      planes.setAttribute("uv", new BufferAttribute(uv, uvSize));
      planes.setAttribute("faceIndex", new BufferAttribute(faceIndex, faceIndexSize));
      lodPlanes.push(planes);
      if (lod > LOD_MIN) {
        lod--;
      }
    }
    return { lodPlanes, sizeLods, sigmas };
  }
  function _createRenderTarget(width, height, params) {
    const cubeUVRenderTarget = new WebGLRenderTarget(width, height, params);
    cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;
    cubeUVRenderTarget.texture.name = "PMREM.cubeUv";
    cubeUVRenderTarget.scissorTest = true;
    return cubeUVRenderTarget;
  }
  function _setViewport(target, x, y, width, height) {
    target.viewport.set(x, y, width, height);
    target.scissor.set(x, y, width, height);
  }
  function _getBlurShader(lodMax, width, height) {
    const weights = new Float32Array(MAX_SAMPLES);
    const poleAxis = new Vector3(0, 1, 0);
    const shaderMaterial = new ShaderMaterial({
      name: "SphericalGaussianBlur",
      defines: {
        "n": MAX_SAMPLES,
        "CUBEUV_TEXEL_WIDTH": 1 / width,
        "CUBEUV_TEXEL_HEIGHT": 1 / height,
        "CUBEUV_MAX_MIP": `${lodMax}.0`
      },
      uniforms: {
        "envMap": { value: null },
        "samples": { value: 1 },
        "weights": { value: weights },
        "latitudinal": { value: false },
        "dTheta": { value: 0 },
        "mipInt": { value: 0 },
        "poleAxis": { value: poleAxis }
      },
      vertexShader: _getCommonVertexShader(),
      fragmentShader: (
        /* glsl */
        `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`
      ),
      blending: NoBlending,
      depthTest: false,
      depthWrite: false
    });
    return shaderMaterial;
  }
  function _getEquirectMaterial() {
    return new ShaderMaterial({
      name: "EquirectangularToCubeUV",
      uniforms: {
        "envMap": { value: null }
      },
      vertexShader: _getCommonVertexShader(),
      fragmentShader: (
        /* glsl */
        `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`
      ),
      blending: NoBlending,
      depthTest: false,
      depthWrite: false
    });
  }
  function _getCubemapMaterial() {
    return new ShaderMaterial({
      name: "CubemapToCubeUV",
      uniforms: {
        "envMap": { value: null },
        "flipEnvMap": { value: -1 }
      },
      vertexShader: _getCommonVertexShader(),
      fragmentShader: (
        /* glsl */
        `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`
      ),
      blending: NoBlending,
      depthTest: false,
      depthWrite: false
    });
  }
  function _getCommonVertexShader() {
    return (
      /* glsl */
      `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
    );
  }
  function WebGLCubeUVMaps(renderer) {
    let cubeUVmaps = /* @__PURE__ */ new WeakMap();
    let pmremGenerator = null;
    function get(texture) {
      if (texture && texture.isTexture) {
        const mapping = texture.mapping;
        const isEquirectMap = mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping;
        const isCubeMap = mapping === CubeReflectionMapping || mapping === CubeRefractionMapping;
        if (isEquirectMap || isCubeMap) {
          if (texture.isRenderTargetTexture && texture.needsPMREMUpdate === true) {
            texture.needsPMREMUpdate = false;
            let renderTarget = cubeUVmaps.get(texture);
            if (pmremGenerator === null)
              pmremGenerator = new PMREMGenerator(renderer);
            renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular(texture, renderTarget) : pmremGenerator.fromCubemap(texture, renderTarget);
            cubeUVmaps.set(texture, renderTarget);
            return renderTarget.texture;
          } else {
            if (cubeUVmaps.has(texture)) {
              return cubeUVmaps.get(texture).texture;
            } else {
              const image = texture.image;
              if (isEquirectMap && image && image.height > 0 || isCubeMap && image && isCubeTextureComplete(image)) {
                if (pmremGenerator === null)
                  pmremGenerator = new PMREMGenerator(renderer);
                const renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular(texture) : pmremGenerator.fromCubemap(texture);
                cubeUVmaps.set(texture, renderTarget);
                texture.addEventListener("dispose", onTextureDispose);
                return renderTarget.texture;
              } else {
                return null;
              }
            }
          }
        }
      }
      return texture;
    }
    function isCubeTextureComplete(image) {
      let count = 0;
      const length = 6;
      for (let i = 0; i < length; i++) {
        if (image[i] !== void 0)
          count++;
      }
      return count === length;
    }
    function onTextureDispose(event) {
      const texture = event.target;
      texture.removeEventListener("dispose", onTextureDispose);
      const cubemapUV = cubeUVmaps.get(texture);
      if (cubemapUV !== void 0) {
        cubeUVmaps.delete(texture);
        cubemapUV.dispose();
      }
    }
    function dispose() {
      cubeUVmaps = /* @__PURE__ */ new WeakMap();
      if (pmremGenerator !== null) {
        pmremGenerator.dispose();
        pmremGenerator = null;
      }
    }
    return {
      get,
      dispose
    };
  }
  function WebGLExtensions(gl) {
    const extensions = {};
    function getExtension2(name) {
      if (extensions[name] !== void 0) {
        return extensions[name];
      }
      let extension;
      switch (name) {
        case "WEBGL_depth_texture":
          extension = gl.getExtension("WEBGL_depth_texture") || gl.getExtension("MOZ_WEBGL_depth_texture") || gl.getExtension("WEBKIT_WEBGL_depth_texture");
          break;
        case "EXT_texture_filter_anisotropic":
          extension = gl.getExtension("EXT_texture_filter_anisotropic") || gl.getExtension("MOZ_EXT_texture_filter_anisotropic") || gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
          break;
        case "WEBGL_compressed_texture_s3tc":
          extension = gl.getExtension("WEBGL_compressed_texture_s3tc") || gl.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
          break;
        case "WEBGL_compressed_texture_pvrtc":
          extension = gl.getExtension("WEBGL_compressed_texture_pvrtc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
          break;
        default:
          extension = gl.getExtension(name);
      }
      extensions[name] = extension;
      return extension;
    }
    return {
      has: function(name) {
        return getExtension2(name) !== null;
      },
      init: function(capabilities) {
        if (capabilities.isWebGL2) {
          getExtension2("EXT_color_buffer_float");
        } else {
          getExtension2("WEBGL_depth_texture");
          getExtension2("OES_texture_float");
          getExtension2("OES_texture_half_float");
          getExtension2("OES_texture_half_float_linear");
          getExtension2("OES_standard_derivatives");
          getExtension2("OES_element_index_uint");
          getExtension2("OES_vertex_array_object");
          getExtension2("ANGLE_instanced_arrays");
        }
        getExtension2("OES_texture_float_linear");
        getExtension2("EXT_color_buffer_half_float");
        getExtension2("WEBGL_multisampled_render_to_texture");
      },
      get: function(name) {
        const extension = getExtension2(name);
        if (extension === null) {
          console.warn("THREE.WebGLRenderer: " + name + " extension not supported.");
        }
        return extension;
      }
    };
  }
  function WebGLGeometries(gl, attributes, info, bindingStates) {
    const geometries = {};
    const wireframeAttributes = /* @__PURE__ */ new WeakMap();
    function onGeometryDispose(event) {
      const geometry = event.target;
      if (geometry.index !== null) {
        attributes.remove(geometry.index);
      }
      for (const name in geometry.attributes) {
        attributes.remove(geometry.attributes[name]);
      }
      geometry.removeEventListener("dispose", onGeometryDispose);
      delete geometries[geometry.id];
      const attribute = wireframeAttributes.get(geometry);
      if (attribute) {
        attributes.remove(attribute);
        wireframeAttributes.delete(geometry);
      }
      bindingStates.releaseStatesOfGeometry(geometry);
      if (geometry.isInstancedBufferGeometry === true) {
        delete geometry._maxInstanceCount;
      }
      info.memory.geometries--;
    }
    function get(object, geometry) {
      if (geometries[geometry.id] === true)
        return geometry;
      geometry.addEventListener("dispose", onGeometryDispose);
      geometries[geometry.id] = true;
      info.memory.geometries++;
      return geometry;
    }
    function update(geometry) {
      const geometryAttributes = geometry.attributes;
      for (const name in geometryAttributes) {
        attributes.update(geometryAttributes[name], 34962);
      }
      const morphAttributes = geometry.morphAttributes;
      for (const name in morphAttributes) {
        const array = morphAttributes[name];
        for (let i = 0, l = array.length; i < l; i++) {
          attributes.update(array[i], 34962);
        }
      }
    }
    function updateWireframeAttribute(geometry) {
      const indices = [];
      const geometryIndex = geometry.index;
      const geometryPosition = geometry.attributes.position;
      let version = 0;
      if (geometryIndex !== null) {
        const array = geometryIndex.array;
        version = geometryIndex.version;
        for (let i = 0, l = array.length; i < l; i += 3) {
          const a = array[i + 0];
          const b = array[i + 1];
          const c = array[i + 2];
          indices.push(a, b, b, c, c, a);
        }
      } else {
        const array = geometryPosition.array;
        version = geometryPosition.version;
        for (let i = 0, l = array.length / 3 - 1; i < l; i += 3) {
          const a = i + 0;
          const b = i + 1;
          const c = i + 2;
          indices.push(a, b, b, c, c, a);
        }
      }
      const attribute = new (arrayNeedsUint32(indices) ? Uint32BufferAttribute : Uint16BufferAttribute)(indices, 1);
      attribute.version = version;
      const previousAttribute = wireframeAttributes.get(geometry);
      if (previousAttribute)
        attributes.remove(previousAttribute);
      wireframeAttributes.set(geometry, attribute);
    }
    function getWireframeAttribute(geometry) {
      const currentAttribute = wireframeAttributes.get(geometry);
      if (currentAttribute) {
        const geometryIndex = geometry.index;
        if (geometryIndex !== null) {
          if (currentAttribute.version < geometryIndex.version) {
            updateWireframeAttribute(geometry);
          }
        }
      } else {
        updateWireframeAttribute(geometry);
      }
      return wireframeAttributes.get(geometry);
    }
    return {
      get,
      update,
      getWireframeAttribute
    };
  }
  function WebGLIndexedBufferRenderer(gl, extensions, info, capabilities) {
    const isWebGL2 = capabilities.isWebGL2;
    let mode;
    function setMode(value) {
      mode = value;
    }
    let type, bytesPerElement;
    function setIndex(value) {
      type = value.type;
      bytesPerElement = value.bytesPerElement;
    }
    function render(start2, count) {
      gl.drawElements(mode, count, type, start2 * bytesPerElement);
      info.update(count, mode, 1);
    }
    function renderInstances(start2, count, primcount) {
      if (primcount === 0)
        return;
      let extension, methodName;
      if (isWebGL2) {
        extension = gl;
        methodName = "drawElementsInstanced";
      } else {
        extension = extensions.get("ANGLE_instanced_arrays");
        methodName = "drawElementsInstancedANGLE";
        if (extension === null) {
          console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
          return;
        }
      }
      extension[methodName](mode, count, type, start2 * bytesPerElement, primcount);
      info.update(count, mode, primcount);
    }
    this.setMode = setMode;
    this.setIndex = setIndex;
    this.render = render;
    this.renderInstances = renderInstances;
  }
  function WebGLInfo(gl) {
    const memory = {
      geometries: 0,
      textures: 0
    };
    const render = {
      frame: 0,
      calls: 0,
      triangles: 0,
      points: 0,
      lines: 0
    };
    function update(count, mode, instanceCount) {
      render.calls++;
      switch (mode) {
        case 4:
          render.triangles += instanceCount * (count / 3);
          break;
        case 1:
          render.lines += instanceCount * (count / 2);
          break;
        case 3:
          render.lines += instanceCount * (count - 1);
          break;
        case 2:
          render.lines += instanceCount * count;
          break;
        case 0:
          render.points += instanceCount * count;
          break;
        default:
          console.error("THREE.WebGLInfo: Unknown draw mode:", mode);
          break;
      }
    }
    function reset() {
      render.frame++;
      render.calls = 0;
      render.triangles = 0;
      render.points = 0;
      render.lines = 0;
    }
    return {
      memory,
      render,
      programs: null,
      autoReset: true,
      reset,
      update
    };
  }
  function numericalSort(a, b) {
    return a[0] - b[0];
  }
  function absNumericalSort(a, b) {
    return Math.abs(b[1]) - Math.abs(a[1]);
  }
  function denormalize(morph, attribute) {
    let denominator = 1;
    const array = attribute.isInterleavedBufferAttribute ? attribute.data.array : attribute.array;
    if (array instanceof Int8Array)
      denominator = 127;
    else if (array instanceof Int16Array)
      denominator = 32767;
    else if (array instanceof Int32Array)
      denominator = 2147483647;
    else
      console.error("THREE.WebGLMorphtargets: Unsupported morph attribute data type: ", array);
    morph.divideScalar(denominator);
  }
  function WebGLMorphtargets(gl, capabilities, textures) {
    const influencesList = {};
    const morphInfluences = new Float32Array(8);
    const morphTextures = /* @__PURE__ */ new WeakMap();
    const morph = new Vector4();
    const workInfluences = [];
    for (let i = 0; i < 8; i++) {
      workInfluences[i] = [i, 0];
    }
    function update(object, geometry, material, program) {
      const objectInfluences = object.morphTargetInfluences;
      if (capabilities.isWebGL2 === true) {
        const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
        const morphTargetsCount = morphAttribute !== void 0 ? morphAttribute.length : 0;
        let entry = morphTextures.get(geometry);
        if (entry === void 0 || entry.count !== morphTargetsCount) {
          let disposeTexture = function() {
            texture.dispose();
            morphTextures.delete(geometry);
            geometry.removeEventListener("dispose", disposeTexture);
          };
          if (entry !== void 0)
            entry.texture.dispose();
          const hasMorphPosition = geometry.morphAttributes.position !== void 0;
          const hasMorphNormals = geometry.morphAttributes.normal !== void 0;
          const hasMorphColors = geometry.morphAttributes.color !== void 0;
          const morphTargets = geometry.morphAttributes.position || [];
          const morphNormals = geometry.morphAttributes.normal || [];
          const morphColors = geometry.morphAttributes.color || [];
          let vertexDataCount = 0;
          if (hasMorphPosition === true)
            vertexDataCount = 1;
          if (hasMorphNormals === true)
            vertexDataCount = 2;
          if (hasMorphColors === true)
            vertexDataCount = 3;
          let width = geometry.attributes.position.count * vertexDataCount;
          let height = 1;
          if (width > capabilities.maxTextureSize) {
            height = Math.ceil(width / capabilities.maxTextureSize);
            width = capabilities.maxTextureSize;
          }
          const buffer = new Float32Array(width * height * 4 * morphTargetsCount);
          const texture = new DataArrayTexture(buffer, width, height, morphTargetsCount);
          texture.type = FloatType;
          texture.needsUpdate = true;
          const vertexDataStride = vertexDataCount * 4;
          for (let i = 0; i < morphTargetsCount; i++) {
            const morphTarget = morphTargets[i];
            const morphNormal = morphNormals[i];
            const morphColor = morphColors[i];
            const offset = width * height * 4 * i;
            for (let j = 0; j < morphTarget.count; j++) {
              const stride = j * vertexDataStride;
              if (hasMorphPosition === true) {
                morph.fromBufferAttribute(morphTarget, j);
                if (morphTarget.normalized === true)
                  denormalize(morph, morphTarget);
                buffer[offset + stride + 0] = morph.x;
                buffer[offset + stride + 1] = morph.y;
                buffer[offset + stride + 2] = morph.z;
                buffer[offset + stride + 3] = 0;
              }
              if (hasMorphNormals === true) {
                morph.fromBufferAttribute(morphNormal, j);
                if (morphNormal.normalized === true)
                  denormalize(morph, morphNormal);
                buffer[offset + stride + 4] = morph.x;
                buffer[offset + stride + 5] = morph.y;
                buffer[offset + stride + 6] = morph.z;
                buffer[offset + stride + 7] = 0;
              }
              if (hasMorphColors === true) {
                morph.fromBufferAttribute(morphColor, j);
                if (morphColor.normalized === true)
                  denormalize(morph, morphColor);
                buffer[offset + stride + 8] = morph.x;
                buffer[offset + stride + 9] = morph.y;
                buffer[offset + stride + 10] = morph.z;
                buffer[offset + stride + 11] = morphColor.itemSize === 4 ? morph.w : 1;
              }
            }
          }
          entry = {
            count: morphTargetsCount,
            texture,
            size: new Vector2(width, height)
          };
          morphTextures.set(geometry, entry);
          geometry.addEventListener("dispose", disposeTexture);
        }
        let morphInfluencesSum = 0;
        for (let i = 0; i < objectInfluences.length; i++) {
          morphInfluencesSum += objectInfluences[i];
        }
        const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
        program.getUniforms().setValue(gl, "morphTargetBaseInfluence", morphBaseInfluence);
        program.getUniforms().setValue(gl, "morphTargetInfluences", objectInfluences);
        program.getUniforms().setValue(gl, "morphTargetsTexture", entry.texture, textures);
        program.getUniforms().setValue(gl, "morphTargetsTextureSize", entry.size);
      } else {
        const length = objectInfluences === void 0 ? 0 : objectInfluences.length;
        let influences = influencesList[geometry.id];
        if (influences === void 0 || influences.length !== length) {
          influences = [];
          for (let i = 0; i < length; i++) {
            influences[i] = [i, 0];
          }
          influencesList[geometry.id] = influences;
        }
        for (let i = 0; i < length; i++) {
          const influence = influences[i];
          influence[0] = i;
          influence[1] = objectInfluences[i];
        }
        influences.sort(absNumericalSort);
        for (let i = 0; i < 8; i++) {
          if (i < length && influences[i][1]) {
            workInfluences[i][0] = influences[i][0];
            workInfluences[i][1] = influences[i][1];
          } else {
            workInfluences[i][0] = Number.MAX_SAFE_INTEGER;
            workInfluences[i][1] = 0;
          }
        }
        workInfluences.sort(numericalSort);
        const morphTargets = geometry.morphAttributes.position;
        const morphNormals = geometry.morphAttributes.normal;
        let morphInfluencesSum = 0;
        for (let i = 0; i < 8; i++) {
          const influence = workInfluences[i];
          const index = influence[0];
          const value = influence[1];
          if (index !== Number.MAX_SAFE_INTEGER && value) {
            if (morphTargets && geometry.getAttribute("morphTarget" + i) !== morphTargets[index]) {
              geometry.setAttribute("morphTarget" + i, morphTargets[index]);
            }
            if (morphNormals && geometry.getAttribute("morphNormal" + i) !== morphNormals[index]) {
              geometry.setAttribute("morphNormal" + i, morphNormals[index]);
            }
            morphInfluences[i] = value;
            morphInfluencesSum += value;
          } else {
            if (morphTargets && geometry.hasAttribute("morphTarget" + i) === true) {
              geometry.deleteAttribute("morphTarget" + i);
            }
            if (morphNormals && geometry.hasAttribute("morphNormal" + i) === true) {
              geometry.deleteAttribute("morphNormal" + i);
            }
            morphInfluences[i] = 0;
          }
        }
        const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
        program.getUniforms().setValue(gl, "morphTargetBaseInfluence", morphBaseInfluence);
        program.getUniforms().setValue(gl, "morphTargetInfluences", morphInfluences);
      }
    }
    return {
      update
    };
  }
  function WebGLObjects(gl, geometries, attributes, info) {
    let updateMap = /* @__PURE__ */ new WeakMap();
    function update(object) {
      const frame = info.render.frame;
      const geometry = object.geometry;
      const buffergeometry = geometries.get(object, geometry);
      if (updateMap.get(buffergeometry) !== frame) {
        geometries.update(buffergeometry);
        updateMap.set(buffergeometry, frame);
      }
      if (object.isInstancedMesh) {
        if (object.hasEventListener("dispose", onInstancedMeshDispose) === false) {
          object.addEventListener("dispose", onInstancedMeshDispose);
        }
        attributes.update(object.instanceMatrix, 34962);
        if (object.instanceColor !== null) {
          attributes.update(object.instanceColor, 34962);
        }
      }
      return buffergeometry;
    }
    function dispose() {
      updateMap = /* @__PURE__ */ new WeakMap();
    }
    function onInstancedMeshDispose(event) {
      const instancedMesh = event.target;
      instancedMesh.removeEventListener("dispose", onInstancedMeshDispose);
      attributes.remove(instancedMesh.instanceMatrix);
      if (instancedMesh.instanceColor !== null)
        attributes.remove(instancedMesh.instanceColor);
    }
    return {
      update,
      dispose
    };
  }
  var emptyTexture = new Texture();
  var emptyArrayTexture = new DataArrayTexture();
  var empty3dTexture = new Data3DTexture();
  var emptyCubeTexture = new CubeTexture();
  var arrayCacheF32 = [];
  var arrayCacheI32 = [];
  var mat4array = new Float32Array(16);
  var mat3array = new Float32Array(9);
  var mat2array = new Float32Array(4);
  function flatten(array, nBlocks, blockSize) {
    const firstElem = array[0];
    if (firstElem <= 0 || firstElem > 0)
      return array;
    const n = nBlocks * blockSize;
    let r = arrayCacheF32[n];
    if (r === void 0) {
      r = new Float32Array(n);
      arrayCacheF32[n] = r;
    }
    if (nBlocks !== 0) {
      firstElem.toArray(r, 0);
      for (let i = 1, offset = 0; i !== nBlocks; ++i) {
        offset += blockSize;
        array[i].toArray(r, offset);
      }
    }
    return r;
  }
  function arraysEqual(a, b) {
    if (a.length !== b.length)
      return false;
    for (let i = 0, l = a.length; i < l; i++) {
      if (a[i] !== b[i])
        return false;
    }
    return true;
  }
  function copyArray(a, b) {
    for (let i = 0, l = b.length; i < l; i++) {
      a[i] = b[i];
    }
  }
  function allocTexUnits(textures, n) {
    let r = arrayCacheI32[n];
    if (r === void 0) {
      r = new Int32Array(n);
      arrayCacheI32[n] = r;
    }
    for (let i = 0; i !== n; ++i) {
      r[i] = textures.allocateTextureUnit();
    }
    return r;
  }
  function setValueV1f(gl, v) {
    const cache = this.cache;
    if (cache[0] === v)
      return;
    gl.uniform1f(this.addr, v);
    cache[0] = v;
  }
  function setValueV2f(gl, v) {
    const cache = this.cache;
    if (v.x !== void 0) {
      if (cache[0] !== v.x || cache[1] !== v.y) {
        gl.uniform2f(this.addr, v.x, v.y);
        cache[0] = v.x;
        cache[1] = v.y;
      }
    } else {
      if (arraysEqual(cache, v))
        return;
      gl.uniform2fv(this.addr, v);
      copyArray(cache, v);
    }
  }
  function setValueV3f(gl, v) {
    const cache = this.cache;
    if (v.x !== void 0) {
      if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z) {
        gl.uniform3f(this.addr, v.x, v.y, v.z);
        cache[0] = v.x;
        cache[1] = v.y;
        cache[2] = v.z;
      }
    } else if (v.r !== void 0) {
      if (cache[0] !== v.r || cache[1] !== v.g || cache[2] !== v.b) {
        gl.uniform3f(this.addr, v.r, v.g, v.b);
        cache[0] = v.r;
        cache[1] = v.g;
        cache[2] = v.b;
      }
    } else {
      if (arraysEqual(cache, v))
        return;
      gl.uniform3fv(this.addr, v);
      copyArray(cache, v);
    }
  }
  function setValueV4f(gl, v) {
    const cache = this.cache;
    if (v.x !== void 0) {
      if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z || cache[3] !== v.w) {
        gl.uniform4f(this.addr, v.x, v.y, v.z, v.w);
        cache[0] = v.x;
        cache[1] = v.y;
        cache[2] = v.z;
        cache[3] = v.w;
      }
    } else {
      if (arraysEqual(cache, v))
        return;
      gl.uniform4fv(this.addr, v);
      copyArray(cache, v);
    }
  }
  function setValueM2(gl, v) {
    const cache = this.cache;
    const elements = v.elements;
    if (elements === void 0) {
      if (arraysEqual(cache, v))
        return;
      gl.uniformMatrix2fv(this.addr, false, v);
      copyArray(cache, v);
    } else {
      if (arraysEqual(cache, elements))
        return;
      mat2array.set(elements);
      gl.uniformMatrix2fv(this.addr, false, mat2array);
      copyArray(cache, elements);
    }
  }
  function setValueM3(gl, v) {
    const cache = this.cache;
    const elements = v.elements;
    if (elements === void 0) {
      if (arraysEqual(cache, v))
        return;
      gl.uniformMatrix3fv(this.addr, false, v);
      copyArray(cache, v);
    } else {
      if (arraysEqual(cache, elements))
        return;
      mat3array.set(elements);
      gl.uniformMatrix3fv(this.addr, false, mat3array);
      copyArray(cache, elements);
    }
  }
  function setValueM4(gl, v) {
    const cache = this.cache;
    const elements = v.elements;
    if (elements === void 0) {
      if (arraysEqual(cache, v))
        return;
      gl.uniformMatrix4fv(this.addr, false, v);
      copyArray(cache, v);
    } else {
      if (arraysEqual(cache, elements))
        return;
      mat4array.set(elements);
      gl.uniformMatrix4fv(this.addr, false, mat4array);
      copyArray(cache, elements);
    }
  }
  function setValueV1i(gl, v) {
    const cache = this.cache;
    if (cache[0] === v)
      return;
    gl.uniform1i(this.addr, v);
    cache[0] = v;
  }
  function setValueV2i(gl, v) {
    const cache = this.cache;
    if (arraysEqual(cache, v))
      return;
    gl.uniform2iv(this.addr, v);
    copyArray(cache, v);
  }
  function setValueV3i(gl, v) {
    const cache = this.cache;
    if (arraysEqual(cache, v))
      return;
    gl.uniform3iv(this.addr, v);
    copyArray(cache, v);
  }
  function setValueV4i(gl, v) {
    const cache = this.cache;
    if (arraysEqual(cache, v))
      return;
    gl.uniform4iv(this.addr, v);
    copyArray(cache, v);
  }
  function setValueV1ui(gl, v) {
    const cache = this.cache;
    if (cache[0] === v)
      return;
    gl.uniform1ui(this.addr, v);
    cache[0] = v;
  }
  function setValueV2ui(gl, v) {
    const cache = this.cache;
    if (arraysEqual(cache, v))
      return;
    gl.uniform2uiv(this.addr, v);
    copyArray(cache, v);
  }
  function setValueV3ui(gl, v) {
    const cache = this.cache;
    if (arraysEqual(cache, v))
      return;
    gl.uniform3uiv(this.addr, v);
    copyArray(cache, v);
  }
  function setValueV4ui(gl, v) {
    const cache = this.cache;
    if (arraysEqual(cache, v))
      return;
    gl.uniform4uiv(this.addr, v);
    copyArray(cache, v);
  }
  function setValueT1(gl, v, textures) {
    const cache = this.cache;
    const unit = textures.allocateTextureUnit();
    if (cache[0] !== unit) {
      gl.uniform1i(this.addr, unit);
      cache[0] = unit;
    }
    textures.setTexture2D(v || emptyTexture, unit);
  }
  function setValueT3D1(gl, v, textures) {
    const cache = this.cache;
    const unit = textures.allocateTextureUnit();
    if (cache[0] !== unit) {
      gl.uniform1i(this.addr, unit);
      cache[0] = unit;
    }
    textures.setTexture3D(v || empty3dTexture, unit);
  }
  function setValueT6(gl, v, textures) {
    const cache = this.cache;
    const unit = textures.allocateTextureUnit();
    if (cache[0] !== unit) {
      gl.uniform1i(this.addr, unit);
      cache[0] = unit;
    }
    textures.setTextureCube(v || emptyCubeTexture, unit);
  }
  function setValueT2DArray1(gl, v, textures) {
    const cache = this.cache;
    const unit = textures.allocateTextureUnit();
    if (cache[0] !== unit) {
      gl.uniform1i(this.addr, unit);
      cache[0] = unit;
    }
    textures.setTexture2DArray(v || emptyArrayTexture, unit);
  }
  function getSingularSetter(type) {
    switch (type) {
      case 5126:
        return setValueV1f;
      case 35664:
        return setValueV2f;
      case 35665:
        return setValueV3f;
      case 35666:
        return setValueV4f;
      case 35674:
        return setValueM2;
      case 35675:
        return setValueM3;
      case 35676:
        return setValueM4;
      case 5124:
      case 35670:
        return setValueV1i;
      case 35667:
      case 35671:
        return setValueV2i;
      case 35668:
      case 35672:
        return setValueV3i;
      case 35669:
      case 35673:
        return setValueV4i;
      case 5125:
        return setValueV1ui;
      case 36294:
        return setValueV2ui;
      case 36295:
        return setValueV3ui;
      case 36296:
        return setValueV4ui;
      case 35678:
      case 36198:
      case 36298:
      case 36306:
      case 35682:
        return setValueT1;
      case 35679:
      case 36299:
      case 36307:
        return setValueT3D1;
      case 35680:
      case 36300:
      case 36308:
      case 36293:
        return setValueT6;
      case 36289:
      case 36303:
      case 36311:
      case 36292:
        return setValueT2DArray1;
    }
  }
  function setValueV1fArray(gl, v) {
    gl.uniform1fv(this.addr, v);
  }
  function setValueV2fArray(gl, v) {
    const data = flatten(v, this.size, 2);
    gl.uniform2fv(this.addr, data);
  }
  function setValueV3fArray(gl, v) {
    const data = flatten(v, this.size, 3);
    gl.uniform3fv(this.addr, data);
  }
  function setValueV4fArray(gl, v) {
    const data = flatten(v, this.size, 4);
    gl.uniform4fv(this.addr, data);
  }
  function setValueM2Array(gl, v) {
    const data = flatten(v, this.size, 4);
    gl.uniformMatrix2fv(this.addr, false, data);
  }
  function setValueM3Array(gl, v) {
    const data = flatten(v, this.size, 9);
    gl.uniformMatrix3fv(this.addr, false, data);
  }
  function setValueM4Array(gl, v) {
    const data = flatten(v, this.size, 16);
    gl.uniformMatrix4fv(this.addr, false, data);
  }
  function setValueV1iArray(gl, v) {
    gl.uniform1iv(this.addr, v);
  }
  function setValueV2iArray(gl, v) {
    gl.uniform2iv(this.addr, v);
  }
  function setValueV3iArray(gl, v) {
    gl.uniform3iv(this.addr, v);
  }
  function setValueV4iArray(gl, v) {
    gl.uniform4iv(this.addr, v);
  }
  function setValueV1uiArray(gl, v) {
    gl.uniform1uiv(this.addr, v);
  }
  function setValueV2uiArray(gl, v) {
    gl.uniform2uiv(this.addr, v);
  }
  function setValueV3uiArray(gl, v) {
    gl.uniform3uiv(this.addr, v);
  }
  function setValueV4uiArray(gl, v) {
    gl.uniform4uiv(this.addr, v);
  }
  function setValueT1Array(gl, v, textures) {
    const n = v.length;
    const units = allocTexUnits(textures, n);
    gl.uniform1iv(this.addr, units);
    for (let i = 0; i !== n; ++i) {
      textures.setTexture2D(v[i] || emptyTexture, units[i]);
    }
  }
  function setValueT3DArray(gl, v, textures) {
    const n = v.length;
    const units = allocTexUnits(textures, n);
    gl.uniform1iv(this.addr, units);
    for (let i = 0; i !== n; ++i) {
      textures.setTexture3D(v[i] || empty3dTexture, units[i]);
    }
  }
  function setValueT6Array(gl, v, textures) {
    const n = v.length;
    const units = allocTexUnits(textures, n);
    gl.uniform1iv(this.addr, units);
    for (let i = 0; i !== n; ++i) {
      textures.setTextureCube(v[i] || emptyCubeTexture, units[i]);
    }
  }
  function setValueT2DArrayArray(gl, v, textures) {
    const n = v.length;
    const units = allocTexUnits(textures, n);
    gl.uniform1iv(this.addr, units);
    for (let i = 0; i !== n; ++i) {
      textures.setTexture2DArray(v[i] || emptyArrayTexture, units[i]);
    }
  }
  function getPureArraySetter(type) {
    switch (type) {
      case 5126:
        return setValueV1fArray;
      case 35664:
        return setValueV2fArray;
      case 35665:
        return setValueV3fArray;
      case 35666:
        return setValueV4fArray;
      case 35674:
        return setValueM2Array;
      case 35675:
        return setValueM3Array;
      case 35676:
        return setValueM4Array;
      case 5124:
      case 35670:
        return setValueV1iArray;
      case 35667:
      case 35671:
        return setValueV2iArray;
      case 35668:
      case 35672:
        return setValueV3iArray;
      case 35669:
      case 35673:
        return setValueV4iArray;
      case 5125:
        return setValueV1uiArray;
      case 36294:
        return setValueV2uiArray;
      case 36295:
        return setValueV3uiArray;
      case 36296:
        return setValueV4uiArray;
      case 35678:
      case 36198:
      case 36298:
      case 36306:
      case 35682:
        return setValueT1Array;
      case 35679:
      case 36299:
      case 36307:
        return setValueT3DArray;
      case 35680:
      case 36300:
      case 36308:
      case 36293:
        return setValueT6Array;
      case 36289:
      case 36303:
      case 36311:
      case 36292:
        return setValueT2DArrayArray;
    }
  }
  function SingleUniform(id, activeInfo, addr) {
    this.id = id;
    this.addr = addr;
    this.cache = [];
    this.setValue = getSingularSetter(activeInfo.type);
  }
  function PureArrayUniform(id, activeInfo, addr) {
    this.id = id;
    this.addr = addr;
    this.cache = [];
    this.size = activeInfo.size;
    this.setValue = getPureArraySetter(activeInfo.type);
  }
  PureArrayUniform.prototype.updateCache = function(data) {
    const cache = this.cache;
    if (data instanceof Float32Array && cache.length !== data.length) {
      this.cache = new Float32Array(data.length);
    }
    copyArray(cache, data);
  };
  function StructuredUniform(id) {
    this.id = id;
    this.seq = [];
    this.map = {};
  }
  StructuredUniform.prototype.setValue = function(gl, value, textures) {
    const seq = this.seq;
    for (let i = 0, n = seq.length; i !== n; ++i) {
      const u = seq[i];
      u.setValue(gl, value[u.id], textures);
    }
  };
  var RePathPart = /(\w+)(\])?(\[|\.)?/g;
  function addUniform(container, uniformObject) {
    container.seq.push(uniformObject);
    container.map[uniformObject.id] = uniformObject;
  }
  function parseUniform(activeInfo, addr, container) {
    const path = activeInfo.name, pathLength = path.length;
    RePathPart.lastIndex = 0;
    while (true) {
      const match = RePathPart.exec(path), matchEnd = RePathPart.lastIndex;
      let id = match[1];
      const idIsIndex = match[2] === "]", subscript = match[3];
      if (idIsIndex)
        id = id | 0;
      if (subscript === void 0 || subscript === "[" && matchEnd + 2 === pathLength) {
        addUniform(container, subscript === void 0 ? new SingleUniform(id, activeInfo, addr) : new PureArrayUniform(id, activeInfo, addr));
        break;
      } else {
        const map = container.map;
        let next = map[id];
        if (next === void 0) {
          next = new StructuredUniform(id);
          addUniform(container, next);
        }
        container = next;
      }
    }
  }
  function WebGLUniforms(gl, program) {
    this.seq = [];
    this.map = {};
    const n = gl.getProgramParameter(program, 35718);
    for (let i = 0; i < n; ++i) {
      const info = gl.getActiveUniform(program, i), addr = gl.getUniformLocation(program, info.name);
      parseUniform(info, addr, this);
    }
  }
  WebGLUniforms.prototype.setValue = function(gl, name, value, textures) {
    const u = this.map[name];
    if (u !== void 0)
      u.setValue(gl, value, textures);
  };
  WebGLUniforms.prototype.setOptional = function(gl, object, name) {
    const v = object[name];
    if (v !== void 0)
      this.setValue(gl, name, v);
  };
  WebGLUniforms.upload = function(gl, seq, values, textures) {
    for (let i = 0, n = seq.length; i !== n; ++i) {
      const u = seq[i], v = values[u.id];
      if (v.needsUpdate !== false) {
        u.setValue(gl, v.value, textures);
      }
    }
  };
  WebGLUniforms.seqWithValue = function(seq, values) {
    const r = [];
    for (let i = 0, n = seq.length; i !== n; ++i) {
      const u = seq[i];
      if (u.id in values)
        r.push(u);
    }
    return r;
  };
  function WebGLShader(gl, type, string) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, string);
    gl.compileShader(shader);
    return shader;
  }
  var programIdCount = 0;
  function handleSource(string, errorLine) {
    const lines = string.split("\n");
    const lines2 = [];
    const from = Math.max(errorLine - 6, 0);
    const to = Math.min(errorLine + 6, lines.length);
    for (let i = from; i < to; i++) {
      lines2.push(i + 1 + ": " + lines[i]);
    }
    return lines2.join("\n");
  }
  function getEncodingComponents(encoding) {
    switch (encoding) {
      case LinearEncoding:
        return ["Linear", "( value )"];
      case sRGBEncoding:
        return ["sRGB", "( value )"];
      default:
        console.warn("THREE.WebGLProgram: Unsupported encoding:", encoding);
        return ["Linear", "( value )"];
    }
  }
  function getShaderErrors(gl, shader, type) {
    const status = gl.getShaderParameter(shader, 35713);
    const errors = gl.getShaderInfoLog(shader).trim();
    if (status && errors === "")
      return "";
    const errorLine = parseInt(/ERROR: 0:(\d+)/.exec(errors)[1]);
    return type.toUpperCase() + "\n\n" + errors + "\n\n" + handleSource(gl.getShaderSource(shader), errorLine);
  }
  function getTexelEncodingFunction(functionName, encoding) {
    const components = getEncodingComponents(encoding);
    return "vec4 " + functionName + "( vec4 value ) { return LinearTo" + components[0] + components[1] + "; }";
  }
  function getToneMappingFunction(functionName, toneMapping) {
    let toneMappingName;
    switch (toneMapping) {
      case LinearToneMapping:
        toneMappingName = "Linear";
        break;
      case ReinhardToneMapping:
        toneMappingName = "Reinhard";
        break;
      case CineonToneMapping:
        toneMappingName = "OptimizedCineon";
        break;
      case ACESFilmicToneMapping:
        toneMappingName = "ACESFilmic";
        break;
      case CustomToneMapping:
        toneMappingName = "Custom";
        break;
      default:
        console.warn("THREE.WebGLProgram: Unsupported toneMapping:", toneMapping);
        toneMappingName = "Linear";
    }
    return "vec3 " + functionName + "( vec3 color ) { return " + toneMappingName + "ToneMapping( color ); }";
  }
  function generateExtensions(parameters) {
    const chunks = [
      parameters.extensionDerivatives || !!parameters.envMapCubeUVHeight || parameters.bumpMap || parameters.tangentSpaceNormalMap || parameters.clearcoatNormalMap || parameters.flatShading || parameters.shaderID === "physical" ? "#extension GL_OES_standard_derivatives : enable" : "",
      (parameters.extensionFragDepth || parameters.logarithmicDepthBuffer) && parameters.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "",
      parameters.extensionDrawBuffers && parameters.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "",
      (parameters.extensionShaderTextureLOD || parameters.envMap || parameters.transmission) && parameters.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""
    ];
    return chunks.filter(filterEmptyLine).join("\n");
  }
  function generateDefines(defines) {
    const chunks = [];
    for (const name in defines) {
      const value = defines[name];
      if (value === false)
        continue;
      chunks.push("#define " + name + " " + value);
    }
    return chunks.join("\n");
  }
  function fetchAttributeLocations(gl, program) {
    const attributes = {};
    const n = gl.getProgramParameter(program, 35721);
    for (let i = 0; i < n; i++) {
      const info = gl.getActiveAttrib(program, i);
      const name = info.name;
      let locationSize = 1;
      if (info.type === 35674)
        locationSize = 2;
      if (info.type === 35675)
        locationSize = 3;
      if (info.type === 35676)
        locationSize = 4;
      attributes[name] = {
        type: info.type,
        location: gl.getAttribLocation(program, name),
        locationSize
      };
    }
    return attributes;
  }
  function filterEmptyLine(string) {
    return string !== "";
  }
  function replaceLightNums(string, parameters) {
    return string.replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows);
  }
  function replaceClippingPlaneNums(string, parameters) {
    return string.replace(/NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, parameters.numClippingPlanes - parameters.numClipIntersection);
  }
  var includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;
  function resolveIncludes(string) {
    return string.replace(includePattern, includeReplacer);
  }
  function includeReplacer(match, include) {
    const string = ShaderChunk[include];
    if (string === void 0) {
      throw new Error("Can not resolve #include <" + include + ">");
    }
    return resolveIncludes(string);
  }
  var deprecatedUnrollLoopPattern = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
  var unrollLoopPattern = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
  function unrollLoops(string) {
    return string.replace(unrollLoopPattern, loopReplacer).replace(deprecatedUnrollLoopPattern, deprecatedLoopReplacer);
  }
  function deprecatedLoopReplacer(match, start2, end, snippet) {
    console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead.");
    return loopReplacer(match, start2, end, snippet);
  }
  function loopReplacer(match, start2, end, snippet) {
    let string = "";
    for (let i = parseInt(start2); i < parseInt(end); i++) {
      string += snippet.replace(/\[\s*i\s*\]/g, "[ " + i + " ]").replace(/UNROLLED_LOOP_INDEX/g, i);
    }
    return string;
  }
  function generatePrecision(parameters) {
    let precisionstring = "precision " + parameters.precision + " float;\nprecision " + parameters.precision + " int;";
    if (parameters.precision === "highp") {
      precisionstring += "\n#define HIGH_PRECISION";
    } else if (parameters.precision === "mediump") {
      precisionstring += "\n#define MEDIUM_PRECISION";
    } else if (parameters.precision === "lowp") {
      precisionstring += "\n#define LOW_PRECISION";
    }
    return precisionstring;
  }
  function generateShadowMapTypeDefine(parameters) {
    let shadowMapTypeDefine = "SHADOWMAP_TYPE_BASIC";
    if (parameters.shadowMapType === PCFShadowMap) {
      shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF";
    } else if (parameters.shadowMapType === PCFSoftShadowMap) {
      shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF_SOFT";
    } else if (parameters.shadowMapType === VSMShadowMap) {
      shadowMapTypeDefine = "SHADOWMAP_TYPE_VSM";
    }
    return shadowMapTypeDefine;
  }
  function generateEnvMapTypeDefine(parameters) {
    let envMapTypeDefine = "ENVMAP_TYPE_CUBE";
    if (parameters.envMap) {
      switch (parameters.envMapMode) {
        case CubeReflectionMapping:
        case CubeRefractionMapping:
          envMapTypeDefine = "ENVMAP_TYPE_CUBE";
          break;
        case CubeUVReflectionMapping:
          envMapTypeDefine = "ENVMAP_TYPE_CUBE_UV";
          break;
      }
    }
    return envMapTypeDefine;
  }
  function generateEnvMapModeDefine(parameters) {
    let envMapModeDefine = "ENVMAP_MODE_REFLECTION";
    if (parameters.envMap) {
      switch (parameters.envMapMode) {
        case CubeRefractionMapping:
          envMapModeDefine = "ENVMAP_MODE_REFRACTION";
          break;
      }
    }
    return envMapModeDefine;
  }
  function generateEnvMapBlendingDefine(parameters) {
    let envMapBlendingDefine = "ENVMAP_BLENDING_NONE";
    if (parameters.envMap) {
      switch (parameters.combine) {
        case MultiplyOperation:
          envMapBlendingDefine = "ENVMAP_BLENDING_MULTIPLY";
          break;
        case MixOperation:
          envMapBlendingDefine = "ENVMAP_BLENDING_MIX";
          break;
        case AddOperation:
          envMapBlendingDefine = "ENVMAP_BLENDING_ADD";
          break;
      }
    }
    return envMapBlendingDefine;
  }
  function generateCubeUVSize(parameters) {
    const imageHeight = parameters.envMapCubeUVHeight;
    if (imageHeight === null)
      return null;
    const maxMip = Math.log2(imageHeight / 32 + 1) + 3;
    const texelHeight = 1 / imageHeight;
    const texelWidth = 1 / (3 * Math.max(Math.pow(2, maxMip), 7 * 16));
    return { texelWidth, texelHeight, maxMip };
  }
  function WebGLProgram(renderer, cacheKey, parameters, bindingStates) {
    const gl = renderer.getContext();
    const defines = parameters.defines;
    let vertexShader = parameters.vertexShader;
    let fragmentShader = parameters.fragmentShader;
    const shadowMapTypeDefine = generateShadowMapTypeDefine(parameters);
    const envMapTypeDefine = generateEnvMapTypeDefine(parameters);
    const envMapModeDefine = generateEnvMapModeDefine(parameters);
    const envMapBlendingDefine = generateEnvMapBlendingDefine(parameters);
    const envMapCubeUVSize = generateCubeUVSize(parameters);
    const customExtensions = parameters.isWebGL2 ? "" : generateExtensions(parameters);
    const customDefines = generateDefines(defines);
    const program = gl.createProgram();
    let prefixVertex, prefixFragment;
    let versionString = parameters.glslVersion ? "#version " + parameters.glslVersion + "\n" : "";
    if (parameters.isRawShaderMaterial) {
      prefixVertex = [
        customDefines
      ].filter(filterEmptyLine).join("\n");
      if (prefixVertex.length > 0) {
        prefixVertex += "\n";
      }
      prefixFragment = [
        customExtensions,
        customDefines
      ].filter(filterEmptyLine).join("\n");
      if (prefixFragment.length > 0) {
        prefixFragment += "\n";
      }
    } else {
      prefixVertex = [
        generatePrecision(parameters),
        "#define SHADER_NAME " + parameters.shaderName,
        customDefines,
        parameters.instancing ? "#define USE_INSTANCING" : "",
        parameters.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
        parameters.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",
        "#define MAX_BONES " + parameters.maxBones,
        parameters.useFog && parameters.fog ? "#define USE_FOG" : "",
        parameters.useFog && parameters.fogExp2 ? "#define FOG_EXP2" : "",
        parameters.map ? "#define USE_MAP" : "",
        parameters.envMap ? "#define USE_ENVMAP" : "",
        parameters.envMap ? "#define " + envMapModeDefine : "",
        parameters.lightMap ? "#define USE_LIGHTMAP" : "",
        parameters.aoMap ? "#define USE_AOMAP" : "",
        parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
        parameters.bumpMap ? "#define USE_BUMPMAP" : "",
        parameters.normalMap ? "#define USE_NORMALMAP" : "",
        parameters.normalMap && parameters.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "",
        parameters.normalMap && parameters.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "",
        parameters.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
        parameters.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
        parameters.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
        parameters.displacementMap && parameters.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "",
        parameters.specularMap ? "#define USE_SPECULARMAP" : "",
        parameters.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "",
        parameters.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "",
        parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
        parameters.metalnessMap ? "#define USE_METALNESSMAP" : "",
        parameters.alphaMap ? "#define USE_ALPHAMAP" : "",
        parameters.transmission ? "#define USE_TRANSMISSION" : "",
        parameters.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
        parameters.thicknessMap ? "#define USE_THICKNESSMAP" : "",
        parameters.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "",
        parameters.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "",
        parameters.vertexTangents ? "#define USE_TANGENT" : "",
        parameters.vertexColors ? "#define USE_COLOR" : "",
        parameters.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
        parameters.vertexUvs ? "#define USE_UV" : "",
        parameters.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
        parameters.flatShading ? "#define FLAT_SHADED" : "",
        parameters.skinning ? "#define USE_SKINNING" : "",
        parameters.useVertexTexture ? "#define BONE_TEXTURE" : "",
        parameters.morphTargets ? "#define USE_MORPHTARGETS" : "",
        parameters.morphNormals && parameters.flatShading === false ? "#define USE_MORPHNORMALS" : "",
        parameters.morphColors && parameters.isWebGL2 ? "#define USE_MORPHCOLORS" : "",
        parameters.morphTargetsCount > 0 && parameters.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "",
        parameters.morphTargetsCount > 0 && parameters.isWebGL2 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + parameters.morphTextureStride : "",
        parameters.morphTargetsCount > 0 && parameters.isWebGL2 ? "#define MORPHTARGETS_COUNT " + parameters.morphTargetsCount : "",
        parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
        parameters.flipSided ? "#define FLIP_SIDED" : "",
        parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
        parameters.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
        parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
        parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
        "uniform mat4 modelMatrix;",
        "uniform mat4 modelViewMatrix;",
        "uniform mat4 projectionMatrix;",
        "uniform mat4 viewMatrix;",
        "uniform mat3 normalMatrix;",
        "uniform vec3 cameraPosition;",
        "uniform bool isOrthographic;",
        "#ifdef USE_INSTANCING",
        "	attribute mat4 instanceMatrix;",
        "#endif",
        "#ifdef USE_INSTANCING_COLOR",
        "	attribute vec3 instanceColor;",
        "#endif",
        "attribute vec3 position;",
        "attribute vec3 normal;",
        "attribute vec2 uv;",
        "#ifdef USE_TANGENT",
        "	attribute vec4 tangent;",
        "#endif",
        "#if defined( USE_COLOR_ALPHA )",
        "	attribute vec4 color;",
        "#elif defined( USE_COLOR )",
        "	attribute vec3 color;",
        "#endif",
        "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )",
        "	attribute vec3 morphTarget0;",
        "	attribute vec3 morphTarget1;",
        "	attribute vec3 morphTarget2;",
        "	attribute vec3 morphTarget3;",
        "	#ifdef USE_MORPHNORMALS",
        "		attribute vec3 morphNormal0;",
        "		attribute vec3 morphNormal1;",
        "		attribute vec3 morphNormal2;",
        "		attribute vec3 morphNormal3;",
        "	#else",
        "		attribute vec3 morphTarget4;",
        "		attribute vec3 morphTarget5;",
        "		attribute vec3 morphTarget6;",
        "		attribute vec3 morphTarget7;",
        "	#endif",
        "#endif",
        "#ifdef USE_SKINNING",
        "	attribute vec4 skinIndex;",
        "	attribute vec4 skinWeight;",
        "#endif",
        "\n"
      ].filter(filterEmptyLine).join("\n");
      prefixFragment = [
        customExtensions,
        generatePrecision(parameters),
        "#define SHADER_NAME " + parameters.shaderName,
        customDefines,
        parameters.useFog && parameters.fog ? "#define USE_FOG" : "",
        parameters.useFog && parameters.fogExp2 ? "#define FOG_EXP2" : "",
        parameters.map ? "#define USE_MAP" : "",
        parameters.matcap ? "#define USE_MATCAP" : "",
        parameters.envMap ? "#define USE_ENVMAP" : "",
        parameters.envMap ? "#define " + envMapTypeDefine : "",
        parameters.envMap ? "#define " + envMapModeDefine : "",
        parameters.envMap ? "#define " + envMapBlendingDefine : "",
        envMapCubeUVSize ? "#define CUBEUV_TEXEL_WIDTH " + envMapCubeUVSize.texelWidth : "",
        envMapCubeUVSize ? "#define CUBEUV_TEXEL_HEIGHT " + envMapCubeUVSize.texelHeight : "",
        envMapCubeUVSize ? "#define CUBEUV_MAX_MIP " + envMapCubeUVSize.maxMip + ".0" : "",
        parameters.lightMap ? "#define USE_LIGHTMAP" : "",
        parameters.aoMap ? "#define USE_AOMAP" : "",
        parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
        parameters.bumpMap ? "#define USE_BUMPMAP" : "",
        parameters.normalMap ? "#define USE_NORMALMAP" : "",
        parameters.normalMap && parameters.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "",
        parameters.normalMap && parameters.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "",
        parameters.clearcoat ? "#define USE_CLEARCOAT" : "",
        parameters.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
        parameters.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
        parameters.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
        parameters.specularMap ? "#define USE_SPECULARMAP" : "",
        parameters.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "",
        parameters.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "",
        parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
        parameters.metalnessMap ? "#define USE_METALNESSMAP" : "",
        parameters.alphaMap ? "#define USE_ALPHAMAP" : "",
        parameters.alphaTest ? "#define USE_ALPHATEST" : "",
        parameters.sheen ? "#define USE_SHEEN" : "",
        parameters.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "",
        parameters.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "",
        parameters.transmission ? "#define USE_TRANSMISSION" : "",
        parameters.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
        parameters.thicknessMap ? "#define USE_THICKNESSMAP" : "",
        parameters.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
        parameters.vertexTangents ? "#define USE_TANGENT" : "",
        parameters.vertexColors || parameters.instancingColor ? "#define USE_COLOR" : "",
        parameters.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
        parameters.vertexUvs ? "#define USE_UV" : "",
        parameters.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
        parameters.gradientMap ? "#define USE_GRADIENTMAP" : "",
        parameters.flatShading ? "#define FLAT_SHADED" : "",
        parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
        parameters.flipSided ? "#define FLIP_SIDED" : "",
        parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
        parameters.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
        parameters.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "",
        parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
        parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
        "uniform mat4 viewMatrix;",
        "uniform vec3 cameraPosition;",
        "uniform bool isOrthographic;",
        parameters.toneMapping !== NoToneMapping ? "#define TONE_MAPPING" : "",
        parameters.toneMapping !== NoToneMapping ? ShaderChunk["tonemapping_pars_fragment"] : "",
        // this code is required here because it is used by the toneMapping() function defined below
        parameters.toneMapping !== NoToneMapping ? getToneMappingFunction("toneMapping", parameters.toneMapping) : "",
        parameters.dithering ? "#define DITHERING" : "",
        parameters.opaque ? "#define OPAQUE" : "",
        ShaderChunk["encodings_pars_fragment"],
        // this code is required here because it is used by the various encoding/decoding function defined below
        getTexelEncodingFunction("linearToOutputTexel", parameters.outputEncoding),
        parameters.depthPacking ? "#define DEPTH_PACKING " + parameters.depthPacking : "",
        "\n"
      ].filter(filterEmptyLine).join("\n");
    }
    vertexShader = resolveIncludes(vertexShader);
    vertexShader = replaceLightNums(vertexShader, parameters);
    vertexShader = replaceClippingPlaneNums(vertexShader, parameters);
    fragmentShader = resolveIncludes(fragmentShader);
    fragmentShader = replaceLightNums(fragmentShader, parameters);
    fragmentShader = replaceClippingPlaneNums(fragmentShader, parameters);
    vertexShader = unrollLoops(vertexShader);
    fragmentShader = unrollLoops(fragmentShader);
    if (parameters.isWebGL2 && parameters.isRawShaderMaterial !== true) {
      versionString = "#version 300 es\n";
      prefixVertex = [
        "precision mediump sampler2DArray;",
        "#define attribute in",
        "#define varying out",
        "#define texture2D texture"
      ].join("\n") + "\n" + prefixVertex;
      prefixFragment = [
        "#define varying in",
        parameters.glslVersion === GLSL3 ? "" : "layout(location = 0) out highp vec4 pc_fragColor;",
        parameters.glslVersion === GLSL3 ? "" : "#define gl_FragColor pc_fragColor",
        "#define gl_FragDepthEXT gl_FragDepth",
        "#define texture2D texture",
        "#define textureCube texture",
        "#define texture2DProj textureProj",
        "#define texture2DLodEXT textureLod",
        "#define texture2DProjLodEXT textureProjLod",
        "#define textureCubeLodEXT textureLod",
        "#define texture2DGradEXT textureGrad",
        "#define texture2DProjGradEXT textureProjGrad",
        "#define textureCubeGradEXT textureGrad"
      ].join("\n") + "\n" + prefixFragment;
    }
    const vertexGlsl = versionString + prefixVertex + vertexShader;
    const fragmentGlsl = versionString + prefixFragment + fragmentShader;
    const glVertexShader = WebGLShader(gl, 35633, vertexGlsl);
    const glFragmentShader = WebGLShader(gl, 35632, fragmentGlsl);
    gl.attachShader(program, glVertexShader);
    gl.attachShader(program, glFragmentShader);
    if (parameters.index0AttributeName !== void 0) {
      gl.bindAttribLocation(program, 0, parameters.index0AttributeName);
    } else if (parameters.morphTargets === true) {
      gl.bindAttribLocation(program, 0, "position");
    }
    gl.linkProgram(program);
    if (renderer.debug.checkShaderErrors) {
      const programLog = gl.getProgramInfoLog(program).trim();
      const vertexLog = gl.getShaderInfoLog(glVertexShader).trim();
      const fragmentLog = gl.getShaderInfoLog(glFragmentShader).trim();
      let runnable = true;
      let haveDiagnostics = true;
      if (gl.getProgramParameter(program, 35714) === false) {
        runnable = false;
        const vertexErrors = getShaderErrors(gl, glVertexShader, "vertex");
        const fragmentErrors = getShaderErrors(gl, glFragmentShader, "fragment");
        console.error(
          "THREE.WebGLProgram: Shader Error " + gl.getError() + " - VALIDATE_STATUS " + gl.getProgramParameter(program, 35715) + "\n\nProgram Info Log: " + programLog + "\n" + vertexErrors + "\n" + fragmentErrors
        );
      } else if (programLog !== "") {
        console.warn("THREE.WebGLProgram: Program Info Log:", programLog);
      } else if (vertexLog === "" || fragmentLog === "") {
        haveDiagnostics = false;
      }
      if (haveDiagnostics) {
        this.diagnostics = {
          runnable,
          programLog,
          vertexShader: {
            log: vertexLog,
            prefix: prefixVertex
          },
          fragmentShader: {
            log: fragmentLog,
            prefix: prefixFragment
          }
        };
      }
    }
    gl.deleteShader(glVertexShader);
    gl.deleteShader(glFragmentShader);
    let cachedUniforms;
    this.getUniforms = function() {
      if (cachedUniforms === void 0) {
        cachedUniforms = new WebGLUniforms(gl, program);
      }
      return cachedUniforms;
    };
    let cachedAttributes;
    this.getAttributes = function() {
      if (cachedAttributes === void 0) {
        cachedAttributes = fetchAttributeLocations(gl, program);
      }
      return cachedAttributes;
    };
    this.destroy = function() {
      bindingStates.releaseStatesOfProgram(this);
      gl.deleteProgram(program);
      this.program = void 0;
    };
    this.name = parameters.shaderName;
    this.id = programIdCount++;
    this.cacheKey = cacheKey;
    this.usedTimes = 1;
    this.program = program;
    this.vertexShader = glVertexShader;
    this.fragmentShader = glFragmentShader;
    return this;
  }
  var _id = 0;
  var WebGLShaderCache = class {
    constructor() {
      this.shaderCache = /* @__PURE__ */ new Map();
      this.materialCache = /* @__PURE__ */ new Map();
    }
    update(material) {
      const vertexShader = material.vertexShader;
      const fragmentShader = material.fragmentShader;
      const vertexShaderStage = this._getShaderStage(vertexShader);
      const fragmentShaderStage = this._getShaderStage(fragmentShader);
      const materialShaders = this._getShaderCacheForMaterial(material);
      if (materialShaders.has(vertexShaderStage) === false) {
        materialShaders.add(vertexShaderStage);
        vertexShaderStage.usedTimes++;
      }
      if (materialShaders.has(fragmentShaderStage) === false) {
        materialShaders.add(fragmentShaderStage);
        fragmentShaderStage.usedTimes++;
      }
      return this;
    }
    remove(material) {
      const materialShaders = this.materialCache.get(material);
      for (const shaderStage of materialShaders) {
        shaderStage.usedTimes--;
        if (shaderStage.usedTimes === 0)
          this.shaderCache.delete(shaderStage.code);
      }
      this.materialCache.delete(material);
      return this;
    }
    getVertexShaderID(material) {
      return this._getShaderStage(material.vertexShader).id;
    }
    getFragmentShaderID(material) {
      return this._getShaderStage(material.fragmentShader).id;
    }
    dispose() {
      this.shaderCache.clear();
      this.materialCache.clear();
    }
    _getShaderCacheForMaterial(material) {
      const cache = this.materialCache;
      if (cache.has(material) === false) {
        cache.set(material, /* @__PURE__ */ new Set());
      }
      return cache.get(material);
    }
    _getShaderStage(code) {
      const cache = this.shaderCache;
      if (cache.has(code) === false) {
        const stage = new WebGLShaderStage(code);
        cache.set(code, stage);
      }
      return cache.get(code);
    }
  };
  var WebGLShaderStage = class {
    constructor(code) {
      this.id = _id++;
      this.code = code;
      this.usedTimes = 0;
    }
  };
  function WebGLPrograms(renderer, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping) {
    const _programLayers = new Layers();
    const _customShaders = new WebGLShaderCache();
    const programs = [];
    const isWebGL2 = capabilities.isWebGL2;
    const logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;
    const floatVertexTextures = capabilities.floatVertexTextures;
    const maxVertexUniforms = capabilities.maxVertexUniforms;
    const vertexTextures = capabilities.vertexTextures;
    let precision = capabilities.precision;
    const shaderIDs = {
      MeshDepthMaterial: "depth",
      MeshDistanceMaterial: "distanceRGBA",
      MeshNormalMaterial: "normal",
      MeshBasicMaterial: "basic",
      MeshLambertMaterial: "lambert",
      MeshPhongMaterial: "phong",
      MeshToonMaterial: "toon",
      MeshStandardMaterial: "physical",
      MeshPhysicalMaterial: "physical",
      MeshMatcapMaterial: "matcap",
      LineBasicMaterial: "basic",
      LineDashedMaterial: "dashed",
      PointsMaterial: "points",
      ShadowMaterial: "shadow",
      SpriteMaterial: "sprite"
    };
    function getMaxBones(object) {
      const skeleton = object.skeleton;
      const bones = skeleton.bones;
      if (floatVertexTextures) {
        return 1024;
      } else {
        const nVertexUniforms = maxVertexUniforms;
        const nVertexMatrices = Math.floor((nVertexUniforms - 20) / 4);
        const maxBones = Math.min(nVertexMatrices, bones.length);
        if (maxBones < bones.length) {
          console.warn("THREE.WebGLRenderer: Skeleton has " + bones.length + " bones. This GPU supports " + maxBones + ".");
          return 0;
        }
        return maxBones;
      }
    }
    function getParameters(material, lights, shadows, scene, object) {
      const fog = scene.fog;
      const geometry = object.geometry;
      const environment = material.isMeshStandardMaterial ? scene.environment : null;
      const envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || environment);
      const envMapCubeUVHeight = !!envMap && envMap.mapping === CubeUVReflectionMapping ? envMap.image.height : null;
      const shaderID = shaderIDs[material.type];
      const maxBones = object.isSkinnedMesh ? getMaxBones(object) : 0;
      if (material.precision !== null) {
        precision = capabilities.getMaxPrecision(material.precision);
        if (precision !== material.precision) {
          console.warn("THREE.WebGLProgram.getParameters:", material.precision, "not supported, using", precision, "instead.");
        }
      }
      const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
      const morphTargetsCount = morphAttribute !== void 0 ? morphAttribute.length : 0;
      let morphTextureStride = 0;
      if (geometry.morphAttributes.position !== void 0)
        morphTextureStride = 1;
      if (geometry.morphAttributes.normal !== void 0)
        morphTextureStride = 2;
      if (geometry.morphAttributes.color !== void 0)
        morphTextureStride = 3;
      let vertexShader, fragmentShader;
      let customVertexShaderID, customFragmentShaderID;
      if (shaderID) {
        const shader = ShaderLib[shaderID];
        vertexShader = shader.vertexShader;
        fragmentShader = shader.fragmentShader;
      } else {
        vertexShader = material.vertexShader;
        fragmentShader = material.fragmentShader;
        _customShaders.update(material);
        customVertexShaderID = _customShaders.getVertexShaderID(material);
        customFragmentShaderID = _customShaders.getFragmentShaderID(material);
      }
      const currentRenderTarget = renderer.getRenderTarget();
      const useAlphaTest = material.alphaTest > 0;
      const useClearcoat = material.clearcoat > 0;
      const parameters = {
        isWebGL2,
        shaderID,
        shaderName: material.type,
        vertexShader,
        fragmentShader,
        defines: material.defines,
        customVertexShaderID,
        customFragmentShaderID,
        isRawShaderMaterial: material.isRawShaderMaterial === true,
        glslVersion: material.glslVersion,
        precision,
        instancing: object.isInstancedMesh === true,
        instancingColor: object.isInstancedMesh === true && object.instanceColor !== null,
        supportsVertexTextures: vertexTextures,
        outputEncoding: currentRenderTarget === null ? renderer.outputEncoding : currentRenderTarget.isXRRenderTarget === true ? currentRenderTarget.texture.encoding : LinearEncoding,
        map: !!material.map,
        matcap: !!material.matcap,
        envMap: !!envMap,
        envMapMode: envMap && envMap.mapping,
        envMapCubeUVHeight,
        lightMap: !!material.lightMap,
        aoMap: !!material.aoMap,
        emissiveMap: !!material.emissiveMap,
        bumpMap: !!material.bumpMap,
        normalMap: !!material.normalMap,
        objectSpaceNormalMap: material.normalMapType === ObjectSpaceNormalMap,
        tangentSpaceNormalMap: material.normalMapType === TangentSpaceNormalMap,
        decodeVideoTexture: !!material.map && material.map.isVideoTexture === true && material.map.encoding === sRGBEncoding,
        clearcoat: useClearcoat,
        clearcoatMap: useClearcoat && !!material.clearcoatMap,
        clearcoatRoughnessMap: useClearcoat && !!material.clearcoatRoughnessMap,
        clearcoatNormalMap: useClearcoat && !!material.clearcoatNormalMap,
        displacementMap: !!material.displacementMap,
        roughnessMap: !!material.roughnessMap,
        metalnessMap: !!material.metalnessMap,
        specularMap: !!material.specularMap,
        specularIntensityMap: !!material.specularIntensityMap,
        specularColorMap: !!material.specularColorMap,
        opaque: material.transparent === false && material.blending === NormalBlending,
        alphaMap: !!material.alphaMap,
        alphaTest: useAlphaTest,
        gradientMap: !!material.gradientMap,
        sheen: material.sheen > 0,
        sheenColorMap: !!material.sheenColorMap,
        sheenRoughnessMap: !!material.sheenRoughnessMap,
        transmission: material.transmission > 0,
        transmissionMap: !!material.transmissionMap,
        thicknessMap: !!material.thicknessMap,
        combine: material.combine,
        vertexTangents: !!material.normalMap && !!geometry.attributes.tangent,
        vertexColors: material.vertexColors,
        vertexAlphas: material.vertexColors === true && !!geometry.attributes.color && geometry.attributes.color.itemSize === 4,
        vertexUvs: !!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatMap || !!material.clearcoatRoughnessMap || !!material.clearcoatNormalMap || !!material.displacementMap || !!material.transmissionMap || !!material.thicknessMap || !!material.specularIntensityMap || !!material.specularColorMap || !!material.sheenColorMap || !!material.sheenRoughnessMap,
        uvsVertexOnly: !(!!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatNormalMap || material.transmission > 0 || !!material.transmissionMap || !!material.thicknessMap || !!material.specularIntensityMap || !!material.specularColorMap || material.sheen > 0 || !!material.sheenColorMap || !!material.sheenRoughnessMap) && !!material.displacementMap,
        fog: !!fog,
        useFog: material.fog,
        fogExp2: fog && fog.isFogExp2,
        flatShading: !!material.flatShading,
        sizeAttenuation: material.sizeAttenuation,
        logarithmicDepthBuffer,
        skinning: object.isSkinnedMesh === true && maxBones > 0,
        maxBones,
        useVertexTexture: floatVertexTextures,
        morphTargets: geometry.morphAttributes.position !== void 0,
        morphNormals: geometry.morphAttributes.normal !== void 0,
        morphColors: geometry.morphAttributes.color !== void 0,
        morphTargetsCount,
        morphTextureStride,
        numDirLights: lights.directional.length,
        numPointLights: lights.point.length,
        numSpotLights: lights.spot.length,
        numRectAreaLights: lights.rectArea.length,
        numHemiLights: lights.hemi.length,
        numDirLightShadows: lights.directionalShadowMap.length,
        numPointLightShadows: lights.pointShadowMap.length,
        numSpotLightShadows: lights.spotShadowMap.length,
        numClippingPlanes: clipping.numPlanes,
        numClipIntersection: clipping.numIntersection,
        dithering: material.dithering,
        shadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,
        shadowMapType: renderer.shadowMap.type,
        toneMapping: material.toneMapped ? renderer.toneMapping : NoToneMapping,
        physicallyCorrectLights: renderer.physicallyCorrectLights,
        premultipliedAlpha: material.premultipliedAlpha,
        doubleSided: material.side === DoubleSide,
        flipSided: material.side === BackSide,
        depthPacking: material.depthPacking !== void 0 ? material.depthPacking : false,
        index0AttributeName: material.index0AttributeName,
        extensionDerivatives: material.extensions && material.extensions.derivatives,
        extensionFragDepth: material.extensions && material.extensions.fragDepth,
        extensionDrawBuffers: material.extensions && material.extensions.drawBuffers,
        extensionShaderTextureLOD: material.extensions && material.extensions.shaderTextureLOD,
        rendererExtensionFragDepth: isWebGL2 || extensions.has("EXT_frag_depth"),
        rendererExtensionDrawBuffers: isWebGL2 || extensions.has("WEBGL_draw_buffers"),
        rendererExtensionShaderTextureLod: isWebGL2 || extensions.has("EXT_shader_texture_lod"),
        customProgramCacheKey: material.customProgramCacheKey()
      };
      return parameters;
    }
    function getProgramCacheKey(parameters) {
      const array = [];
      if (parameters.shaderID) {
        array.push(parameters.shaderID);
      } else {
        array.push(parameters.customVertexShaderID);
        array.push(parameters.customFragmentShaderID);
      }
      if (parameters.defines !== void 0) {
        for (const name in parameters.defines) {
          array.push(name);
          array.push(parameters.defines[name]);
        }
      }
      if (parameters.isRawShaderMaterial === false) {
        getProgramCacheKeyParameters(array, parameters);
        getProgramCacheKeyBooleans(array, parameters);
        array.push(renderer.outputEncoding);
      }
      array.push(parameters.customProgramCacheKey);
      return array.join();
    }
    function getProgramCacheKeyParameters(array, parameters) {
      array.push(parameters.precision);
      array.push(parameters.outputEncoding);
      array.push(parameters.envMapMode);
      array.push(parameters.envMapCubeUVHeight);
      array.push(parameters.combine);
      array.push(parameters.vertexUvs);
      array.push(parameters.fogExp2);
      array.push(parameters.sizeAttenuation);
      array.push(parameters.maxBones);
      array.push(parameters.morphTargetsCount);
      array.push(parameters.morphAttributeCount);
      array.push(parameters.numDirLights);
      array.push(parameters.numPointLights);
      array.push(parameters.numSpotLights);
      array.push(parameters.numHemiLights);
      array.push(parameters.numRectAreaLights);
      array.push(parameters.numDirLightShadows);
      array.push(parameters.numPointLightShadows);
      array.push(parameters.numSpotLightShadows);
      array.push(parameters.shadowMapType);
      array.push(parameters.toneMapping);
      array.push(parameters.numClippingPlanes);
      array.push(parameters.numClipIntersection);
    }
    function getProgramCacheKeyBooleans(array, parameters) {
      _programLayers.disableAll();
      if (parameters.isWebGL2)
        _programLayers.enable(0);
      if (parameters.supportsVertexTextures)
        _programLayers.enable(1);
      if (parameters.instancing)
        _programLayers.enable(2);
      if (parameters.instancingColor)
        _programLayers.enable(3);
      if (parameters.map)
        _programLayers.enable(4);
      if (parameters.matcap)
        _programLayers.enable(5);
      if (parameters.envMap)
        _programLayers.enable(6);
      if (parameters.lightMap)
        _programLayers.enable(7);
      if (parameters.aoMap)
        _programLayers.enable(8);
      if (parameters.emissiveMap)
        _programLayers.enable(9);
      if (parameters.bumpMap)
        _programLayers.enable(10);
      if (parameters.normalMap)
        _programLayers.enable(11);
      if (parameters.objectSpaceNormalMap)
        _programLayers.enable(12);
      if (parameters.tangentSpaceNormalMap)
        _programLayers.enable(13);
      if (parameters.clearcoat)
        _programLayers.enable(14);
      if (parameters.clearcoatMap)
        _programLayers.enable(15);
      if (parameters.clearcoatRoughnessMap)
        _programLayers.enable(16);
      if (parameters.clearcoatNormalMap)
        _programLayers.enable(17);
      if (parameters.displacementMap)
        _programLayers.enable(18);
      if (parameters.specularMap)
        _programLayers.enable(19);
      if (parameters.roughnessMap)
        _programLayers.enable(20);
      if (parameters.metalnessMap)
        _programLayers.enable(21);
      if (parameters.gradientMap)
        _programLayers.enable(22);
      if (parameters.alphaMap)
        _programLayers.enable(23);
      if (parameters.alphaTest)
        _programLayers.enable(24);
      if (parameters.vertexColors)
        _programLayers.enable(25);
      if (parameters.vertexAlphas)
        _programLayers.enable(26);
      if (parameters.vertexUvs)
        _programLayers.enable(27);
      if (parameters.vertexTangents)
        _programLayers.enable(28);
      if (parameters.uvsVertexOnly)
        _programLayers.enable(29);
      if (parameters.fog)
        _programLayers.enable(30);
      array.push(_programLayers.mask);
      _programLayers.disableAll();
      if (parameters.useFog)
        _programLayers.enable(0);
      if (parameters.flatShading)
        _programLayers.enable(1);
      if (parameters.logarithmicDepthBuffer)
        _programLayers.enable(2);
      if (parameters.skinning)
        _programLayers.enable(3);
      if (parameters.useVertexTexture)
        _programLayers.enable(4);
      if (parameters.morphTargets)
        _programLayers.enable(5);
      if (parameters.morphNormals)
        _programLayers.enable(6);
      if (parameters.morphColors)
        _programLayers.enable(7);
      if (parameters.premultipliedAlpha)
        _programLayers.enable(8);
      if (parameters.shadowMapEnabled)
        _programLayers.enable(9);
      if (parameters.physicallyCorrectLights)
        _programLayers.enable(10);
      if (parameters.doubleSided)
        _programLayers.enable(11);
      if (parameters.flipSided)
        _programLayers.enable(12);
      if (parameters.depthPacking)
        _programLayers.enable(13);
      if (parameters.dithering)
        _programLayers.enable(14);
      if (parameters.specularIntensityMap)
        _programLayers.enable(15);
      if (parameters.specularColorMap)
        _programLayers.enable(16);
      if (parameters.transmission)
        _programLayers.enable(17);
      if (parameters.transmissionMap)
        _programLayers.enable(18);
      if (parameters.thicknessMap)
        _programLayers.enable(19);
      if (parameters.sheen)
        _programLayers.enable(20);
      if (parameters.sheenColorMap)
        _programLayers.enable(21);
      if (parameters.sheenRoughnessMap)
        _programLayers.enable(22);
      if (parameters.decodeVideoTexture)
        _programLayers.enable(23);
      if (parameters.opaque)
        _programLayers.enable(24);
      array.push(_programLayers.mask);
    }
    function getUniforms(material) {
      const shaderID = shaderIDs[material.type];
      let uniforms;
      if (shaderID) {
        const shader = ShaderLib[shaderID];
        uniforms = UniformsUtils.clone(shader.uniforms);
      } else {
        uniforms = material.uniforms;
      }
      return uniforms;
    }
    function acquireProgram(parameters, cacheKey) {
      let program;
      for (let p = 0, pl = programs.length; p < pl; p++) {
        const preexistingProgram = programs[p];
        if (preexistingProgram.cacheKey === cacheKey) {
          program = preexistingProgram;
          ++program.usedTimes;
          break;
        }
      }
      if (program === void 0) {
        program = new WebGLProgram(renderer, cacheKey, parameters, bindingStates);
        programs.push(program);
      }
      return program;
    }
    function releaseProgram(program) {
      if (--program.usedTimes === 0) {
        const i = programs.indexOf(program);
        programs[i] = programs[programs.length - 1];
        programs.pop();
        program.destroy();
      }
    }
    function releaseShaderCache(material) {
      _customShaders.remove(material);
    }
    function dispose() {
      _customShaders.dispose();
    }
    return {
      getParameters,
      getProgramCacheKey,
      getUniforms,
      acquireProgram,
      releaseProgram,
      releaseShaderCache,
      // Exposed for resource monitoring & error feedback via renderer.info:
      programs,
      dispose
    };
  }
  function WebGLProperties() {
    let properties = /* @__PURE__ */ new WeakMap();
    function get(object) {
      let map = properties.get(object);
      if (map === void 0) {
        map = {};
        properties.set(object, map);
      }
      return map;
    }
    function remove(object) {
      properties.delete(object);
    }
    function update(object, key, value) {
      properties.get(object)[key] = value;
    }
    function dispose() {
      properties = /* @__PURE__ */ new WeakMap();
    }
    return {
      get,
      remove,
      update,
      dispose
    };
  }
  function painterSortStable(a, b) {
    if (a.groupOrder !== b.groupOrder) {
      return a.groupOrder - b.groupOrder;
    } else if (a.renderOrder !== b.renderOrder) {
      return a.renderOrder - b.renderOrder;
    } else if (a.material.id !== b.material.id) {
      return a.material.id - b.material.id;
    } else if (a.z !== b.z) {
      return a.z - b.z;
    } else {
      return a.id - b.id;
    }
  }
  function reversePainterSortStable(a, b) {
    if (a.groupOrder !== b.groupOrder) {
      return a.groupOrder - b.groupOrder;
    } else if (a.renderOrder !== b.renderOrder) {
      return a.renderOrder - b.renderOrder;
    } else if (a.z !== b.z) {
      return b.z - a.z;
    } else {
      return a.id - b.id;
    }
  }
  function WebGLRenderList() {
    const renderItems = [];
    let renderItemsIndex = 0;
    const opaque = [];
    const transmissive = [];
    const transparent = [];
    function init() {
      renderItemsIndex = 0;
      opaque.length = 0;
      transmissive.length = 0;
      transparent.length = 0;
    }
    function getNextRenderItem(object, geometry, material, groupOrder, z, group) {
      let renderItem = renderItems[renderItemsIndex];
      if (renderItem === void 0) {
        renderItem = {
          id: object.id,
          object,
          geometry,
          material,
          groupOrder,
          renderOrder: object.renderOrder,
          z,
          group
        };
        renderItems[renderItemsIndex] = renderItem;
      } else {
        renderItem.id = object.id;
        renderItem.object = object;
        renderItem.geometry = geometry;
        renderItem.material = material;
        renderItem.groupOrder = groupOrder;
        renderItem.renderOrder = object.renderOrder;
        renderItem.z = z;
        renderItem.group = group;
      }
      renderItemsIndex++;
      return renderItem;
    }
    function push(object, geometry, material, groupOrder, z, group) {
      const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);
      if (material.transmission > 0) {
        transmissive.push(renderItem);
      } else if (material.transparent === true) {
        transparent.push(renderItem);
      } else {
        opaque.push(renderItem);
      }
    }
    function unshift(object, geometry, material, groupOrder, z, group) {
      const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);
      if (material.transmission > 0) {
        transmissive.unshift(renderItem);
      } else if (material.transparent === true) {
        transparent.unshift(renderItem);
      } else {
        opaque.unshift(renderItem);
      }
    }
    function sort(customOpaqueSort, customTransparentSort) {
      if (opaque.length > 1)
        opaque.sort(customOpaqueSort || painterSortStable);
      if (transmissive.length > 1)
        transmissive.sort(customTransparentSort || reversePainterSortStable);
      if (transparent.length > 1)
        transparent.sort(customTransparentSort || reversePainterSortStable);
    }
    function finish() {
      for (let i = renderItemsIndex, il = renderItems.length; i < il; i++) {
        const renderItem = renderItems[i];
        if (renderItem.id === null)
          break;
        renderItem.id = null;
        renderItem.object = null;
        renderItem.geometry = null;
        renderItem.material = null;
        renderItem.group = null;
      }
    }
    return {
      opaque,
      transmissive,
      transparent,
      init,
      push,
      unshift,
      finish,
      sort
    };
  }
  function WebGLRenderLists() {
    let lists = /* @__PURE__ */ new WeakMap();
    function get(scene, renderCallDepth) {
      let list;
      if (lists.has(scene) === false) {
        list = new WebGLRenderList();
        lists.set(scene, [list]);
      } else {
        if (renderCallDepth >= lists.get(scene).length) {
          list = new WebGLRenderList();
          lists.get(scene).push(list);
        } else {
          list = lists.get(scene)[renderCallDepth];
        }
      }
      return list;
    }
    function dispose() {
      lists = /* @__PURE__ */ new WeakMap();
    }
    return {
      get,
      dispose
    };
  }
  function UniformsCache() {
    const lights = {};
    return {
      get: function(light) {
        if (lights[light.id] !== void 0) {
          return lights[light.id];
        }
        let uniforms;
        switch (light.type) {
          case "DirectionalLight":
            uniforms = {
              direction: new Vector3(),
              color: new Color()
            };
            break;
          case "SpotLight":
            uniforms = {
              position: new Vector3(),
              direction: new Vector3(),
              color: new Color(),
              distance: 0,
              coneCos: 0,
              penumbraCos: 0,
              decay: 0
            };
            break;
          case "PointLight":
            uniforms = {
              position: new Vector3(),
              color: new Color(),
              distance: 0,
              decay: 0
            };
            break;
          case "HemisphereLight":
            uniforms = {
              direction: new Vector3(),
              skyColor: new Color(),
              groundColor: new Color()
            };
            break;
          case "RectAreaLight":
            uniforms = {
              color: new Color(),
              position: new Vector3(),
              halfWidth: new Vector3(),
              halfHeight: new Vector3()
            };
            break;
        }
        lights[light.id] = uniforms;
        return uniforms;
      }
    };
  }
  function ShadowUniformsCache() {
    const lights = {};
    return {
      get: function(light) {
        if (lights[light.id] !== void 0) {
          return lights[light.id];
        }
        let uniforms;
        switch (light.type) {
          case "DirectionalLight":
            uniforms = {
              shadowBias: 0,
              shadowNormalBias: 0,
              shadowRadius: 1,
              shadowMapSize: new Vector2()
            };
            break;
          case "SpotLight":
            uniforms = {
              shadowBias: 0,
              shadowNormalBias: 0,
              shadowRadius: 1,
              shadowMapSize: new Vector2()
            };
            break;
          case "PointLight":
            uniforms = {
              shadowBias: 0,
              shadowNormalBias: 0,
              shadowRadius: 1,
              shadowMapSize: new Vector2(),
              shadowCameraNear: 1,
              shadowCameraFar: 1e3
            };
            break;
        }
        lights[light.id] = uniforms;
        return uniforms;
      }
    };
  }
  var nextVersion = 0;
  function shadowCastingLightsFirst(lightA, lightB) {
    return (lightB.castShadow ? 1 : 0) - (lightA.castShadow ? 1 : 0);
  }
  function WebGLLights(extensions, capabilities) {
    const cache = new UniformsCache();
    const shadowCache = ShadowUniformsCache();
    const state = {
      version: 0,
      hash: {
        directionalLength: -1,
        pointLength: -1,
        spotLength: -1,
        rectAreaLength: -1,
        hemiLength: -1,
        numDirectionalShadows: -1,
        numPointShadows: -1,
        numSpotShadows: -1
      },
      ambient: [0, 0, 0],
      probe: [],
      directional: [],
      directionalShadow: [],
      directionalShadowMap: [],
      directionalShadowMatrix: [],
      spot: [],
      spotShadow: [],
      spotShadowMap: [],
      spotShadowMatrix: [],
      rectArea: [],
      rectAreaLTC1: null,
      rectAreaLTC2: null,
      point: [],
      pointShadow: [],
      pointShadowMap: [],
      pointShadowMatrix: [],
      hemi: []
    };
    for (let i = 0; i < 9; i++)
      state.probe.push(new Vector3());
    const vector3 = new Vector3();
    const matrix4 = new Matrix4();
    const matrix42 = new Matrix4();
    function setup(lights, physicallyCorrectLights) {
      let r = 0, g = 0, b = 0;
      for (let i = 0; i < 9; i++)
        state.probe[i].set(0, 0, 0);
      let directionalLength = 0;
      let pointLength = 0;
      let spotLength = 0;
      let rectAreaLength = 0;
      let hemiLength = 0;
      let numDirectionalShadows = 0;
      let numPointShadows = 0;
      let numSpotShadows = 0;
      lights.sort(shadowCastingLightsFirst);
      const scaleFactor = physicallyCorrectLights !== true ? Math.PI : 1;
      for (let i = 0, l = lights.length; i < l; i++) {
        const light = lights[i];
        const color = light.color;
        const intensity = light.intensity;
        const distance = light.distance;
        const shadowMap = light.shadow && light.shadow.map ? light.shadow.map.texture : null;
        if (light.isAmbientLight) {
          r += color.r * intensity * scaleFactor;
          g += color.g * intensity * scaleFactor;
          b += color.b * intensity * scaleFactor;
        } else if (light.isLightProbe) {
          for (let j = 0; j < 9; j++) {
            state.probe[j].addScaledVector(light.sh.coefficients[j], intensity);
          }
        } else if (light.isDirectionalLight) {
          const uniforms = cache.get(light);
          uniforms.color.copy(light.color).multiplyScalar(light.intensity * scaleFactor);
          if (light.castShadow) {
            const shadow2 = light.shadow;
            const shadowUniforms = shadowCache.get(light);
            shadowUniforms.shadowBias = shadow2.bias;
            shadowUniforms.shadowNormalBias = shadow2.normalBias;
            shadowUniforms.shadowRadius = shadow2.radius;
            shadowUniforms.shadowMapSize = shadow2.mapSize;
            state.directionalShadow[directionalLength] = shadowUniforms;
            state.directionalShadowMap[directionalLength] = shadowMap;
            state.directionalShadowMatrix[directionalLength] = light.shadow.matrix;
            numDirectionalShadows++;
          }
          state.directional[directionalLength] = uniforms;
          directionalLength++;
        } else if (light.isSpotLight) {
          const uniforms = cache.get(light);
          uniforms.position.setFromMatrixPosition(light.matrixWorld);
          uniforms.color.copy(color).multiplyScalar(intensity * scaleFactor);
          uniforms.distance = distance;
          uniforms.coneCos = Math.cos(light.angle);
          uniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra));
          uniforms.decay = light.decay;
          if (light.castShadow) {
            const shadow2 = light.shadow;
            const shadowUniforms = shadowCache.get(light);
            shadowUniforms.shadowBias = shadow2.bias;
            shadowUniforms.shadowNormalBias = shadow2.normalBias;
            shadowUniforms.shadowRadius = shadow2.radius;
            shadowUniforms.shadowMapSize = shadow2.mapSize;
            state.spotShadow[spotLength] = shadowUniforms;
            state.spotShadowMap[spotLength] = shadowMap;
            state.spotShadowMatrix[spotLength] = light.shadow.matrix;
            numSpotShadows++;
          }
          state.spot[spotLength] = uniforms;
          spotLength++;
        } else if (light.isRectAreaLight) {
          const uniforms = cache.get(light);
          uniforms.color.copy(color).multiplyScalar(intensity);
          uniforms.halfWidth.set(light.width * 0.5, 0, 0);
          uniforms.halfHeight.set(0, light.height * 0.5, 0);
          state.rectArea[rectAreaLength] = uniforms;
          rectAreaLength++;
        } else if (light.isPointLight) {
          const uniforms = cache.get(light);
          uniforms.color.copy(light.color).multiplyScalar(light.intensity * scaleFactor);
          uniforms.distance = light.distance;
          uniforms.decay = light.decay;
          if (light.castShadow) {
            const shadow2 = light.shadow;
            const shadowUniforms = shadowCache.get(light);
            shadowUniforms.shadowBias = shadow2.bias;
            shadowUniforms.shadowNormalBias = shadow2.normalBias;
            shadowUniforms.shadowRadius = shadow2.radius;
            shadowUniforms.shadowMapSize = shadow2.mapSize;
            shadowUniforms.shadowCameraNear = shadow2.camera.near;
            shadowUniforms.shadowCameraFar = shadow2.camera.far;
            state.pointShadow[pointLength] = shadowUniforms;
            state.pointShadowMap[pointLength] = shadowMap;
            state.pointShadowMatrix[pointLength] = light.shadow.matrix;
            numPointShadows++;
          }
          state.point[pointLength] = uniforms;
          pointLength++;
        } else if (light.isHemisphereLight) {
          const uniforms = cache.get(light);
          uniforms.skyColor.copy(light.color).multiplyScalar(intensity * scaleFactor);
          uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity * scaleFactor);
          state.hemi[hemiLength] = uniforms;
          hemiLength++;
        }
      }
      if (rectAreaLength > 0) {
        if (capabilities.isWebGL2) {
          state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
          state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;
        } else {
          if (extensions.has("OES_texture_float_linear") === true) {
            state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
            state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;
          } else if (extensions.has("OES_texture_half_float_linear") === true) {
            state.rectAreaLTC1 = UniformsLib.LTC_HALF_1;
            state.rectAreaLTC2 = UniformsLib.LTC_HALF_2;
          } else {
            console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.");
          }
        }
      }
      state.ambient[0] = r;
      state.ambient[1] = g;
      state.ambient[2] = b;
      const hash = state.hash;
      if (hash.directionalLength !== directionalLength || hash.pointLength !== pointLength || hash.spotLength !== spotLength || hash.rectAreaLength !== rectAreaLength || hash.hemiLength !== hemiLength || hash.numDirectionalShadows !== numDirectionalShadows || hash.numPointShadows !== numPointShadows || hash.numSpotShadows !== numSpotShadows) {
        state.directional.length = directionalLength;
        state.spot.length = spotLength;
        state.rectArea.length = rectAreaLength;
        state.point.length = pointLength;
        state.hemi.length = hemiLength;
        state.directionalShadow.length = numDirectionalShadows;
        state.directionalShadowMap.length = numDirectionalShadows;
        state.pointShadow.length = numPointShadows;
        state.pointShadowMap.length = numPointShadows;
        state.spotShadow.length = numSpotShadows;
        state.spotShadowMap.length = numSpotShadows;
        state.directionalShadowMatrix.length = numDirectionalShadows;
        state.pointShadowMatrix.length = numPointShadows;
        state.spotShadowMatrix.length = numSpotShadows;
        hash.directionalLength = directionalLength;
        hash.pointLength = pointLength;
        hash.spotLength = spotLength;
        hash.rectAreaLength = rectAreaLength;
        hash.hemiLength = hemiLength;
        hash.numDirectionalShadows = numDirectionalShadows;
        hash.numPointShadows = numPointShadows;
        hash.numSpotShadows = numSpotShadows;
        state.version = nextVersion++;
      }
    }
    function setupView(lights, camera) {
      let directionalLength = 0;
      let pointLength = 0;
      let spotLength = 0;
      let rectAreaLength = 0;
      let hemiLength = 0;
      const viewMatrix = camera.matrixWorldInverse;
      for (let i = 0, l = lights.length; i < l; i++) {
        const light = lights[i];
        if (light.isDirectionalLight) {
          const uniforms = state.directional[directionalLength];
          uniforms.direction.setFromMatrixPosition(light.matrixWorld);
          vector3.setFromMatrixPosition(light.target.matrixWorld);
          uniforms.direction.sub(vector3);
          uniforms.direction.transformDirection(viewMatrix);
          directionalLength++;
        } else if (light.isSpotLight) {
          const uniforms = state.spot[spotLength];
          uniforms.position.setFromMatrixPosition(light.matrixWorld);
          uniforms.position.applyMatrix4(viewMatrix);
          uniforms.direction.setFromMatrixPosition(light.matrixWorld);
          vector3.setFromMatrixPosition(light.target.matrixWorld);
          uniforms.direction.sub(vector3);
          uniforms.direction.transformDirection(viewMatrix);
          spotLength++;
        } else if (light.isRectAreaLight) {
          const uniforms = state.rectArea[rectAreaLength];
          uniforms.position.setFromMatrixPosition(light.matrixWorld);
          uniforms.position.applyMatrix4(viewMatrix);
          matrix42.identity();
          matrix4.copy(light.matrixWorld);
          matrix4.premultiply(viewMatrix);
          matrix42.extractRotation(matrix4);
          uniforms.halfWidth.set(light.width * 0.5, 0, 0);
          uniforms.halfHeight.set(0, light.height * 0.5, 0);
          uniforms.halfWidth.applyMatrix4(matrix42);
          uniforms.halfHeight.applyMatrix4(matrix42);
          rectAreaLength++;
        } else if (light.isPointLight) {
          const uniforms = state.point[pointLength];
          uniforms.position.setFromMatrixPosition(light.matrixWorld);
          uniforms.position.applyMatrix4(viewMatrix);
          pointLength++;
        } else if (light.isHemisphereLight) {
          const uniforms = state.hemi[hemiLength];
          uniforms.direction.setFromMatrixPosition(light.matrixWorld);
          uniforms.direction.transformDirection(viewMatrix);
          uniforms.direction.normalize();
          hemiLength++;
        }
      }
    }
    return {
      setup,
      setupView,
      state
    };
  }
  function WebGLRenderState(extensions, capabilities) {
    const lights = new WebGLLights(extensions, capabilities);
    const lightsArray = [];
    const shadowsArray = [];
    function init() {
      lightsArray.length = 0;
      shadowsArray.length = 0;
    }
    function pushLight(light) {
      lightsArray.push(light);
    }
    function pushShadow(shadowLight) {
      shadowsArray.push(shadowLight);
    }
    function setupLights(physicallyCorrectLights) {
      lights.setup(lightsArray, physicallyCorrectLights);
    }
    function setupLightsView(camera) {
      lights.setupView(lightsArray, camera);
    }
    const state = {
      lightsArray,
      shadowsArray,
      lights
    };
    return {
      init,
      state,
      setupLights,
      setupLightsView,
      pushLight,
      pushShadow
    };
  }
  function WebGLRenderStates(extensions, capabilities) {
    let renderStates = /* @__PURE__ */ new WeakMap();
    function get(scene, renderCallDepth = 0) {
      let renderState;
      if (renderStates.has(scene) === false) {
        renderState = new WebGLRenderState(extensions, capabilities);
        renderStates.set(scene, [renderState]);
      } else {
        if (renderCallDepth >= renderStates.get(scene).length) {
          renderState = new WebGLRenderState(extensions, capabilities);
          renderStates.get(scene).push(renderState);
        } else {
          renderState = renderStates.get(scene)[renderCallDepth];
        }
      }
      return renderState;
    }
    function dispose() {
      renderStates = /* @__PURE__ */ new WeakMap();
    }
    return {
      get,
      dispose
    };
  }
  var MeshDepthMaterial = class extends Material {
    constructor(parameters) {
      super();
      this.type = "MeshDepthMaterial";
      this.depthPacking = BasicDepthPacking;
      this.map = null;
      this.alphaMap = null;
      this.displacementMap = null;
      this.displacementScale = 1;
      this.displacementBias = 0;
      this.wireframe = false;
      this.wireframeLinewidth = 1;
      this.fog = false;
      this.setValues(parameters);
    }
    copy(source) {
      super.copy(source);
      this.depthPacking = source.depthPacking;
      this.map = source.map;
      this.alphaMap = source.alphaMap;
      this.displacementMap = source.displacementMap;
      this.displacementScale = source.displacementScale;
      this.displacementBias = source.displacementBias;
      this.wireframe = source.wireframe;
      this.wireframeLinewidth = source.wireframeLinewidth;
      return this;
    }
  };
  MeshDepthMaterial.prototype.isMeshDepthMaterial = true;
  var MeshDistanceMaterial = class extends Material {
    constructor(parameters) {
      super();
      this.type = "MeshDistanceMaterial";
      this.referencePosition = new Vector3();
      this.nearDistance = 1;
      this.farDistance = 1e3;
      this.map = null;
      this.alphaMap = null;
      this.displacementMap = null;
      this.displacementScale = 1;
      this.displacementBias = 0;
      this.fog = false;
      this.setValues(parameters);
    }
    copy(source) {
      super.copy(source);
      this.referencePosition.copy(source.referencePosition);
      this.nearDistance = source.nearDistance;
      this.farDistance = source.farDistance;
      this.map = source.map;
      this.alphaMap = source.alphaMap;
      this.displacementMap = source.displacementMap;
      this.displacementScale = source.displacementScale;
      this.displacementBias = source.displacementBias;
      return this;
    }
  };
  MeshDistanceMaterial.prototype.isMeshDistanceMaterial = true;
  var vertex = "void main() {\n	gl_Position = vec4( position, 1.0 );\n}";
  var fragment = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n	const float samples = float( VSM_SAMPLES );\n	float mean = 0.0;\n	float squared_mean = 0.0;\n	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n	for ( float i = 0.0; i < samples; i ++ ) {\n		float uvOffset = uvStart + i * uvStride;\n		#ifdef HORIZONTAL_PASS\n			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n			mean += distribution.x;\n			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n		#else\n			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n			mean += depth;\n			squared_mean += depth * depth;\n		#endif\n	}\n	mean = mean / samples;\n	squared_mean = squared_mean / samples;\n	float std_dev = sqrt( squared_mean - mean * mean );\n	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";
  function WebGLShadowMap(_renderer, _objects, _capabilities) {
    let _frustum = new Frustum();
    const _shadowMapSize = new Vector2(), _viewportSize = new Vector2(), _viewport = new Vector4(), _depthMaterial = new MeshDepthMaterial({ depthPacking: RGBADepthPacking }), _distanceMaterial = new MeshDistanceMaterial(), _materialCache = {}, _maxTextureSize = _capabilities.maxTextureSize;
    const shadowSide = { 0: BackSide, 1: FrontSide, 2: DoubleSide };
    const shadowMaterialVertical = new ShaderMaterial({
      defines: {
        VSM_SAMPLES: 8
      },
      uniforms: {
        shadow_pass: { value: null },
        resolution: { value: new Vector2() },
        radius: { value: 4 }
      },
      vertexShader: vertex,
      fragmentShader: fragment
    });
    const shadowMaterialHorizontal = shadowMaterialVertical.clone();
    shadowMaterialHorizontal.defines.HORIZONTAL_PASS = 1;
    const fullScreenTri = new BufferGeometry();
    fullScreenTri.setAttribute(
      "position",
      new BufferAttribute(
        new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]),
        3
      )
    );
    const fullScreenMesh = new Mesh(fullScreenTri, shadowMaterialVertical);
    const scope = this;
    this.enabled = false;
    this.autoUpdate = true;
    this.needsUpdate = false;
    this.type = PCFShadowMap;
    this.render = function(lights, scene, camera) {
      if (scope.enabled === false)
        return;
      if (scope.autoUpdate === false && scope.needsUpdate === false)
        return;
      if (lights.length === 0)
        return;
      const currentRenderTarget = _renderer.getRenderTarget();
      const activeCubeFace = _renderer.getActiveCubeFace();
      const activeMipmapLevel = _renderer.getActiveMipmapLevel();
      const _state = _renderer.state;
      _state.setBlending(NoBlending);
      _state.buffers.color.setClear(1, 1, 1, 1);
      _state.buffers.depth.setTest(true);
      _state.setScissorTest(false);
      for (let i = 0, il = lights.length; i < il; i++) {
        const light = lights[i];
        const shadow2 = light.shadow;
        if (shadow2 === void 0) {
          console.warn("THREE.WebGLShadowMap:", light, "has no shadow.");
          continue;
        }
        if (shadow2.autoUpdate === false && shadow2.needsUpdate === false)
          continue;
        _shadowMapSize.copy(shadow2.mapSize);
        const shadowFrameExtents = shadow2.getFrameExtents();
        _shadowMapSize.multiply(shadowFrameExtents);
        _viewportSize.copy(shadow2.mapSize);
        if (_shadowMapSize.x > _maxTextureSize || _shadowMapSize.y > _maxTextureSize) {
          if (_shadowMapSize.x > _maxTextureSize) {
            _viewportSize.x = Math.floor(_maxTextureSize / shadowFrameExtents.x);
            _shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;
            shadow2.mapSize.x = _viewportSize.x;
          }
          if (_shadowMapSize.y > _maxTextureSize) {
            _viewportSize.y = Math.floor(_maxTextureSize / shadowFrameExtents.y);
            _shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;
            shadow2.mapSize.y = _viewportSize.y;
          }
        }
        if (shadow2.map === null && !shadow2.isPointLightShadow && this.type === VSMShadowMap) {
          shadow2.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y);
          shadow2.map.texture.name = light.name + ".shadowMap";
          shadow2.mapPass = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y);
          shadow2.camera.updateProjectionMatrix();
        }
        if (shadow2.map === null) {
          const pars = { minFilter: NearestFilter, magFilter: NearestFilter, format: RGBAFormat };
          shadow2.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
          shadow2.map.texture.name = light.name + ".shadowMap";
          shadow2.camera.updateProjectionMatrix();
        }
        _renderer.setRenderTarget(shadow2.map);
        _renderer.clear();
        const viewportCount = shadow2.getViewportCount();
        for (let vp = 0; vp < viewportCount; vp++) {
          const viewport = shadow2.getViewport(vp);
          _viewport.set(
            _viewportSize.x * viewport.x,
            _viewportSize.y * viewport.y,
            _viewportSize.x * viewport.z,
            _viewportSize.y * viewport.w
          );
          _state.viewport(_viewport);
          shadow2.updateMatrices(light, vp);
          _frustum = shadow2.getFrustum();
          renderObject(scene, camera, shadow2.camera, light, this.type);
        }
        if (!shadow2.isPointLightShadow && this.type === VSMShadowMap) {
          VSMPass(shadow2, camera);
        }
        shadow2.needsUpdate = false;
      }
      scope.needsUpdate = false;
      _renderer.setRenderTarget(currentRenderTarget, activeCubeFace, activeMipmapLevel);
    };
    function VSMPass(shadow2, camera) {
      const geometry = _objects.update(fullScreenMesh);
      if (shadowMaterialVertical.defines.VSM_SAMPLES !== shadow2.blurSamples) {
        shadowMaterialVertical.defines.VSM_SAMPLES = shadow2.blurSamples;
        shadowMaterialHorizontal.defines.VSM_SAMPLES = shadow2.blurSamples;
        shadowMaterialVertical.needsUpdate = true;
        shadowMaterialHorizontal.needsUpdate = true;
      }
      shadowMaterialVertical.uniforms.shadow_pass.value = shadow2.map.texture;
      shadowMaterialVertical.uniforms.resolution.value = shadow2.mapSize;
      shadowMaterialVertical.uniforms.radius.value = shadow2.radius;
      _renderer.setRenderTarget(shadow2.mapPass);
      _renderer.clear();
      _renderer.renderBufferDirect(camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null);
      shadowMaterialHorizontal.uniforms.shadow_pass.value = shadow2.mapPass.texture;
      shadowMaterialHorizontal.uniforms.resolution.value = shadow2.mapSize;
      shadowMaterialHorizontal.uniforms.radius.value = shadow2.radius;
      _renderer.setRenderTarget(shadow2.map);
      _renderer.clear();
      _renderer.renderBufferDirect(camera, null, geometry, shadowMaterialHorizontal, fullScreenMesh, null);
    }
    function getDepthMaterial(object, material, light, shadowCameraNear, shadowCameraFar, type) {
      let result = null;
      const customMaterial = light.isPointLight === true ? object.customDistanceMaterial : object.customDepthMaterial;
      if (customMaterial !== void 0) {
        result = customMaterial;
      } else {
        result = light.isPointLight === true ? _distanceMaterial : _depthMaterial;
      }
      if (_renderer.localClippingEnabled && material.clipShadows === true && material.clippingPlanes.length !== 0 || material.displacementMap && material.displacementScale !== 0 || material.alphaMap && material.alphaTest > 0) {
        const keyA = result.uuid, keyB = material.uuid;
        let materialsForVariant = _materialCache[keyA];
        if (materialsForVariant === void 0) {
          materialsForVariant = {};
          _materialCache[keyA] = materialsForVariant;
        }
        let cachedMaterial = materialsForVariant[keyB];
        if (cachedMaterial === void 0) {
          cachedMaterial = result.clone();
          materialsForVariant[keyB] = cachedMaterial;
        }
        result = cachedMaterial;
      }
      result.visible = material.visible;
      result.wireframe = material.wireframe;
      if (type === VSMShadowMap) {
        result.side = material.shadowSide !== null ? material.shadowSide : material.side;
      } else {
        result.side = material.shadowSide !== null ? material.shadowSide : shadowSide[material.side];
      }
      result.alphaMap = material.alphaMap;
      result.alphaTest = material.alphaTest;
      result.clipShadows = material.clipShadows;
      result.clippingPlanes = material.clippingPlanes;
      result.clipIntersection = material.clipIntersection;
      result.displacementMap = material.displacementMap;
      result.displacementScale = material.displacementScale;
      result.displacementBias = material.displacementBias;
      result.wireframeLinewidth = material.wireframeLinewidth;
      result.linewidth = material.linewidth;
      if (light.isPointLight === true && result.isMeshDistanceMaterial === true) {
        result.referencePosition.setFromMatrixPosition(light.matrixWorld);
        result.nearDistance = shadowCameraNear;
        result.farDistance = shadowCameraFar;
      }
      return result;
    }
    function renderObject(object, camera, shadowCamera, light, type) {
      if (object.visible === false)
        return;
      const visible = object.layers.test(camera.layers);
      if (visible && (object.isMesh || object.isLine || object.isPoints)) {
        if ((object.castShadow || object.receiveShadow && type === VSMShadowMap) && (!object.frustumCulled || _frustum.intersectsObject(object))) {
          object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);
          const geometry = _objects.update(object);
          const material = object.material;
          if (Array.isArray(material)) {
            const groups = geometry.groups;
            for (let k = 0, kl = groups.length; k < kl; k++) {
              const group = groups[k];
              const groupMaterial = material[group.materialIndex];
              if (groupMaterial && groupMaterial.visible) {
                const depthMaterial = getDepthMaterial(object, groupMaterial, light, shadowCamera.near, shadowCamera.far, type);
                _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, group);
              }
            }
          } else if (material.visible) {
            const depthMaterial = getDepthMaterial(object, material, light, shadowCamera.near, shadowCamera.far, type);
            _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, null);
          }
        }
      }
      const children = object.children;
      for (let i = 0, l = children.length; i < l; i++) {
        renderObject(children[i], camera, shadowCamera, light, type);
      }
    }
  }
  function WebGLState(gl, extensions, capabilities) {
    const isWebGL2 = capabilities.isWebGL2;
    function ColorBuffer() {
      let locked = false;
      const color = new Vector4();
      let currentColorMask = null;
      const currentColorClear = new Vector4(0, 0, 0, 0);
      return {
        setMask: function(colorMask) {
          if (currentColorMask !== colorMask && !locked) {
            gl.colorMask(colorMask, colorMask, colorMask, colorMask);
            currentColorMask = colorMask;
          }
        },
        setLocked: function(lock) {
          locked = lock;
        },
        setClear: function(r, g, b, a, premultipliedAlpha) {
          if (premultipliedAlpha === true) {
            r *= a;
            g *= a;
            b *= a;
          }
          color.set(r, g, b, a);
          if (currentColorClear.equals(color) === false) {
            gl.clearColor(r, g, b, a);
            currentColorClear.copy(color);
          }
        },
        reset: function() {
          locked = false;
          currentColorMask = null;
          currentColorClear.set(-1, 0, 0, 0);
        }
      };
    }
    function DepthBuffer() {
      let locked = false;
      let currentDepthMask = null;
      let currentDepthFunc = null;
      let currentDepthClear = null;
      return {
        setTest: function(depthTest) {
          if (depthTest) {
            enable(2929);
          } else {
            disable(2929);
          }
        },
        setMask: function(depthMask) {
          if (currentDepthMask !== depthMask && !locked) {
            gl.depthMask(depthMask);
            currentDepthMask = depthMask;
          }
        },
        setFunc: function(depthFunc) {
          if (currentDepthFunc !== depthFunc) {
            if (depthFunc) {
              switch (depthFunc) {
                case NeverDepth:
                  gl.depthFunc(512);
                  break;
                case AlwaysDepth:
                  gl.depthFunc(519);
                  break;
                case LessDepth:
                  gl.depthFunc(513);
                  break;
                case LessEqualDepth:
                  gl.depthFunc(515);
                  break;
                case EqualDepth:
                  gl.depthFunc(514);
                  break;
                case GreaterEqualDepth:
                  gl.depthFunc(518);
                  break;
                case GreaterDepth:
                  gl.depthFunc(516);
                  break;
                case NotEqualDepth:
                  gl.depthFunc(517);
                  break;
                default:
                  gl.depthFunc(515);
              }
            } else {
              gl.depthFunc(515);
            }
            currentDepthFunc = depthFunc;
          }
        },
        setLocked: function(lock) {
          locked = lock;
        },
        setClear: function(depth) {
          if (currentDepthClear !== depth) {
            gl.clearDepth(depth);
            currentDepthClear = depth;
          }
        },
        reset: function() {
          locked = false;
          currentDepthMask = null;
          currentDepthFunc = null;
          currentDepthClear = null;
        }
      };
    }
    function StencilBuffer() {
      let locked = false;
      let currentStencilMask = null;
      let currentStencilFunc = null;
      let currentStencilRef = null;
      let currentStencilFuncMask = null;
      let currentStencilFail = null;
      let currentStencilZFail = null;
      let currentStencilZPass = null;
      let currentStencilClear = null;
      return {
        setTest: function(stencilTest) {
          if (!locked) {
            if (stencilTest) {
              enable(2960);
            } else {
              disable(2960);
            }
          }
        },
        setMask: function(stencilMask) {
          if (currentStencilMask !== stencilMask && !locked) {
            gl.stencilMask(stencilMask);
            currentStencilMask = stencilMask;
          }
        },
        setFunc: function(stencilFunc, stencilRef, stencilMask) {
          if (currentStencilFunc !== stencilFunc || currentStencilRef !== stencilRef || currentStencilFuncMask !== stencilMask) {
            gl.stencilFunc(stencilFunc, stencilRef, stencilMask);
            currentStencilFunc = stencilFunc;
            currentStencilRef = stencilRef;
            currentStencilFuncMask = stencilMask;
          }
        },
        setOp: function(stencilFail, stencilZFail, stencilZPass) {
          if (currentStencilFail !== stencilFail || currentStencilZFail !== stencilZFail || currentStencilZPass !== stencilZPass) {
            gl.stencilOp(stencilFail, stencilZFail, stencilZPass);
            currentStencilFail = stencilFail;
            currentStencilZFail = stencilZFail;
            currentStencilZPass = stencilZPass;
          }
        },
        setLocked: function(lock) {
          locked = lock;
        },
        setClear: function(stencil) {
          if (currentStencilClear !== stencil) {
            gl.clearStencil(stencil);
            currentStencilClear = stencil;
          }
        },
        reset: function() {
          locked = false;
          currentStencilMask = null;
          currentStencilFunc = null;
          currentStencilRef = null;
          currentStencilFuncMask = null;
          currentStencilFail = null;
          currentStencilZFail = null;
          currentStencilZPass = null;
          currentStencilClear = null;
        }
      };
    }
    const colorBuffer = new ColorBuffer();
    const depthBuffer = new DepthBuffer();
    const stencilBuffer = new StencilBuffer();
    let enabledCapabilities = {};
    let currentBoundFramebuffers = {};
    let currentDrawbuffers = /* @__PURE__ */ new WeakMap();
    let defaultDrawbuffers = [];
    let currentProgram = null;
    let currentBlendingEnabled = false;
    let currentBlending = null;
    let currentBlendEquation = null;
    let currentBlendSrc = null;
    let currentBlendDst = null;
    let currentBlendEquationAlpha = null;
    let currentBlendSrcAlpha = null;
    let currentBlendDstAlpha = null;
    let currentPremultipledAlpha = false;
    let currentFlipSided = null;
    let currentCullFace = null;
    let currentLineWidth = null;
    let currentPolygonOffsetFactor = null;
    let currentPolygonOffsetUnits = null;
    const maxTextures = gl.getParameter(35661);
    let lineWidthAvailable = false;
    let version = 0;
    const glVersion = gl.getParameter(7938);
    if (glVersion.indexOf("WebGL") !== -1) {
      version = parseFloat(/^WebGL (\d)/.exec(glVersion)[1]);
      lineWidthAvailable = version >= 1;
    } else if (glVersion.indexOf("OpenGL ES") !== -1) {
      version = parseFloat(/^OpenGL ES (\d)/.exec(glVersion)[1]);
      lineWidthAvailable = version >= 2;
    }
    let currentTextureSlot = null;
    let currentBoundTextures = {};
    const scissorParam = gl.getParameter(3088);
    const viewportParam = gl.getParameter(2978);
    const currentScissor = new Vector4().fromArray(scissorParam);
    const currentViewport = new Vector4().fromArray(viewportParam);
    function createTexture(type, target, count) {
      const data = new Uint8Array(4);
      const texture = gl.createTexture();
      gl.bindTexture(type, texture);
      gl.texParameteri(type, 10241, 9728);
      gl.texParameteri(type, 10240, 9728);
      for (let i = 0; i < count; i++) {
        gl.texImage2D(target + i, 0, 6408, 1, 1, 0, 6408, 5121, data);
      }
      return texture;
    }
    const emptyTextures = {};
    emptyTextures[3553] = createTexture(3553, 3553, 1);
    emptyTextures[34067] = createTexture(34067, 34069, 6);
    colorBuffer.setClear(0, 0, 0, 1);
    depthBuffer.setClear(1);
    stencilBuffer.setClear(0);
    enable(2929);
    depthBuffer.setFunc(LessEqualDepth);
    setFlipSided(false);
    setCullFace(CullFaceBack);
    enable(2884);
    setBlending(NoBlending);
    function enable(id) {
      if (enabledCapabilities[id] !== true) {
        gl.enable(id);
        enabledCapabilities[id] = true;
      }
    }
    function disable(id) {
      if (enabledCapabilities[id] !== false) {
        gl.disable(id);
        enabledCapabilities[id] = false;
      }
    }
    function bindFramebuffer(target, framebuffer) {
      if (currentBoundFramebuffers[target] !== framebuffer) {
        gl.bindFramebuffer(target, framebuffer);
        currentBoundFramebuffers[target] = framebuffer;
        if (isWebGL2) {
          if (target === 36009) {
            currentBoundFramebuffers[36160] = framebuffer;
          }
          if (target === 36160) {
            currentBoundFramebuffers[36009] = framebuffer;
          }
        }
        return true;
      }
      return false;
    }
    function drawBuffers(renderTarget, framebuffer) {
      let drawBuffers2 = defaultDrawbuffers;
      let needsUpdate = false;
      if (renderTarget) {
        drawBuffers2 = currentDrawbuffers.get(framebuffer);
        if (drawBuffers2 === void 0) {
          drawBuffers2 = [];
          currentDrawbuffers.set(framebuffer, drawBuffers2);
        }
        if (renderTarget.isWebGLMultipleRenderTargets) {
          const textures = renderTarget.texture;
          if (drawBuffers2.length !== textures.length || drawBuffers2[0] !== 36064) {
            for (let i = 0, il = textures.length; i < il; i++) {
              drawBuffers2[i] = 36064 + i;
            }
            drawBuffers2.length = textures.length;
            needsUpdate = true;
          }
        } else {
          if (drawBuffers2[0] !== 36064) {
            drawBuffers2[0] = 36064;
            needsUpdate = true;
          }
        }
      } else {
        if (drawBuffers2[0] !== 1029) {
          drawBuffers2[0] = 1029;
          needsUpdate = true;
        }
      }
      if (needsUpdate) {
        if (capabilities.isWebGL2) {
          gl.drawBuffers(drawBuffers2);
        } else {
          extensions.get("WEBGL_draw_buffers").drawBuffersWEBGL(drawBuffers2);
        }
      }
    }
    function useProgram(program) {
      if (currentProgram !== program) {
        gl.useProgram(program);
        currentProgram = program;
        return true;
      }
      return false;
    }
    const equationToGL = {
      [AddEquation]: 32774,
      [SubtractEquation]: 32778,
      [ReverseSubtractEquation]: 32779
    };
    if (isWebGL2) {
      equationToGL[MinEquation] = 32775;
      equationToGL[MaxEquation] = 32776;
    } else {
      const extension = extensions.get("EXT_blend_minmax");
      if (extension !== null) {
        equationToGL[MinEquation] = extension.MIN_EXT;
        equationToGL[MaxEquation] = extension.MAX_EXT;
      }
    }
    const factorToGL = {
      [ZeroFactor]: 0,
      [OneFactor]: 1,
      [SrcColorFactor]: 768,
      [SrcAlphaFactor]: 770,
      [SrcAlphaSaturateFactor]: 776,
      [DstColorFactor]: 774,
      [DstAlphaFactor]: 772,
      [OneMinusSrcColorFactor]: 769,
      [OneMinusSrcAlphaFactor]: 771,
      [OneMinusDstColorFactor]: 775,
      [OneMinusDstAlphaFactor]: 773
    };
    function setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha) {
      if (blending === NoBlending) {
        if (currentBlendingEnabled === true) {
          disable(3042);
          currentBlendingEnabled = false;
        }
        return;
      }
      if (currentBlendingEnabled === false) {
        enable(3042);
        currentBlendingEnabled = true;
      }
      if (blending !== CustomBlending) {
        if (blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha) {
          if (currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation) {
            gl.blendEquation(32774);
            currentBlendEquation = AddEquation;
            currentBlendEquationAlpha = AddEquation;
          }
          if (premultipliedAlpha) {
            switch (blending) {
              case NormalBlending:
                gl.blendFuncSeparate(1, 771, 1, 771);
                break;
              case AdditiveBlending:
                gl.blendFunc(1, 1);
                break;
              case SubtractiveBlending:
                gl.blendFuncSeparate(0, 769, 0, 1);
                break;
              case MultiplyBlending:
                gl.blendFuncSeparate(0, 768, 0, 770);
                break;
              default:
                console.error("THREE.WebGLState: Invalid blending: ", blending);
                break;
            }
          } else {
            switch (blending) {
              case NormalBlending:
                gl.blendFuncSeparate(770, 771, 1, 771);
                break;
              case AdditiveBlending:
                gl.blendFunc(770, 1);
                break;
              case SubtractiveBlending:
                gl.blendFuncSeparate(0, 769, 0, 1);
                break;
              case MultiplyBlending:
                gl.blendFunc(0, 768);
                break;
              default:
                console.error("THREE.WebGLState: Invalid blending: ", blending);
                break;
            }
          }
          currentBlendSrc = null;
          currentBlendDst = null;
          currentBlendSrcAlpha = null;
          currentBlendDstAlpha = null;
          currentBlending = blending;
          currentPremultipledAlpha = premultipliedAlpha;
        }
        return;
      }
      blendEquationAlpha = blendEquationAlpha || blendEquation;
      blendSrcAlpha = blendSrcAlpha || blendSrc;
      blendDstAlpha = blendDstAlpha || blendDst;
      if (blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha) {
        gl.blendEquationSeparate(equationToGL[blendEquation], equationToGL[blendEquationAlpha]);
        currentBlendEquation = blendEquation;
        currentBlendEquationAlpha = blendEquationAlpha;
      }
      if (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha) {
        gl.blendFuncSeparate(factorToGL[blendSrc], factorToGL[blendDst], factorToGL[blendSrcAlpha], factorToGL[blendDstAlpha]);
        currentBlendSrc = blendSrc;
        currentBlendDst = blendDst;
        currentBlendSrcAlpha = blendSrcAlpha;
        currentBlendDstAlpha = blendDstAlpha;
      }
      currentBlending = blending;
      currentPremultipledAlpha = null;
    }
    function setMaterial(material, frontFaceCW) {
      material.side === DoubleSide ? disable(2884) : enable(2884);
      let flipSided = material.side === BackSide;
      if (frontFaceCW)
        flipSided = !flipSided;
      setFlipSided(flipSided);
      material.blending === NormalBlending && material.transparent === false ? setBlending(NoBlending) : setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha);
      depthBuffer.setFunc(material.depthFunc);
      depthBuffer.setTest(material.depthTest);
      depthBuffer.setMask(material.depthWrite);
      colorBuffer.setMask(material.colorWrite);
      const stencilWrite = material.stencilWrite;
      stencilBuffer.setTest(stencilWrite);
      if (stencilWrite) {
        stencilBuffer.setMask(material.stencilWriteMask);
        stencilBuffer.setFunc(material.stencilFunc, material.stencilRef, material.stencilFuncMask);
        stencilBuffer.setOp(material.stencilFail, material.stencilZFail, material.stencilZPass);
      }
      setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
      material.alphaToCoverage === true ? enable(32926) : disable(32926);
    }
    function setFlipSided(flipSided) {
      if (currentFlipSided !== flipSided) {
        if (flipSided) {
          gl.frontFace(2304);
        } else {
          gl.frontFace(2305);
        }
        currentFlipSided = flipSided;
      }
    }
    function setCullFace(cullFace) {
      if (cullFace !== CullFaceNone) {
        enable(2884);
        if (cullFace !== currentCullFace) {
          if (cullFace === CullFaceBack) {
            gl.cullFace(1029);
          } else if (cullFace === CullFaceFront) {
            gl.cullFace(1028);
          } else {
            gl.cullFace(1032);
          }
        }
      } else {
        disable(2884);
      }
      currentCullFace = cullFace;
    }
    function setLineWidth(width) {
      if (width !== currentLineWidth) {
        if (lineWidthAvailable)
          gl.lineWidth(width);
        currentLineWidth = width;
      }
    }
    function setPolygonOffset(polygonOffset, factor, units) {
      if (polygonOffset) {
        enable(32823);
        if (currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units) {
          gl.polygonOffset(factor, units);
          currentPolygonOffsetFactor = factor;
          currentPolygonOffsetUnits = units;
        }
      } else {
        disable(32823);
      }
    }
    function setScissorTest(scissorTest) {
      if (scissorTest) {
        enable(3089);
      } else {
        disable(3089);
      }
    }
    function activeTexture(webglSlot) {
      if (webglSlot === void 0)
        webglSlot = 33984 + maxTextures - 1;
      if (currentTextureSlot !== webglSlot) {
        gl.activeTexture(webglSlot);
        currentTextureSlot = webglSlot;
      }
    }
    function bindTexture(webglType, webglTexture) {
      if (currentTextureSlot === null) {
        activeTexture();
      }
      let boundTexture = currentBoundTextures[currentTextureSlot];
      if (boundTexture === void 0) {
        boundTexture = { type: void 0, texture: void 0 };
        currentBoundTextures[currentTextureSlot] = boundTexture;
      }
      if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {
        gl.bindTexture(webglType, webglTexture || emptyTextures[webglType]);
        boundTexture.type = webglType;
        boundTexture.texture = webglTexture;
      }
    }
    function unbindTexture() {
      const boundTexture = currentBoundTextures[currentTextureSlot];
      if (boundTexture !== void 0 && boundTexture.type !== void 0) {
        gl.bindTexture(boundTexture.type, null);
        boundTexture.type = void 0;
        boundTexture.texture = void 0;
      }
    }
    function compressedTexImage2D() {
      try {
        gl.compressedTexImage2D.apply(gl, arguments);
      } catch (error2) {
        console.error("THREE.WebGLState:", error2);
      }
    }
    function texSubImage2D() {
      try {
        gl.texSubImage2D.apply(gl, arguments);
      } catch (error2) {
        console.error("THREE.WebGLState:", error2);
      }
    }
    function texSubImage3D() {
      try {
        gl.texSubImage3D.apply(gl, arguments);
      } catch (error2) {
        console.error("THREE.WebGLState:", error2);
      }
    }
    function compressedTexSubImage2D() {
      try {
        gl.compressedTexSubImage2D.apply(gl, arguments);
      } catch (error2) {
        console.error("THREE.WebGLState:", error2);
      }
    }
    function texStorage2D() {
      try {
        gl.texStorage2D.apply(gl, arguments);
      } catch (error2) {
        console.error("THREE.WebGLState:", error2);
      }
    }
    function texStorage3D() {
      try {
        gl.texStorage3D.apply(gl, arguments);
      } catch (error2) {
        console.error("THREE.WebGLState:", error2);
      }
    }
    function texImage2D() {
      try {
        gl.texImage2D.apply(gl, arguments);
      } catch (error2) {
        console.error("THREE.WebGLState:", error2);
      }
    }
    function texImage3D() {
      try {
        gl.texImage3D.apply(gl, arguments);
      } catch (error2) {
        console.error("THREE.WebGLState:", error2);
      }
    }
    function scissor(scissor2) {
      if (currentScissor.equals(scissor2) === false) {
        gl.scissor(scissor2.x, scissor2.y, scissor2.z, scissor2.w);
        currentScissor.copy(scissor2);
      }
    }
    function viewport(viewport2) {
      if (currentViewport.equals(viewport2) === false) {
        gl.viewport(viewport2.x, viewport2.y, viewport2.z, viewport2.w);
        currentViewport.copy(viewport2);
      }
    }
    function reset() {
      gl.disable(3042);
      gl.disable(2884);
      gl.disable(2929);
      gl.disable(32823);
      gl.disable(3089);
      gl.disable(2960);
      gl.disable(32926);
      gl.blendEquation(32774);
      gl.blendFunc(1, 0);
      gl.blendFuncSeparate(1, 0, 1, 0);
      gl.colorMask(true, true, true, true);
      gl.clearColor(0, 0, 0, 0);
      gl.depthMask(true);
      gl.depthFunc(513);
      gl.clearDepth(1);
      gl.stencilMask(4294967295);
      gl.stencilFunc(519, 0, 4294967295);
      gl.stencilOp(7680, 7680, 7680);
      gl.clearStencil(0);
      gl.cullFace(1029);
      gl.frontFace(2305);
      gl.polygonOffset(0, 0);
      gl.activeTexture(33984);
      gl.bindFramebuffer(36160, null);
      if (isWebGL2 === true) {
        gl.bindFramebuffer(36009, null);
        gl.bindFramebuffer(36008, null);
      }
      gl.useProgram(null);
      gl.lineWidth(1);
      gl.scissor(0, 0, gl.canvas.width, gl.canvas.height);
      gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
      enabledCapabilities = {};
      currentTextureSlot = null;
      currentBoundTextures = {};
      currentBoundFramebuffers = {};
      currentDrawbuffers = /* @__PURE__ */ new WeakMap();
      defaultDrawbuffers = [];
      currentProgram = null;
      currentBlendingEnabled = false;
      currentBlending = null;
      currentBlendEquation = null;
      currentBlendSrc = null;
      currentBlendDst = null;
      currentBlendEquationAlpha = null;
      currentBlendSrcAlpha = null;
      currentBlendDstAlpha = null;
      currentPremultipledAlpha = false;
      currentFlipSided = null;
      currentCullFace = null;
      currentLineWidth = null;
      currentPolygonOffsetFactor = null;
      currentPolygonOffsetUnits = null;
      currentScissor.set(0, 0, gl.canvas.width, gl.canvas.height);
      currentViewport.set(0, 0, gl.canvas.width, gl.canvas.height);
      colorBuffer.reset();
      depthBuffer.reset();
      stencilBuffer.reset();
    }
    return {
      buffers: {
        color: colorBuffer,
        depth: depthBuffer,
        stencil: stencilBuffer
      },
      enable,
      disable,
      bindFramebuffer,
      drawBuffers,
      useProgram,
      setBlending,
      setMaterial,
      setFlipSided,
      setCullFace,
      setLineWidth,
      setPolygonOffset,
      setScissorTest,
      activeTexture,
      bindTexture,
      unbindTexture,
      compressedTexImage2D,
      texImage2D,
      texImage3D,
      texStorage2D,
      texStorage3D,
      texSubImage2D,
      texSubImage3D,
      compressedTexSubImage2D,
      scissor,
      viewport,
      reset
    };
  }
  function WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info) {
    const isWebGL2 = capabilities.isWebGL2;
    const maxTextures = capabilities.maxTextures;
    const maxCubemapSize = capabilities.maxCubemapSize;
    const maxTextureSize = capabilities.maxTextureSize;
    const maxSamples = capabilities.maxSamples;
    const multisampledRTTExt = extensions.has("WEBGL_multisampled_render_to_texture") ? extensions.get("WEBGL_multisampled_render_to_texture") : null;
    const supportsInvalidateFramebuffer = /OculusBrowser/g.test(navigator.userAgent);
    const _videoTextures = /* @__PURE__ */ new WeakMap();
    let _canvas2;
    const _sources = /* @__PURE__ */ new WeakMap();
    let useOffscreenCanvas = false;
    try {
      useOffscreenCanvas = typeof OffscreenCanvas !== "undefined" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
    } catch (err) {
    }
    function createCanvas(width, height) {
      return useOffscreenCanvas ? (
        // eslint-disable-next-line compat/compat
        new OffscreenCanvas(width, height)
      ) : createElementNS("canvas");
    }
    function resizeImage(image, needsPowerOfTwo, needsNewCanvas, maxSize) {
      let scale = 1;
      if (image.width > maxSize || image.height > maxSize) {
        scale = maxSize / Math.max(image.width, image.height);
      }
      if (scale < 1 || needsPowerOfTwo === true) {
        if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
          const floor = needsPowerOfTwo ? floorPowerOfTwo : Math.floor;
          const width = floor(scale * image.width);
          const height = floor(scale * image.height);
          if (_canvas2 === void 0)
            _canvas2 = createCanvas(width, height);
          const canvas = needsNewCanvas ? createCanvas(width, height) : _canvas2;
          canvas.width = width;
          canvas.height = height;
          const context = canvas.getContext("2d");
          context.drawImage(image, 0, 0, width, height);
          console.warn("THREE.WebGLRenderer: Texture has been resized from (" + image.width + "x" + image.height + ") to (" + width + "x" + height + ").");
          return canvas;
        } else {
          if ("data" in image) {
            console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + image.width + "x" + image.height + ").");
          }
          return image;
        }
      }
      return image;
    }
    function isPowerOfTwo$1(image) {
      return isPowerOfTwo(image.width) && isPowerOfTwo(image.height);
    }
    function textureNeedsPowerOfTwo(texture) {
      if (isWebGL2)
        return false;
      return texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping || texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
    }
    function textureNeedsGenerateMipmaps(texture, supportsMips) {
      return texture.generateMipmaps && supportsMips && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
    }
    function generateMipmap(target) {
      _gl.generateMipmap(target);
    }
    function getInternalFormat(internalFormatName, glFormat, glType, encoding, isVideoTexture = false) {
      if (isWebGL2 === false)
        return glFormat;
      if (internalFormatName !== null) {
        if (_gl[internalFormatName] !== void 0)
          return _gl[internalFormatName];
        console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + internalFormatName + "'");
      }
      let internalFormat = glFormat;
      if (glFormat === 6403) {
        if (glType === 5126)
          internalFormat = 33326;
        if (glType === 5131)
          internalFormat = 33325;
        if (glType === 5121)
          internalFormat = 33321;
      }
      if (glFormat === 33319) {
        if (glType === 5126)
          internalFormat = 33328;
        if (glType === 5131)
          internalFormat = 33327;
        if (glType === 5121)
          internalFormat = 33323;
      }
      if (glFormat === 6408) {
        if (glType === 5126)
          internalFormat = 34836;
        if (glType === 5131)
          internalFormat = 34842;
        if (glType === 5121)
          internalFormat = encoding === sRGBEncoding && isVideoTexture === false ? 35907 : 32856;
        if (glType === 32819)
          internalFormat = 32854;
        if (glType === 32820)
          internalFormat = 32855;
      }
      if (internalFormat === 33325 || internalFormat === 33326 || internalFormat === 33327 || internalFormat === 33328 || internalFormat === 34842 || internalFormat === 34836) {
        extensions.get("EXT_color_buffer_float");
      }
      return internalFormat;
    }
    function getMipLevels(texture, image, supportsMips) {
      if (textureNeedsGenerateMipmaps(texture, supportsMips) === true || texture.isFramebufferTexture && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) {
        return Math.log2(Math.max(image.width, image.height)) + 1;
      } else if (texture.mipmaps !== void 0 && texture.mipmaps.length > 0) {
        return texture.mipmaps.length;
      } else if (texture.isCompressedTexture && Array.isArray(texture.image)) {
        return image.mipmaps.length;
      } else {
        return 1;
      }
    }
    function filterFallback(f) {
      if (f === NearestFilter || f === NearestMipmapNearestFilter || f === NearestMipmapLinearFilter) {
        return 9728;
      }
      return 9729;
    }
    function onTextureDispose(event) {
      const texture = event.target;
      texture.removeEventListener("dispose", onTextureDispose);
      deallocateTexture(texture);
      if (texture.isVideoTexture) {
        _videoTextures.delete(texture);
      }
    }
    function onRenderTargetDispose(event) {
      const renderTarget = event.target;
      renderTarget.removeEventListener("dispose", onRenderTargetDispose);
      deallocateRenderTarget(renderTarget);
    }
    function deallocateTexture(texture) {
      const textureProperties = properties.get(texture);
      if (textureProperties.__webglInit === void 0)
        return;
      const source = texture.source;
      const webglTextures = _sources.get(source);
      if (webglTextures) {
        const webglTexture = webglTextures[textureProperties.__cacheKey];
        webglTexture.usedTimes--;
        if (webglTexture.usedTimes === 0) {
          deleteTexture(texture);
        }
        if (Object.keys(webglTextures).length === 0) {
          _sources.delete(source);
        }
      }
      properties.remove(texture);
    }
    function deleteTexture(texture) {
      const textureProperties = properties.get(texture);
      _gl.deleteTexture(textureProperties.__webglTexture);
      const source = texture.source;
      const webglTextures = _sources.get(source);
      delete webglTextures[textureProperties.__cacheKey];
      info.memory.textures--;
    }
    function deallocateRenderTarget(renderTarget) {
      const texture = renderTarget.texture;
      const renderTargetProperties = properties.get(renderTarget);
      const textureProperties = properties.get(texture);
      if (textureProperties.__webglTexture !== void 0) {
        _gl.deleteTexture(textureProperties.__webglTexture);
        info.memory.textures--;
      }
      if (renderTarget.depthTexture) {
        renderTarget.depthTexture.dispose();
      }
      if (renderTarget.isWebGLCubeRenderTarget) {
        for (let i = 0; i < 6; i++) {
          _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i]);
          if (renderTargetProperties.__webglDepthbuffer)
            _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i]);
        }
      } else {
        _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);
        if (renderTargetProperties.__webglDepthbuffer)
          _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);
        if (renderTargetProperties.__webglMultisampledFramebuffer)
          _gl.deleteFramebuffer(renderTargetProperties.__webglMultisampledFramebuffer);
        if (renderTargetProperties.__webglColorRenderbuffer)
          _gl.deleteRenderbuffer(renderTargetProperties.__webglColorRenderbuffer);
        if (renderTargetProperties.__webglDepthRenderbuffer)
          _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthRenderbuffer);
      }
      if (renderTarget.isWebGLMultipleRenderTargets) {
        for (let i = 0, il = texture.length; i < il; i++) {
          const attachmentProperties = properties.get(texture[i]);
          if (attachmentProperties.__webglTexture) {
            _gl.deleteTexture(attachmentProperties.__webglTexture);
            info.memory.textures--;
          }
          properties.remove(texture[i]);
        }
      }
      properties.remove(texture);
      properties.remove(renderTarget);
    }
    let textureUnits = 0;
    function resetTextureUnits() {
      textureUnits = 0;
    }
    function allocateTextureUnit() {
      const textureUnit = textureUnits;
      if (textureUnit >= maxTextures) {
        console.warn("THREE.WebGLTextures: Trying to use " + textureUnit + " texture units while this GPU supports only " + maxTextures);
      }
      textureUnits += 1;
      return textureUnit;
    }
    function getTextureCacheKey(texture) {
      const array = [];
      array.push(texture.wrapS);
      array.push(texture.wrapT);
      array.push(texture.magFilter);
      array.push(texture.minFilter);
      array.push(texture.anisotropy);
      array.push(texture.internalFormat);
      array.push(texture.format);
      array.push(texture.type);
      array.push(texture.generateMipmaps);
      array.push(texture.premultiplyAlpha);
      array.push(texture.flipY);
      array.push(texture.unpackAlignment);
      array.push(texture.encoding);
      return array.join();
    }
    function setTexture2D(texture, slot) {
      const textureProperties = properties.get(texture);
      if (texture.isVideoTexture)
        updateVideoTexture(texture);
      if (texture.isRenderTargetTexture === false && texture.version > 0 && textureProperties.__version !== texture.version) {
        const image = texture.image;
        if (image === null) {
          console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
        } else if (image.complete === false) {
          console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
        } else {
          uploadTexture(textureProperties, texture, slot);
          return;
        }
      }
      state.activeTexture(33984 + slot);
      state.bindTexture(3553, textureProperties.__webglTexture);
    }
    function setTexture2DArray(texture, slot) {
      const textureProperties = properties.get(texture);
      if (texture.version > 0 && textureProperties.__version !== texture.version) {
        uploadTexture(textureProperties, texture, slot);
        return;
      }
      state.activeTexture(33984 + slot);
      state.bindTexture(35866, textureProperties.__webglTexture);
    }
    function setTexture3D(texture, slot) {
      const textureProperties = properties.get(texture);
      if (texture.version > 0 && textureProperties.__version !== texture.version) {
        uploadTexture(textureProperties, texture, slot);
        return;
      }
      state.activeTexture(33984 + slot);
      state.bindTexture(32879, textureProperties.__webglTexture);
    }
    function setTextureCube(texture, slot) {
      const textureProperties = properties.get(texture);
      if (texture.version > 0 && textureProperties.__version !== texture.version) {
        uploadCubeTexture(textureProperties, texture, slot);
        return;
      }
      state.activeTexture(33984 + slot);
      state.bindTexture(34067, textureProperties.__webglTexture);
    }
    const wrappingToGL = {
      [RepeatWrapping]: 10497,
      [ClampToEdgeWrapping]: 33071,
      [MirroredRepeatWrapping]: 33648
    };
    const filterToGL = {
      [NearestFilter]: 9728,
      [NearestMipmapNearestFilter]: 9984,
      [NearestMipmapLinearFilter]: 9986,
      [LinearFilter]: 9729,
      [LinearMipmapNearestFilter]: 9985,
      [LinearMipmapLinearFilter]: 9987
    };
    function setTextureParameters(textureType, texture, supportsMips) {
      if (supportsMips) {
        _gl.texParameteri(textureType, 10242, wrappingToGL[texture.wrapS]);
        _gl.texParameteri(textureType, 10243, wrappingToGL[texture.wrapT]);
        if (textureType === 32879 || textureType === 35866) {
          _gl.texParameteri(textureType, 32882, wrappingToGL[texture.wrapR]);
        }
        _gl.texParameteri(textureType, 10240, filterToGL[texture.magFilter]);
        _gl.texParameteri(textureType, 10241, filterToGL[texture.minFilter]);
      } else {
        _gl.texParameteri(textureType, 10242, 33071);
        _gl.texParameteri(textureType, 10243, 33071);
        if (textureType === 32879 || textureType === 35866) {
          _gl.texParameteri(textureType, 32882, 33071);
        }
        if (texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping) {
          console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.");
        }
        _gl.texParameteri(textureType, 10240, filterFallback(texture.magFilter));
        _gl.texParameteri(textureType, 10241, filterFallback(texture.minFilter));
        if (texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) {
          console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.");
        }
      }
      if (extensions.has("EXT_texture_filter_anisotropic") === true) {
        const extension = extensions.get("EXT_texture_filter_anisotropic");
        if (texture.type === FloatType && extensions.has("OES_texture_float_linear") === false)
          return;
        if (isWebGL2 === false && (texture.type === HalfFloatType && extensions.has("OES_texture_half_float_linear") === false))
          return;
        if (texture.anisotropy > 1 || properties.get(texture).__currentAnisotropy) {
          _gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, capabilities.getMaxAnisotropy()));
          properties.get(texture).__currentAnisotropy = texture.anisotropy;
        }
      }
    }
    function initTexture(textureProperties, texture) {
      let forceUpload = false;
      if (textureProperties.__webglInit === void 0) {
        textureProperties.__webglInit = true;
        texture.addEventListener("dispose", onTextureDispose);
      }
      const source = texture.source;
      let webglTextures = _sources.get(source);
      if (webglTextures === void 0) {
        webglTextures = {};
        _sources.set(source, webglTextures);
      }
      const textureCacheKey = getTextureCacheKey(texture);
      if (textureCacheKey !== textureProperties.__cacheKey) {
        if (webglTextures[textureCacheKey] === void 0) {
          webglTextures[textureCacheKey] = {
            texture: _gl.createTexture(),
            usedTimes: 0
          };
          info.memory.textures++;
          forceUpload = true;
        }
        webglTextures[textureCacheKey].usedTimes++;
        const webglTexture = webglTextures[textureProperties.__cacheKey];
        if (webglTexture !== void 0) {
          webglTextures[textureProperties.__cacheKey].usedTimes--;
          if (webglTexture.usedTimes === 0) {
            deleteTexture(texture);
          }
        }
        textureProperties.__cacheKey = textureCacheKey;
        textureProperties.__webglTexture = webglTextures[textureCacheKey].texture;
      }
      return forceUpload;
    }
    function uploadTexture(textureProperties, texture, slot) {
      let textureType = 3553;
      if (texture.isDataArrayTexture)
        textureType = 35866;
      if (texture.isData3DTexture)
        textureType = 32879;
      const forceUpload = initTexture(textureProperties, texture);
      const source = texture.source;
      state.activeTexture(33984 + slot);
      state.bindTexture(textureType, textureProperties.__webglTexture);
      if (source.version !== source.__currentVersion || forceUpload === true) {
        _gl.pixelStorei(37440, texture.flipY);
        _gl.pixelStorei(37441, texture.premultiplyAlpha);
        _gl.pixelStorei(3317, texture.unpackAlignment);
        _gl.pixelStorei(37443, 0);
        const needsPowerOfTwo = textureNeedsPowerOfTwo(texture) && isPowerOfTwo$1(texture.image) === false;
        let image = resizeImage(texture.image, needsPowerOfTwo, false, maxTextureSize);
        image = verifyColorSpace(texture, image);
        const supportsMips = isPowerOfTwo$1(image) || isWebGL2, glFormat = utils.convert(texture.format, texture.encoding);
        let glType = utils.convert(texture.type), glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding, texture.isVideoTexture);
        setTextureParameters(textureType, texture, supportsMips);
        let mipmap;
        const mipmaps = texture.mipmaps;
        const useTexStorage = isWebGL2 && texture.isVideoTexture !== true;
        const allocateMemory = textureProperties.__version === void 0;
        const levels = getMipLevels(texture, image, supportsMips);
        if (texture.isDepthTexture) {
          glInternalFormat = 6402;
          if (isWebGL2) {
            if (texture.type === FloatType) {
              glInternalFormat = 36012;
            } else if (texture.type === UnsignedIntType) {
              glInternalFormat = 33190;
            } else if (texture.type === UnsignedInt248Type) {
              glInternalFormat = 35056;
            } else {
              glInternalFormat = 33189;
            }
          } else {
            if (texture.type === FloatType) {
              console.error("WebGLRenderer: Floating point depth texture requires WebGL2.");
            }
          }
          if (texture.format === DepthFormat && glInternalFormat === 6402) {
            if (texture.type !== UnsignedShortType && texture.type !== UnsignedIntType) {
              console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.");
              texture.type = UnsignedShortType;
              glType = utils.convert(texture.type);
            }
          }
          if (texture.format === DepthStencilFormat && glInternalFormat === 6402) {
            glInternalFormat = 34041;
            if (texture.type !== UnsignedInt248Type) {
              console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.");
              texture.type = UnsignedInt248Type;
              glType = utils.convert(texture.type);
            }
          }
          if (useTexStorage && allocateMemory) {
            state.texStorage2D(3553, 1, glInternalFormat, image.width, image.height);
          } else {
            state.texImage2D(3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null);
          }
        } else if (texture.isDataTexture) {
          if (mipmaps.length > 0 && supportsMips) {
            if (useTexStorage && allocateMemory) {
              state.texStorage2D(3553, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height);
            }
            for (let i = 0, il = mipmaps.length; i < il; i++) {
              mipmap = mipmaps[i];
              if (useTexStorage) {
                state.texSubImage2D(3553, i, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data);
              } else {
                state.texImage2D(3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
              }
            }
            texture.generateMipmaps = false;
          } else {
            if (useTexStorage) {
              if (allocateMemory) {
                state.texStorage2D(3553, levels, glInternalFormat, image.width, image.height);
              }
              state.texSubImage2D(3553, 0, 0, 0, image.width, image.height, glFormat, glType, image.data);
            } else {
              state.texImage2D(3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data);
            }
          }
        } else if (texture.isCompressedTexture) {
          if (useTexStorage && allocateMemory) {
            state.texStorage2D(3553, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height);
          }
          for (let i = 0, il = mipmaps.length; i < il; i++) {
            mipmap = mipmaps[i];
            if (texture.format !== RGBAFormat) {
              if (glFormat !== null) {
                if (useTexStorage) {
                  state.compressedTexSubImage2D(3553, i, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data);
                } else {
                  state.compressedTexImage2D(3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
                }
              } else {
                console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
              }
            } else {
              if (useTexStorage) {
                state.texSubImage2D(3553, i, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data);
              } else {
                state.texImage2D(3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
              }
            }
          }
        } else if (texture.isDataArrayTexture) {
          if (useTexStorage) {
            if (allocateMemory) {
              state.texStorage3D(35866, levels, glInternalFormat, image.width, image.height, image.depth);
            }
            state.texSubImage3D(35866, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data);
          } else {
            state.texImage3D(35866, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
          }
        } else if (texture.isData3DTexture) {
          if (useTexStorage) {
            if (allocateMemory) {
              state.texStorage3D(32879, levels, glInternalFormat, image.width, image.height, image.depth);
            }
            state.texSubImage3D(32879, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data);
          } else {
            state.texImage3D(32879, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
          }
        } else if (texture.isFramebufferTexture) {
          if (useTexStorage && allocateMemory) {
            state.texStorage2D(3553, levels, glInternalFormat, image.width, image.height);
          } else {
            state.texImage2D(3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null);
          }
        } else {
          if (mipmaps.length > 0 && supportsMips) {
            if (useTexStorage && allocateMemory) {
              state.texStorage2D(3553, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height);
            }
            for (let i = 0, il = mipmaps.length; i < il; i++) {
              mipmap = mipmaps[i];
              if (useTexStorage) {
                state.texSubImage2D(3553, i, 0, 0, glFormat, glType, mipmap);
              } else {
                state.texImage2D(3553, i, glInternalFormat, glFormat, glType, mipmap);
              }
            }
            texture.generateMipmaps = false;
          } else {
            if (useTexStorage) {
              if (allocateMemory) {
                state.texStorage2D(3553, levels, glInternalFormat, image.width, image.height);
              }
              state.texSubImage2D(3553, 0, 0, 0, glFormat, glType, image);
            } else {
              state.texImage2D(3553, 0, glInternalFormat, glFormat, glType, image);
            }
          }
        }
        if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
          generateMipmap(textureType);
        }
        source.__currentVersion = source.version;
        if (texture.onUpdate)
          texture.onUpdate(texture);
      }
      textureProperties.__version = texture.version;
    }
    function uploadCubeTexture(textureProperties, texture, slot) {
      if (texture.image.length !== 6)
        return;
      const forceUpload = initTexture(textureProperties, texture);
      const source = texture.source;
      state.activeTexture(33984 + slot);
      state.bindTexture(34067, textureProperties.__webglTexture);
      if (source.version !== source.__currentVersion || forceUpload === true) {
        _gl.pixelStorei(37440, texture.flipY);
        _gl.pixelStorei(37441, texture.premultiplyAlpha);
        _gl.pixelStorei(3317, texture.unpackAlignment);
        _gl.pixelStorei(37443, 0);
        const isCompressed = texture.isCompressedTexture || texture.image[0].isCompressedTexture;
        const isDataTexture = texture.image[0] && texture.image[0].isDataTexture;
        const cubeImage = [];
        for (let i = 0; i < 6; i++) {
          if (!isCompressed && !isDataTexture) {
            cubeImage[i] = resizeImage(texture.image[i], false, true, maxCubemapSize);
          } else {
            cubeImage[i] = isDataTexture ? texture.image[i].image : texture.image[i];
          }
          cubeImage[i] = verifyColorSpace(texture, cubeImage[i]);
        }
        const image = cubeImage[0], supportsMips = isPowerOfTwo$1(image) || isWebGL2, glFormat = utils.convert(texture.format, texture.encoding), glType = utils.convert(texture.type), glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding);
        const useTexStorage = isWebGL2 && texture.isVideoTexture !== true;
        const allocateMemory = textureProperties.__version === void 0;
        let levels = getMipLevels(texture, image, supportsMips);
        setTextureParameters(34067, texture, supportsMips);
        let mipmaps;
        if (isCompressed) {
          if (useTexStorage && allocateMemory) {
            state.texStorage2D(34067, levels, glInternalFormat, image.width, image.height);
          }
          for (let i = 0; i < 6; i++) {
            mipmaps = cubeImage[i].mipmaps;
            for (let j = 0; j < mipmaps.length; j++) {
              const mipmap = mipmaps[j];
              if (texture.format !== RGBAFormat) {
                if (glFormat !== null) {
                  if (useTexStorage) {
                    state.compressedTexSubImage2D(34069 + i, j, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data);
                  } else {
                    state.compressedTexImage2D(34069 + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
                  }
                } else {
                  console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()");
                }
              } else {
                if (useTexStorage) {
                  state.texSubImage2D(34069 + i, j, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data);
                } else {
                  state.texImage2D(34069 + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
                }
              }
            }
          }
        } else {
          mipmaps = texture.mipmaps;
          if (useTexStorage && allocateMemory) {
            if (mipmaps.length > 0)
              levels++;
            state.texStorage2D(34067, levels, glInternalFormat, cubeImage[0].width, cubeImage[0].height);
          }
          for (let i = 0; i < 6; i++) {
            if (isDataTexture) {
              if (useTexStorage) {
                state.texSubImage2D(34069 + i, 0, 0, 0, cubeImage[i].width, cubeImage[i].height, glFormat, glType, cubeImage[i].data);
              } else {
                state.texImage2D(34069 + i, 0, glInternalFormat, cubeImage[i].width, cubeImage[i].height, 0, glFormat, glType, cubeImage[i].data);
              }
              for (let j = 0; j < mipmaps.length; j++) {
                const mipmap = mipmaps[j];
                const mipmapImage = mipmap.image[i].image;
                if (useTexStorage) {
                  state.texSubImage2D(34069 + i, j + 1, 0, 0, mipmapImage.width, mipmapImage.height, glFormat, glType, mipmapImage.data);
                } else {
                  state.texImage2D(34069 + i, j + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data);
                }
              }
            } else {
              if (useTexStorage) {
                state.texSubImage2D(34069 + i, 0, 0, 0, glFormat, glType, cubeImage[i]);
              } else {
                state.texImage2D(34069 + i, 0, glInternalFormat, glFormat, glType, cubeImage[i]);
              }
              for (let j = 0; j < mipmaps.length; j++) {
                const mipmap = mipmaps[j];
                if (useTexStorage) {
                  state.texSubImage2D(34069 + i, j + 1, 0, 0, glFormat, glType, mipmap.image[i]);
                } else {
                  state.texImage2D(34069 + i, j + 1, glInternalFormat, glFormat, glType, mipmap.image[i]);
                }
              }
            }
          }
        }
        if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
          generateMipmap(34067);
        }
        source.__currentVersion = source.version;
        if (texture.onUpdate)
          texture.onUpdate(texture);
      }
      textureProperties.__version = texture.version;
    }
    function setupFrameBufferTexture(framebuffer, renderTarget, texture, attachment, textureTarget) {
      const glFormat = utils.convert(texture.format, texture.encoding);
      const glType = utils.convert(texture.type);
      const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding);
      const renderTargetProperties = properties.get(renderTarget);
      if (!renderTargetProperties.__hasExternalTextures) {
        if (textureTarget === 32879 || textureTarget === 35866) {
          state.texImage3D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, renderTarget.depth, 0, glFormat, glType, null);
        } else {
          state.texImage2D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null);
        }
      }
      state.bindFramebuffer(36160, framebuffer);
      if (useMultisampledRTT(renderTarget)) {
        multisampledRTTExt.framebufferTexture2DMultisampleEXT(36160, attachment, textureTarget, properties.get(texture).__webglTexture, 0, getRenderTargetSamples(renderTarget));
      } else {
        _gl.framebufferTexture2D(36160, attachment, textureTarget, properties.get(texture).__webglTexture, 0);
      }
      state.bindFramebuffer(36160, null);
    }
    function setupRenderBufferStorage(renderbuffer, renderTarget, isMultisample) {
      _gl.bindRenderbuffer(36161, renderbuffer);
      if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {
        let glInternalFormat = 33189;
        if (isMultisample || useMultisampledRTT(renderTarget)) {
          const depthTexture = renderTarget.depthTexture;
          if (depthTexture && depthTexture.isDepthTexture) {
            if (depthTexture.type === FloatType) {
              glInternalFormat = 36012;
            } else if (depthTexture.type === UnsignedIntType) {
              glInternalFormat = 33190;
            }
          }
          const samples = getRenderTargetSamples(renderTarget);
          if (useMultisampledRTT(renderTarget)) {
            multisampledRTTExt.renderbufferStorageMultisampleEXT(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
          } else {
            _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
          }
        } else {
          _gl.renderbufferStorage(36161, glInternalFormat, renderTarget.width, renderTarget.height);
        }
        _gl.framebufferRenderbuffer(36160, 36096, 36161, renderbuffer);
      } else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {
        const samples = getRenderTargetSamples(renderTarget);
        if (isMultisample && useMultisampledRTT(renderTarget) === false) {
          _gl.renderbufferStorageMultisample(36161, samples, 35056, renderTarget.width, renderTarget.height);
        } else if (useMultisampledRTT(renderTarget)) {
          multisampledRTTExt.renderbufferStorageMultisampleEXT(36161, samples, 35056, renderTarget.width, renderTarget.height);
        } else {
          _gl.renderbufferStorage(36161, 34041, renderTarget.width, renderTarget.height);
        }
        _gl.framebufferRenderbuffer(36160, 33306, 36161, renderbuffer);
      } else {
        const texture = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture[0] : renderTarget.texture;
        const glFormat = utils.convert(texture.format, texture.encoding);
        const glType = utils.convert(texture.type);
        const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding);
        const samples = getRenderTargetSamples(renderTarget);
        if (isMultisample && useMultisampledRTT(renderTarget) === false) {
          _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
        } else if (useMultisampledRTT(renderTarget)) {
          multisampledRTTExt.renderbufferStorageMultisampleEXT(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
        } else {
          _gl.renderbufferStorage(36161, glInternalFormat, renderTarget.width, renderTarget.height);
        }
      }
      _gl.bindRenderbuffer(36161, null);
    }
    function setupDepthTexture(framebuffer, renderTarget) {
      const isCube = renderTarget && renderTarget.isWebGLCubeRenderTarget;
      if (isCube)
        throw new Error("Depth Texture with cube render targets is not supported");
      state.bindFramebuffer(36160, framebuffer);
      if (!(renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture)) {
        throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
      }
      if (!properties.get(renderTarget.depthTexture).__webglTexture || renderTarget.depthTexture.image.width !== renderTarget.width || renderTarget.depthTexture.image.height !== renderTarget.height) {
        renderTarget.depthTexture.image.width = renderTarget.width;
        renderTarget.depthTexture.image.height = renderTarget.height;
        renderTarget.depthTexture.needsUpdate = true;
      }
      setTexture2D(renderTarget.depthTexture, 0);
      const webglDepthTexture = properties.get(renderTarget.depthTexture).__webglTexture;
      const samples = getRenderTargetSamples(renderTarget);
      if (renderTarget.depthTexture.format === DepthFormat) {
        if (useMultisampledRTT(renderTarget)) {
          multisampledRTTExt.framebufferTexture2DMultisampleEXT(36160, 36096, 3553, webglDepthTexture, 0, samples);
        } else {
          _gl.framebufferTexture2D(36160, 36096, 3553, webglDepthTexture, 0);
        }
      } else if (renderTarget.depthTexture.format === DepthStencilFormat) {
        if (useMultisampledRTT(renderTarget)) {
          multisampledRTTExt.framebufferTexture2DMultisampleEXT(36160, 33306, 3553, webglDepthTexture, 0, samples);
        } else {
          _gl.framebufferTexture2D(36160, 33306, 3553, webglDepthTexture, 0);
        }
      } else {
        throw new Error("Unknown depthTexture format");
      }
    }
    function setupDepthRenderbuffer(renderTarget) {
      const renderTargetProperties = properties.get(renderTarget);
      const isCube = renderTarget.isWebGLCubeRenderTarget === true;
      if (renderTarget.depthTexture && !renderTargetProperties.__autoAllocateDepthBuffer) {
        if (isCube)
          throw new Error("target.depthTexture not supported in Cube render targets");
        setupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget);
      } else {
        if (isCube) {
          renderTargetProperties.__webglDepthbuffer = [];
          for (let i = 0; i < 6; i++) {
            state.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer[i]);
            renderTargetProperties.__webglDepthbuffer[i] = _gl.createRenderbuffer();
            setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i], renderTarget, false);
          }
        } else {
          state.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer);
          renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
          setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget, false);
        }
      }
      state.bindFramebuffer(36160, null);
    }
    function rebindTextures(renderTarget, colorTexture, depthTexture) {
      const renderTargetProperties = properties.get(renderTarget);
      if (colorTexture !== void 0) {
        setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, renderTarget.texture, 36064, 3553);
      }
      if (depthTexture !== void 0) {
        setupDepthRenderbuffer(renderTarget);
      }
    }
    function setupRenderTarget(renderTarget) {
      const texture = renderTarget.texture;
      const renderTargetProperties = properties.get(renderTarget);
      const textureProperties = properties.get(texture);
      renderTarget.addEventListener("dispose", onRenderTargetDispose);
      if (renderTarget.isWebGLMultipleRenderTargets !== true) {
        if (textureProperties.__webglTexture === void 0) {
          textureProperties.__webglTexture = _gl.createTexture();
        }
        textureProperties.__version = texture.version;
        info.memory.textures++;
      }
      const isCube = renderTarget.isWebGLCubeRenderTarget === true;
      const isMultipleRenderTargets = renderTarget.isWebGLMultipleRenderTargets === true;
      const supportsMips = isPowerOfTwo$1(renderTarget) || isWebGL2;
      if (isCube) {
        renderTargetProperties.__webglFramebuffer = [];
        for (let i = 0; i < 6; i++) {
          renderTargetProperties.__webglFramebuffer[i] = _gl.createFramebuffer();
        }
      } else {
        renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();
        if (isMultipleRenderTargets) {
          if (capabilities.drawBuffers) {
            const textures = renderTarget.texture;
            for (let i = 0, il = textures.length; i < il; i++) {
              const attachmentProperties = properties.get(textures[i]);
              if (attachmentProperties.__webglTexture === void 0) {
                attachmentProperties.__webglTexture = _gl.createTexture();
                info.memory.textures++;
              }
            }
          } else {
            console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
          }
        } else if (isWebGL2 && renderTarget.samples > 0 && useMultisampledRTT(renderTarget) === false) {
          renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
          renderTargetProperties.__webglColorRenderbuffer = _gl.createRenderbuffer();
          _gl.bindRenderbuffer(36161, renderTargetProperties.__webglColorRenderbuffer);
          const glFormat = utils.convert(texture.format, texture.encoding);
          const glType = utils.convert(texture.type);
          const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding);
          const samples = getRenderTargetSamples(renderTarget);
          _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
          state.bindFramebuffer(36160, renderTargetProperties.__webglMultisampledFramebuffer);
          _gl.framebufferRenderbuffer(36160, 36064, 36161, renderTargetProperties.__webglColorRenderbuffer);
          _gl.bindRenderbuffer(36161, null);
          if (renderTarget.depthBuffer) {
            renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
            setupRenderBufferStorage(renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true);
          }
          state.bindFramebuffer(36160, null);
        }
      }
      if (isCube) {
        state.bindTexture(34067, textureProperties.__webglTexture);
        setTextureParameters(34067, texture, supportsMips);
        for (let i = 0; i < 6; i++) {
          setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i], renderTarget, texture, 36064, 34069 + i);
        }
        if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
          generateMipmap(34067);
        }
        state.unbindTexture();
      } else if (isMultipleRenderTargets) {
        const textures = renderTarget.texture;
        for (let i = 0, il = textures.length; i < il; i++) {
          const attachment = textures[i];
          const attachmentProperties = properties.get(attachment);
          state.bindTexture(3553, attachmentProperties.__webglTexture);
          setTextureParameters(3553, attachment, supportsMips);
          setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, attachment, 36064 + i, 3553);
          if (textureNeedsGenerateMipmaps(attachment, supportsMips)) {
            generateMipmap(3553);
          }
        }
        state.unbindTexture();
      } else {
        let glTextureType = 3553;
        if (renderTarget.isWebGL3DRenderTarget || renderTarget.isWebGLArrayRenderTarget) {
          if (isWebGL2) {
            glTextureType = renderTarget.isWebGL3DRenderTarget ? 32879 : 35866;
          } else {
            console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.");
          }
        }
        state.bindTexture(glTextureType, textureProperties.__webglTexture);
        setTextureParameters(glTextureType, texture, supportsMips);
        setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, texture, 36064, glTextureType);
        if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
          generateMipmap(glTextureType);
        }
        state.unbindTexture();
      }
      if (renderTarget.depthBuffer) {
        setupDepthRenderbuffer(renderTarget);
      }
    }
    function updateRenderTargetMipmap(renderTarget) {
      const supportsMips = isPowerOfTwo$1(renderTarget) || isWebGL2;
      const textures = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture : [renderTarget.texture];
      for (let i = 0, il = textures.length; i < il; i++) {
        const texture = textures[i];
        if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
          const target = renderTarget.isWebGLCubeRenderTarget ? 34067 : 3553;
          const webglTexture = properties.get(texture).__webglTexture;
          state.bindTexture(target, webglTexture);
          generateMipmap(target);
          state.unbindTexture();
        }
      }
    }
    function updateMultisampleRenderTarget(renderTarget) {
      if (isWebGL2 && renderTarget.samples > 0 && useMultisampledRTT(renderTarget) === false) {
        const width = renderTarget.width;
        const height = renderTarget.height;
        let mask = 16384;
        const invalidationArray = [36064];
        const depthStyle = renderTarget.stencilBuffer ? 33306 : 36096;
        if (renderTarget.depthBuffer) {
          invalidationArray.push(depthStyle);
        }
        const renderTargetProperties = properties.get(renderTarget);
        const ignoreDepthValues = renderTargetProperties.__ignoreDepthValues !== void 0 ? renderTargetProperties.__ignoreDepthValues : false;
        if (ignoreDepthValues === false) {
          if (renderTarget.depthBuffer)
            mask |= 256;
          if (renderTarget.stencilBuffer)
            mask |= 1024;
        }
        state.bindFramebuffer(36008, renderTargetProperties.__webglMultisampledFramebuffer);
        state.bindFramebuffer(36009, renderTargetProperties.__webglFramebuffer);
        if (ignoreDepthValues === true) {
          _gl.invalidateFramebuffer(36008, [depthStyle]);
          _gl.invalidateFramebuffer(36009, [depthStyle]);
        }
        _gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, mask, 9728);
        if (supportsInvalidateFramebuffer) {
          _gl.invalidateFramebuffer(36008, invalidationArray);
        }
        state.bindFramebuffer(36008, null);
        state.bindFramebuffer(36009, renderTargetProperties.__webglMultisampledFramebuffer);
      }
    }
    function getRenderTargetSamples(renderTarget) {
      return Math.min(maxSamples, renderTarget.samples);
    }
    function useMultisampledRTT(renderTarget) {
      const renderTargetProperties = properties.get(renderTarget);
      return isWebGL2 && renderTarget.samples > 0 && extensions.has("WEBGL_multisampled_render_to_texture") === true && renderTargetProperties.__useRenderToTexture !== false;
    }
    function updateVideoTexture(texture) {
      const frame = info.render.frame;
      if (_videoTextures.get(texture) !== frame) {
        _videoTextures.set(texture, frame);
        texture.update();
      }
    }
    function verifyColorSpace(texture, image) {
      const encoding = texture.encoding;
      const format = texture.format;
      const type = texture.type;
      if (texture.isCompressedTexture === true || texture.isVideoTexture === true || texture.format === _SRGBAFormat)
        return image;
      if (encoding !== LinearEncoding) {
        if (encoding === sRGBEncoding) {
          if (isWebGL2 === false) {
            if (extensions.has("EXT_sRGB") === true && format === RGBAFormat) {
              texture.format = _SRGBAFormat;
              texture.minFilter = LinearFilter;
              texture.generateMipmaps = false;
            } else {
              image = ImageUtils.sRGBToLinear(image);
            }
          } else {
            if (format !== RGBAFormat || type !== UnsignedByteType) {
              console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.");
            }
          }
        } else {
          console.error("THREE.WebGLTextures: Unsupported texture encoding:", encoding);
        }
      }
      return image;
    }
    this.allocateTextureUnit = allocateTextureUnit;
    this.resetTextureUnits = resetTextureUnits;
    this.setTexture2D = setTexture2D;
    this.setTexture2DArray = setTexture2DArray;
    this.setTexture3D = setTexture3D;
    this.setTextureCube = setTextureCube;
    this.rebindTextures = rebindTextures;
    this.setupRenderTarget = setupRenderTarget;
    this.updateRenderTargetMipmap = updateRenderTargetMipmap;
    this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;
    this.setupDepthRenderbuffer = setupDepthRenderbuffer;
    this.setupFrameBufferTexture = setupFrameBufferTexture;
    this.useMultisampledRTT = useMultisampledRTT;
  }
  function WebGLUtils(gl, extensions, capabilities) {
    const isWebGL2 = capabilities.isWebGL2;
    function convert(p, encoding = null) {
      let extension;
      if (p === UnsignedByteType)
        return 5121;
      if (p === UnsignedShort4444Type)
        return 32819;
      if (p === UnsignedShort5551Type)
        return 32820;
      if (p === ByteType)
        return 5120;
      if (p === ShortType)
        return 5122;
      if (p === UnsignedShortType)
        return 5123;
      if (p === IntType)
        return 5124;
      if (p === UnsignedIntType)
        return 5125;
      if (p === FloatType)
        return 5126;
      if (p === HalfFloatType) {
        if (isWebGL2)
          return 5131;
        extension = extensions.get("OES_texture_half_float");
        if (extension !== null) {
          return extension.HALF_FLOAT_OES;
        } else {
          return null;
        }
      }
      if (p === AlphaFormat)
        return 6406;
      if (p === RGBAFormat)
        return 6408;
      if (p === LuminanceFormat)
        return 6409;
      if (p === LuminanceAlphaFormat)
        return 6410;
      if (p === DepthFormat)
        return 6402;
      if (p === DepthStencilFormat)
        return 34041;
      if (p === RedFormat)
        return 6403;
      if (p === RGBFormat) {
        console.warn("THREE.WebGLRenderer: THREE.RGBFormat has been removed. Use THREE.RGBAFormat instead. https://github.com/mrdoob/three.js/pull/23228");
        return 6408;
      }
      if (p === _SRGBAFormat) {
        extension = extensions.get("EXT_sRGB");
        if (extension !== null) {
          return extension.SRGB_ALPHA_EXT;
        } else {
          return null;
        }
      }
      if (p === RedIntegerFormat)
        return 36244;
      if (p === RGFormat)
        return 33319;
      if (p === RGIntegerFormat)
        return 33320;
      if (p === RGBAIntegerFormat)
        return 36249;
      if (p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format || p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format) {
        if (encoding === sRGBEncoding) {
          extension = extensions.get("WEBGL_compressed_texture_s3tc_srgb");
          if (extension !== null) {
            if (p === RGB_S3TC_DXT1_Format)
              return extension.COMPRESSED_SRGB_S3TC_DXT1_EXT;
            if (p === RGBA_S3TC_DXT1_Format)
              return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
            if (p === RGBA_S3TC_DXT3_Format)
              return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
            if (p === RGBA_S3TC_DXT5_Format)
              return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
          } else {
            return null;
          }
        } else {
          extension = extensions.get("WEBGL_compressed_texture_s3tc");
          if (extension !== null) {
            if (p === RGB_S3TC_DXT1_Format)
              return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
            if (p === RGBA_S3TC_DXT1_Format)
              return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
            if (p === RGBA_S3TC_DXT3_Format)
              return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
            if (p === RGBA_S3TC_DXT5_Format)
              return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
          } else {
            return null;
          }
        }
      }
      if (p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format || p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format) {
        extension = extensions.get("WEBGL_compressed_texture_pvrtc");
        if (extension !== null) {
          if (p === RGB_PVRTC_4BPPV1_Format)
            return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
          if (p === RGB_PVRTC_2BPPV1_Format)
            return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
          if (p === RGBA_PVRTC_4BPPV1_Format)
            return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
          if (p === RGBA_PVRTC_2BPPV1_Format)
            return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
        } else {
          return null;
        }
      }
      if (p === RGB_ETC1_Format) {
        extension = extensions.get("WEBGL_compressed_texture_etc1");
        if (extension !== null) {
          return extension.COMPRESSED_RGB_ETC1_WEBGL;
        } else {
          return null;
        }
      }
      if (p === RGB_ETC2_Format || p === RGBA_ETC2_EAC_Format) {
        extension = extensions.get("WEBGL_compressed_texture_etc");
        if (extension !== null) {
          if (p === RGB_ETC2_Format)
            return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ETC2 : extension.COMPRESSED_RGB8_ETC2;
          if (p === RGBA_ETC2_EAC_Format)
            return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : extension.COMPRESSED_RGBA8_ETC2_EAC;
        } else {
          return null;
        }
      }
      if (p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format || p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format || p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format || p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format || p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format) {
        extension = extensions.get("WEBGL_compressed_texture_astc");
        if (extension !== null) {
          if (p === RGBA_ASTC_4x4_Format)
            return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : extension.COMPRESSED_RGBA_ASTC_4x4_KHR;
          if (p === RGBA_ASTC_5x4_Format)
            return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : extension.COMPRESSED_RGBA_ASTC_5x4_KHR;
          if (p === RGBA_ASTC_5x5_Format)
            return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : extension.COMPRESSED_RGBA_ASTC_5x5_KHR;
          if (p === RGBA_ASTC_6x5_Format)
            return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : extension.COMPRESSED_RGBA_ASTC_6x5_KHR;
          if (p === RGBA_ASTC_6x6_Format)
            return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : extension.COMPRESSED_RGBA_ASTC_6x6_KHR;
          if (p === RGBA_ASTC_8x5_Format)
            return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : extension.COMPRESSED_RGBA_ASTC_8x5_KHR;
          if (p === RGBA_ASTC_8x6_Format)
            return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : extension.COMPRESSED_RGBA_ASTC_8x6_KHR;
          if (p === RGBA_ASTC_8x8_Format)
            return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : extension.COMPRESSED_RGBA_ASTC_8x8_KHR;
          if (p === RGBA_ASTC_10x5_Format)
            return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : extension.COMPRESSED_RGBA_ASTC_10x5_KHR;
          if (p === RGBA_ASTC_10x6_Format)
            return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : extension.COMPRESSED_RGBA_ASTC_10x6_KHR;
          if (p === RGBA_ASTC_10x8_Format)
            return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : extension.COMPRESSED_RGBA_ASTC_10x8_KHR;
          if (p === RGBA_ASTC_10x10_Format)
            return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : extension.COMPRESSED_RGBA_ASTC_10x10_KHR;
          if (p === RGBA_ASTC_12x10_Format)
            return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : extension.COMPRESSED_RGBA_ASTC_12x10_KHR;
          if (p === RGBA_ASTC_12x12_Format)
            return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : extension.COMPRESSED_RGBA_ASTC_12x12_KHR;
        } else {
          return null;
        }
      }
      if (p === RGBA_BPTC_Format) {
        extension = extensions.get("EXT_texture_compression_bptc");
        if (extension !== null) {
          if (p === RGBA_BPTC_Format)
            return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : extension.COMPRESSED_RGBA_BPTC_UNORM_EXT;
        } else {
          return null;
        }
      }
      if (p === UnsignedInt248Type) {
        if (isWebGL2)
          return 34042;
        extension = extensions.get("WEBGL_depth_texture");
        if (extension !== null) {
          return extension.UNSIGNED_INT_24_8_WEBGL;
        } else {
          return null;
        }
      }
    }
    return { convert };
  }
  var ArrayCamera = class extends PerspectiveCamera {
    constructor(array = []) {
      super();
      this.cameras = array;
    }
  };
  ArrayCamera.prototype.isArrayCamera = true;
  var Group = class extends Object3D {
    constructor() {
      super();
      this.type = "Group";
    }
  };
  Group.prototype.isGroup = true;
  var _moveEvent = { type: "move" };
  var WebXRController = class {
    constructor() {
      this._targetRay = null;
      this._grip = null;
      this._hand = null;
    }
    getHandSpace() {
      if (this._hand === null) {
        this._hand = new Group();
        this._hand.matrixAutoUpdate = false;
        this._hand.visible = false;
        this._hand.joints = {};
        this._hand.inputState = { pinching: false };
      }
      return this._hand;
    }
    getTargetRaySpace() {
      if (this._targetRay === null) {
        this._targetRay = new Group();
        this._targetRay.matrixAutoUpdate = false;
        this._targetRay.visible = false;
        this._targetRay.hasLinearVelocity = false;
        this._targetRay.linearVelocity = new Vector3();
        this._targetRay.hasAngularVelocity = false;
        this._targetRay.angularVelocity = new Vector3();
      }
      return this._targetRay;
    }
    getGripSpace() {
      if (this._grip === null) {
        this._grip = new Group();
        this._grip.matrixAutoUpdate = false;
        this._grip.visible = false;
        this._grip.hasLinearVelocity = false;
        this._grip.linearVelocity = new Vector3();
        this._grip.hasAngularVelocity = false;
        this._grip.angularVelocity = new Vector3();
      }
      return this._grip;
    }
    dispatchEvent(event) {
      if (this._targetRay !== null) {
        this._targetRay.dispatchEvent(event);
      }
      if (this._grip !== null) {
        this._grip.dispatchEvent(event);
      }
      if (this._hand !== null) {
        this._hand.dispatchEvent(event);
      }
      return this;
    }
    disconnect(inputSource) {
      this.dispatchEvent({ type: "disconnected", data: inputSource });
      if (this._targetRay !== null) {
        this._targetRay.visible = false;
      }
      if (this._grip !== null) {
        this._grip.visible = false;
      }
      if (this._hand !== null) {
        this._hand.visible = false;
      }
      return this;
    }
    update(inputSource, frame, referenceSpace) {
      let inputPose = null;
      let gripPose = null;
      let handPose = null;
      const targetRay = this._targetRay;
      const grip = this._grip;
      const hand = this._hand;
      if (inputSource && frame.session.visibilityState !== "visible-blurred") {
        if (targetRay !== null) {
          inputPose = frame.getPose(inputSource.targetRaySpace, referenceSpace);
          if (inputPose !== null) {
            targetRay.matrix.fromArray(inputPose.transform.matrix);
            targetRay.matrix.decompose(targetRay.position, targetRay.rotation, targetRay.scale);
            if (inputPose.linearVelocity) {
              targetRay.hasLinearVelocity = true;
              targetRay.linearVelocity.copy(inputPose.linearVelocity);
            } else {
              targetRay.hasLinearVelocity = false;
            }
            if (inputPose.angularVelocity) {
              targetRay.hasAngularVelocity = true;
              targetRay.angularVelocity.copy(inputPose.angularVelocity);
            } else {
              targetRay.hasAngularVelocity = false;
            }
            this.dispatchEvent(_moveEvent);
          }
        }
        if (hand && inputSource.hand) {
          handPose = true;
          for (const inputjoint of inputSource.hand.values()) {
            const jointPose = frame.getJointPose(inputjoint, referenceSpace);
            if (hand.joints[inputjoint.jointName] === void 0) {
              const joint2 = new Group();
              joint2.matrixAutoUpdate = false;
              joint2.visible = false;
              hand.joints[inputjoint.jointName] = joint2;
              hand.add(joint2);
            }
            const joint = hand.joints[inputjoint.jointName];
            if (jointPose !== null) {
              joint.matrix.fromArray(jointPose.transform.matrix);
              joint.matrix.decompose(joint.position, joint.rotation, joint.scale);
              joint.jointRadius = jointPose.radius;
            }
            joint.visible = jointPose !== null;
          }
          const indexTip = hand.joints["index-finger-tip"];
          const thumbTip = hand.joints["thumb-tip"];
          const distance = indexTip.position.distanceTo(thumbTip.position);
          const distanceToPinch = 0.02;
          const threshold = 5e-3;
          if (hand.inputState.pinching && distance > distanceToPinch + threshold) {
            hand.inputState.pinching = false;
            this.dispatchEvent({
              type: "pinchend",
              handedness: inputSource.handedness,
              target: this
            });
          } else if (!hand.inputState.pinching && distance <= distanceToPinch - threshold) {
            hand.inputState.pinching = true;
            this.dispatchEvent({
              type: "pinchstart",
              handedness: inputSource.handedness,
              target: this
            });
          }
        } else {
          if (grip !== null && inputSource.gripSpace) {
            gripPose = frame.getPose(inputSource.gripSpace, referenceSpace);
            if (gripPose !== null) {
              grip.matrix.fromArray(gripPose.transform.matrix);
              grip.matrix.decompose(grip.position, grip.rotation, grip.scale);
              if (gripPose.linearVelocity) {
                grip.hasLinearVelocity = true;
                grip.linearVelocity.copy(gripPose.linearVelocity);
              } else {
                grip.hasLinearVelocity = false;
              }
              if (gripPose.angularVelocity) {
                grip.hasAngularVelocity = true;
                grip.angularVelocity.copy(gripPose.angularVelocity);
              } else {
                grip.hasAngularVelocity = false;
              }
            }
          }
        }
      }
      if (targetRay !== null) {
        targetRay.visible = inputPose !== null;
      }
      if (grip !== null) {
        grip.visible = gripPose !== null;
      }
      if (hand !== null) {
        hand.visible = handPose !== null;
      }
      return this;
    }
  };
  var DepthTexture = class extends Texture {
    constructor(width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format) {
      format = format !== void 0 ? format : DepthFormat;
      if (format !== DepthFormat && format !== DepthStencilFormat) {
        throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
      }
      if (type === void 0 && format === DepthFormat)
        type = UnsignedShortType;
      if (type === void 0 && format === DepthStencilFormat)
        type = UnsignedInt248Type;
      super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
      this.image = { width, height };
      this.magFilter = magFilter !== void 0 ? magFilter : NearestFilter;
      this.minFilter = minFilter !== void 0 ? minFilter : NearestFilter;
      this.flipY = false;
      this.generateMipmaps = false;
    }
  };
  DepthTexture.prototype.isDepthTexture = true;
  var WebXRManager = class extends EventDispatcher {
    constructor(renderer, gl) {
      super();
      const scope = this;
      let session2 = null;
      let framebufferScaleFactor = 1;
      let referenceSpace = null;
      let referenceSpaceType = "local-floor";
      let pose = null;
      let glBinding = null;
      let glProjLayer = null;
      let glBaseLayer = null;
      let xrFrame = null;
      const attributes = gl.getContextAttributes();
      let initialRenderTarget = null;
      let newRenderTarget = null;
      const controllers = [];
      const inputSourcesMap = /* @__PURE__ */ new Map();
      const cameraL = new PerspectiveCamera();
      cameraL.layers.enable(1);
      cameraL.viewport = new Vector4();
      const cameraR = new PerspectiveCamera();
      cameraR.layers.enable(2);
      cameraR.viewport = new Vector4();
      const cameras = [cameraL, cameraR];
      const cameraVR = new ArrayCamera();
      cameraVR.layers.enable(1);
      cameraVR.layers.enable(2);
      let _currentDepthNear = null;
      let _currentDepthFar = null;
      this.cameraAutoUpdate = true;
      this.enabled = false;
      this.isPresenting = false;
      this.getController = function(index) {
        let controller = controllers[index];
        if (controller === void 0) {
          controller = new WebXRController();
          controllers[index] = controller;
        }
        return controller.getTargetRaySpace();
      };
      this.getControllerGrip = function(index) {
        let controller = controllers[index];
        if (controller === void 0) {
          controller = new WebXRController();
          controllers[index] = controller;
        }
        return controller.getGripSpace();
      };
      this.getHand = function(index) {
        let controller = controllers[index];
        if (controller === void 0) {
          controller = new WebXRController();
          controllers[index] = controller;
        }
        return controller.getHandSpace();
      };
      function onSessionEvent(event) {
        const controller = inputSourcesMap.get(event.inputSource);
        if (controller) {
          controller.dispatchEvent({ type: event.type, data: event.inputSource });
        }
      }
      function onSessionEnd() {
        inputSourcesMap.forEach(function(controller, inputSource) {
          controller.disconnect(inputSource);
        });
        inputSourcesMap.clear();
        _currentDepthNear = null;
        _currentDepthFar = null;
        renderer.setRenderTarget(initialRenderTarget);
        glBaseLayer = null;
        glProjLayer = null;
        glBinding = null;
        session2 = null;
        newRenderTarget = null;
        animation.stop();
        scope.isPresenting = false;
        scope.dispatchEvent({ type: "sessionend" });
      }
      this.setFramebufferScaleFactor = function(value) {
        framebufferScaleFactor = value;
        if (scope.isPresenting === true) {
          console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
        }
      };
      this.setReferenceSpaceType = function(value) {
        referenceSpaceType = value;
        if (scope.isPresenting === true) {
          console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
        }
      };
      this.getReferenceSpace = function() {
        return referenceSpace;
      };
      this.getBaseLayer = function() {
        return glProjLayer !== null ? glProjLayer : glBaseLayer;
      };
      this.getBinding = function() {
        return glBinding;
      };
      this.getFrame = function() {
        return xrFrame;
      };
      this.getSession = function() {
        return session2;
      };
      this.setSession = async function(value) {
        session2 = value;
        if (session2 !== null) {
          initialRenderTarget = renderer.getRenderTarget();
          session2.addEventListener("select", onSessionEvent);
          session2.addEventListener("selectstart", onSessionEvent);
          session2.addEventListener("selectend", onSessionEvent);
          session2.addEventListener("squeeze", onSessionEvent);
          session2.addEventListener("squeezestart", onSessionEvent);
          session2.addEventListener("squeezeend", onSessionEvent);
          session2.addEventListener("end", onSessionEnd);
          session2.addEventListener("inputsourceschange", onInputSourcesChange);
          if (attributes.xrCompatible !== true) {
            await gl.makeXRCompatible();
          }
          if (session2.renderState.layers === void 0 || renderer.capabilities.isWebGL2 === false) {
            const layerInit = {
              antialias: session2.renderState.layers === void 0 ? attributes.antialias : true,
              alpha: attributes.alpha,
              depth: attributes.depth,
              stencil: attributes.stencil,
              framebufferScaleFactor
            };
            glBaseLayer = new XRWebGLLayer(session2, gl, layerInit);
            session2.updateRenderState({ baseLayer: glBaseLayer });
            newRenderTarget = new WebGLRenderTarget(
              glBaseLayer.framebufferWidth,
              glBaseLayer.framebufferHeight,
              {
                format: RGBAFormat,
                type: UnsignedByteType,
                encoding: renderer.outputEncoding
              }
            );
          } else {
            let depthFormat = null;
            let depthType = null;
            let glDepthFormat = null;
            if (attributes.depth) {
              glDepthFormat = attributes.stencil ? 35056 : 33190;
              depthFormat = attributes.stencil ? DepthStencilFormat : DepthFormat;
              depthType = attributes.stencil ? UnsignedInt248Type : UnsignedShortType;
            }
            const projectionlayerInit = {
              colorFormat: renderer.outputEncoding === sRGBEncoding ? 35907 : 32856,
              depthFormat: glDepthFormat,
              scaleFactor: framebufferScaleFactor
            };
            glBinding = new XRWebGLBinding(session2, gl);
            glProjLayer = glBinding.createProjectionLayer(projectionlayerInit);
            session2.updateRenderState({ layers: [glProjLayer] });
            newRenderTarget = new WebGLRenderTarget(
              glProjLayer.textureWidth,
              glProjLayer.textureHeight,
              {
                format: RGBAFormat,
                type: UnsignedByteType,
                depthTexture: new DepthTexture(glProjLayer.textureWidth, glProjLayer.textureHeight, depthType, void 0, void 0, void 0, void 0, void 0, void 0, depthFormat),
                stencilBuffer: attributes.stencil,
                encoding: renderer.outputEncoding,
                samples: attributes.antialias ? 4 : 0
              }
            );
            const renderTargetProperties = renderer.properties.get(newRenderTarget);
            renderTargetProperties.__ignoreDepthValues = glProjLayer.ignoreDepthValues;
          }
          newRenderTarget.isXRRenderTarget = true;
          this.setFoveation(1);
          referenceSpace = await session2.requestReferenceSpace(referenceSpaceType);
          animation.setContext(session2);
          animation.start();
          scope.isPresenting = true;
          scope.dispatchEvent({ type: "sessionstart" });
        }
      };
      function onInputSourcesChange(event) {
        const inputSources = session2.inputSources;
        for (let i = 0; i < controllers.length; i++) {
          inputSourcesMap.set(inputSources[i], controllers[i]);
        }
        for (let i = 0; i < event.removed.length; i++) {
          const inputSource = event.removed[i];
          const controller = inputSourcesMap.get(inputSource);
          if (controller) {
            controller.dispatchEvent({ type: "disconnected", data: inputSource });
            inputSourcesMap.delete(inputSource);
          }
        }
        for (let i = 0; i < event.added.length; i++) {
          const inputSource = event.added[i];
          const controller = inputSourcesMap.get(inputSource);
          if (controller) {
            controller.dispatchEvent({ type: "connected", data: inputSource });
          }
        }
      }
      const cameraLPos = new Vector3();
      const cameraRPos = new Vector3();
      function setProjectionFromUnion(camera, cameraL2, cameraR2) {
        cameraLPos.setFromMatrixPosition(cameraL2.matrixWorld);
        cameraRPos.setFromMatrixPosition(cameraR2.matrixWorld);
        const ipd = cameraLPos.distanceTo(cameraRPos);
        const projL = cameraL2.projectionMatrix.elements;
        const projR = cameraR2.projectionMatrix.elements;
        const near = projL[14] / (projL[10] - 1);
        const far = projL[14] / (projL[10] + 1);
        const topFov = (projL[9] + 1) / projL[5];
        const bottomFov = (projL[9] - 1) / projL[5];
        const leftFov = (projL[8] - 1) / projL[0];
        const rightFov = (projR[8] + 1) / projR[0];
        const left = near * leftFov;
        const right = near * rightFov;
        const zOffset = ipd / (-leftFov + rightFov);
        const xOffset = zOffset * -leftFov;
        cameraL2.matrixWorld.decompose(camera.position, camera.quaternion, camera.scale);
        camera.translateX(xOffset);
        camera.translateZ(zOffset);
        camera.matrixWorld.compose(camera.position, camera.quaternion, camera.scale);
        camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
        const near2 = near + zOffset;
        const far2 = far + zOffset;
        const left2 = left - xOffset;
        const right2 = right + (ipd - xOffset);
        const top2 = topFov * far / far2 * near2;
        const bottom2 = bottomFov * far / far2 * near2;
        camera.projectionMatrix.makePerspective(left2, right2, top2, bottom2, near2, far2);
      }
      function updateCamera(camera, parent) {
        if (parent === null) {
          camera.matrixWorld.copy(camera.matrix);
        } else {
          camera.matrixWorld.multiplyMatrices(parent.matrixWorld, camera.matrix);
        }
        camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
      }
      this.updateCamera = function(camera) {
        if (session2 === null)
          return;
        cameraVR.near = cameraR.near = cameraL.near = camera.near;
        cameraVR.far = cameraR.far = cameraL.far = camera.far;
        if (_currentDepthNear !== cameraVR.near || _currentDepthFar !== cameraVR.far) {
          session2.updateRenderState({
            depthNear: cameraVR.near,
            depthFar: cameraVR.far
          });
          _currentDepthNear = cameraVR.near;
          _currentDepthFar = cameraVR.far;
        }
        const parent = camera.parent;
        const cameras2 = cameraVR.cameras;
        updateCamera(cameraVR, parent);
        for (let i = 0; i < cameras2.length; i++) {
          updateCamera(cameras2[i], parent);
        }
        cameraVR.matrixWorld.decompose(cameraVR.position, cameraVR.quaternion, cameraVR.scale);
        camera.position.copy(cameraVR.position);
        camera.quaternion.copy(cameraVR.quaternion);
        camera.scale.copy(cameraVR.scale);
        camera.matrix.copy(cameraVR.matrix);
        camera.matrixWorld.copy(cameraVR.matrixWorld);
        const children = camera.children;
        for (let i = 0, l = children.length; i < l; i++) {
          children[i].updateMatrixWorld(true);
        }
        if (cameras2.length === 2) {
          setProjectionFromUnion(cameraVR, cameraL, cameraR);
        } else {
          cameraVR.projectionMatrix.copy(cameraL.projectionMatrix);
        }
      };
      this.getCamera = function() {
        return cameraVR;
      };
      this.getFoveation = function() {
        if (glProjLayer !== null) {
          return glProjLayer.fixedFoveation;
        }
        if (glBaseLayer !== null) {
          return glBaseLayer.fixedFoveation;
        }
        return void 0;
      };
      this.setFoveation = function(foveation) {
        if (glProjLayer !== null) {
          glProjLayer.fixedFoveation = foveation;
        }
        if (glBaseLayer !== null && glBaseLayer.fixedFoveation !== void 0) {
          glBaseLayer.fixedFoveation = foveation;
        }
      };
      let onAnimationFrameCallback = null;
      function onAnimationFrame(time, frame) {
        pose = frame.getViewerPose(referenceSpace);
        xrFrame = frame;
        if (pose !== null) {
          const views = pose.views;
          if (glBaseLayer !== null) {
            renderer.setRenderTargetFramebuffer(newRenderTarget, glBaseLayer.framebuffer);
            renderer.setRenderTarget(newRenderTarget);
          }
          let cameraVRNeedsUpdate = false;
          if (views.length !== cameraVR.cameras.length) {
            cameraVR.cameras.length = 0;
            cameraVRNeedsUpdate = true;
          }
          for (let i = 0; i < views.length; i++) {
            const view = views[i];
            let viewport = null;
            if (glBaseLayer !== null) {
              viewport = glBaseLayer.getViewport(view);
            } else {
              const glSubImage = glBinding.getViewSubImage(glProjLayer, view);
              viewport = glSubImage.viewport;
              if (i === 0) {
                renderer.setRenderTargetTextures(
                  newRenderTarget,
                  glSubImage.colorTexture,
                  glProjLayer.ignoreDepthValues ? void 0 : glSubImage.depthStencilTexture
                );
                renderer.setRenderTarget(newRenderTarget);
              }
            }
            const camera = cameras[i];
            camera.matrix.fromArray(view.transform.matrix);
            camera.projectionMatrix.fromArray(view.projectionMatrix);
            camera.viewport.set(viewport.x, viewport.y, viewport.width, viewport.height);
            if (i === 0) {
              cameraVR.matrix.copy(camera.matrix);
            }
            if (cameraVRNeedsUpdate === true) {
              cameraVR.cameras.push(camera);
            }
          }
        }
        const inputSources = session2.inputSources;
        for (let i = 0; i < controllers.length; i++) {
          const controller = controllers[i];
          const inputSource = inputSources[i];
          controller.update(inputSource, frame, referenceSpace);
        }
        if (onAnimationFrameCallback)
          onAnimationFrameCallback(time, frame);
        xrFrame = null;
      }
      const animation = new WebGLAnimation();
      animation.setAnimationLoop(onAnimationFrame);
      this.setAnimationLoop = function(callback) {
        onAnimationFrameCallback = callback;
      };
      this.dispose = function() {
      };
    }
  };
  function WebGLMaterials(renderer, properties) {
    function refreshFogUniforms(uniforms, fog) {
      uniforms.fogColor.value.copy(fog.color);
      if (fog.isFog) {
        uniforms.fogNear.value = fog.near;
        uniforms.fogFar.value = fog.far;
      } else if (fog.isFogExp2) {
        uniforms.fogDensity.value = fog.density;
      }
    }
    function refreshMaterialUniforms(uniforms, material, pixelRatio, height, transmissionRenderTarget) {
      if (material.isMeshBasicMaterial) {
        refreshUniformsCommon(uniforms, material);
      } else if (material.isMeshLambertMaterial) {
        refreshUniformsCommon(uniforms, material);
      } else if (material.isMeshToonMaterial) {
        refreshUniformsCommon(uniforms, material);
        refreshUniformsToon(uniforms, material);
      } else if (material.isMeshPhongMaterial) {
        refreshUniformsCommon(uniforms, material);
        refreshUniformsPhong(uniforms, material);
      } else if (material.isMeshStandardMaterial) {
        refreshUniformsCommon(uniforms, material);
        refreshUniformsStandard(uniforms, material);
        if (material.isMeshPhysicalMaterial) {
          refreshUniformsPhysical(uniforms, material, transmissionRenderTarget);
        }
      } else if (material.isMeshMatcapMaterial) {
        refreshUniformsCommon(uniforms, material);
        refreshUniformsMatcap(uniforms, material);
      } else if (material.isMeshDepthMaterial) {
        refreshUniformsCommon(uniforms, material);
      } else if (material.isMeshDistanceMaterial) {
        refreshUniformsCommon(uniforms, material);
        refreshUniformsDistance(uniforms, material);
      } else if (material.isMeshNormalMaterial) {
        refreshUniformsCommon(uniforms, material);
      } else if (material.isLineBasicMaterial) {
        refreshUniformsLine(uniforms, material);
        if (material.isLineDashedMaterial) {
          refreshUniformsDash(uniforms, material);
        }
      } else if (material.isPointsMaterial) {
        refreshUniformsPoints(uniforms, material, pixelRatio, height);
      } else if (material.isSpriteMaterial) {
        refreshUniformsSprites(uniforms, material);
      } else if (material.isShadowMaterial) {
        uniforms.color.value.copy(material.color);
        uniforms.opacity.value = material.opacity;
      } else if (material.isShaderMaterial) {
        material.uniformsNeedUpdate = false;
      }
    }
    function refreshUniformsCommon(uniforms, material) {
      uniforms.opacity.value = material.opacity;
      if (material.color) {
        uniforms.diffuse.value.copy(material.color);
      }
      if (material.emissive) {
        uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);
      }
      if (material.map) {
        uniforms.map.value = material.map;
      }
      if (material.alphaMap) {
        uniforms.alphaMap.value = material.alphaMap;
      }
      if (material.bumpMap) {
        uniforms.bumpMap.value = material.bumpMap;
        uniforms.bumpScale.value = material.bumpScale;
        if (material.side === BackSide)
          uniforms.bumpScale.value *= -1;
      }
      if (material.displacementMap) {
        uniforms.displacementMap.value = material.displacementMap;
        uniforms.displacementScale.value = material.displacementScale;
        uniforms.displacementBias.value = material.displacementBias;
      }
      if (material.emissiveMap) {
        uniforms.emissiveMap.value = material.emissiveMap;
      }
      if (material.normalMap) {
        uniforms.normalMap.value = material.normalMap;
        uniforms.normalScale.value.copy(material.normalScale);
        if (material.side === BackSide)
          uniforms.normalScale.value.negate();
      }
      if (material.specularMap) {
        uniforms.specularMap.value = material.specularMap;
      }
      if (material.alphaTest > 0) {
        uniforms.alphaTest.value = material.alphaTest;
      }
      const envMap = properties.get(material).envMap;
      if (envMap) {
        uniforms.envMap.value = envMap;
        uniforms.flipEnvMap.value = envMap.isCubeTexture && envMap.isRenderTargetTexture === false ? -1 : 1;
        uniforms.reflectivity.value = material.reflectivity;
        uniforms.ior.value = material.ior;
        uniforms.refractionRatio.value = material.refractionRatio;
      }
      if (material.lightMap) {
        uniforms.lightMap.value = material.lightMap;
        const scaleFactor = renderer.physicallyCorrectLights !== true ? Math.PI : 1;
        uniforms.lightMapIntensity.value = material.lightMapIntensity * scaleFactor;
      }
      if (material.aoMap) {
        uniforms.aoMap.value = material.aoMap;
        uniforms.aoMapIntensity.value = material.aoMapIntensity;
      }
      let uvScaleMap;
      if (material.map) {
        uvScaleMap = material.map;
      } else if (material.specularMap) {
        uvScaleMap = material.specularMap;
      } else if (material.displacementMap) {
        uvScaleMap = material.displacementMap;
      } else if (material.normalMap) {
        uvScaleMap = material.normalMap;
      } else if (material.bumpMap) {
        uvScaleMap = material.bumpMap;
      } else if (material.roughnessMap) {
        uvScaleMap = material.roughnessMap;
      } else if (material.metalnessMap) {
        uvScaleMap = material.metalnessMap;
      } else if (material.alphaMap) {
        uvScaleMap = material.alphaMap;
      } else if (material.emissiveMap) {
        uvScaleMap = material.emissiveMap;
      } else if (material.clearcoatMap) {
        uvScaleMap = material.clearcoatMap;
      } else if (material.clearcoatNormalMap) {
        uvScaleMap = material.clearcoatNormalMap;
      } else if (material.clearcoatRoughnessMap) {
        uvScaleMap = material.clearcoatRoughnessMap;
      } else if (material.specularIntensityMap) {
        uvScaleMap = material.specularIntensityMap;
      } else if (material.specularColorMap) {
        uvScaleMap = material.specularColorMap;
      } else if (material.transmissionMap) {
        uvScaleMap = material.transmissionMap;
      } else if (material.thicknessMap) {
        uvScaleMap = material.thicknessMap;
      } else if (material.sheenColorMap) {
        uvScaleMap = material.sheenColorMap;
      } else if (material.sheenRoughnessMap) {
        uvScaleMap = material.sheenRoughnessMap;
      }
      if (uvScaleMap !== void 0) {
        if (uvScaleMap.isWebGLRenderTarget) {
          uvScaleMap = uvScaleMap.texture;
        }
        if (uvScaleMap.matrixAutoUpdate === true) {
          uvScaleMap.updateMatrix();
        }
        uniforms.uvTransform.value.copy(uvScaleMap.matrix);
      }
      let uv2ScaleMap;
      if (material.aoMap) {
        uv2ScaleMap = material.aoMap;
      } else if (material.lightMap) {
        uv2ScaleMap = material.lightMap;
      }
      if (uv2ScaleMap !== void 0) {
        if (uv2ScaleMap.isWebGLRenderTarget) {
          uv2ScaleMap = uv2ScaleMap.texture;
        }
        if (uv2ScaleMap.matrixAutoUpdate === true) {
          uv2ScaleMap.updateMatrix();
        }
        uniforms.uv2Transform.value.copy(uv2ScaleMap.matrix);
      }
    }
    function refreshUniformsLine(uniforms, material) {
      uniforms.diffuse.value.copy(material.color);
      uniforms.opacity.value = material.opacity;
    }
    function refreshUniformsDash(uniforms, material) {
      uniforms.dashSize.value = material.dashSize;
      uniforms.totalSize.value = material.dashSize + material.gapSize;
      uniforms.scale.value = material.scale;
    }
    function refreshUniformsPoints(uniforms, material, pixelRatio, height) {
      uniforms.diffuse.value.copy(material.color);
      uniforms.opacity.value = material.opacity;
      uniforms.size.value = material.size * pixelRatio;
      uniforms.scale.value = height * 0.5;
      if (material.map) {
        uniforms.map.value = material.map;
      }
      if (material.alphaMap) {
        uniforms.alphaMap.value = material.alphaMap;
      }
      if (material.alphaTest > 0) {
        uniforms.alphaTest.value = material.alphaTest;
      }
      let uvScaleMap;
      if (material.map) {
        uvScaleMap = material.map;
      } else if (material.alphaMap) {
        uvScaleMap = material.alphaMap;
      }
      if (uvScaleMap !== void 0) {
        if (uvScaleMap.matrixAutoUpdate === true) {
          uvScaleMap.updateMatrix();
        }
        uniforms.uvTransform.value.copy(uvScaleMap.matrix);
      }
    }
    function refreshUniformsSprites(uniforms, material) {
      uniforms.diffuse.value.copy(material.color);
      uniforms.opacity.value = material.opacity;
      uniforms.rotation.value = material.rotation;
      if (material.map) {
        uniforms.map.value = material.map;
      }
      if (material.alphaMap) {
        uniforms.alphaMap.value = material.alphaMap;
      }
      if (material.alphaTest > 0) {
        uniforms.alphaTest.value = material.alphaTest;
      }
      let uvScaleMap;
      if (material.map) {
        uvScaleMap = material.map;
      } else if (material.alphaMap) {
        uvScaleMap = material.alphaMap;
      }
      if (uvScaleMap !== void 0) {
        if (uvScaleMap.matrixAutoUpdate === true) {
          uvScaleMap.updateMatrix();
        }
        uniforms.uvTransform.value.copy(uvScaleMap.matrix);
      }
    }
    function refreshUniformsPhong(uniforms, material) {
      uniforms.specular.value.copy(material.specular);
      uniforms.shininess.value = Math.max(material.shininess, 1e-4);
    }
    function refreshUniformsToon(uniforms, material) {
      if (material.gradientMap) {
        uniforms.gradientMap.value = material.gradientMap;
      }
    }
    function refreshUniformsStandard(uniforms, material) {
      uniforms.roughness.value = material.roughness;
      uniforms.metalness.value = material.metalness;
      if (material.roughnessMap) {
        uniforms.roughnessMap.value = material.roughnessMap;
      }
      if (material.metalnessMap) {
        uniforms.metalnessMap.value = material.metalnessMap;
      }
      const envMap = properties.get(material).envMap;
      if (envMap) {
        uniforms.envMapIntensity.value = material.envMapIntensity;
      }
    }
    function refreshUniformsPhysical(uniforms, material, transmissionRenderTarget) {
      uniforms.ior.value = material.ior;
      if (material.sheen > 0) {
        uniforms.sheenColor.value.copy(material.sheenColor).multiplyScalar(material.sheen);
        uniforms.sheenRoughness.value = material.sheenRoughness;
        if (material.sheenColorMap) {
          uniforms.sheenColorMap.value = material.sheenColorMap;
        }
        if (material.sheenRoughnessMap) {
          uniforms.sheenRoughnessMap.value = material.sheenRoughnessMap;
        }
      }
      if (material.clearcoat > 0) {
        uniforms.clearcoat.value = material.clearcoat;
        uniforms.clearcoatRoughness.value = material.clearcoatRoughness;
        if (material.clearcoatMap) {
          uniforms.clearcoatMap.value = material.clearcoatMap;
        }
        if (material.clearcoatRoughnessMap) {
          uniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;
        }
        if (material.clearcoatNormalMap) {
          uniforms.clearcoatNormalScale.value.copy(material.clearcoatNormalScale);
          uniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;
          if (material.side === BackSide) {
            uniforms.clearcoatNormalScale.value.negate();
          }
        }
      }
      if (material.transmission > 0) {
        uniforms.transmission.value = material.transmission;
        uniforms.transmissionSamplerMap.value = transmissionRenderTarget.texture;
        uniforms.transmissionSamplerSize.value.set(transmissionRenderTarget.width, transmissionRenderTarget.height);
        if (material.transmissionMap) {
          uniforms.transmissionMap.value = material.transmissionMap;
        }
        uniforms.thickness.value = material.thickness;
        if (material.thicknessMap) {
          uniforms.thicknessMap.value = material.thicknessMap;
        }
        uniforms.attenuationDistance.value = material.attenuationDistance;
        uniforms.attenuationColor.value.copy(material.attenuationColor);
      }
      uniforms.specularIntensity.value = material.specularIntensity;
      uniforms.specularColor.value.copy(material.specularColor);
      if (material.specularIntensityMap) {
        uniforms.specularIntensityMap.value = material.specularIntensityMap;
      }
      if (material.specularColorMap) {
        uniforms.specularColorMap.value = material.specularColorMap;
      }
    }
    function refreshUniformsMatcap(uniforms, material) {
      if (material.matcap) {
        uniforms.matcap.value = material.matcap;
      }
    }
    function refreshUniformsDistance(uniforms, material) {
      uniforms.referencePosition.value.copy(material.referencePosition);
      uniforms.nearDistance.value = material.nearDistance;
      uniforms.farDistance.value = material.farDistance;
    }
    return {
      refreshFogUniforms,
      refreshMaterialUniforms
    };
  }
  function createCanvasElement() {
    const canvas = createElementNS("canvas");
    canvas.style.display = "block";
    return canvas;
  }
  function WebGLRenderer(parameters = {}) {
    const _canvas2 = parameters.canvas !== void 0 ? parameters.canvas : createCanvasElement(), _context2 = parameters.context !== void 0 ? parameters.context : null, _depth = parameters.depth !== void 0 ? parameters.depth : true, _stencil = parameters.stencil !== void 0 ? parameters.stencil : true, _antialias = parameters.antialias !== void 0 ? parameters.antialias : false, _premultipliedAlpha = parameters.premultipliedAlpha !== void 0 ? parameters.premultipliedAlpha : true, _preserveDrawingBuffer = parameters.preserveDrawingBuffer !== void 0 ? parameters.preserveDrawingBuffer : false, _powerPreference = parameters.powerPreference !== void 0 ? parameters.powerPreference : "default", _failIfMajorPerformanceCaveat = parameters.failIfMajorPerformanceCaveat !== void 0 ? parameters.failIfMajorPerformanceCaveat : false;
    let _alpha;
    if (parameters.context !== void 0) {
      _alpha = _context2.getContextAttributes().alpha;
    } else {
      _alpha = parameters.alpha !== void 0 ? parameters.alpha : false;
    }
    let currentRenderList = null;
    let currentRenderState = null;
    const renderListStack = [];
    const renderStateStack = [];
    this.domElement = _canvas2;
    this.debug = {
      /**
       * Enables error checking and reporting when shader programs are being compiled
       * @type {boolean}
       */
      checkShaderErrors: true
    };
    this.autoClear = true;
    this.autoClearColor = true;
    this.autoClearDepth = true;
    this.autoClearStencil = true;
    this.sortObjects = true;
    this.clippingPlanes = [];
    this.localClippingEnabled = false;
    this.outputEncoding = LinearEncoding;
    this.physicallyCorrectLights = false;
    this.toneMapping = NoToneMapping;
    this.toneMappingExposure = 1;
    const _this = this;
    let _isContextLost = false;
    let _currentActiveCubeFace = 0;
    let _currentActiveMipmapLevel = 0;
    let _currentRenderTarget = null;
    let _currentMaterialId = -1;
    let _currentCamera = null;
    const _currentViewport = new Vector4();
    const _currentScissor = new Vector4();
    let _currentScissorTest = null;
    let _width = _canvas2.width;
    let _height = _canvas2.height;
    let _pixelRatio = 1;
    let _opaqueSort = null;
    let _transparentSort = null;
    const _viewport = new Vector4(0, 0, _width, _height);
    const _scissor = new Vector4(0, 0, _width, _height);
    let _scissorTest = false;
    const _frustum = new Frustum();
    let _clippingEnabled = false;
    let _localClippingEnabled = false;
    let _transmissionRenderTarget = null;
    const _projScreenMatrix2 = new Matrix4();
    const _vector22 = new Vector2();
    const _vector3 = new Vector3();
    const _emptyScene = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: true };
    function getTargetPixelRatio() {
      return _currentRenderTarget === null ? _pixelRatio : 1;
    }
    let _gl = _context2;
    function getContext(contextNames, contextAttributes) {
      for (let i = 0; i < contextNames.length; i++) {
        const contextName = contextNames[i];
        const context = _canvas2.getContext(contextName, contextAttributes);
        if (context !== null)
          return context;
      }
      return null;
    }
    try {
      const contextAttributes = {
        alpha: true,
        depth: _depth,
        stencil: _stencil,
        antialias: _antialias,
        premultipliedAlpha: _premultipliedAlpha,
        preserveDrawingBuffer: _preserveDrawingBuffer,
        powerPreference: _powerPreference,
        failIfMajorPerformanceCaveat: _failIfMajorPerformanceCaveat
      };
      if ("setAttribute" in _canvas2)
        _canvas2.setAttribute("data-engine", `three.js r${REVISION}`);
      _canvas2.addEventListener("webglcontextlost", onContextLost, false);
      _canvas2.addEventListener("webglcontextrestored", onContextRestore, false);
      if (_gl === null) {
        const contextNames = ["webgl2", "webgl", "experimental-webgl"];
        if (_this.isWebGL1Renderer === true) {
          contextNames.shift();
        }
        _gl = getContext(contextNames, contextAttributes);
        if (_gl === null) {
          if (getContext(contextNames)) {
            throw new Error("Error creating WebGL context with your selected attributes.");
          } else {
            throw new Error("Error creating WebGL context.");
          }
        }
      }
      if (_gl.getShaderPrecisionFormat === void 0) {
        _gl.getShaderPrecisionFormat = function() {
          return { "rangeMin": 1, "rangeMax": 1, "precision": 1 };
        };
      }
    } catch (error2) {
      console.error("THREE.WebGLRenderer: " + error2.message);
      throw error2;
    }
    let extensions, capabilities, state, info;
    let properties, textures, cubemaps, cubeuvmaps, attributes, geometries, objects;
    let programCache, materials, renderLists, renderStates, clipping, shadowMap;
    let background, morphtargets, bufferRenderer, indexedBufferRenderer;
    let utils, bindingStates;
    function initGLContext() {
      extensions = new WebGLExtensions(_gl);
      capabilities = new WebGLCapabilities(_gl, extensions, parameters);
      extensions.init(capabilities);
      utils = new WebGLUtils(_gl, extensions, capabilities);
      state = new WebGLState(_gl, extensions, capabilities);
      info = new WebGLInfo(_gl);
      properties = new WebGLProperties();
      textures = new WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info);
      cubemaps = new WebGLCubeMaps(_this);
      cubeuvmaps = new WebGLCubeUVMaps(_this);
      attributes = new WebGLAttributes(_gl, capabilities);
      bindingStates = new WebGLBindingStates(_gl, extensions, attributes, capabilities);
      geometries = new WebGLGeometries(_gl, attributes, info, bindingStates);
      objects = new WebGLObjects(_gl, geometries, attributes, info);
      morphtargets = new WebGLMorphtargets(_gl, capabilities, textures);
      clipping = new WebGLClipping(properties);
      programCache = new WebGLPrograms(_this, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping);
      materials = new WebGLMaterials(_this, properties);
      renderLists = new WebGLRenderLists();
      renderStates = new WebGLRenderStates(extensions, capabilities);
      background = new WebGLBackground(_this, cubemaps, state, objects, _alpha, _premultipliedAlpha);
      shadowMap = new WebGLShadowMap(_this, objects, capabilities);
      bufferRenderer = new WebGLBufferRenderer(_gl, extensions, info, capabilities);
      indexedBufferRenderer = new WebGLIndexedBufferRenderer(_gl, extensions, info, capabilities);
      info.programs = programCache.programs;
      _this.capabilities = capabilities;
      _this.extensions = extensions;
      _this.properties = properties;
      _this.renderLists = renderLists;
      _this.shadowMap = shadowMap;
      _this.state = state;
      _this.info = info;
    }
    initGLContext();
    const xr = new WebXRManager(_this, _gl);
    this.xr = xr;
    this.getContext = function() {
      return _gl;
    };
    this.getContextAttributes = function() {
      return _gl.getContextAttributes();
    };
    this.forceContextLoss = function() {
      const extension = extensions.get("WEBGL_lose_context");
      if (extension)
        extension.loseContext();
    };
    this.forceContextRestore = function() {
      const extension = extensions.get("WEBGL_lose_context");
      if (extension)
        extension.restoreContext();
    };
    this.getPixelRatio = function() {
      return _pixelRatio;
    };
    this.setPixelRatio = function(value) {
      if (value === void 0)
        return;
      _pixelRatio = value;
      this.setSize(_width, _height, false);
    };
    this.getSize = function(target) {
      return target.set(_width, _height);
    };
    this.setSize = function(width, height, updateStyle) {
      if (xr.isPresenting) {
        console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
        return;
      }
      _width = width;
      _height = height;
      _canvas2.width = Math.floor(width * _pixelRatio);
      _canvas2.height = Math.floor(height * _pixelRatio);
      if (updateStyle !== false) {
        _canvas2.style.width = width + "px";
        _canvas2.style.height = height + "px";
      }
      this.setViewport(0, 0, width, height);
    };
    this.getDrawingBufferSize = function(target) {
      return target.set(_width * _pixelRatio, _height * _pixelRatio).floor();
    };
    this.setDrawingBufferSize = function(width, height, pixelRatio) {
      _width = width;
      _height = height;
      _pixelRatio = pixelRatio;
      _canvas2.width = Math.floor(width * pixelRatio);
      _canvas2.height = Math.floor(height * pixelRatio);
      this.setViewport(0, 0, width, height);
    };
    this.getCurrentViewport = function(target) {
      return target.copy(_currentViewport);
    };
    this.getViewport = function(target) {
      return target.copy(_viewport);
    };
    this.setViewport = function(x, y, width, height) {
      if (x.isVector4) {
        _viewport.set(x.x, x.y, x.z, x.w);
      } else {
        _viewport.set(x, y, width, height);
      }
      state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor());
    };
    this.getScissor = function(target) {
      return target.copy(_scissor);
    };
    this.setScissor = function(x, y, width, height) {
      if (x.isVector4) {
        _scissor.set(x.x, x.y, x.z, x.w);
      } else {
        _scissor.set(x, y, width, height);
      }
      state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor());
    };
    this.getScissorTest = function() {
      return _scissorTest;
    };
    this.setScissorTest = function(boolean) {
      state.setScissorTest(_scissorTest = boolean);
    };
    this.setOpaqueSort = function(method) {
      _opaqueSort = method;
    };
    this.setTransparentSort = function(method) {
      _transparentSort = method;
    };
    this.getClearColor = function(target) {
      return target.copy(background.getClearColor());
    };
    this.setClearColor = function() {
      background.setClearColor.apply(background, arguments);
    };
    this.getClearAlpha = function() {
      return background.getClearAlpha();
    };
    this.setClearAlpha = function() {
      background.setClearAlpha.apply(background, arguments);
    };
    this.clear = function(color = true, depth = true, stencil = true) {
      let bits = 0;
      if (color)
        bits |= 16384;
      if (depth)
        bits |= 256;
      if (stencil)
        bits |= 1024;
      _gl.clear(bits);
    };
    this.clearColor = function() {
      this.clear(true, false, false);
    };
    this.clearDepth = function() {
      this.clear(false, true, false);
    };
    this.clearStencil = function() {
      this.clear(false, false, true);
    };
    this.dispose = function() {
      _canvas2.removeEventListener("webglcontextlost", onContextLost, false);
      _canvas2.removeEventListener("webglcontextrestored", onContextRestore, false);
      renderLists.dispose();
      renderStates.dispose();
      properties.dispose();
      cubemaps.dispose();
      cubeuvmaps.dispose();
      objects.dispose();
      bindingStates.dispose();
      programCache.dispose();
      xr.dispose();
      xr.removeEventListener("sessionstart", onXRSessionStart);
      xr.removeEventListener("sessionend", onXRSessionEnd);
      if (_transmissionRenderTarget) {
        _transmissionRenderTarget.dispose();
        _transmissionRenderTarget = null;
      }
      animation.stop();
    };
    function onContextLost(event) {
      event.preventDefault();
      console.log("THREE.WebGLRenderer: Context Lost.");
      _isContextLost = true;
    }
    function onContextRestore() {
      console.log("THREE.WebGLRenderer: Context Restored.");
      _isContextLost = false;
      const infoAutoReset = info.autoReset;
      const shadowMapEnabled = shadowMap.enabled;
      const shadowMapAutoUpdate = shadowMap.autoUpdate;
      const shadowMapNeedsUpdate = shadowMap.needsUpdate;
      const shadowMapType = shadowMap.type;
      initGLContext();
      info.autoReset = infoAutoReset;
      shadowMap.enabled = shadowMapEnabled;
      shadowMap.autoUpdate = shadowMapAutoUpdate;
      shadowMap.needsUpdate = shadowMapNeedsUpdate;
      shadowMap.type = shadowMapType;
    }
    function onMaterialDispose(event) {
      const material = event.target;
      material.removeEventListener("dispose", onMaterialDispose);
      deallocateMaterial(material);
    }
    function deallocateMaterial(material) {
      releaseMaterialProgramReferences(material);
      properties.remove(material);
    }
    function releaseMaterialProgramReferences(material) {
      const programs = properties.get(material).programs;
      if (programs !== void 0) {
        programs.forEach(function(program) {
          programCache.releaseProgram(program);
        });
        if (material.isShaderMaterial) {
          programCache.releaseShaderCache(material);
        }
      }
    }
    this.renderBufferDirect = function(camera, scene, geometry, material, object, group) {
      if (scene === null)
        scene = _emptyScene;
      const frontFaceCW = object.isMesh && object.matrixWorld.determinant() < 0;
      const program = setProgram(camera, scene, geometry, material, object);
      state.setMaterial(material, frontFaceCW);
      let index = geometry.index;
      const position = geometry.attributes.position;
      if (index === null) {
        if (position === void 0 || position.count === 0)
          return;
      } else if (index.count === 0) {
        return;
      }
      let rangeFactor = 1;
      if (material.wireframe === true) {
        index = geometries.getWireframeAttribute(geometry);
        rangeFactor = 2;
      }
      bindingStates.setup(object, material, program, geometry, index);
      let attribute;
      let renderer = bufferRenderer;
      if (index !== null) {
        attribute = attributes.get(index);
        renderer = indexedBufferRenderer;
        renderer.setIndex(attribute);
      }
      const dataCount = index !== null ? index.count : position.count;
      const rangeStart = geometry.drawRange.start * rangeFactor;
      const rangeCount = geometry.drawRange.count * rangeFactor;
      const groupStart = group !== null ? group.start * rangeFactor : 0;
      const groupCount = group !== null ? group.count * rangeFactor : Infinity;
      const drawStart = Math.max(rangeStart, groupStart);
      const drawEnd = Math.min(dataCount, rangeStart + rangeCount, groupStart + groupCount) - 1;
      const drawCount = Math.max(0, drawEnd - drawStart + 1);
      if (drawCount === 0)
        return;
      if (object.isMesh) {
        if (material.wireframe === true) {
          state.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio());
          renderer.setMode(1);
        } else {
          renderer.setMode(4);
        }
      } else if (object.isLine) {
        let lineWidth = material.linewidth;
        if (lineWidth === void 0)
          lineWidth = 1;
        state.setLineWidth(lineWidth * getTargetPixelRatio());
        if (object.isLineSegments) {
          renderer.setMode(1);
        } else if (object.isLineLoop) {
          renderer.setMode(2);
        } else {
          renderer.setMode(3);
        }
      } else if (object.isPoints) {
        renderer.setMode(0);
      } else if (object.isSprite) {
        renderer.setMode(4);
      }
      if (object.isInstancedMesh) {
        renderer.renderInstances(drawStart, drawCount, object.count);
      } else if (geometry.isInstancedBufferGeometry) {
        const instanceCount = Math.min(geometry.instanceCount, geometry._maxInstanceCount);
        renderer.renderInstances(drawStart, drawCount, instanceCount);
      } else {
        renderer.render(drawStart, drawCount);
      }
    };
    this.compile = function(scene, camera) {
      currentRenderState = renderStates.get(scene);
      currentRenderState.init();
      renderStateStack.push(currentRenderState);
      scene.traverseVisible(function(object) {
        if (object.isLight && object.layers.test(camera.layers)) {
          currentRenderState.pushLight(object);
          if (object.castShadow) {
            currentRenderState.pushShadow(object);
          }
        }
      });
      currentRenderState.setupLights(_this.physicallyCorrectLights);
      scene.traverse(function(object) {
        const material = object.material;
        if (material) {
          if (Array.isArray(material)) {
            for (let i = 0; i < material.length; i++) {
              const material2 = material[i];
              getProgram(material2, scene, object);
            }
          } else {
            getProgram(material, scene, object);
          }
        }
      });
      renderStateStack.pop();
      currentRenderState = null;
    };
    let onAnimationFrameCallback = null;
    function onAnimationFrame(time) {
      if (onAnimationFrameCallback)
        onAnimationFrameCallback(time);
    }
    function onXRSessionStart() {
      animation.stop();
    }
    function onXRSessionEnd() {
      animation.start();
    }
    const animation = new WebGLAnimation();
    animation.setAnimationLoop(onAnimationFrame);
    if (typeof self !== "undefined")
      animation.setContext(self);
    this.setAnimationLoop = function(callback) {
      onAnimationFrameCallback = callback;
      xr.setAnimationLoop(callback);
      callback === null ? animation.stop() : animation.start();
    };
    xr.addEventListener("sessionstart", onXRSessionStart);
    xr.addEventListener("sessionend", onXRSessionEnd);
    this.render = function(scene, camera) {
      if (camera !== void 0 && camera.isCamera !== true) {
        console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
        return;
      }
      if (_isContextLost === true)
        return;
      if (scene.autoUpdate === true)
        scene.updateMatrixWorld();
      if (camera.parent === null)
        camera.updateMatrixWorld();
      if (xr.enabled === true && xr.isPresenting === true) {
        if (xr.cameraAutoUpdate === true)
          xr.updateCamera(camera);
        camera = xr.getCamera();
      }
      if (scene.isScene === true)
        scene.onBeforeRender(_this, scene, camera, _currentRenderTarget);
      currentRenderState = renderStates.get(scene, renderStateStack.length);
      currentRenderState.init();
      renderStateStack.push(currentRenderState);
      _projScreenMatrix2.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
      _frustum.setFromProjectionMatrix(_projScreenMatrix2);
      _localClippingEnabled = this.localClippingEnabled;
      _clippingEnabled = clipping.init(this.clippingPlanes, _localClippingEnabled, camera);
      currentRenderList = renderLists.get(scene, renderListStack.length);
      currentRenderList.init();
      renderListStack.push(currentRenderList);
      projectObject(scene, camera, 0, _this.sortObjects);
      currentRenderList.finish();
      if (_this.sortObjects === true) {
        currentRenderList.sort(_opaqueSort, _transparentSort);
      }
      if (_clippingEnabled === true)
        clipping.beginShadows();
      const shadowsArray = currentRenderState.state.shadowsArray;
      shadowMap.render(shadowsArray, scene, camera);
      if (_clippingEnabled === true)
        clipping.endShadows();
      if (this.info.autoReset === true)
        this.info.reset();
      background.render(currentRenderList, scene);
      currentRenderState.setupLights(_this.physicallyCorrectLights);
      if (camera.isArrayCamera) {
        const cameras = camera.cameras;
        for (let i = 0, l = cameras.length; i < l; i++) {
          const camera2 = cameras[i];
          renderScene(currentRenderList, scene, camera2, camera2.viewport);
        }
      } else {
        renderScene(currentRenderList, scene, camera);
      }
      if (_currentRenderTarget !== null) {
        textures.updateMultisampleRenderTarget(_currentRenderTarget);
        textures.updateRenderTargetMipmap(_currentRenderTarget);
      }
      if (scene.isScene === true)
        scene.onAfterRender(_this, scene, camera);
      bindingStates.resetDefaultState();
      _currentMaterialId = -1;
      _currentCamera = null;
      renderStateStack.pop();
      if (renderStateStack.length > 0) {
        currentRenderState = renderStateStack[renderStateStack.length - 1];
      } else {
        currentRenderState = null;
      }
      renderListStack.pop();
      if (renderListStack.length > 0) {
        currentRenderList = renderListStack[renderListStack.length - 1];
      } else {
        currentRenderList = null;
      }
    };
    function projectObject(object, camera, groupOrder, sortObjects) {
      if (object.visible === false)
        return;
      const visible = object.layers.test(camera.layers);
      if (visible) {
        if (object.isGroup) {
          groupOrder = object.renderOrder;
        } else if (object.isLOD) {
          if (object.autoUpdate === true)
            object.update(camera);
        } else if (object.isLight) {
          currentRenderState.pushLight(object);
          if (object.castShadow) {
            currentRenderState.pushShadow(object);
          }
        } else if (object.isSprite) {
          if (!object.frustumCulled || _frustum.intersectsSprite(object)) {
            if (sortObjects) {
              _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix2);
            }
            const geometry = objects.update(object);
            const material = object.material;
            if (material.visible) {
              currentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null);
            }
          }
        } else if (object.isMesh || object.isLine || object.isPoints) {
          if (object.isSkinnedMesh) {
            if (object.skeleton.frame !== info.render.frame) {
              object.skeleton.update();
              object.skeleton.frame = info.render.frame;
            }
          }
          if (!object.frustumCulled || _frustum.intersectsObject(object)) {
            if (sortObjects) {
              _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix2);
            }
            const geometry = objects.update(object);
            const material = object.material;
            if (Array.isArray(material)) {
              const groups = geometry.groups;
              for (let i = 0, l = groups.length; i < l; i++) {
                const group = groups[i];
                const groupMaterial = material[group.materialIndex];
                if (groupMaterial && groupMaterial.visible) {
                  currentRenderList.push(object, geometry, groupMaterial, groupOrder, _vector3.z, group);
                }
              }
            } else if (material.visible) {
              currentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null);
            }
          }
        }
      }
      const children = object.children;
      for (let i = 0, l = children.length; i < l; i++) {
        projectObject(children[i], camera, groupOrder, sortObjects);
      }
    }
    function renderScene(currentRenderList2, scene, camera, viewport) {
      const opaqueObjects = currentRenderList2.opaque;
      const transmissiveObjects = currentRenderList2.transmissive;
      const transparentObjects = currentRenderList2.transparent;
      currentRenderState.setupLightsView(camera);
      if (transmissiveObjects.length > 0)
        renderTransmissionPass(opaqueObjects, scene, camera);
      if (viewport)
        state.viewport(_currentViewport.copy(viewport));
      if (opaqueObjects.length > 0)
        renderObjects(opaqueObjects, scene, camera);
      if (transmissiveObjects.length > 0)
        renderObjects(transmissiveObjects, scene, camera);
      if (transparentObjects.length > 0)
        renderObjects(transparentObjects, scene, camera);
      state.buffers.depth.setTest(true);
      state.buffers.depth.setMask(true);
      state.buffers.color.setMask(true);
      state.setPolygonOffset(false);
    }
    function renderTransmissionPass(opaqueObjects, scene, camera) {
      const isWebGL2 = capabilities.isWebGL2;
      if (_transmissionRenderTarget === null) {
        _transmissionRenderTarget = new WebGLRenderTarget(1, 1, {
          generateMipmaps: true,
          type: utils.convert(HalfFloatType) !== null ? HalfFloatType : UnsignedByteType,
          minFilter: LinearMipmapLinearFilter,
          samples: isWebGL2 && _antialias === true ? 4 : 0
        });
      }
      _this.getDrawingBufferSize(_vector22);
      if (isWebGL2) {
        _transmissionRenderTarget.setSize(_vector22.x, _vector22.y);
      } else {
        _transmissionRenderTarget.setSize(floorPowerOfTwo(_vector22.x), floorPowerOfTwo(_vector22.y));
      }
      const currentRenderTarget = _this.getRenderTarget();
      _this.setRenderTarget(_transmissionRenderTarget);
      _this.clear();
      const currentToneMapping = _this.toneMapping;
      _this.toneMapping = NoToneMapping;
      renderObjects(opaqueObjects, scene, camera);
      _this.toneMapping = currentToneMapping;
      textures.updateMultisampleRenderTarget(_transmissionRenderTarget);
      textures.updateRenderTargetMipmap(_transmissionRenderTarget);
      _this.setRenderTarget(currentRenderTarget);
    }
    function renderObjects(renderList, scene, camera) {
      const overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;
      for (let i = 0, l = renderList.length; i < l; i++) {
        const renderItem = renderList[i];
        const object = renderItem.object;
        const geometry = renderItem.geometry;
        const material = overrideMaterial === null ? renderItem.material : overrideMaterial;
        const group = renderItem.group;
        if (object.layers.test(camera.layers)) {
          renderObject(object, scene, camera, geometry, material, group);
        }
      }
    }
    function renderObject(object, scene, camera, geometry, material, group) {
      object.onBeforeRender(_this, scene, camera, geometry, material, group);
      object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
      object.normalMatrix.getNormalMatrix(object.modelViewMatrix);
      material.onBeforeRender(_this, scene, camera, geometry, object, group);
      if (material.transparent === true && material.side === DoubleSide) {
        material.side = BackSide;
        material.needsUpdate = true;
        _this.renderBufferDirect(camera, scene, geometry, material, object, group);
        material.side = FrontSide;
        material.needsUpdate = true;
        _this.renderBufferDirect(camera, scene, geometry, material, object, group);
        material.side = DoubleSide;
      } else {
        _this.renderBufferDirect(camera, scene, geometry, material, object, group);
      }
      object.onAfterRender(_this, scene, camera, geometry, material, group);
    }
    function getProgram(material, scene, object) {
      if (scene.isScene !== true)
        scene = _emptyScene;
      const materialProperties = properties.get(material);
      const lights = currentRenderState.state.lights;
      const shadowsArray = currentRenderState.state.shadowsArray;
      const lightsStateVersion = lights.state.version;
      const parameters2 = programCache.getParameters(material, lights.state, shadowsArray, scene, object);
      const programCacheKey = programCache.getProgramCacheKey(parameters2);
      let programs = materialProperties.programs;
      materialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null;
      materialProperties.fog = scene.fog;
      materialProperties.envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || materialProperties.environment);
      if (programs === void 0) {
        material.addEventListener("dispose", onMaterialDispose);
        programs = /* @__PURE__ */ new Map();
        materialProperties.programs = programs;
      }
      let program = programs.get(programCacheKey);
      if (program !== void 0) {
        if (materialProperties.currentProgram === program && materialProperties.lightsStateVersion === lightsStateVersion) {
          updateCommonMaterialProperties(material, parameters2);
          return program;
        }
      } else {
        parameters2.uniforms = programCache.getUniforms(material);
        material.onBuild(object, parameters2, _this);
        material.onBeforeCompile(parameters2, _this);
        program = programCache.acquireProgram(parameters2, programCacheKey);
        programs.set(programCacheKey, program);
        materialProperties.uniforms = parameters2.uniforms;
      }
      const uniforms = materialProperties.uniforms;
      if (!material.isShaderMaterial && !material.isRawShaderMaterial || material.clipping === true) {
        uniforms.clippingPlanes = clipping.uniform;
      }
      updateCommonMaterialProperties(material, parameters2);
      materialProperties.needsLights = materialNeedsLights(material);
      materialProperties.lightsStateVersion = lightsStateVersion;
      if (materialProperties.needsLights) {
        uniforms.ambientLightColor.value = lights.state.ambient;
        uniforms.lightProbe.value = lights.state.probe;
        uniforms.directionalLights.value = lights.state.directional;
        uniforms.directionalLightShadows.value = lights.state.directionalShadow;
        uniforms.spotLights.value = lights.state.spot;
        uniforms.spotLightShadows.value = lights.state.spotShadow;
        uniforms.rectAreaLights.value = lights.state.rectArea;
        uniforms.ltc_1.value = lights.state.rectAreaLTC1;
        uniforms.ltc_2.value = lights.state.rectAreaLTC2;
        uniforms.pointLights.value = lights.state.point;
        uniforms.pointLightShadows.value = lights.state.pointShadow;
        uniforms.hemisphereLights.value = lights.state.hemi;
        uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
        uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
        uniforms.spotShadowMap.value = lights.state.spotShadowMap;
        uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;
        uniforms.pointShadowMap.value = lights.state.pointShadowMap;
        uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
      }
      const progUniforms = program.getUniforms();
      const uniformsList = WebGLUniforms.seqWithValue(progUniforms.seq, uniforms);
      materialProperties.currentProgram = program;
      materialProperties.uniformsList = uniformsList;
      return program;
    }
    function updateCommonMaterialProperties(material, parameters2) {
      const materialProperties = properties.get(material);
      materialProperties.outputEncoding = parameters2.outputEncoding;
      materialProperties.instancing = parameters2.instancing;
      materialProperties.skinning = parameters2.skinning;
      materialProperties.morphTargets = parameters2.morphTargets;
      materialProperties.morphNormals = parameters2.morphNormals;
      materialProperties.morphColors = parameters2.morphColors;
      materialProperties.morphTargetsCount = parameters2.morphTargetsCount;
      materialProperties.numClippingPlanes = parameters2.numClippingPlanes;
      materialProperties.numIntersection = parameters2.numClipIntersection;
      materialProperties.vertexAlphas = parameters2.vertexAlphas;
      materialProperties.vertexTangents = parameters2.vertexTangents;
      materialProperties.toneMapping = parameters2.toneMapping;
    }
    function setProgram(camera, scene, geometry, material, object) {
      if (scene.isScene !== true)
        scene = _emptyScene;
      textures.resetTextureUnits();
      const fog = scene.fog;
      const environment = material.isMeshStandardMaterial ? scene.environment : null;
      const encoding = _currentRenderTarget === null ? _this.outputEncoding : _currentRenderTarget.isXRRenderTarget === true ? _currentRenderTarget.texture.encoding : LinearEncoding;
      const envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || environment);
      const vertexAlphas = material.vertexColors === true && !!geometry.attributes.color && geometry.attributes.color.itemSize === 4;
      const vertexTangents = !!material.normalMap && !!geometry.attributes.tangent;
      const morphTargets = !!geometry.morphAttributes.position;
      const morphNormals = !!geometry.morphAttributes.normal;
      const morphColors = !!geometry.morphAttributes.color;
      const toneMapping = material.toneMapped ? _this.toneMapping : NoToneMapping;
      const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
      const morphTargetsCount = morphAttribute !== void 0 ? morphAttribute.length : 0;
      const materialProperties = properties.get(material);
      const lights = currentRenderState.state.lights;
      if (_clippingEnabled === true) {
        if (_localClippingEnabled === true || camera !== _currentCamera) {
          const useCache = camera === _currentCamera && material.id === _currentMaterialId;
          clipping.setState(material, camera, useCache);
        }
      }
      let needsProgramChange = false;
      if (material.version === materialProperties.__version) {
        if (materialProperties.needsLights && materialProperties.lightsStateVersion !== lights.state.version) {
          needsProgramChange = true;
        } else if (materialProperties.outputEncoding !== encoding) {
          needsProgramChange = true;
        } else if (object.isInstancedMesh && materialProperties.instancing === false) {
          needsProgramChange = true;
        } else if (!object.isInstancedMesh && materialProperties.instancing === true) {
          needsProgramChange = true;
        } else if (object.isSkinnedMesh && materialProperties.skinning === false) {
          needsProgramChange = true;
        } else if (!object.isSkinnedMesh && materialProperties.skinning === true) {
          needsProgramChange = true;
        } else if (materialProperties.envMap !== envMap) {
          needsProgramChange = true;
        } else if (material.fog && materialProperties.fog !== fog) {
          needsProgramChange = true;
        } else if (materialProperties.numClippingPlanes !== void 0 && (materialProperties.numClippingPlanes !== clipping.numPlanes || materialProperties.numIntersection !== clipping.numIntersection)) {
          needsProgramChange = true;
        } else if (materialProperties.vertexAlphas !== vertexAlphas) {
          needsProgramChange = true;
        } else if (materialProperties.vertexTangents !== vertexTangents) {
          needsProgramChange = true;
        } else if (materialProperties.morphTargets !== morphTargets) {
          needsProgramChange = true;
        } else if (materialProperties.morphNormals !== morphNormals) {
          needsProgramChange = true;
        } else if (materialProperties.morphColors !== morphColors) {
          needsProgramChange = true;
        } else if (materialProperties.toneMapping !== toneMapping) {
          needsProgramChange = true;
        } else if (capabilities.isWebGL2 === true && materialProperties.morphTargetsCount !== morphTargetsCount) {
          needsProgramChange = true;
        }
      } else {
        needsProgramChange = true;
        materialProperties.__version = material.version;
      }
      let program = materialProperties.currentProgram;
      if (needsProgramChange === true) {
        program = getProgram(material, scene, object);
      }
      let refreshProgram = false;
      let refreshMaterial = false;
      let refreshLights = false;
      const p_uniforms = program.getUniforms(), m_uniforms = materialProperties.uniforms;
      if (state.useProgram(program.program)) {
        refreshProgram = true;
        refreshMaterial = true;
        refreshLights = true;
      }
      if (material.id !== _currentMaterialId) {
        _currentMaterialId = material.id;
        refreshMaterial = true;
      }
      if (refreshProgram || _currentCamera !== camera) {
        p_uniforms.setValue(_gl, "projectionMatrix", camera.projectionMatrix);
        if (capabilities.logarithmicDepthBuffer) {
          p_uniforms.setValue(
            _gl,
            "logDepthBufFC",
            2 / (Math.log(camera.far + 1) / Math.LN2)
          );
        }
        if (_currentCamera !== camera) {
          _currentCamera = camera;
          refreshMaterial = true;
          refreshLights = true;
        }
        if (material.isShaderMaterial || material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshStandardMaterial || material.envMap) {
          const uCamPos = p_uniforms.map.cameraPosition;
          if (uCamPos !== void 0) {
            uCamPos.setValue(
              _gl,
              _vector3.setFromMatrixPosition(camera.matrixWorld)
            );
          }
        }
        if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial) {
          p_uniforms.setValue(_gl, "isOrthographic", camera.isOrthographicCamera === true);
        }
        if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial || material.isShadowMaterial || object.isSkinnedMesh) {
          p_uniforms.setValue(_gl, "viewMatrix", camera.matrixWorldInverse);
        }
      }
      if (object.isSkinnedMesh) {
        p_uniforms.setOptional(_gl, object, "bindMatrix");
        p_uniforms.setOptional(_gl, object, "bindMatrixInverse");
        const skeleton = object.skeleton;
        if (skeleton) {
          if (capabilities.floatVertexTextures) {
            if (skeleton.boneTexture === null)
              skeleton.computeBoneTexture();
            p_uniforms.setValue(_gl, "boneTexture", skeleton.boneTexture, textures);
            p_uniforms.setValue(_gl, "boneTextureSize", skeleton.boneTextureSize);
          } else {
            p_uniforms.setOptional(_gl, skeleton, "boneMatrices");
          }
        }
      }
      const morphAttributes = geometry.morphAttributes;
      if (morphAttributes.position !== void 0 || morphAttributes.normal !== void 0 || morphAttributes.color !== void 0 && capabilities.isWebGL2 === true) {
        morphtargets.update(object, geometry, material, program);
      }
      if (refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow) {
        materialProperties.receiveShadow = object.receiveShadow;
        p_uniforms.setValue(_gl, "receiveShadow", object.receiveShadow);
      }
      if (refreshMaterial) {
        p_uniforms.setValue(_gl, "toneMappingExposure", _this.toneMappingExposure);
        if (materialProperties.needsLights) {
          markUniformsLightsNeedsUpdate(m_uniforms, refreshLights);
        }
        if (fog && material.fog) {
          materials.refreshFogUniforms(m_uniforms, fog);
        }
        materials.refreshMaterialUniforms(m_uniforms, material, _pixelRatio, _height, _transmissionRenderTarget);
        WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
      }
      if (material.isShaderMaterial && material.uniformsNeedUpdate === true) {
        WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
        material.uniformsNeedUpdate = false;
      }
      if (material.isSpriteMaterial) {
        p_uniforms.setValue(_gl, "center", object.center);
      }
      p_uniforms.setValue(_gl, "modelViewMatrix", object.modelViewMatrix);
      p_uniforms.setValue(_gl, "normalMatrix", object.normalMatrix);
      p_uniforms.setValue(_gl, "modelMatrix", object.matrixWorld);
      return program;
    }
    function markUniformsLightsNeedsUpdate(uniforms, value) {
      uniforms.ambientLightColor.needsUpdate = value;
      uniforms.lightProbe.needsUpdate = value;
      uniforms.directionalLights.needsUpdate = value;
      uniforms.directionalLightShadows.needsUpdate = value;
      uniforms.pointLights.needsUpdate = value;
      uniforms.pointLightShadows.needsUpdate = value;
      uniforms.spotLights.needsUpdate = value;
      uniforms.spotLightShadows.needsUpdate = value;
      uniforms.rectAreaLights.needsUpdate = value;
      uniforms.hemisphereLights.needsUpdate = value;
    }
    function materialNeedsLights(material) {
      return material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial || material.isShadowMaterial || material.isShaderMaterial && material.lights === true;
    }
    this.getActiveCubeFace = function() {
      return _currentActiveCubeFace;
    };
    this.getActiveMipmapLevel = function() {
      return _currentActiveMipmapLevel;
    };
    this.getRenderTarget = function() {
      return _currentRenderTarget;
    };
    this.setRenderTargetTextures = function(renderTarget, colorTexture, depthTexture) {
      properties.get(renderTarget.texture).__webglTexture = colorTexture;
      properties.get(renderTarget.depthTexture).__webglTexture = depthTexture;
      const renderTargetProperties = properties.get(renderTarget);
      renderTargetProperties.__hasExternalTextures = true;
      if (renderTargetProperties.__hasExternalTextures) {
        renderTargetProperties.__autoAllocateDepthBuffer = depthTexture === void 0;
        if (!renderTargetProperties.__autoAllocateDepthBuffer) {
          if (extensions.has("WEBGL_multisampled_render_to_texture") === true) {
            console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided");
            renderTargetProperties.__useRenderToTexture = false;
          }
        }
      }
    };
    this.setRenderTargetFramebuffer = function(renderTarget, defaultFramebuffer) {
      const renderTargetProperties = properties.get(renderTarget);
      renderTargetProperties.__webglFramebuffer = defaultFramebuffer;
      renderTargetProperties.__useDefaultFramebuffer = defaultFramebuffer === void 0;
    };
    this.setRenderTarget = function(renderTarget, activeCubeFace = 0, activeMipmapLevel = 0) {
      _currentRenderTarget = renderTarget;
      _currentActiveCubeFace = activeCubeFace;
      _currentActiveMipmapLevel = activeMipmapLevel;
      let useDefaultFramebuffer = true;
      if (renderTarget) {
        const renderTargetProperties = properties.get(renderTarget);
        if (renderTargetProperties.__useDefaultFramebuffer !== void 0) {
          state.bindFramebuffer(36160, null);
          useDefaultFramebuffer = false;
        } else if (renderTargetProperties.__webglFramebuffer === void 0) {
          textures.setupRenderTarget(renderTarget);
        } else if (renderTargetProperties.__hasExternalTextures) {
          textures.rebindTextures(renderTarget, properties.get(renderTarget.texture).__webglTexture, properties.get(renderTarget.depthTexture).__webglTexture);
        }
      }
      let framebuffer = null;
      let isCube = false;
      let isRenderTarget3D = false;
      if (renderTarget) {
        const texture = renderTarget.texture;
        if (texture.isData3DTexture || texture.isDataArrayTexture) {
          isRenderTarget3D = true;
        }
        const __webglFramebuffer = properties.get(renderTarget).__webglFramebuffer;
        if (renderTarget.isWebGLCubeRenderTarget) {
          framebuffer = __webglFramebuffer[activeCubeFace];
          isCube = true;
        } else if (capabilities.isWebGL2 && renderTarget.samples > 0 && textures.useMultisampledRTT(renderTarget) === false) {
          framebuffer = properties.get(renderTarget).__webglMultisampledFramebuffer;
        } else {
          framebuffer = __webglFramebuffer;
        }
        _currentViewport.copy(renderTarget.viewport);
        _currentScissor.copy(renderTarget.scissor);
        _currentScissorTest = renderTarget.scissorTest;
      } else {
        _currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor();
        _currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor();
        _currentScissorTest = _scissorTest;
      }
      const framebufferBound = state.bindFramebuffer(36160, framebuffer);
      if (framebufferBound && capabilities.drawBuffers && useDefaultFramebuffer) {
        state.drawBuffers(renderTarget, framebuffer);
      }
      state.viewport(_currentViewport);
      state.scissor(_currentScissor);
      state.setScissorTest(_currentScissorTest);
      if (isCube) {
        const textureProperties = properties.get(renderTarget.texture);
        _gl.framebufferTexture2D(36160, 36064, 34069 + activeCubeFace, textureProperties.__webglTexture, activeMipmapLevel);
      } else if (isRenderTarget3D) {
        const textureProperties = properties.get(renderTarget.texture);
        const layer = activeCubeFace || 0;
        _gl.framebufferTextureLayer(36160, 36064, textureProperties.__webglTexture, activeMipmapLevel || 0, layer);
      }
      _currentMaterialId = -1;
    };
    this.readRenderTargetPixels = function(renderTarget, x, y, width, height, buffer, activeCubeFaceIndex) {
      if (!(renderTarget && renderTarget.isWebGLRenderTarget)) {
        console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
        return;
      }
      let framebuffer = properties.get(renderTarget).__webglFramebuffer;
      if (renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== void 0) {
        framebuffer = framebuffer[activeCubeFaceIndex];
      }
      if (framebuffer) {
        state.bindFramebuffer(36160, framebuffer);
        try {
          const texture = renderTarget.texture;
          const textureFormat = texture.format;
          const textureType = texture.type;
          if (textureFormat !== RGBAFormat && utils.convert(textureFormat) !== _gl.getParameter(35739)) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
            return;
          }
          const halfFloatSupportedByExt = textureType === HalfFloatType && (extensions.has("EXT_color_buffer_half_float") || capabilities.isWebGL2 && extensions.has("EXT_color_buffer_float"));
          if (textureType !== UnsignedByteType && utils.convert(textureType) !== _gl.getParameter(35738) && // Edge and Chrome Mac < 52 (#9513)
          !(textureType === FloatType && (capabilities.isWebGL2 || extensions.has("OES_texture_float") || extensions.has("WEBGL_color_buffer_float"))) && // Chrome Mac >= 52 and Firefox
          !halfFloatSupportedByExt) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
            return;
          }
          if (x >= 0 && x <= renderTarget.width - width && (y >= 0 && y <= renderTarget.height - height)) {
            _gl.readPixels(x, y, width, height, utils.convert(textureFormat), utils.convert(textureType), buffer);
          }
        } finally {
          const framebuffer2 = _currentRenderTarget !== null ? properties.get(_currentRenderTarget).__webglFramebuffer : null;
          state.bindFramebuffer(36160, framebuffer2);
        }
      }
    };
    this.copyFramebufferToTexture = function(position, texture, level = 0) {
      if (texture.isFramebufferTexture !== true) {
        console.error("THREE.WebGLRenderer: copyFramebufferToTexture() can only be used with FramebufferTexture.");
        return;
      }
      const levelScale = Math.pow(2, -level);
      const width = Math.floor(texture.image.width * levelScale);
      const height = Math.floor(texture.image.height * levelScale);
      textures.setTexture2D(texture, 0);
      _gl.copyTexSubImage2D(3553, level, 0, 0, position.x, position.y, width, height);
      state.unbindTexture();
    };
    this.copyTextureToTexture = function(position, srcTexture, dstTexture, level = 0) {
      const width = srcTexture.image.width;
      const height = srcTexture.image.height;
      const glFormat = utils.convert(dstTexture.format);
      const glType = utils.convert(dstTexture.type);
      textures.setTexture2D(dstTexture, 0);
      _gl.pixelStorei(37440, dstTexture.flipY);
      _gl.pixelStorei(37441, dstTexture.premultiplyAlpha);
      _gl.pixelStorei(3317, dstTexture.unpackAlignment);
      if (srcTexture.isDataTexture) {
        _gl.texSubImage2D(3553, level, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data);
      } else {
        if (srcTexture.isCompressedTexture) {
          _gl.compressedTexSubImage2D(3553, level, position.x, position.y, srcTexture.mipmaps[0].width, srcTexture.mipmaps[0].height, glFormat, srcTexture.mipmaps[0].data);
        } else {
          _gl.texSubImage2D(3553, level, position.x, position.y, glFormat, glType, srcTexture.image);
        }
      }
      if (level === 0 && dstTexture.generateMipmaps)
        _gl.generateMipmap(3553);
      state.unbindTexture();
    };
    this.copyTextureToTexture3D = function(sourceBox, position, srcTexture, dstTexture, level = 0) {
      if (_this.isWebGL1Renderer) {
        console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
        return;
      }
      const width = sourceBox.max.x - sourceBox.min.x + 1;
      const height = sourceBox.max.y - sourceBox.min.y + 1;
      const depth = sourceBox.max.z - sourceBox.min.z + 1;
      const glFormat = utils.convert(dstTexture.format);
      const glType = utils.convert(dstTexture.type);
      let glTarget;
      if (dstTexture.isData3DTexture) {
        textures.setTexture3D(dstTexture, 0);
        glTarget = 32879;
      } else if (dstTexture.isDataArrayTexture) {
        textures.setTexture2DArray(dstTexture, 0);
        glTarget = 35866;
      } else {
        console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
        return;
      }
      _gl.pixelStorei(37440, dstTexture.flipY);
      _gl.pixelStorei(37441, dstTexture.premultiplyAlpha);
      _gl.pixelStorei(3317, dstTexture.unpackAlignment);
      const unpackRowLen = _gl.getParameter(3314);
      const unpackImageHeight = _gl.getParameter(32878);
      const unpackSkipPixels = _gl.getParameter(3316);
      const unpackSkipRows = _gl.getParameter(3315);
      const unpackSkipImages = _gl.getParameter(32877);
      const image = srcTexture.isCompressedTexture ? srcTexture.mipmaps[0] : srcTexture.image;
      _gl.pixelStorei(3314, image.width);
      _gl.pixelStorei(32878, image.height);
      _gl.pixelStorei(3316, sourceBox.min.x);
      _gl.pixelStorei(3315, sourceBox.min.y);
      _gl.pixelStorei(32877, sourceBox.min.z);
      if (srcTexture.isDataTexture || srcTexture.isData3DTexture) {
        _gl.texSubImage3D(glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, glType, image.data);
      } else {
        if (srcTexture.isCompressedTexture) {
          console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture.");
          _gl.compressedTexSubImage3D(glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, image.data);
        } else {
          _gl.texSubImage3D(glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, glType, image);
        }
      }
      _gl.pixelStorei(3314, unpackRowLen);
      _gl.pixelStorei(32878, unpackImageHeight);
      _gl.pixelStorei(3316, unpackSkipPixels);
      _gl.pixelStorei(3315, unpackSkipRows);
      _gl.pixelStorei(32877, unpackSkipImages);
      if (level === 0 && dstTexture.generateMipmaps)
        _gl.generateMipmap(glTarget);
      state.unbindTexture();
    };
    this.initTexture = function(texture) {
      textures.setTexture2D(texture, 0);
      state.unbindTexture();
    };
    this.resetState = function() {
      _currentActiveCubeFace = 0;
      _currentActiveMipmapLevel = 0;
      _currentRenderTarget = null;
      state.reset();
      bindingStates.reset();
    };
    if (typeof __THREE_DEVTOOLS__ !== "undefined") {
      __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
    }
  }
  WebGLRenderer.prototype.isWebGLRenderer = true;
  var WebGL1Renderer = class extends WebGLRenderer {
  };
  WebGL1Renderer.prototype.isWebGL1Renderer = true;
  var FogExp2 = class _FogExp2 {
    constructor(color, density = 25e-5) {
      this.name = "";
      this.color = new Color(color);
      this.density = density;
    }
    clone() {
      return new _FogExp2(this.color, this.density);
    }
    toJSON() {
      return {
        type: "FogExp2",
        color: this.color.getHex(),
        density: this.density
      };
    }
  };
  FogExp2.prototype.isFogExp2 = true;
  var Fog = class _Fog {
    constructor(color, near = 1, far = 1e3) {
      this.name = "";
      this.color = new Color(color);
      this.near = near;
      this.far = far;
    }
    clone() {
      return new _Fog(this.color, this.near, this.far);
    }
    toJSON() {
      return {
        type: "Fog",
        color: this.color.getHex(),
        near: this.near,
        far: this.far
      };
    }
  };
  Fog.prototype.isFog = true;
  var Scene = class extends Object3D {
    constructor() {
      super();
      this.type = "Scene";
      this.background = null;
      this.environment = null;
      this.fog = null;
      this.overrideMaterial = null;
      this.autoUpdate = true;
      if (typeof __THREE_DEVTOOLS__ !== "undefined") {
        __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
      }
    }
    copy(source, recursive) {
      super.copy(source, recursive);
      if (source.background !== null)
        this.background = source.background.clone();
      if (source.environment !== null)
        this.environment = source.environment.clone();
      if (source.fog !== null)
        this.fog = source.fog.clone();
      if (source.overrideMaterial !== null)
        this.overrideMaterial = source.overrideMaterial.clone();
      this.autoUpdate = source.autoUpdate;
      this.matrixAutoUpdate = source.matrixAutoUpdate;
      return this;
    }
    toJSON(meta) {
      const data = super.toJSON(meta);
      if (this.fog !== null)
        data.object.fog = this.fog.toJSON();
      return data;
    }
  };
  Scene.prototype.isScene = true;
  var InterleavedBuffer = class {
    constructor(array, stride) {
      this.array = array;
      this.stride = stride;
      this.count = array !== void 0 ? array.length / stride : 0;
      this.usage = StaticDrawUsage;
      this.updateRange = { offset: 0, count: -1 };
      this.version = 0;
      this.uuid = generateUUID();
    }
    onUploadCallback() {
    }
    set needsUpdate(value) {
      if (value === true)
        this.version++;
    }
    setUsage(value) {
      this.usage = value;
      return this;
    }
    copy(source) {
      this.array = new source.array.constructor(source.array);
      this.count = source.count;
      this.stride = source.stride;
      this.usage = source.usage;
      return this;
    }
    copyAt(index1, attribute, index2) {
      index1 *= this.stride;
      index2 *= attribute.stride;
      for (let i = 0, l = this.stride; i < l; i++) {
        this.array[index1 + i] = attribute.array[index2 + i];
      }
      return this;
    }
    set(value, offset = 0) {
      this.array.set(value, offset);
      return this;
    }
    clone(data) {
      if (data.arrayBuffers === void 0) {
        data.arrayBuffers = {};
      }
      if (this.array.buffer._uuid === void 0) {
        this.array.buffer._uuid = generateUUID();
      }
      if (data.arrayBuffers[this.array.buffer._uuid] === void 0) {
        data.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer;
      }
      const array = new this.array.constructor(data.arrayBuffers[this.array.buffer._uuid]);
      const ib = new this.constructor(array, this.stride);
      ib.setUsage(this.usage);
      return ib;
    }
    onUpload(callback) {
      this.onUploadCallback = callback;
      return this;
    }
    toJSON(data) {
      if (data.arrayBuffers === void 0) {
        data.arrayBuffers = {};
      }
      if (this.array.buffer._uuid === void 0) {
        this.array.buffer._uuid = generateUUID();
      }
      if (data.arrayBuffers[this.array.buffer._uuid] === void 0) {
        data.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer));
      }
      return {
        uuid: this.uuid,
        buffer: this.array.buffer._uuid,
        type: this.array.constructor.name,
        stride: this.stride
      };
    }
  };
  InterleavedBuffer.prototype.isInterleavedBuffer = true;
  var _vector$6 = /* @__PURE__ */ new Vector3();
  var InterleavedBufferAttribute = class _InterleavedBufferAttribute {
    constructor(interleavedBuffer, itemSize, offset, normalized = false) {
      this.name = "";
      this.data = interleavedBuffer;
      this.itemSize = itemSize;
      this.offset = offset;
      this.normalized = normalized === true;
    }
    get count() {
      return this.data.count;
    }
    get array() {
      return this.data.array;
    }
    set needsUpdate(value) {
      this.data.needsUpdate = value;
    }
    applyMatrix4(m) {
      for (let i = 0, l = this.data.count; i < l; i++) {
        _vector$6.fromBufferAttribute(this, i);
        _vector$6.applyMatrix4(m);
        this.setXYZ(i, _vector$6.x, _vector$6.y, _vector$6.z);
      }
      return this;
    }
    applyNormalMatrix(m) {
      for (let i = 0, l = this.count; i < l; i++) {
        _vector$6.fromBufferAttribute(this, i);
        _vector$6.applyNormalMatrix(m);
        this.setXYZ(i, _vector$6.x, _vector$6.y, _vector$6.z);
      }
      return this;
    }
    transformDirection(m) {
      for (let i = 0, l = this.count; i < l; i++) {
        _vector$6.fromBufferAttribute(this, i);
        _vector$6.transformDirection(m);
        this.setXYZ(i, _vector$6.x, _vector$6.y, _vector$6.z);
      }
      return this;
    }
    setX(index, x) {
      this.data.array[index * this.data.stride + this.offset] = x;
      return this;
    }
    setY(index, y) {
      this.data.array[index * this.data.stride + this.offset + 1] = y;
      return this;
    }
    setZ(index, z) {
      this.data.array[index * this.data.stride + this.offset + 2] = z;
      return this;
    }
    setW(index, w) {
      this.data.array[index * this.data.stride + this.offset + 3] = w;
      return this;
    }
    getX(index) {
      return this.data.array[index * this.data.stride + this.offset];
    }
    getY(index) {
      return this.data.array[index * this.data.stride + this.offset + 1];
    }
    getZ(index) {
      return this.data.array[index * this.data.stride + this.offset + 2];
    }
    getW(index) {
      return this.data.array[index * this.data.stride + this.offset + 3];
    }
    setXY(index, x, y) {
      index = index * this.data.stride + this.offset;
      this.data.array[index + 0] = x;
      this.data.array[index + 1] = y;
      return this;
    }
    setXYZ(index, x, y, z) {
      index = index * this.data.stride + this.offset;
      this.data.array[index + 0] = x;
      this.data.array[index + 1] = y;
      this.data.array[index + 2] = z;
      return this;
    }
    setXYZW(index, x, y, z, w) {
      index = index * this.data.stride + this.offset;
      this.data.array[index + 0] = x;
      this.data.array[index + 1] = y;
      this.data.array[index + 2] = z;
      this.data.array[index + 3] = w;
      return this;
    }
    clone(data) {
      if (data === void 0) {
        console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");
        const array = [];
        for (let i = 0; i < this.count; i++) {
          const index = i * this.data.stride + this.offset;
          for (let j = 0; j < this.itemSize; j++) {
            array.push(this.data.array[index + j]);
          }
        }
        return new BufferAttribute(new this.array.constructor(array), this.itemSize, this.normalized);
      } else {
        if (data.interleavedBuffers === void 0) {
          data.interleavedBuffers = {};
        }
        if (data.interleavedBuffers[this.data.uuid] === void 0) {
          data.interleavedBuffers[this.data.uuid] = this.data.clone(data);
        }
        return new _InterleavedBufferAttribute(data.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
      }
    }
    toJSON(data) {
      if (data === void 0) {
        console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");
        const array = [];
        for (let i = 0; i < this.count; i++) {
          const index = i * this.data.stride + this.offset;
          for (let j = 0; j < this.itemSize; j++) {
            array.push(this.data.array[index + j]);
          }
        }
        return {
          itemSize: this.itemSize,
          type: this.array.constructor.name,
          array,
          normalized: this.normalized
        };
      } else {
        if (data.interleavedBuffers === void 0) {
          data.interleavedBuffers = {};
        }
        if (data.interleavedBuffers[this.data.uuid] === void 0) {
          data.interleavedBuffers[this.data.uuid] = this.data.toJSON(data);
        }
        return {
          isInterleavedBufferAttribute: true,
          itemSize: this.itemSize,
          data: this.data.uuid,
          offset: this.offset,
          normalized: this.normalized
        };
      }
    }
  };
  InterleavedBufferAttribute.prototype.isInterleavedBufferAttribute = true;
  var SpriteMaterial = class extends Material {
    constructor(parameters) {
      super();
      this.type = "SpriteMaterial";
      this.color = new Color(16777215);
      this.map = null;
      this.alphaMap = null;
      this.rotation = 0;
      this.sizeAttenuation = true;
      this.transparent = true;
      this.setValues(parameters);
    }
    copy(source) {
      super.copy(source);
      this.color.copy(source.color);
      this.map = source.map;
      this.alphaMap = source.alphaMap;
      this.rotation = source.rotation;
      this.sizeAttenuation = source.sizeAttenuation;
      return this;
    }
  };
  SpriteMaterial.prototype.isSpriteMaterial = true;
  var _geometry;
  var _intersectPoint = /* @__PURE__ */ new Vector3();
  var _worldScale = /* @__PURE__ */ new Vector3();
  var _mvPosition = /* @__PURE__ */ new Vector3();
  var _alignedPosition = /* @__PURE__ */ new Vector2();
  var _rotatedPosition = /* @__PURE__ */ new Vector2();
  var _viewWorldMatrix = /* @__PURE__ */ new Matrix4();
  var _vA = /* @__PURE__ */ new Vector3();
  var _vB = /* @__PURE__ */ new Vector3();
  var _vC = /* @__PURE__ */ new Vector3();
  var _uvA = /* @__PURE__ */ new Vector2();
  var _uvB = /* @__PURE__ */ new Vector2();
  var _uvC = /* @__PURE__ */ new Vector2();
  var Sprite = class extends Object3D {
    constructor(material) {
      super();
      this.type = "Sprite";
      if (_geometry === void 0) {
        _geometry = new BufferGeometry();
        const float32Array = new Float32Array([
          -0.5,
          -0.5,
          0,
          0,
          0,
          0.5,
          -0.5,
          0,
          1,
          0,
          0.5,
          0.5,
          0,
          1,
          1,
          -0.5,
          0.5,
          0,
          0,
          1
        ]);
        const interleavedBuffer = new InterleavedBuffer(float32Array, 5);
        _geometry.setIndex([0, 1, 2, 0, 2, 3]);
        _geometry.setAttribute("position", new InterleavedBufferAttribute(interleavedBuffer, 3, 0, false));
        _geometry.setAttribute("uv", new InterleavedBufferAttribute(interleavedBuffer, 2, 3, false));
      }
      this.geometry = _geometry;
      this.material = material !== void 0 ? material : new SpriteMaterial();
      this.center = new Vector2(0.5, 0.5);
    }
    raycast(raycaster, intersects2) {
      if (raycaster.camera === null) {
        console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.');
      }
      _worldScale.setFromMatrixScale(this.matrixWorld);
      _viewWorldMatrix.copy(raycaster.camera.matrixWorld);
      this.modelViewMatrix.multiplyMatrices(raycaster.camera.matrixWorldInverse, this.matrixWorld);
      _mvPosition.setFromMatrixPosition(this.modelViewMatrix);
      if (raycaster.camera.isPerspectiveCamera && this.material.sizeAttenuation === false) {
        _worldScale.multiplyScalar(-_mvPosition.z);
      }
      const rotation = this.material.rotation;
      let sin, cos;
      if (rotation !== 0) {
        cos = Math.cos(rotation);
        sin = Math.sin(rotation);
      }
      const center = this.center;
      transformVertex(_vA.set(-0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);
      transformVertex(_vB.set(0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);
      transformVertex(_vC.set(0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);
      _uvA.set(0, 0);
      _uvB.set(1, 0);
      _uvC.set(1, 1);
      let intersect = raycaster.ray.intersectTriangle(_vA, _vB, _vC, false, _intersectPoint);
      if (intersect === null) {
        transformVertex(_vB.set(-0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);
        _uvB.set(0, 1);
        intersect = raycaster.ray.intersectTriangle(_vA, _vC, _vB, false, _intersectPoint);
        if (intersect === null) {
          return;
        }
      }
      const distance = raycaster.ray.origin.distanceTo(_intersectPoint);
      if (distance < raycaster.near || distance > raycaster.far)
        return;
      intersects2.push({
        distance,
        point: _intersectPoint.clone(),
        uv: Triangle.getUV(_intersectPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2()),
        face: null,
        object: this
      });
    }
    copy(source) {
      super.copy(source);
      if (source.center !== void 0)
        this.center.copy(source.center);
      this.material = source.material;
      return this;
    }
  };
  Sprite.prototype.isSprite = true;
  function transformVertex(vertexPosition, mvPosition, center, scale, sin, cos) {
    _alignedPosition.subVectors(vertexPosition, center).addScalar(0.5).multiply(scale);
    if (sin !== void 0) {
      _rotatedPosition.x = cos * _alignedPosition.x - sin * _alignedPosition.y;
      _rotatedPosition.y = sin * _alignedPosition.x + cos * _alignedPosition.y;
    } else {
      _rotatedPosition.copy(_alignedPosition);
    }
    vertexPosition.copy(mvPosition);
    vertexPosition.x += _rotatedPosition.x;
    vertexPosition.y += _rotatedPosition.y;
    vertexPosition.applyMatrix4(_viewWorldMatrix);
  }
  var _basePosition = /* @__PURE__ */ new Vector3();
  var _skinIndex = /* @__PURE__ */ new Vector4();
  var _skinWeight = /* @__PURE__ */ new Vector4();
  var _vector$5 = /* @__PURE__ */ new Vector3();
  var _matrix = /* @__PURE__ */ new Matrix4();
  var SkinnedMesh = class extends Mesh {
    constructor(geometry, material) {
      super(geometry, material);
      this.type = "SkinnedMesh";
      this.bindMode = "attached";
      this.bindMatrix = new Matrix4();
      this.bindMatrixInverse = new Matrix4();
    }
    copy(source) {
      super.copy(source);
      this.bindMode = source.bindMode;
      this.bindMatrix.copy(source.bindMatrix);
      this.bindMatrixInverse.copy(source.bindMatrixInverse);
      this.skeleton = source.skeleton;
      return this;
    }
    bind(skeleton, bindMatrix) {
      this.skeleton = skeleton;
      if (bindMatrix === void 0) {
        this.updateMatrixWorld(true);
        this.skeleton.calculateInverses();
        bindMatrix = this.matrixWorld;
      }
      this.bindMatrix.copy(bindMatrix);
      this.bindMatrixInverse.copy(bindMatrix).invert();
    }
    pose() {
      this.skeleton.pose();
    }
    normalizeSkinWeights() {
      const vector = new Vector4();
      const skinWeight = this.geometry.attributes.skinWeight;
      for (let i = 0, l = skinWeight.count; i < l; i++) {
        vector.fromBufferAttribute(skinWeight, i);
        const scale = 1 / vector.manhattanLength();
        if (scale !== Infinity) {
          vector.multiplyScalar(scale);
        } else {
          vector.set(1, 0, 0, 0);
        }
        skinWeight.setXYZW(i, vector.x, vector.y, vector.z, vector.w);
      }
    }
    updateMatrixWorld(force) {
      super.updateMatrixWorld(force);
      if (this.bindMode === "attached") {
        this.bindMatrixInverse.copy(this.matrixWorld).invert();
      } else if (this.bindMode === "detached") {
        this.bindMatrixInverse.copy(this.bindMatrix).invert();
      } else {
        console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
      }
    }
    boneTransform(index, target) {
      const skeleton = this.skeleton;
      const geometry = this.geometry;
      _skinIndex.fromBufferAttribute(geometry.attributes.skinIndex, index);
      _skinWeight.fromBufferAttribute(geometry.attributes.skinWeight, index);
      _basePosition.copy(target).applyMatrix4(this.bindMatrix);
      target.set(0, 0, 0);
      for (let i = 0; i < 4; i++) {
        const weight = _skinWeight.getComponent(i);
        if (weight !== 0) {
          const boneIndex = _skinIndex.getComponent(i);
          _matrix.multiplyMatrices(skeleton.bones[boneIndex].matrixWorld, skeleton.boneInverses[boneIndex]);
          target.addScaledVector(_vector$5.copy(_basePosition).applyMatrix4(_matrix), weight);
        }
      }
      return target.applyMatrix4(this.bindMatrixInverse);
    }
  };
  SkinnedMesh.prototype.isSkinnedMesh = true;
  var Bone = class extends Object3D {
    constructor() {
      super();
      this.type = "Bone";
    }
  };
  Bone.prototype.isBone = true;
  var DataTexture = class extends Texture {
    constructor(data = null, width = 1, height = 1, format, type, mapping, wrapS, wrapT, magFilter = NearestFilter, minFilter = NearestFilter, anisotropy, encoding) {
      super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
      this.image = { data, width, height };
      this.generateMipmaps = false;
      this.flipY = false;
      this.unpackAlignment = 1;
    }
  };
  DataTexture.prototype.isDataTexture = true;
  var InstancedBufferAttribute = class extends BufferAttribute {
    constructor(array, itemSize, normalized, meshPerAttribute = 1) {
      if (typeof normalized === "number") {
        meshPerAttribute = normalized;
        normalized = false;
        console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.");
      }
      super(array, itemSize, normalized);
      this.meshPerAttribute = meshPerAttribute;
    }
    copy(source) {
      super.copy(source);
      this.meshPerAttribute = source.meshPerAttribute;
      return this;
    }
    toJSON() {
      const data = super.toJSON();
      data.meshPerAttribute = this.meshPerAttribute;
      data.isInstancedBufferAttribute = true;
      return data;
    }
  };
  InstancedBufferAttribute.prototype.isInstancedBufferAttribute = true;
  var _instanceLocalMatrix = /* @__PURE__ */ new Matrix4();
  var _instanceWorldMatrix = /* @__PURE__ */ new Matrix4();
  var _instanceIntersects = [];
  var _mesh = /* @__PURE__ */ new Mesh();
  var InstancedMesh = class extends Mesh {
    constructor(geometry, material, count) {
      super(geometry, material);
      this.instanceMatrix = new InstancedBufferAttribute(new Float32Array(count * 16), 16);
      this.instanceColor = null;
      this.count = count;
      this.frustumCulled = false;
    }
    copy(source) {
      super.copy(source);
      this.instanceMatrix.copy(source.instanceMatrix);
      if (source.instanceColor !== null)
        this.instanceColor = source.instanceColor.clone();
      this.count = source.count;
      return this;
    }
    getColorAt(index, color) {
      color.fromArray(this.instanceColor.array, index * 3);
    }
    getMatrixAt(index, matrix) {
      matrix.fromArray(this.instanceMatrix.array, index * 16);
    }
    raycast(raycaster, intersects2) {
      const matrixWorld = this.matrixWorld;
      const raycastTimes = this.count;
      _mesh.geometry = this.geometry;
      _mesh.material = this.material;
      if (_mesh.material === void 0)
        return;
      for (let instanceId = 0; instanceId < raycastTimes; instanceId++) {
        this.getMatrixAt(instanceId, _instanceLocalMatrix);
        _instanceWorldMatrix.multiplyMatrices(matrixWorld, _instanceLocalMatrix);
        _mesh.matrixWorld = _instanceWorldMatrix;
        _mesh.raycast(raycaster, _instanceIntersects);
        for (let i = 0, l = _instanceIntersects.length; i < l; i++) {
          const intersect = _instanceIntersects[i];
          intersect.instanceId = instanceId;
          intersect.object = this;
          intersects2.push(intersect);
        }
        _instanceIntersects.length = 0;
      }
    }
    setColorAt(index, color) {
      if (this.instanceColor === null) {
        this.instanceColor = new InstancedBufferAttribute(new Float32Array(this.instanceMatrix.count * 3), 3);
      }
      color.toArray(this.instanceColor.array, index * 3);
    }
    setMatrixAt(index, matrix) {
      matrix.toArray(this.instanceMatrix.array, index * 16);
    }
    updateMorphTargets() {
    }
    dispose() {
      this.dispatchEvent({ type: "dispose" });
    }
  };
  InstancedMesh.prototype.isInstancedMesh = true;
  var LineBasicMaterial = class extends Material {
    constructor(parameters) {
      super();
      this.type = "LineBasicMaterial";
      this.color = new Color(16777215);
      this.linewidth = 1;
      this.linecap = "round";
      this.linejoin = "round";
      this.setValues(parameters);
    }
    copy(source) {
      super.copy(source);
      this.color.copy(source.color);
      this.linewidth = source.linewidth;
      this.linecap = source.linecap;
      this.linejoin = source.linejoin;
      return this;
    }
  };
  LineBasicMaterial.prototype.isLineBasicMaterial = true;
  var _start$1 = /* @__PURE__ */ new Vector3();
  var _end$1 = /* @__PURE__ */ new Vector3();
  var _inverseMatrix$1 = /* @__PURE__ */ new Matrix4();
  var _ray$1 = /* @__PURE__ */ new Ray();
  var _sphere$1 = /* @__PURE__ */ new Sphere();
  var Line = class extends Object3D {
    constructor(geometry = new BufferGeometry(), material = new LineBasicMaterial()) {
      super();
      this.type = "Line";
      this.geometry = geometry;
      this.material = material;
      this.updateMorphTargets();
    }
    copy(source) {
      super.copy(source);
      this.material = source.material;
      this.geometry = source.geometry;
      return this;
    }
    computeLineDistances() {
      const geometry = this.geometry;
      if (geometry.isBufferGeometry) {
        if (geometry.index === null) {
          const positionAttribute = geometry.attributes.position;
          const lineDistances = [0];
          for (let i = 1, l = positionAttribute.count; i < l; i++) {
            _start$1.fromBufferAttribute(positionAttribute, i - 1);
            _end$1.fromBufferAttribute(positionAttribute, i);
            lineDistances[i] = lineDistances[i - 1];
            lineDistances[i] += _start$1.distanceTo(_end$1);
          }
          geometry.setAttribute("lineDistance", new Float32BufferAttribute(lineDistances, 1));
        } else {
          console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
        }
      } else if (geometry.isGeometry) {
        console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
      }
      return this;
    }
    raycast(raycaster, intersects2) {
      const geometry = this.geometry;
      const matrixWorld = this.matrixWorld;
      const threshold = raycaster.params.Line.threshold;
      const drawRange = geometry.drawRange;
      if (geometry.boundingSphere === null)
        geometry.computeBoundingSphere();
      _sphere$1.copy(geometry.boundingSphere);
      _sphere$1.applyMatrix4(matrixWorld);
      _sphere$1.radius += threshold;
      if (raycaster.ray.intersectsSphere(_sphere$1) === false)
        return;
      _inverseMatrix$1.copy(matrixWorld).invert();
      _ray$1.copy(raycaster.ray).applyMatrix4(_inverseMatrix$1);
      const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
      const localThresholdSq = localThreshold * localThreshold;
      const vStart = new Vector3();
      const vEnd = new Vector3();
      const interSegment = new Vector3();
      const interRay = new Vector3();
      const step = this.isLineSegments ? 2 : 1;
      if (geometry.isBufferGeometry) {
        const index = geometry.index;
        const attributes = geometry.attributes;
        const positionAttribute = attributes.position;
        if (index !== null) {
          const start2 = Math.max(0, drawRange.start);
          const end = Math.min(index.count, drawRange.start + drawRange.count);
          for (let i = start2, l = end - 1; i < l; i += step) {
            const a = index.getX(i);
            const b = index.getX(i + 1);
            vStart.fromBufferAttribute(positionAttribute, a);
            vEnd.fromBufferAttribute(positionAttribute, b);
            const distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
            if (distSq > localThresholdSq)
              continue;
            interRay.applyMatrix4(this.matrixWorld);
            const distance = raycaster.ray.origin.distanceTo(interRay);
            if (distance < raycaster.near || distance > raycaster.far)
              continue;
            intersects2.push({
              distance,
              // What do we want? intersection point on the ray or on the segment??
              // point: raycaster.ray.at( distance ),
              point: interSegment.clone().applyMatrix4(this.matrixWorld),
              index: i,
              face: null,
              faceIndex: null,
              object: this
            });
          }
        } else {
          const start2 = Math.max(0, drawRange.start);
          const end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);
          for (let i = start2, l = end - 1; i < l; i += step) {
            vStart.fromBufferAttribute(positionAttribute, i);
            vEnd.fromBufferAttribute(positionAttribute, i + 1);
            const distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
            if (distSq > localThresholdSq)
              continue;
            interRay.applyMatrix4(this.matrixWorld);
            const distance = raycaster.ray.origin.distanceTo(interRay);
            if (distance < raycaster.near || distance > raycaster.far)
              continue;
            intersects2.push({
              distance,
              // What do we want? intersection point on the ray or on the segment??
              // point: raycaster.ray.at( distance ),
              point: interSegment.clone().applyMatrix4(this.matrixWorld),
              index: i,
              face: null,
              faceIndex: null,
              object: this
            });
          }
        }
      } else if (geometry.isGeometry) {
        console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
      }
    }
    updateMorphTargets() {
      const geometry = this.geometry;
      if (geometry.isBufferGeometry) {
        const morphAttributes = geometry.morphAttributes;
        const keys = Object.keys(morphAttributes);
        if (keys.length > 0) {
          const morphAttribute = morphAttributes[keys[0]];
          if (morphAttribute !== void 0) {
            this.morphTargetInfluences = [];
            this.morphTargetDictionary = {};
            for (let m = 0, ml = morphAttribute.length; m < ml; m++) {
              const name = morphAttribute[m].name || String(m);
              this.morphTargetInfluences.push(0);
              this.morphTargetDictionary[name] = m;
            }
          }
        }
      } else {
        const morphTargets = geometry.morphTargets;
        if (morphTargets !== void 0 && morphTargets.length > 0) {
          console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.");
        }
      }
    }
  };
  Line.prototype.isLine = true;
  var _start = /* @__PURE__ */ new Vector3();
  var _end = /* @__PURE__ */ new Vector3();
  var LineSegments = class extends Line {
    constructor(geometry, material) {
      super(geometry, material);
      this.type = "LineSegments";
    }
    computeLineDistances() {
      const geometry = this.geometry;
      if (geometry.isBufferGeometry) {
        if (geometry.index === null) {
          const positionAttribute = geometry.attributes.position;
          const lineDistances = [];
          for (let i = 0, l = positionAttribute.count; i < l; i += 2) {
            _start.fromBufferAttribute(positionAttribute, i);
            _end.fromBufferAttribute(positionAttribute, i + 1);
            lineDistances[i] = i === 0 ? 0 : lineDistances[i - 1];
            lineDistances[i + 1] = lineDistances[i] + _start.distanceTo(_end);
          }
          geometry.setAttribute("lineDistance", new Float32BufferAttribute(lineDistances, 1));
        } else {
          console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
        }
      } else if (geometry.isGeometry) {
        console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
      }
      return this;
    }
  };
  LineSegments.prototype.isLineSegments = true;
  var LineLoop = class extends Line {
    constructor(geometry, material) {
      super(geometry, material);
      this.type = "LineLoop";
    }
  };
  LineLoop.prototype.isLineLoop = true;
  var PointsMaterial = class extends Material {
    constructor(parameters) {
      super();
      this.type = "PointsMaterial";
      this.color = new Color(16777215);
      this.map = null;
      this.alphaMap = null;
      this.size = 1;
      this.sizeAttenuation = true;
      this.setValues(parameters);
    }
    copy(source) {
      super.copy(source);
      this.color.copy(source.color);
      this.map = source.map;
      this.alphaMap = source.alphaMap;
      this.size = source.size;
      this.sizeAttenuation = source.sizeAttenuation;
      return this;
    }
  };
  PointsMaterial.prototype.isPointsMaterial = true;
  var _inverseMatrix = /* @__PURE__ */ new Matrix4();
  var _ray = /* @__PURE__ */ new Ray();
  var _sphere = /* @__PURE__ */ new Sphere();
  var _position$2 = /* @__PURE__ */ new Vector3();
  var Points = class extends Object3D {
    constructor(geometry = new BufferGeometry(), material = new PointsMaterial()) {
      super();
      this.type = "Points";
      this.geometry = geometry;
      this.material = material;
      this.updateMorphTargets();
    }
    copy(source) {
      super.copy(source);
      this.material = source.material;
      this.geometry = source.geometry;
      return this;
    }
    raycast(raycaster, intersects2) {
      const geometry = this.geometry;
      const matrixWorld = this.matrixWorld;
      const threshold = raycaster.params.Points.threshold;
      const drawRange = geometry.drawRange;
      if (geometry.boundingSphere === null)
        geometry.computeBoundingSphere();
      _sphere.copy(geometry.boundingSphere);
      _sphere.applyMatrix4(matrixWorld);
      _sphere.radius += threshold;
      if (raycaster.ray.intersectsSphere(_sphere) === false)
        return;
      _inverseMatrix.copy(matrixWorld).invert();
      _ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix);
      const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
      const localThresholdSq = localThreshold * localThreshold;
      if (geometry.isBufferGeometry) {
        const index = geometry.index;
        const attributes = geometry.attributes;
        const positionAttribute = attributes.position;
        if (index !== null) {
          const start2 = Math.max(0, drawRange.start);
          const end = Math.min(index.count, drawRange.start + drawRange.count);
          for (let i = start2, il = end; i < il; i++) {
            const a = index.getX(i);
            _position$2.fromBufferAttribute(positionAttribute, a);
            testPoint(_position$2, a, localThresholdSq, matrixWorld, raycaster, intersects2, this);
          }
        } else {
          const start2 = Math.max(0, drawRange.start);
          const end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);
          for (let i = start2, l = end; i < l; i++) {
            _position$2.fromBufferAttribute(positionAttribute, i);
            testPoint(_position$2, i, localThresholdSq, matrixWorld, raycaster, intersects2, this);
          }
        }
      } else {
        console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
      }
    }
    updateMorphTargets() {
      const geometry = this.geometry;
      if (geometry.isBufferGeometry) {
        const morphAttributes = geometry.morphAttributes;
        const keys = Object.keys(morphAttributes);
        if (keys.length > 0) {
          const morphAttribute = morphAttributes[keys[0]];
          if (morphAttribute !== void 0) {
            this.morphTargetInfluences = [];
            this.morphTargetDictionary = {};
            for (let m = 0, ml = morphAttribute.length; m < ml; m++) {
              const name = morphAttribute[m].name || String(m);
              this.morphTargetInfluences.push(0);
              this.morphTargetDictionary[name] = m;
            }
          }
        }
      } else {
        const morphTargets = geometry.morphTargets;
        if (morphTargets !== void 0 && morphTargets.length > 0) {
          console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.");
        }
      }
    }
  };
  Points.prototype.isPoints = true;
  function testPoint(point, index, localThresholdSq, matrixWorld, raycaster, intersects2, object) {
    const rayPointDistanceSq = _ray.distanceSqToPoint(point);
    if (rayPointDistanceSq < localThresholdSq) {
      const intersectPoint = new Vector3();
      _ray.closestPointToPoint(point, intersectPoint);
      intersectPoint.applyMatrix4(matrixWorld);
      const distance = raycaster.ray.origin.distanceTo(intersectPoint);
      if (distance < raycaster.near || distance > raycaster.far)
        return;
      intersects2.push({
        distance,
        distanceToRay: Math.sqrt(rayPointDistanceSq),
        point: intersectPoint,
        index,
        face: null,
        object
      });
    }
  }
  var VideoTexture = class extends Texture {
    constructor(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
      super(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
      this.minFilter = minFilter !== void 0 ? minFilter : LinearFilter;
      this.magFilter = magFilter !== void 0 ? magFilter : LinearFilter;
      this.generateMipmaps = false;
      const scope = this;
      function updateVideo() {
        scope.needsUpdate = true;
        video.requestVideoFrameCallback(updateVideo);
      }
      if ("requestVideoFrameCallback" in video) {
        video.requestVideoFrameCallback(updateVideo);
      }
    }
    clone() {
      return new this.constructor(this.image).copy(this);
    }
    update() {
      const video = this.image;
      const hasVideoFrameCallback = "requestVideoFrameCallback" in video;
      if (hasVideoFrameCallback === false && video.readyState >= video.HAVE_CURRENT_DATA) {
        this.needsUpdate = true;
      }
    }
  };
  VideoTexture.prototype.isVideoTexture = true;
  var FramebufferTexture = class extends Texture {
    constructor(width, height, format) {
      super({ width, height });
      this.format = format;
      this.magFilter = NearestFilter;
      this.minFilter = NearestFilter;
      this.generateMipmaps = false;
      this.needsUpdate = true;
    }
  };
  FramebufferTexture.prototype.isFramebufferTexture = true;
  var CompressedTexture = class extends Texture {
    constructor(mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
      super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
      this.image = { width, height };
      this.mipmaps = mipmaps;
      this.flipY = false;
      this.generateMipmaps = false;
    }
  };
  CompressedTexture.prototype.isCompressedTexture = true;
  var CanvasTexture = class extends Texture {
    constructor(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
      super(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
      this.needsUpdate = true;
    }
  };
  CanvasTexture.prototype.isCanvasTexture = true;
  var Curve = class {
    constructor() {
      this.type = "Curve";
      this.arcLengthDivisions = 200;
    }
    // Virtual base class method to overwrite and implement in subclasses
    //	- t [0 .. 1]
    getPoint() {
      console.warn("THREE.Curve: .getPoint() not implemented.");
      return null;
    }
    // Get point at relative position in curve according to arc length
    // - u [0 .. 1]
    getPointAt(u, optionalTarget) {
      const t = this.getUtoTmapping(u);
      return this.getPoint(t, optionalTarget);
    }
    // Get sequence of points using getPoint( t )
    getPoints(divisions = 5) {
      const points = [];
      for (let d = 0; d <= divisions; d++) {
        points.push(this.getPoint(d / divisions));
      }
      return points;
    }
    // Get sequence of points using getPointAt( u )
    getSpacedPoints(divisions = 5) {
      const points = [];
      for (let d = 0; d <= divisions; d++) {
        points.push(this.getPointAt(d / divisions));
      }
      return points;
    }
    // Get total curve arc length
    getLength() {
      const lengths = this.getLengths();
      return lengths[lengths.length - 1];
    }
    // Get list of cumulative segment lengths
    getLengths(divisions = this.arcLengthDivisions) {
      if (this.cacheArcLengths && this.cacheArcLengths.length === divisions + 1 && !this.needsUpdate) {
        return this.cacheArcLengths;
      }
      this.needsUpdate = false;
      const cache = [];
      let current, last = this.getPoint(0);
      let sum = 0;
      cache.push(0);
      for (let p = 1; p <= divisions; p++) {
        current = this.getPoint(p / divisions);
        sum += current.distanceTo(last);
        cache.push(sum);
        last = current;
      }
      this.cacheArcLengths = cache;
      return cache;
    }
    updateArcLengths() {
      this.needsUpdate = true;
      this.getLengths();
    }
    // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant
    getUtoTmapping(u, distance) {
      const arcLengths = this.getLengths();
      let i = 0;
      const il = arcLengths.length;
      let targetArcLength;
      if (distance) {
        targetArcLength = distance;
      } else {
        targetArcLength = u * arcLengths[il - 1];
      }
      let low = 0, high = il - 1, comparison;
      while (low <= high) {
        i = Math.floor(low + (high - low) / 2);
        comparison = arcLengths[i] - targetArcLength;
        if (comparison < 0) {
          low = i + 1;
        } else if (comparison > 0) {
          high = i - 1;
        } else {
          high = i;
          break;
        }
      }
      i = high;
      if (arcLengths[i] === targetArcLength) {
        return i / (il - 1);
      }
      const lengthBefore = arcLengths[i];
      const lengthAfter = arcLengths[i + 1];
      const segmentLength = lengthAfter - lengthBefore;
      const segmentFraction = (targetArcLength - lengthBefore) / segmentLength;
      const t = (i + segmentFraction) / (il - 1);
      return t;
    }
    // Returns a unit vector tangent at t
    // In case any sub curve does not implement its tangent derivation,
    // 2 points a small delta apart will be used to find its gradient
    // which seems to give a reasonable approximation
    getTangent(t, optionalTarget) {
      const delta = 1e-4;
      let t1 = t - delta;
      let t2 = t + delta;
      if (t1 < 0)
        t1 = 0;
      if (t2 > 1)
        t2 = 1;
      const pt1 = this.getPoint(t1);
      const pt2 = this.getPoint(t2);
      const tangent = optionalTarget || (pt1.isVector2 ? new Vector2() : new Vector3());
      tangent.copy(pt2).sub(pt1).normalize();
      return tangent;
    }
    getTangentAt(u, optionalTarget) {
      const t = this.getUtoTmapping(u);
      return this.getTangent(t, optionalTarget);
    }
    computeFrenetFrames(segments, closed) {
      const normal = new Vector3();
      const tangents = [];
      const normals = [];
      const binormals = [];
      const vec = new Vector3();
      const mat = new Matrix4();
      for (let i = 0; i <= segments; i++) {
        const u = i / segments;
        tangents[i] = this.getTangentAt(u, new Vector3());
      }
      normals[0] = new Vector3();
      binormals[0] = new Vector3();
      let min = Number.MAX_VALUE;
      const tx = Math.abs(tangents[0].x);
      const ty = Math.abs(tangents[0].y);
      const tz = Math.abs(tangents[0].z);
      if (tx <= min) {
        min = tx;
        normal.set(1, 0, 0);
      }
      if (ty <= min) {
        min = ty;
        normal.set(0, 1, 0);
      }
      if (tz <= min) {
        normal.set(0, 0, 1);
      }
      vec.crossVectors(tangents[0], normal).normalize();
      normals[0].crossVectors(tangents[0], vec);
      binormals[0].crossVectors(tangents[0], normals[0]);
      for (let i = 1; i <= segments; i++) {
        normals[i] = normals[i - 1].clone();
        binormals[i] = binormals[i - 1].clone();
        vec.crossVectors(tangents[i - 1], tangents[i]);
        if (vec.length() > Number.EPSILON) {
          vec.normalize();
          const theta = Math.acos(clamp(tangents[i - 1].dot(tangents[i]), -1, 1));
          normals[i].applyMatrix4(mat.makeRotationAxis(vec, theta));
        }
        binormals[i].crossVectors(tangents[i], normals[i]);
      }
      if (closed === true) {
        let theta = Math.acos(clamp(normals[0].dot(normals[segments]), -1, 1));
        theta /= segments;
        if (tangents[0].dot(vec.crossVectors(normals[0], normals[segments])) > 0) {
          theta = -theta;
        }
        for (let i = 1; i <= segments; i++) {
          normals[i].applyMatrix4(mat.makeRotationAxis(tangents[i], theta * i));
          binormals[i].crossVectors(tangents[i], normals[i]);
        }
      }
      return {
        tangents,
        normals,
        binormals
      };
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(source) {
      this.arcLengthDivisions = source.arcLengthDivisions;
      return this;
    }
    toJSON() {
      const data = {
        metadata: {
          version: 4.5,
          type: "Curve",
          generator: "Curve.toJSON"
        }
      };
      data.arcLengthDivisions = this.arcLengthDivisions;
      data.type = this.type;
      return data;
    }
    fromJSON(json) {
      this.arcLengthDivisions = json.arcLengthDivisions;
      return this;
    }
  };
  var EllipseCurve = class extends Curve {
    constructor(aX = 0, aY = 0, xRadius = 1, yRadius = 1, aStartAngle = 0, aEndAngle = Math.PI * 2, aClockwise = false, aRotation = 0) {
      super();
      this.type = "EllipseCurve";
      this.aX = aX;
      this.aY = aY;
      this.xRadius = xRadius;
      this.yRadius = yRadius;
      this.aStartAngle = aStartAngle;
      this.aEndAngle = aEndAngle;
      this.aClockwise = aClockwise;
      this.aRotation = aRotation;
    }
    getPoint(t, optionalTarget) {
      const point = optionalTarget || new Vector2();
      const twoPi = Math.PI * 2;
      let deltaAngle = this.aEndAngle - this.aStartAngle;
      const samePoints = Math.abs(deltaAngle) < Number.EPSILON;
      while (deltaAngle < 0)
        deltaAngle += twoPi;
      while (deltaAngle > twoPi)
        deltaAngle -= twoPi;
      if (deltaAngle < Number.EPSILON) {
        if (samePoints) {
          deltaAngle = 0;
        } else {
          deltaAngle = twoPi;
        }
      }
      if (this.aClockwise === true && !samePoints) {
        if (deltaAngle === twoPi) {
          deltaAngle = -twoPi;
        } else {
          deltaAngle = deltaAngle - twoPi;
        }
      }
      const angle = this.aStartAngle + t * deltaAngle;
      let x = this.aX + this.xRadius * Math.cos(angle);
      let y = this.aY + this.yRadius * Math.sin(angle);
      if (this.aRotation !== 0) {
        const cos = Math.cos(this.aRotation);
        const sin = Math.sin(this.aRotation);
        const tx = x - this.aX;
        const ty = y - this.aY;
        x = tx * cos - ty * sin + this.aX;
        y = tx * sin + ty * cos + this.aY;
      }
      return point.set(x, y);
    }
    copy(source) {
      super.copy(source);
      this.aX = source.aX;
      this.aY = source.aY;
      this.xRadius = source.xRadius;
      this.yRadius = source.yRadius;
      this.aStartAngle = source.aStartAngle;
      this.aEndAngle = source.aEndAngle;
      this.aClockwise = source.aClockwise;
      this.aRotation = source.aRotation;
      return this;
    }
    toJSON() {
      const data = super.toJSON();
      data.aX = this.aX;
      data.aY = this.aY;
      data.xRadius = this.xRadius;
      data.yRadius = this.yRadius;
      data.aStartAngle = this.aStartAngle;
      data.aEndAngle = this.aEndAngle;
      data.aClockwise = this.aClockwise;
      data.aRotation = this.aRotation;
      return data;
    }
    fromJSON(json) {
      super.fromJSON(json);
      this.aX = json.aX;
      this.aY = json.aY;
      this.xRadius = json.xRadius;
      this.yRadius = json.yRadius;
      this.aStartAngle = json.aStartAngle;
      this.aEndAngle = json.aEndAngle;
      this.aClockwise = json.aClockwise;
      this.aRotation = json.aRotation;
      return this;
    }
  };
  EllipseCurve.prototype.isEllipseCurve = true;
  var ArcCurve = class extends EllipseCurve {
    constructor(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
      super(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
      this.type = "ArcCurve";
    }
  };
  ArcCurve.prototype.isArcCurve = true;
  function CubicPoly() {
    let c0 = 0, c1 = 0, c2 = 0, c3 = 0;
    function init(x0, x1, t0, t1) {
      c0 = x0;
      c1 = t0;
      c2 = -3 * x0 + 3 * x1 - 2 * t0 - t1;
      c3 = 2 * x0 - 2 * x1 + t0 + t1;
    }
    return {
      initCatmullRom: function(x0, x1, x2, x3, tension) {
        init(x1, x2, tension * (x2 - x0), tension * (x3 - x1));
      },
      initNonuniformCatmullRom: function(x0, x1, x2, x3, dt0, dt1, dt2) {
        let t1 = (x1 - x0) / dt0 - (x2 - x0) / (dt0 + dt1) + (x2 - x1) / dt1;
        let t2 = (x2 - x1) / dt1 - (x3 - x1) / (dt1 + dt2) + (x3 - x2) / dt2;
        t1 *= dt1;
        t2 *= dt1;
        init(x1, x2, t1, t2);
      },
      calc: function(t) {
        const t2 = t * t;
        const t3 = t2 * t;
        return c0 + c1 * t + c2 * t2 + c3 * t3;
      }
    };
  }
  var tmp = new Vector3();
  var px = new CubicPoly();
  var py = new CubicPoly();
  var pz = new CubicPoly();
  var CatmullRomCurve3 = class extends Curve {
    constructor(points = [], closed = false, curveType = "centripetal", tension = 0.5) {
      super();
      this.type = "CatmullRomCurve3";
      this.points = points;
      this.closed = closed;
      this.curveType = curveType;
      this.tension = tension;
    }
    getPoint(t, optionalTarget = new Vector3()) {
      const point = optionalTarget;
      const points = this.points;
      const l = points.length;
      const p = (l - (this.closed ? 0 : 1)) * t;
      let intPoint = Math.floor(p);
      let weight = p - intPoint;
      if (this.closed) {
        intPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / l) + 1) * l;
      } else if (weight === 0 && intPoint === l - 1) {
        intPoint = l - 2;
        weight = 1;
      }
      let p0, p3;
      if (this.closed || intPoint > 0) {
        p0 = points[(intPoint - 1) % l];
      } else {
        tmp.subVectors(points[0], points[1]).add(points[0]);
        p0 = tmp;
      }
      const p1 = points[intPoint % l];
      const p2 = points[(intPoint + 1) % l];
      if (this.closed || intPoint + 2 < l) {
        p3 = points[(intPoint + 2) % l];
      } else {
        tmp.subVectors(points[l - 1], points[l - 2]).add(points[l - 1]);
        p3 = tmp;
      }
      if (this.curveType === "centripetal" || this.curveType === "chordal") {
        const pow = this.curveType === "chordal" ? 0.5 : 0.25;
        let dt0 = Math.pow(p0.distanceToSquared(p1), pow);
        let dt1 = Math.pow(p1.distanceToSquared(p2), pow);
        let dt2 = Math.pow(p2.distanceToSquared(p3), pow);
        if (dt1 < 1e-4)
          dt1 = 1;
        if (dt0 < 1e-4)
          dt0 = dt1;
        if (dt2 < 1e-4)
          dt2 = dt1;
        px.initNonuniformCatmullRom(p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2);
        py.initNonuniformCatmullRom(p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2);
        pz.initNonuniformCatmullRom(p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2);
      } else if (this.curveType === "catmullrom") {
        px.initCatmullRom(p0.x, p1.x, p2.x, p3.x, this.tension);
        py.initCatmullRom(p0.y, p1.y, p2.y, p3.y, this.tension);
        pz.initCatmullRom(p0.z, p1.z, p2.z, p3.z, this.tension);
      }
      point.set(
        px.calc(weight),
        py.calc(weight),
        pz.calc(weight)
      );
      return point;
    }
    copy(source) {
      super.copy(source);
      this.points = [];
      for (let i = 0, l = source.points.length; i < l; i++) {
        const point = source.points[i];
        this.points.push(point.clone());
      }
      this.closed = source.closed;
      this.curveType = source.curveType;
      this.tension = source.tension;
      return this;
    }
    toJSON() {
      const data = super.toJSON();
      data.points = [];
      for (let i = 0, l = this.points.length; i < l; i++) {
        const point = this.points[i];
        data.points.push(point.toArray());
      }
      data.closed = this.closed;
      data.curveType = this.curveType;
      data.tension = this.tension;
      return data;
    }
    fromJSON(json) {
      super.fromJSON(json);
      this.points = [];
      for (let i = 0, l = json.points.length; i < l; i++) {
        const point = json.points[i];
        this.points.push(new Vector3().fromArray(point));
      }
      this.closed = json.closed;
      this.curveType = json.curveType;
      this.tension = json.tension;
      return this;
    }
  };
  CatmullRomCurve3.prototype.isCatmullRomCurve3 = true;
  function CatmullRom(t, p0, p1, p2, p3) {
    const v0 = (p2 - p0) * 0.5;
    const v1 = (p3 - p1) * 0.5;
    const t2 = t * t;
    const t3 = t * t2;
    return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
  }
  function QuadraticBezierP0(t, p) {
    const k = 1 - t;
    return k * k * p;
  }
  function QuadraticBezierP1(t, p) {
    return 2 * (1 - t) * t * p;
  }
  function QuadraticBezierP2(t, p) {
    return t * t * p;
  }
  function QuadraticBezier(t, p0, p1, p2) {
    return QuadraticBezierP0(t, p0) + QuadraticBezierP1(t, p1) + QuadraticBezierP2(t, p2);
  }
  function CubicBezierP0(t, p) {
    const k = 1 - t;
    return k * k * k * p;
  }
  function CubicBezierP1(t, p) {
    const k = 1 - t;
    return 3 * k * k * t * p;
  }
  function CubicBezierP2(t, p) {
    return 3 * (1 - t) * t * t * p;
  }
  function CubicBezierP3(t, p) {
    return t * t * t * p;
  }
  function CubicBezier(t, p0, p1, p2, p3) {
    return CubicBezierP0(t, p0) + CubicBezierP1(t, p1) + CubicBezierP2(t, p2) + CubicBezierP3(t, p3);
  }
  var CubicBezierCurve = class extends Curve {
    constructor(v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2(), v3 = new Vector2()) {
      super();
      this.type = "CubicBezierCurve";
      this.v0 = v0;
      this.v1 = v1;
      this.v2 = v2;
      this.v3 = v3;
    }
    getPoint(t, optionalTarget = new Vector2()) {
      const point = optionalTarget;
      const v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;
      point.set(
        CubicBezier(t, v0.x, v1.x, v2.x, v3.x),
        CubicBezier(t, v0.y, v1.y, v2.y, v3.y)
      );
      return point;
    }
    copy(source) {
      super.copy(source);
      this.v0.copy(source.v0);
      this.v1.copy(source.v1);
      this.v2.copy(source.v2);
      this.v3.copy(source.v3);
      return this;
    }
    toJSON() {
      const data = super.toJSON();
      data.v0 = this.v0.toArray();
      data.v1 = this.v1.toArray();
      data.v2 = this.v2.toArray();
      data.v3 = this.v3.toArray();
      return data;
    }
    fromJSON(json) {
      super.fromJSON(json);
      this.v0.fromArray(json.v0);
      this.v1.fromArray(json.v1);
      this.v2.fromArray(json.v2);
      this.v3.fromArray(json.v3);
      return this;
    }
  };
  CubicBezierCurve.prototype.isCubicBezierCurve = true;
  var CubicBezierCurve3 = class extends Curve {
    constructor(v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3(), v3 = new Vector3()) {
      super();
      this.type = "CubicBezierCurve3";
      this.v0 = v0;
      this.v1 = v1;
      this.v2 = v2;
      this.v3 = v3;
    }
    getPoint(t, optionalTarget = new Vector3()) {
      const point = optionalTarget;
      const v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;
      point.set(
        CubicBezier(t, v0.x, v1.x, v2.x, v3.x),
        CubicBezier(t, v0.y, v1.y, v2.y, v3.y),
        CubicBezier(t, v0.z, v1.z, v2.z, v3.z)
      );
      return point;
    }
    copy(source) {
      super.copy(source);
      this.v0.copy(source.v0);
      this.v1.copy(source.v1);
      this.v2.copy(source.v2);
      this.v3.copy(source.v3);
      return this;
    }
    toJSON() {
      const data = super.toJSON();
      data.v0 = this.v0.toArray();
      data.v1 = this.v1.toArray();
      data.v2 = this.v2.toArray();
      data.v3 = this.v3.toArray();
      return data;
    }
    fromJSON(json) {
      super.fromJSON(json);
      this.v0.fromArray(json.v0);
      this.v1.fromArray(json.v1);
      this.v2.fromArray(json.v2);
      this.v3.fromArray(json.v3);
      return this;
    }
  };
  CubicBezierCurve3.prototype.isCubicBezierCurve3 = true;
  var LineCurve = class extends Curve {
    constructor(v1 = new Vector2(), v2 = new Vector2()) {
      super();
      this.type = "LineCurve";
      this.v1 = v1;
      this.v2 = v2;
    }
    getPoint(t, optionalTarget = new Vector2()) {
      const point = optionalTarget;
      if (t === 1) {
        point.copy(this.v2);
      } else {
        point.copy(this.v2).sub(this.v1);
        point.multiplyScalar(t).add(this.v1);
      }
      return point;
    }
    // Line curve is linear, so we can overwrite default getPointAt
    getPointAt(u, optionalTarget) {
      return this.getPoint(u, optionalTarget);
    }
    getTangent(t, optionalTarget) {
      const tangent = optionalTarget || new Vector2();
      tangent.copy(this.v2).sub(this.v1).normalize();
      return tangent;
    }
    copy(source) {
      super.copy(source);
      this.v1.copy(source.v1);
      this.v2.copy(source.v2);
      return this;
    }
    toJSON() {
      const data = super.toJSON();
      data.v1 = this.v1.toArray();
      data.v2 = this.v2.toArray();
      return data;
    }
    fromJSON(json) {
      super.fromJSON(json);
      this.v1.fromArray(json.v1);
      this.v2.fromArray(json.v2);
      return this;
    }
  };
  LineCurve.prototype.isLineCurve = true;
  var LineCurve3 = class extends Curve {
    constructor(v1 = new Vector3(), v2 = new Vector3()) {
      super();
      this.type = "LineCurve3";
      this.isLineCurve3 = true;
      this.v1 = v1;
      this.v2 = v2;
    }
    getPoint(t, optionalTarget = new Vector3()) {
      const point = optionalTarget;
      if (t === 1) {
        point.copy(this.v2);
      } else {
        point.copy(this.v2).sub(this.v1);
        point.multiplyScalar(t).add(this.v1);
      }
      return point;
    }
    // Line curve is linear, so we can overwrite default getPointAt
    getPointAt(u, optionalTarget) {
      return this.getPoint(u, optionalTarget);
    }
    copy(source) {
      super.copy(source);
      this.v1.copy(source.v1);
      this.v2.copy(source.v2);
      return this;
    }
    toJSON() {
      const data = super.toJSON();
      data.v1 = this.v1.toArray();
      data.v2 = this.v2.toArray();
      return data;
    }
    fromJSON(json) {
      super.fromJSON(json);
      this.v1.fromArray(json.v1);
      this.v2.fromArray(json.v2);
      return this;
    }
  };
  var QuadraticBezierCurve = class extends Curve {
    constructor(v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2()) {
      super();
      this.type = "QuadraticBezierCurve";
      this.v0 = v0;
      this.v1 = v1;
      this.v2 = v2;
    }
    getPoint(t, optionalTarget = new Vector2()) {
      const point = optionalTarget;
      const v0 = this.v0, v1 = this.v1, v2 = this.v2;
      point.set(
        QuadraticBezier(t, v0.x, v1.x, v2.x),
        QuadraticBezier(t, v0.y, v1.y, v2.y)
      );
      return point;
    }
    copy(source) {
      super.copy(source);
      this.v0.copy(source.v0);
      this.v1.copy(source.v1);
      this.v2.copy(source.v2);
      return this;
    }
    toJSON() {
      const data = super.toJSON();
      data.v0 = this.v0.toArray();
      data.v1 = this.v1.toArray();
      data.v2 = this.v2.toArray();
      return data;
    }
    fromJSON(json) {
      super.fromJSON(json);
      this.v0.fromArray(json.v0);
      this.v1.fromArray(json.v1);
      this.v2.fromArray(json.v2);
      return this;
    }
  };
  QuadraticBezierCurve.prototype.isQuadraticBezierCurve = true;
  var QuadraticBezierCurve3 = class extends Curve {
    constructor(v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3()) {
      super();
      this.type = "QuadraticBezierCurve3";
      this.v0 = v0;
      this.v1 = v1;
      this.v2 = v2;
    }
    getPoint(t, optionalTarget = new Vector3()) {
      const point = optionalTarget;
      const v0 = this.v0, v1 = this.v1, v2 = this.v2;
      point.set(
        QuadraticBezier(t, v0.x, v1.x, v2.x),
        QuadraticBezier(t, v0.y, v1.y, v2.y),
        QuadraticBezier(t, v0.z, v1.z, v2.z)
      );
      return point;
    }
    copy(source) {
      super.copy(source);
      this.v0.copy(source.v0);
      this.v1.copy(source.v1);
      this.v2.copy(source.v2);
      return this;
    }
    toJSON() {
      const data = super.toJSON();
      data.v0 = this.v0.toArray();
      data.v1 = this.v1.toArray();
      data.v2 = this.v2.toArray();
      return data;
    }
    fromJSON(json) {
      super.fromJSON(json);
      this.v0.fromArray(json.v0);
      this.v1.fromArray(json.v1);
      this.v2.fromArray(json.v2);
      return this;
    }
  };
  QuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = true;
  var SplineCurve = class extends Curve {
    constructor(points = []) {
      super();
      this.type = "SplineCurve";
      this.points = points;
    }
    getPoint(t, optionalTarget = new Vector2()) {
      const point = optionalTarget;
      const points = this.points;
      const p = (points.length - 1) * t;
      const intPoint = Math.floor(p);
      const weight = p - intPoint;
      const p0 = points[intPoint === 0 ? intPoint : intPoint - 1];
      const p1 = points[intPoint];
      const p2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];
      const p3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];
      point.set(
        CatmullRom(weight, p0.x, p1.x, p2.x, p3.x),
        CatmullRom(weight, p0.y, p1.y, p2.y, p3.y)
      );
      return point;
    }
    copy(source) {
      super.copy(source);
      this.points = [];
      for (let i = 0, l = source.points.length; i < l; i++) {
        const point = source.points[i];
        this.points.push(point.clone());
      }
      return this;
    }
    toJSON() {
      const data = super.toJSON();
      data.points = [];
      for (let i = 0, l = this.points.length; i < l; i++) {
        const point = this.points[i];
        data.points.push(point.toArray());
      }
      return data;
    }
    fromJSON(json) {
      super.fromJSON(json);
      this.points = [];
      for (let i = 0, l = json.points.length; i < l; i++) {
        const point = json.points[i];
        this.points.push(new Vector2().fromArray(point));
      }
      return this;
    }
  };
  SplineCurve.prototype.isSplineCurve = true;
  var Curves = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    ArcCurve,
    CatmullRomCurve3,
    CubicBezierCurve,
    CubicBezierCurve3,
    EllipseCurve,
    LineCurve,
    LineCurve3,
    QuadraticBezierCurve,
    QuadraticBezierCurve3,
    SplineCurve
  });
  var CurvePath = class extends Curve {
    constructor() {
      super();
      this.type = "CurvePath";
      this.curves = [];
      this.autoClose = false;
    }
    add(curve) {
      this.curves.push(curve);
    }
    closePath() {
      const startPoint = this.curves[0].getPoint(0);
      const endPoint = this.curves[this.curves.length - 1].getPoint(1);
      if (!startPoint.equals(endPoint)) {
        this.curves.push(new LineCurve(endPoint, startPoint));
      }
    }
    // To get accurate point with reference to
    // entire path distance at time t,
    // following has to be done:
    // 1. Length of each sub path have to be known
    // 2. Locate and identify type of curve
    // 3. Get t for the curve
    // 4. Return curve.getPointAt(t')
    getPoint(t, optionalTarget) {
      const d = t * this.getLength();
      const curveLengths = this.getCurveLengths();
      let i = 0;
      while (i < curveLengths.length) {
        if (curveLengths[i] >= d) {
          const diff = curveLengths[i] - d;
          const curve = this.curves[i];
          const segmentLength = curve.getLength();
          const u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;
          return curve.getPointAt(u, optionalTarget);
        }
        i++;
      }
      return null;
    }
    // We cannot use the default THREE.Curve getPoint() with getLength() because in
    // THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
    // getPoint() depends on getLength
    getLength() {
      const lens = this.getCurveLengths();
      return lens[lens.length - 1];
    }
    // cacheLengths must be recalculated.
    updateArcLengths() {
      this.needsUpdate = true;
      this.cacheLengths = null;
      this.getCurveLengths();
    }
    // Compute lengths and cache them
    // We cannot overwrite getLengths() because UtoT mapping uses it.
    getCurveLengths() {
      if (this.cacheLengths && this.cacheLengths.length === this.curves.length) {
        return this.cacheLengths;
      }
      const lengths = [];
      let sums = 0;
      for (let i = 0, l = this.curves.length; i < l; i++) {
        sums += this.curves[i].getLength();
        lengths.push(sums);
      }
      this.cacheLengths = lengths;
      return lengths;
    }
    getSpacedPoints(divisions = 40) {
      const points = [];
      for (let i = 0; i <= divisions; i++) {
        points.push(this.getPoint(i / divisions));
      }
      if (this.autoClose) {
        points.push(points[0]);
      }
      return points;
    }
    getPoints(divisions = 12) {
      const points = [];
      let last;
      for (let i = 0, curves = this.curves; i < curves.length; i++) {
        const curve = curves[i];
        const resolution = curve.isEllipseCurve ? divisions * 2 : curve.isLineCurve || curve.isLineCurve3 ? 1 : curve.isSplineCurve ? divisions * curve.points.length : divisions;
        const pts = curve.getPoints(resolution);
        for (let j = 0; j < pts.length; j++) {
          const point = pts[j];
          if (last && last.equals(point))
            continue;
          points.push(point);
          last = point;
        }
      }
      if (this.autoClose && points.length > 1 && !points[points.length - 1].equals(points[0])) {
        points.push(points[0]);
      }
      return points;
    }
    copy(source) {
      super.copy(source);
      this.curves = [];
      for (let i = 0, l = source.curves.length; i < l; i++) {
        const curve = source.curves[i];
        this.curves.push(curve.clone());
      }
      this.autoClose = source.autoClose;
      return this;
    }
    toJSON() {
      const data = super.toJSON();
      data.autoClose = this.autoClose;
      data.curves = [];
      for (let i = 0, l = this.curves.length; i < l; i++) {
        const curve = this.curves[i];
        data.curves.push(curve.toJSON());
      }
      return data;
    }
    fromJSON(json) {
      super.fromJSON(json);
      this.autoClose = json.autoClose;
      this.curves = [];
      for (let i = 0, l = json.curves.length; i < l; i++) {
        const curve = json.curves[i];
        this.curves.push(new Curves[curve.type]().fromJSON(curve));
      }
      return this;
    }
  };
  var Path = class extends CurvePath {
    constructor(points) {
      super();
      this.type = "Path";
      this.currentPoint = new Vector2();
      if (points) {
        this.setFromPoints(points);
      }
    }
    setFromPoints(points) {
      this.moveTo(points[0].x, points[0].y);
      for (let i = 1, l = points.length; i < l; i++) {
        this.lineTo(points[i].x, points[i].y);
      }
      return this;
    }
    moveTo(x, y) {
      this.currentPoint.set(x, y);
      return this;
    }
    lineTo(x, y) {
      const curve = new LineCurve(this.currentPoint.clone(), new Vector2(x, y));
      this.curves.push(curve);
      this.currentPoint.set(x, y);
      return this;
    }
    quadraticCurveTo(aCPx, aCPy, aX, aY) {
      const curve = new QuadraticBezierCurve(
        this.currentPoint.clone(),
        new Vector2(aCPx, aCPy),
        new Vector2(aX, aY)
      );
      this.curves.push(curve);
      this.currentPoint.set(aX, aY);
      return this;
    }
    bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
      const curve = new CubicBezierCurve(
        this.currentPoint.clone(),
        new Vector2(aCP1x, aCP1y),
        new Vector2(aCP2x, aCP2y),
        new Vector2(aX, aY)
      );
      this.curves.push(curve);
      this.currentPoint.set(aX, aY);
      return this;
    }
    splineThru(pts) {
      const npts = [this.currentPoint.clone()].concat(pts);
      const curve = new SplineCurve(npts);
      this.curves.push(curve);
      this.currentPoint.copy(pts[pts.length - 1]);
      return this;
    }
    arc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
      const x0 = this.currentPoint.x;
      const y0 = this.currentPoint.y;
      this.absarc(
        aX + x0,
        aY + y0,
        aRadius,
        aStartAngle,
        aEndAngle,
        aClockwise
      );
      return this;
    }
    absarc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
      this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
      return this;
    }
    ellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
      const x0 = this.currentPoint.x;
      const y0 = this.currentPoint.y;
      this.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
      return this;
    }
    absellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
      const curve = new EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
      if (this.curves.length > 0) {
        const firstPoint = curve.getPoint(0);
        if (!firstPoint.equals(this.currentPoint)) {
          this.lineTo(firstPoint.x, firstPoint.y);
        }
      }
      this.curves.push(curve);
      const lastPoint = curve.getPoint(1);
      this.currentPoint.copy(lastPoint);
      return this;
    }
    copy(source) {
      super.copy(source);
      this.currentPoint.copy(source.currentPoint);
      return this;
    }
    toJSON() {
      const data = super.toJSON();
      data.currentPoint = this.currentPoint.toArray();
      return data;
    }
    fromJSON(json) {
      super.fromJSON(json);
      this.currentPoint.fromArray(json.currentPoint);
      return this;
    }
  };
  var CircleGeometry = class _CircleGeometry extends BufferGeometry {
    constructor(radius = 1, segments = 8, thetaStart = 0, thetaLength = Math.PI * 2) {
      super();
      this.type = "CircleGeometry";
      this.parameters = {
        radius,
        segments,
        thetaStart,
        thetaLength
      };
      segments = Math.max(3, segments);
      const indices = [];
      const vertices = [];
      const normals = [];
      const uvs = [];
      const vertex2 = new Vector3();
      const uv = new Vector2();
      vertices.push(0, 0, 0);
      normals.push(0, 0, 1);
      uvs.push(0.5, 0.5);
      for (let s = 0, i = 3; s <= segments; s++, i += 3) {
        const segment = thetaStart + s / segments * thetaLength;
        vertex2.x = radius * Math.cos(segment);
        vertex2.y = radius * Math.sin(segment);
        vertices.push(vertex2.x, vertex2.y, vertex2.z);
        normals.push(0, 0, 1);
        uv.x = (vertices[i] / radius + 1) / 2;
        uv.y = (vertices[i + 1] / radius + 1) / 2;
        uvs.push(uv.x, uv.y);
      }
      for (let i = 1; i <= segments; i++) {
        indices.push(i, i + 1, 0);
      }
      this.setIndex(indices);
      this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
      this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
      this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    }
    static fromJSON(data) {
      return new _CircleGeometry(data.radius, data.segments, data.thetaStart, data.thetaLength);
    }
  };
  var _v0 = new Vector3();
  var _v1$1 = new Vector3();
  var _normal = new Vector3();
  var _triangle = new Triangle();
  var Shape = class extends Path {
    constructor(points) {
      super(points);
      this.uuid = generateUUID();
      this.type = "Shape";
      this.holes = [];
    }
    getPointsHoles(divisions) {
      const holesPts = [];
      for (let i = 0, l = this.holes.length; i < l; i++) {
        holesPts[i] = this.holes[i].getPoints(divisions);
      }
      return holesPts;
    }
    // get points of shape and holes (keypoints based on segments parameter)
    extractPoints(divisions) {
      return {
        shape: this.getPoints(divisions),
        holes: this.getPointsHoles(divisions)
      };
    }
    copy(source) {
      super.copy(source);
      this.holes = [];
      for (let i = 0, l = source.holes.length; i < l; i++) {
        const hole = source.holes[i];
        this.holes.push(hole.clone());
      }
      return this;
    }
    toJSON() {
      const data = super.toJSON();
      data.uuid = this.uuid;
      data.holes = [];
      for (let i = 0, l = this.holes.length; i < l; i++) {
        const hole = this.holes[i];
        data.holes.push(hole.toJSON());
      }
      return data;
    }
    fromJSON(json) {
      super.fromJSON(json);
      this.uuid = json.uuid;
      this.holes = [];
      for (let i = 0, l = json.holes.length; i < l; i++) {
        const hole = json.holes[i];
        this.holes.push(new Path().fromJSON(hole));
      }
      return this;
    }
  };
  var Earcut = {
    triangulate: function(data, holeIndices, dim = 2) {
      const hasHoles = holeIndices && holeIndices.length;
      const outerLen = hasHoles ? holeIndices[0] * dim : data.length;
      let outerNode = linkedList(data, 0, outerLen, dim, true);
      const triangles = [];
      if (!outerNode || outerNode.next === outerNode.prev)
        return triangles;
      let minX, minY, maxX, maxY, x, y, invSize;
      if (hasHoles)
        outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
      if (data.length > 80 * dim) {
        minX = maxX = data[0];
        minY = maxY = data[1];
        for (let i = dim; i < outerLen; i += dim) {
          x = data[i];
          y = data[i + 1];
          if (x < minX)
            minX = x;
          if (y < minY)
            minY = y;
          if (x > maxX)
            maxX = x;
          if (y > maxY)
            maxY = y;
        }
        invSize = Math.max(maxX - minX, maxY - minY);
        invSize = invSize !== 0 ? 1 / invSize : 0;
      }
      earcutLinked(outerNode, triangles, dim, minX, minY, invSize);
      return triangles;
    }
  };
  function linkedList(data, start2, end, dim, clockwise) {
    let i, last;
    if (clockwise === signedArea(data, start2, end, dim) > 0) {
      for (i = start2; i < end; i += dim)
        last = insertNode(i, data[i], data[i + 1], last);
    } else {
      for (i = end - dim; i >= start2; i -= dim)
        last = insertNode(i, data[i], data[i + 1], last);
    }
    if (last && equals(last, last.next)) {
      removeNode(last);
      last = last.next;
    }
    return last;
  }
  function filterPoints(start2, end) {
    if (!start2)
      return start2;
    if (!end)
      end = start2;
    let p = start2, again;
    do {
      again = false;
      if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
        removeNode(p);
        p = end = p.prev;
        if (p === p.next)
          break;
        again = true;
      } else {
        p = p.next;
      }
    } while (again || p !== end);
    return end;
  }
  function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
    if (!ear)
      return;
    if (!pass && invSize)
      indexCurve(ear, minX, minY, invSize);
    let stop = ear, prev, next;
    while (ear.prev !== ear.next) {
      prev = ear.prev;
      next = ear.next;
      if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
        triangles.push(prev.i / dim);
        triangles.push(ear.i / dim);
        triangles.push(next.i / dim);
        removeNode(ear);
        ear = next.next;
        stop = next.next;
        continue;
      }
      ear = next;
      if (ear === stop) {
        if (!pass) {
          earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
        } else if (pass === 1) {
          ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
          earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
        } else if (pass === 2) {
          splitEarcut(ear, triangles, dim, minX, minY, invSize);
        }
        break;
      }
    }
  }
  function isEar(ear) {
    const a = ear.prev, b = ear, c = ear.next;
    if (area(a, b, c) >= 0)
      return false;
    let p = ear.next.next;
    while (p !== ear.prev) {
      if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0)
        return false;
      p = p.next;
    }
    return true;
  }
  function isEarHashed(ear, minX, minY, invSize) {
    const a = ear.prev, b = ear, c = ear.next;
    if (area(a, b, c) >= 0)
      return false;
    const minTX = a.x < b.x ? a.x < c.x ? a.x : c.x : b.x < c.x ? b.x : c.x, minTY = a.y < b.y ? a.y < c.y ? a.y : c.y : b.y < c.y ? b.y : c.y, maxTX = a.x > b.x ? a.x > c.x ? a.x : c.x : b.x > c.x ? b.x : c.x, maxTY = a.y > b.y ? a.y > c.y ? a.y : c.y : b.y > c.y ? b.y : c.y;
    const minZ = zOrder(minTX, minTY, minX, minY, invSize), maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);
    let p = ear.prevZ, n = ear.nextZ;
    while (p && p.z >= minZ && n && n.z <= maxZ) {
      if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0)
        return false;
      p = p.prevZ;
      if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0)
        return false;
      n = n.nextZ;
    }
    while (p && p.z >= minZ) {
      if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0)
        return false;
      p = p.prevZ;
    }
    while (n && n.z <= maxZ) {
      if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0)
        return false;
      n = n.nextZ;
    }
    return true;
  }
  function cureLocalIntersections(start2, triangles, dim) {
    let p = start2;
    do {
      const a = p.prev, b = p.next.next;
      if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
        triangles.push(a.i / dim);
        triangles.push(p.i / dim);
        triangles.push(b.i / dim);
        removeNode(p);
        removeNode(p.next);
        p = start2 = b;
      }
      p = p.next;
    } while (p !== start2);
    return filterPoints(p);
  }
  function splitEarcut(start2, triangles, dim, minX, minY, invSize) {
    let a = start2;
    do {
      let b = a.next.next;
      while (b !== a.prev) {
        if (a.i !== b.i && isValidDiagonal(a, b)) {
          let c = splitPolygon(a, b);
          a = filterPoints(a, a.next);
          c = filterPoints(c, c.next);
          earcutLinked(a, triangles, dim, minX, minY, invSize);
          earcutLinked(c, triangles, dim, minX, minY, invSize);
          return;
        }
        b = b.next;
      }
      a = a.next;
    } while (a !== start2);
  }
  function eliminateHoles(data, holeIndices, outerNode, dim) {
    const queue = [];
    let i, len, start2, end, list;
    for (i = 0, len = holeIndices.length; i < len; i++) {
      start2 = holeIndices[i] * dim;
      end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
      list = linkedList(data, start2, end, dim, false);
      if (list === list.next)
        list.steiner = true;
      queue.push(getLeftmost(list));
    }
    queue.sort(compareX);
    for (i = 0; i < queue.length; i++) {
      eliminateHole(queue[i], outerNode);
      outerNode = filterPoints(outerNode, outerNode.next);
    }
    return outerNode;
  }
  function compareX(a, b) {
    return a.x - b.x;
  }
  function eliminateHole(hole, outerNode) {
    outerNode = findHoleBridge(hole, outerNode);
    if (outerNode) {
      const b = splitPolygon(outerNode, hole);
      filterPoints(outerNode, outerNode.next);
      filterPoints(b, b.next);
    }
  }
  function findHoleBridge(hole, outerNode) {
    let p = outerNode;
    const hx = hole.x;
    const hy = hole.y;
    let qx = -Infinity, m;
    do {
      if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
        const x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
        if (x <= hx && x > qx) {
          qx = x;
          if (x === hx) {
            if (hy === p.y)
              return p;
            if (hy === p.next.y)
              return p.next;
          }
          m = p.x < p.next.x ? p : p.next;
        }
      }
      p = p.next;
    } while (p !== outerNode);
    if (!m)
      return null;
    if (hx === qx)
      return m;
    const stop = m, mx = m.x, my = m.y;
    let tanMin = Infinity, tan;
    p = m;
    do {
      if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
        tan = Math.abs(hy - p.y) / (hx - p.x);
        if (locallyInside(p, hole) && (tan < tanMin || tan === tanMin && (p.x > m.x || p.x === m.x && sectorContainsSector(m, p)))) {
          m = p;
          tanMin = tan;
        }
      }
      p = p.next;
    } while (p !== stop);
    return m;
  }
  function sectorContainsSector(m, p) {
    return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
  }
  function indexCurve(start2, minX, minY, invSize) {
    let p = start2;
    do {
      if (p.z === null)
        p.z = zOrder(p.x, p.y, minX, minY, invSize);
      p.prevZ = p.prev;
      p.nextZ = p.next;
      p = p.next;
    } while (p !== start2);
    p.prevZ.nextZ = null;
    p.prevZ = null;
    sortLinked(p);
  }
  function sortLinked(list) {
    let i, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;
    do {
      p = list;
      list = null;
      tail = null;
      numMerges = 0;
      while (p) {
        numMerges++;
        q = p;
        pSize = 0;
        for (i = 0; i < inSize; i++) {
          pSize++;
          q = q.nextZ;
          if (!q)
            break;
        }
        qSize = inSize;
        while (pSize > 0 || qSize > 0 && q) {
          if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
            e = p;
            p = p.nextZ;
            pSize--;
          } else {
            e = q;
            q = q.nextZ;
            qSize--;
          }
          if (tail)
            tail.nextZ = e;
          else
            list = e;
          e.prevZ = tail;
          tail = e;
        }
        p = q;
      }
      tail.nextZ = null;
      inSize *= 2;
    } while (numMerges > 1);
    return list;
  }
  function zOrder(x, y, minX, minY, invSize) {
    x = 32767 * (x - minX) * invSize;
    y = 32767 * (y - minY) * invSize;
    x = (x | x << 8) & 16711935;
    x = (x | x << 4) & 252645135;
    x = (x | x << 2) & 858993459;
    x = (x | x << 1) & 1431655765;
    y = (y | y << 8) & 16711935;
    y = (y | y << 4) & 252645135;
    y = (y | y << 2) & 858993459;
    y = (y | y << 1) & 1431655765;
    return x | y << 1;
  }
  function getLeftmost(start2) {
    let p = start2, leftmost = start2;
    do {
      if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y)
        leftmost = p;
      p = p.next;
    } while (p !== start2);
    return leftmost;
  }
  function pointInTriangle(ax, ay, bx, by, cx, cy, px2, py2) {
    return (cx - px2) * (ay - py2) - (ax - px2) * (cy - py2) >= 0 && (ax - px2) * (by - py2) - (bx - px2) * (ay - py2) >= 0 && (bx - px2) * (cy - py2) - (cx - px2) * (by - py2) >= 0;
  }
  function isValidDiagonal(a, b) {
    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // doesn't intersect other edges
    (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible
    (area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors
    equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0);
  }
  function area(p, q, r) {
    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
  }
  function equals(p1, p2) {
    return p1.x === p2.x && p1.y === p2.y;
  }
  function intersects(p1, q1, p2, q2) {
    const o1 = sign(area(p1, q1, p2));
    const o2 = sign(area(p1, q1, q2));
    const o3 = sign(area(p2, q2, p1));
    const o4 = sign(area(p2, q2, q1));
    if (o1 !== o2 && o3 !== o4)
      return true;
    if (o1 === 0 && onSegment(p1, p2, q1))
      return true;
    if (o2 === 0 && onSegment(p1, q2, q1))
      return true;
    if (o3 === 0 && onSegment(p2, p1, q2))
      return true;
    if (o4 === 0 && onSegment(p2, q1, q2))
      return true;
    return false;
  }
  function onSegment(p, q, r) {
    return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
  }
  function sign(num) {
    return num > 0 ? 1 : num < 0 ? -1 : 0;
  }
  function intersectsPolygon(a, b) {
    let p = a;
    do {
      if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b))
        return true;
      p = p.next;
    } while (p !== a);
    return false;
  }
  function locallyInside(a, b) {
    return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
  }
  function middleInside(a, b) {
    let p = a, inside = false;
    const px2 = (a.x + b.x) / 2, py2 = (a.y + b.y) / 2;
    do {
      if (p.y > py2 !== p.next.y > py2 && p.next.y !== p.y && px2 < (p.next.x - p.x) * (py2 - p.y) / (p.next.y - p.y) + p.x)
        inside = !inside;
      p = p.next;
    } while (p !== a);
    return inside;
  }
  function splitPolygon(a, b) {
    const a2 = new Node2(a.i, a.x, a.y), b2 = new Node2(b.i, b.x, b.y), an = a.next, bp = b.prev;
    a.next = b;
    b.prev = a;
    a2.next = an;
    an.prev = a2;
    b2.next = a2;
    a2.prev = b2;
    bp.next = b2;
    b2.prev = bp;
    return b2;
  }
  function insertNode(i, x, y, last) {
    const p = new Node2(i, x, y);
    if (!last) {
      p.prev = p;
      p.next = p;
    } else {
      p.next = last.next;
      p.prev = last;
      last.next.prev = p;
      last.next = p;
    }
    return p;
  }
  function removeNode(p) {
    p.next.prev = p.prev;
    p.prev.next = p.next;
    if (p.prevZ)
      p.prevZ.nextZ = p.nextZ;
    if (p.nextZ)
      p.nextZ.prevZ = p.prevZ;
  }
  function Node2(i, x, y) {
    this.i = i;
    this.x = x;
    this.y = y;
    this.prev = null;
    this.next = null;
    this.z = null;
    this.prevZ = null;
    this.nextZ = null;
    this.steiner = false;
  }
  function signedArea(data, start2, end, dim) {
    let sum = 0;
    for (let i = start2, j = end - dim; i < end; i += dim) {
      sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
      j = i;
    }
    return sum;
  }
  var ShapeUtils = class _ShapeUtils {
    // calculate area of the contour polygon
    static area(contour) {
      const n = contour.length;
      let a = 0;
      for (let p = n - 1, q = 0; q < n; p = q++) {
        a += contour[p].x * contour[q].y - contour[q].x * contour[p].y;
      }
      return a * 0.5;
    }
    static isClockWise(pts) {
      return _ShapeUtils.area(pts) < 0;
    }
    static triangulateShape(contour, holes) {
      const vertices = [];
      const holeIndices = [];
      const faces = [];
      removeDupEndPts(contour);
      addContour(vertices, contour);
      let holeIndex = contour.length;
      holes.forEach(removeDupEndPts);
      for (let i = 0; i < holes.length; i++) {
        holeIndices.push(holeIndex);
        holeIndex += holes[i].length;
        addContour(vertices, holes[i]);
      }
      const triangles = Earcut.triangulate(vertices, holeIndices);
      for (let i = 0; i < triangles.length; i += 3) {
        faces.push(triangles.slice(i, i + 3));
      }
      return faces;
    }
  };
  function removeDupEndPts(points) {
    const l = points.length;
    if (l > 2 && points[l - 1].equals(points[0])) {
      points.pop();
    }
  }
  function addContour(vertices, contour) {
    for (let i = 0; i < contour.length; i++) {
      vertices.push(contour[i].x);
      vertices.push(contour[i].y);
    }
  }
  var ExtrudeGeometry = class _ExtrudeGeometry extends BufferGeometry {
    constructor(shapes = new Shape([new Vector2(0.5, 0.5), new Vector2(-0.5, 0.5), new Vector2(-0.5, -0.5), new Vector2(0.5, -0.5)]), options = {}) {
      super();
      this.type = "ExtrudeGeometry";
      this.parameters = {
        shapes,
        options
      };
      shapes = Array.isArray(shapes) ? shapes : [shapes];
      const scope = this;
      const verticesArray = [];
      const uvArray = [];
      for (let i = 0, l = shapes.length; i < l; i++) {
        const shape = shapes[i];
        addShape(shape);
      }
      this.setAttribute("position", new Float32BufferAttribute(verticesArray, 3));
      this.setAttribute("uv", new Float32BufferAttribute(uvArray, 2));
      this.computeVertexNormals();
      function addShape(shape) {
        const placeholder = [];
        const curveSegments = options.curveSegments !== void 0 ? options.curveSegments : 12;
        const steps = options.steps !== void 0 ? options.steps : 1;
        let depth = options.depth !== void 0 ? options.depth : 1;
        let bevelEnabled = options.bevelEnabled !== void 0 ? options.bevelEnabled : true;
        let bevelThickness = options.bevelThickness !== void 0 ? options.bevelThickness : 0.2;
        let bevelSize = options.bevelSize !== void 0 ? options.bevelSize : bevelThickness - 0.1;
        let bevelOffset = options.bevelOffset !== void 0 ? options.bevelOffset : 0;
        let bevelSegments = options.bevelSegments !== void 0 ? options.bevelSegments : 3;
        const extrudePath = options.extrudePath;
        const uvgen = options.UVGenerator !== void 0 ? options.UVGenerator : WorldUVGenerator;
        if (options.amount !== void 0) {
          console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth.");
          depth = options.amount;
        }
        let extrudePts, extrudeByPath = false;
        let splineTube, binormal, normal, position2;
        if (extrudePath) {
          extrudePts = extrudePath.getSpacedPoints(steps);
          extrudeByPath = true;
          bevelEnabled = false;
          splineTube = extrudePath.computeFrenetFrames(steps, false);
          binormal = new Vector3();
          normal = new Vector3();
          position2 = new Vector3();
        }
        if (!bevelEnabled) {
          bevelSegments = 0;
          bevelThickness = 0;
          bevelSize = 0;
          bevelOffset = 0;
        }
        const shapePoints = shape.extractPoints(curveSegments);
        let vertices = shapePoints.shape;
        const holes = shapePoints.holes;
        const reverse = !ShapeUtils.isClockWise(vertices);
        if (reverse) {
          vertices = vertices.reverse();
          for (let h = 0, hl = holes.length; h < hl; h++) {
            const ahole = holes[h];
            if (ShapeUtils.isClockWise(ahole)) {
              holes[h] = ahole.reverse();
            }
          }
        }
        const faces = ShapeUtils.triangulateShape(vertices, holes);
        const contour = vertices;
        for (let h = 0, hl = holes.length; h < hl; h++) {
          const ahole = holes[h];
          vertices = vertices.concat(ahole);
        }
        function scalePt2(pt, vec, size) {
          if (!vec)
            console.error("THREE.ExtrudeGeometry: vec does not exist");
          return vec.clone().multiplyScalar(size).add(pt);
        }
        const vlen = vertices.length, flen = faces.length;
        function getBevelVec(inPt, inPrev, inNext) {
          let v_trans_x, v_trans_y, shrink_by;
          const v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;
          const v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;
          const v_prev_lensq = v_prev_x * v_prev_x + v_prev_y * v_prev_y;
          const collinear0 = v_prev_x * v_next_y - v_prev_y * v_next_x;
          if (Math.abs(collinear0) > Number.EPSILON) {
            const v_prev_len = Math.sqrt(v_prev_lensq);
            const v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y);
            const ptPrevShift_x = inPrev.x - v_prev_y / v_prev_len;
            const ptPrevShift_y = inPrev.y + v_prev_x / v_prev_len;
            const ptNextShift_x = inNext.x - v_next_y / v_next_len;
            const ptNextShift_y = inNext.y + v_next_x / v_next_len;
            const sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y - (ptNextShift_y - ptPrevShift_y) * v_next_x) / (v_prev_x * v_next_y - v_prev_y * v_next_x);
            v_trans_x = ptPrevShift_x + v_prev_x * sf - inPt.x;
            v_trans_y = ptPrevShift_y + v_prev_y * sf - inPt.y;
            const v_trans_lensq = v_trans_x * v_trans_x + v_trans_y * v_trans_y;
            if (v_trans_lensq <= 2) {
              return new Vector2(v_trans_x, v_trans_y);
            } else {
              shrink_by = Math.sqrt(v_trans_lensq / 2);
            }
          } else {
            let direction_eq = false;
            if (v_prev_x > Number.EPSILON) {
              if (v_next_x > Number.EPSILON) {
                direction_eq = true;
              }
            } else {
              if (v_prev_x < -Number.EPSILON) {
                if (v_next_x < -Number.EPSILON) {
                  direction_eq = true;
                }
              } else {
                if (Math.sign(v_prev_y) === Math.sign(v_next_y)) {
                  direction_eq = true;
                }
              }
            }
            if (direction_eq) {
              v_trans_x = -v_prev_y;
              v_trans_y = v_prev_x;
              shrink_by = Math.sqrt(v_prev_lensq);
            } else {
              v_trans_x = v_prev_x;
              v_trans_y = v_prev_y;
              shrink_by = Math.sqrt(v_prev_lensq / 2);
            }
          }
          return new Vector2(v_trans_x / shrink_by, v_trans_y / shrink_by);
        }
        const contourMovements = [];
        for (let i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {
          if (j === il)
            j = 0;
          if (k === il)
            k = 0;
          contourMovements[i] = getBevelVec(contour[i], contour[j], contour[k]);
        }
        const holesMovements = [];
        let oneHoleMovements, verticesMovements = contourMovements.concat();
        for (let h = 0, hl = holes.length; h < hl; h++) {
          const ahole = holes[h];
          oneHoleMovements = [];
          for (let i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {
            if (j === il)
              j = 0;
            if (k === il)
              k = 0;
            oneHoleMovements[i] = getBevelVec(ahole[i], ahole[j], ahole[k]);
          }
          holesMovements.push(oneHoleMovements);
          verticesMovements = verticesMovements.concat(oneHoleMovements);
        }
        for (let b = 0; b < bevelSegments; b++) {
          const t = b / bevelSegments;
          const z = bevelThickness * Math.cos(t * Math.PI / 2);
          const bs2 = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset;
          for (let i = 0, il = contour.length; i < il; i++) {
            const vert = scalePt2(contour[i], contourMovements[i], bs2);
            v(vert.x, vert.y, -z);
          }
          for (let h = 0, hl = holes.length; h < hl; h++) {
            const ahole = holes[h];
            oneHoleMovements = holesMovements[h];
            for (let i = 0, il = ahole.length; i < il; i++) {
              const vert = scalePt2(ahole[i], oneHoleMovements[i], bs2);
              v(vert.x, vert.y, -z);
            }
          }
        }
        const bs = bevelSize + bevelOffset;
        for (let i = 0; i < vlen; i++) {
          const vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];
          if (!extrudeByPath) {
            v(vert.x, vert.y, 0);
          } else {
            normal.copy(splineTube.normals[0]).multiplyScalar(vert.x);
            binormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y);
            position2.copy(extrudePts[0]).add(normal).add(binormal);
            v(position2.x, position2.y, position2.z);
          }
        }
        for (let s = 1; s <= steps; s++) {
          for (let i = 0; i < vlen; i++) {
            const vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];
            if (!extrudeByPath) {
              v(vert.x, vert.y, depth / steps * s);
            } else {
              normal.copy(splineTube.normals[s]).multiplyScalar(vert.x);
              binormal.copy(splineTube.binormals[s]).multiplyScalar(vert.y);
              position2.copy(extrudePts[s]).add(normal).add(binormal);
              v(position2.x, position2.y, position2.z);
            }
          }
        }
        for (let b = bevelSegments - 1; b >= 0; b--) {
          const t = b / bevelSegments;
          const z = bevelThickness * Math.cos(t * Math.PI / 2);
          const bs2 = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset;
          for (let i = 0, il = contour.length; i < il; i++) {
            const vert = scalePt2(contour[i], contourMovements[i], bs2);
            v(vert.x, vert.y, depth + z);
          }
          for (let h = 0, hl = holes.length; h < hl; h++) {
            const ahole = holes[h];
            oneHoleMovements = holesMovements[h];
            for (let i = 0, il = ahole.length; i < il; i++) {
              const vert = scalePt2(ahole[i], oneHoleMovements[i], bs2);
              if (!extrudeByPath) {
                v(vert.x, vert.y, depth + z);
              } else {
                v(vert.x, vert.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + z);
              }
            }
          }
        }
        buildLidFaces();
        buildSideFaces();
        function buildLidFaces() {
          const start2 = verticesArray.length / 3;
          if (bevelEnabled) {
            let layer = 0;
            let offset = vlen * layer;
            for (let i = 0; i < flen; i++) {
              const face = faces[i];
              f3(face[2] + offset, face[1] + offset, face[0] + offset);
            }
            layer = steps + bevelSegments * 2;
            offset = vlen * layer;
            for (let i = 0; i < flen; i++) {
              const face = faces[i];
              f3(face[0] + offset, face[1] + offset, face[2] + offset);
            }
          } else {
            for (let i = 0; i < flen; i++) {
              const face = faces[i];
              f3(face[2], face[1], face[0]);
            }
            for (let i = 0; i < flen; i++) {
              const face = faces[i];
              f3(face[0] + vlen * steps, face[1] + vlen * steps, face[2] + vlen * steps);
            }
          }
          scope.addGroup(start2, verticesArray.length / 3 - start2, 0);
        }
        function buildSideFaces() {
          const start2 = verticesArray.length / 3;
          let layeroffset = 0;
          sidewalls(contour, layeroffset);
          layeroffset += contour.length;
          for (let h = 0, hl = holes.length; h < hl; h++) {
            const ahole = holes[h];
            sidewalls(ahole, layeroffset);
            layeroffset += ahole.length;
          }
          scope.addGroup(start2, verticesArray.length / 3 - start2, 1);
        }
        function sidewalls(contour2, layeroffset) {
          let i = contour2.length;
          while (--i >= 0) {
            const j = i;
            let k = i - 1;
            if (k < 0)
              k = contour2.length - 1;
            for (let s = 0, sl = steps + bevelSegments * 2; s < sl; s++) {
              const slen1 = vlen * s;
              const slen2 = vlen * (s + 1);
              const a = layeroffset + j + slen1, b = layeroffset + k + slen1, c = layeroffset + k + slen2, d = layeroffset + j + slen2;
              f4(a, b, c, d);
            }
          }
        }
        function v(x, y, z) {
          placeholder.push(x);
          placeholder.push(y);
          placeholder.push(z);
        }
        function f3(a, b, c) {
          addVertex(a);
          addVertex(b);
          addVertex(c);
          const nextIndex = verticesArray.length / 3;
          const uvs = uvgen.generateTopUV(scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1);
          addUV(uvs[0]);
          addUV(uvs[1]);
          addUV(uvs[2]);
        }
        function f4(a, b, c, d) {
          addVertex(a);
          addVertex(b);
          addVertex(d);
          addVertex(b);
          addVertex(c);
          addVertex(d);
          const nextIndex = verticesArray.length / 3;
          const uvs = uvgen.generateSideWallUV(scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1);
          addUV(uvs[0]);
          addUV(uvs[1]);
          addUV(uvs[3]);
          addUV(uvs[1]);
          addUV(uvs[2]);
          addUV(uvs[3]);
        }
        function addVertex(index) {
          verticesArray.push(placeholder[index * 3 + 0]);
          verticesArray.push(placeholder[index * 3 + 1]);
          verticesArray.push(placeholder[index * 3 + 2]);
        }
        function addUV(vector2) {
          uvArray.push(vector2.x);
          uvArray.push(vector2.y);
        }
      }
    }
    toJSON() {
      const data = super.toJSON();
      const shapes = this.parameters.shapes;
      const options = this.parameters.options;
      return toJSON$1(shapes, options, data);
    }
    static fromJSON(data, shapes) {
      const geometryShapes = [];
      for (let j = 0, jl = data.shapes.length; j < jl; j++) {
        const shape = shapes[data.shapes[j]];
        geometryShapes.push(shape);
      }
      const extrudePath = data.options.extrudePath;
      if (extrudePath !== void 0) {
        data.options.extrudePath = new Curves[extrudePath.type]().fromJSON(extrudePath);
      }
      return new _ExtrudeGeometry(geometryShapes, data.options);
    }
  };
  var WorldUVGenerator = {
    generateTopUV: function(geometry, vertices, indexA, indexB, indexC) {
      const a_x = vertices[indexA * 3];
      const a_y = vertices[indexA * 3 + 1];
      const b_x = vertices[indexB * 3];
      const b_y = vertices[indexB * 3 + 1];
      const c_x = vertices[indexC * 3];
      const c_y = vertices[indexC * 3 + 1];
      return [
        new Vector2(a_x, a_y),
        new Vector2(b_x, b_y),
        new Vector2(c_x, c_y)
      ];
    },
    generateSideWallUV: function(geometry, vertices, indexA, indexB, indexC, indexD) {
      const a_x = vertices[indexA * 3];
      const a_y = vertices[indexA * 3 + 1];
      const a_z = vertices[indexA * 3 + 2];
      const b_x = vertices[indexB * 3];
      const b_y = vertices[indexB * 3 + 1];
      const b_z = vertices[indexB * 3 + 2];
      const c_x = vertices[indexC * 3];
      const c_y = vertices[indexC * 3 + 1];
      const c_z = vertices[indexC * 3 + 2];
      const d_x = vertices[indexD * 3];
      const d_y = vertices[indexD * 3 + 1];
      const d_z = vertices[indexD * 3 + 2];
      if (Math.abs(a_y - b_y) < Math.abs(a_x - b_x)) {
        return [
          new Vector2(a_x, 1 - a_z),
          new Vector2(b_x, 1 - b_z),
          new Vector2(c_x, 1 - c_z),
          new Vector2(d_x, 1 - d_z)
        ];
      } else {
        return [
          new Vector2(a_y, 1 - a_z),
          new Vector2(b_y, 1 - b_z),
          new Vector2(c_y, 1 - c_z),
          new Vector2(d_y, 1 - d_z)
        ];
      }
    }
  };
  function toJSON$1(shapes, options, data) {
    data.shapes = [];
    if (Array.isArray(shapes)) {
      for (let i = 0, l = shapes.length; i < l; i++) {
        const shape = shapes[i];
        data.shapes.push(shape.uuid);
      }
    } else {
      data.shapes.push(shapes.uuid);
    }
    if (options.extrudePath !== void 0)
      data.options.extrudePath = options.extrudePath.toJSON();
    return data;
  }
  var ShapeGeometry = class _ShapeGeometry extends BufferGeometry {
    constructor(shapes = new Shape([new Vector2(0, 0.5), new Vector2(-0.5, -0.5), new Vector2(0.5, -0.5)]), curveSegments = 12) {
      super();
      this.type = "ShapeGeometry";
      this.parameters = {
        shapes,
        curveSegments
      };
      const indices = [];
      const vertices = [];
      const normals = [];
      const uvs = [];
      let groupStart = 0;
      let groupCount = 0;
      if (Array.isArray(shapes) === false) {
        addShape(shapes);
      } else {
        for (let i = 0; i < shapes.length; i++) {
          addShape(shapes[i]);
          this.addGroup(groupStart, groupCount, i);
          groupStart += groupCount;
          groupCount = 0;
        }
      }
      this.setIndex(indices);
      this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
      this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
      this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
      function addShape(shape) {
        const indexOffset = vertices.length / 3;
        const points = shape.extractPoints(curveSegments);
        let shapeVertices = points.shape;
        const shapeHoles = points.holes;
        if (ShapeUtils.isClockWise(shapeVertices) === false) {
          shapeVertices = shapeVertices.reverse();
        }
        for (let i = 0, l = shapeHoles.length; i < l; i++) {
          const shapeHole = shapeHoles[i];
          if (ShapeUtils.isClockWise(shapeHole) === true) {
            shapeHoles[i] = shapeHole.reverse();
          }
        }
        const faces = ShapeUtils.triangulateShape(shapeVertices, shapeHoles);
        for (let i = 0, l = shapeHoles.length; i < l; i++) {
          const shapeHole = shapeHoles[i];
          shapeVertices = shapeVertices.concat(shapeHole);
        }
        for (let i = 0, l = shapeVertices.length; i < l; i++) {
          const vertex2 = shapeVertices[i];
          vertices.push(vertex2.x, vertex2.y, 0);
          normals.push(0, 0, 1);
          uvs.push(vertex2.x, vertex2.y);
        }
        for (let i = 0, l = faces.length; i < l; i++) {
          const face = faces[i];
          const a = face[0] + indexOffset;
          const b = face[1] + indexOffset;
          const c = face[2] + indexOffset;
          indices.push(a, b, c);
          groupCount += 3;
        }
      }
    }
    toJSON() {
      const data = super.toJSON();
      const shapes = this.parameters.shapes;
      return toJSON(shapes, data);
    }
    static fromJSON(data, shapes) {
      const geometryShapes = [];
      for (let j = 0, jl = data.shapes.length; j < jl; j++) {
        const shape = shapes[data.shapes[j]];
        geometryShapes.push(shape);
      }
      return new _ShapeGeometry(geometryShapes, data.curveSegments);
    }
  };
  function toJSON(shapes, data) {
    data.shapes = [];
    if (Array.isArray(shapes)) {
      for (let i = 0, l = shapes.length; i < l; i++) {
        const shape = shapes[i];
        data.shapes.push(shape.uuid);
      }
    } else {
      data.shapes.push(shapes.uuid);
    }
    return data;
  }
  var ShadowMaterial = class extends Material {
    constructor(parameters) {
      super();
      this.type = "ShadowMaterial";
      this.color = new Color(0);
      this.transparent = true;
      this.setValues(parameters);
    }
    copy(source) {
      super.copy(source);
      this.color.copy(source.color);
      return this;
    }
  };
  ShadowMaterial.prototype.isShadowMaterial = true;
  var RawShaderMaterial = class extends ShaderMaterial {
    constructor(parameters) {
      super(parameters);
      this.type = "RawShaderMaterial";
    }
  };
  RawShaderMaterial.prototype.isRawShaderMaterial = true;
  var MeshStandardMaterial = class extends Material {
    constructor(parameters) {
      super();
      this.defines = { "STANDARD": "" };
      this.type = "MeshStandardMaterial";
      this.color = new Color(16777215);
      this.roughness = 1;
      this.metalness = 0;
      this.map = null;
      this.lightMap = null;
      this.lightMapIntensity = 1;
      this.aoMap = null;
      this.aoMapIntensity = 1;
      this.emissive = new Color(0);
      this.emissiveIntensity = 1;
      this.emissiveMap = null;
      this.bumpMap = null;
      this.bumpScale = 1;
      this.normalMap = null;
      this.normalMapType = TangentSpaceNormalMap;
      this.normalScale = new Vector2(1, 1);
      this.displacementMap = null;
      this.displacementScale = 1;
      this.displacementBias = 0;
      this.roughnessMap = null;
      this.metalnessMap = null;
      this.alphaMap = null;
      this.envMap = null;
      this.envMapIntensity = 1;
      this.wireframe = false;
      this.wireframeLinewidth = 1;
      this.wireframeLinecap = "round";
      this.wireframeLinejoin = "round";
      this.flatShading = false;
      this.setValues(parameters);
    }
    copy(source) {
      super.copy(source);
      this.defines = { "STANDARD": "" };
      this.color.copy(source.color);
      this.roughness = source.roughness;
      this.metalness = source.metalness;
      this.map = source.map;
      this.lightMap = source.lightMap;
      this.lightMapIntensity = source.lightMapIntensity;
      this.aoMap = source.aoMap;
      this.aoMapIntensity = source.aoMapIntensity;
      this.emissive.copy(source.emissive);
      this.emissiveMap = source.emissiveMap;
      this.emissiveIntensity = source.emissiveIntensity;
      this.bumpMap = source.bumpMap;
      this.bumpScale = source.bumpScale;
      this.normalMap = source.normalMap;
      this.normalMapType = source.normalMapType;
      this.normalScale.copy(source.normalScale);
      this.displacementMap = source.displacementMap;
      this.displacementScale = source.displacementScale;
      this.displacementBias = source.displacementBias;
      this.roughnessMap = source.roughnessMap;
      this.metalnessMap = source.metalnessMap;
      this.alphaMap = source.alphaMap;
      this.envMap = source.envMap;
      this.envMapIntensity = source.envMapIntensity;
      this.wireframe = source.wireframe;
      this.wireframeLinewidth = source.wireframeLinewidth;
      this.wireframeLinecap = source.wireframeLinecap;
      this.wireframeLinejoin = source.wireframeLinejoin;
      this.flatShading = source.flatShading;
      return this;
    }
  };
  MeshStandardMaterial.prototype.isMeshStandardMaterial = true;
  var MeshPhysicalMaterial = class extends MeshStandardMaterial {
    constructor(parameters) {
      super();
      this.defines = {
        "STANDARD": "",
        "PHYSICAL": ""
      };
      this.type = "MeshPhysicalMaterial";
      this.clearcoatMap = null;
      this.clearcoatRoughness = 0;
      this.clearcoatRoughnessMap = null;
      this.clearcoatNormalScale = new Vector2(1, 1);
      this.clearcoatNormalMap = null;
      this.ior = 1.5;
      Object.defineProperty(this, "reflectivity", {
        get: function() {
          return clamp(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1);
        },
        set: function(reflectivity) {
          this.ior = (1 + 0.4 * reflectivity) / (1 - 0.4 * reflectivity);
        }
      });
      this.sheenColor = new Color(0);
      this.sheenColorMap = null;
      this.sheenRoughness = 1;
      this.sheenRoughnessMap = null;
      this.transmissionMap = null;
      this.thickness = 0;
      this.thicknessMap = null;
      this.attenuationDistance = 0;
      this.attenuationColor = new Color(1, 1, 1);
      this.specularIntensity = 1;
      this.specularIntensityMap = null;
      this.specularColor = new Color(1, 1, 1);
      this.specularColorMap = null;
      this._sheen = 0;
      this._clearcoat = 0;
      this._transmission = 0;
      this.setValues(parameters);
    }
    get sheen() {
      return this._sheen;
    }
    set sheen(value) {
      if (this._sheen > 0 !== value > 0) {
        this.version++;
      }
      this._sheen = value;
    }
    get clearcoat() {
      return this._clearcoat;
    }
    set clearcoat(value) {
      if (this._clearcoat > 0 !== value > 0) {
        this.version++;
      }
      this._clearcoat = value;
    }
    get transmission() {
      return this._transmission;
    }
    set transmission(value) {
      if (this._transmission > 0 !== value > 0) {
        this.version++;
      }
      this._transmission = value;
    }
    copy(source) {
      super.copy(source);
      this.defines = {
        "STANDARD": "",
        "PHYSICAL": ""
      };
      this.clearcoat = source.clearcoat;
      this.clearcoatMap = source.clearcoatMap;
      this.clearcoatRoughness = source.clearcoatRoughness;
      this.clearcoatRoughnessMap = source.clearcoatRoughnessMap;
      this.clearcoatNormalMap = source.clearcoatNormalMap;
      this.clearcoatNormalScale.copy(source.clearcoatNormalScale);
      this.ior = source.ior;
      this.sheen = source.sheen;
      this.sheenColor.copy(source.sheenColor);
      this.sheenColorMap = source.sheenColorMap;
      this.sheenRoughness = source.sheenRoughness;
      this.sheenRoughnessMap = source.sheenRoughnessMap;
      this.transmission = source.transmission;
      this.transmissionMap = source.transmissionMap;
      this.thickness = source.thickness;
      this.thicknessMap = source.thicknessMap;
      this.attenuationDistance = source.attenuationDistance;
      this.attenuationColor.copy(source.attenuationColor);
      this.specularIntensity = source.specularIntensity;
      this.specularIntensityMap = source.specularIntensityMap;
      this.specularColor.copy(source.specularColor);
      this.specularColorMap = source.specularColorMap;
      return this;
    }
  };
  MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;
  var MeshPhongMaterial = class extends Material {
    constructor(parameters) {
      super();
      this.type = "MeshPhongMaterial";
      this.color = new Color(16777215);
      this.specular = new Color(1118481);
      this.shininess = 30;
      this.map = null;
      this.lightMap = null;
      this.lightMapIntensity = 1;
      this.aoMap = null;
      this.aoMapIntensity = 1;
      this.emissive = new Color(0);
      this.emissiveIntensity = 1;
      this.emissiveMap = null;
      this.bumpMap = null;
      this.bumpScale = 1;
      this.normalMap = null;
      this.normalMapType = TangentSpaceNormalMap;
      this.normalScale = new Vector2(1, 1);
      this.displacementMap = null;
      this.displacementScale = 1;
      this.displacementBias = 0;
      this.specularMap = null;
      this.alphaMap = null;
      this.envMap = null;
      this.combine = MultiplyOperation;
      this.reflectivity = 1;
      this.refractionRatio = 0.98;
      this.wireframe = false;
      this.wireframeLinewidth = 1;
      this.wireframeLinecap = "round";
      this.wireframeLinejoin = "round";
      this.flatShading = false;
      this.setValues(parameters);
    }
    copy(source) {
      super.copy(source);
      this.color.copy(source.color);
      this.specular.copy(source.specular);
      this.shininess = source.shininess;
      this.map = source.map;
      this.lightMap = source.lightMap;
      this.lightMapIntensity = source.lightMapIntensity;
      this.aoMap = source.aoMap;
      this.aoMapIntensity = source.aoMapIntensity;
      this.emissive.copy(source.emissive);
      this.emissiveMap = source.emissiveMap;
      this.emissiveIntensity = source.emissiveIntensity;
      this.bumpMap = source.bumpMap;
      this.bumpScale = source.bumpScale;
      this.normalMap = source.normalMap;
      this.normalMapType = source.normalMapType;
      this.normalScale.copy(source.normalScale);
      this.displacementMap = source.displacementMap;
      this.displacementScale = source.displacementScale;
      this.displacementBias = source.displacementBias;
      this.specularMap = source.specularMap;
      this.alphaMap = source.alphaMap;
      this.envMap = source.envMap;
      this.combine = source.combine;
      this.reflectivity = source.reflectivity;
      this.refractionRatio = source.refractionRatio;
      this.wireframe = source.wireframe;
      this.wireframeLinewidth = source.wireframeLinewidth;
      this.wireframeLinecap = source.wireframeLinecap;
      this.wireframeLinejoin = source.wireframeLinejoin;
      this.flatShading = source.flatShading;
      return this;
    }
  };
  MeshPhongMaterial.prototype.isMeshPhongMaterial = true;
  var MeshToonMaterial = class extends Material {
    constructor(parameters) {
      super();
      this.defines = { "TOON": "" };
      this.type = "MeshToonMaterial";
      this.color = new Color(16777215);
      this.map = null;
      this.gradientMap = null;
      this.lightMap = null;
      this.lightMapIntensity = 1;
      this.aoMap = null;
      this.aoMapIntensity = 1;
      this.emissive = new Color(0);
      this.emissiveIntensity = 1;
      this.emissiveMap = null;
      this.bumpMap = null;
      this.bumpScale = 1;
      this.normalMap = null;
      this.normalMapType = TangentSpaceNormalMap;
      this.normalScale = new Vector2(1, 1);
      this.displacementMap = null;
      this.displacementScale = 1;
      this.displacementBias = 0;
      this.alphaMap = null;
      this.wireframe = false;
      this.wireframeLinewidth = 1;
      this.wireframeLinecap = "round";
      this.wireframeLinejoin = "round";
      this.setValues(parameters);
    }
    copy(source) {
      super.copy(source);
      this.color.copy(source.color);
      this.map = source.map;
      this.gradientMap = source.gradientMap;
      this.lightMap = source.lightMap;
      this.lightMapIntensity = source.lightMapIntensity;
      this.aoMap = source.aoMap;
      this.aoMapIntensity = source.aoMapIntensity;
      this.emissive.copy(source.emissive);
      this.emissiveMap = source.emissiveMap;
      this.emissiveIntensity = source.emissiveIntensity;
      this.bumpMap = source.bumpMap;
      this.bumpScale = source.bumpScale;
      this.normalMap = source.normalMap;
      this.normalMapType = source.normalMapType;
      this.normalScale.copy(source.normalScale);
      this.displacementMap = source.displacementMap;
      this.displacementScale = source.displacementScale;
      this.displacementBias = source.displacementBias;
      this.alphaMap = source.alphaMap;
      this.wireframe = source.wireframe;
      this.wireframeLinewidth = source.wireframeLinewidth;
      this.wireframeLinecap = source.wireframeLinecap;
      this.wireframeLinejoin = source.wireframeLinejoin;
      return this;
    }
  };
  MeshToonMaterial.prototype.isMeshToonMaterial = true;
  var MeshNormalMaterial = class extends Material {
    constructor(parameters) {
      super();
      this.type = "MeshNormalMaterial";
      this.bumpMap = null;
      this.bumpScale = 1;
      this.normalMap = null;
      this.normalMapType = TangentSpaceNormalMap;
      this.normalScale = new Vector2(1, 1);
      this.displacementMap = null;
      this.displacementScale = 1;
      this.displacementBias = 0;
      this.wireframe = false;
      this.wireframeLinewidth = 1;
      this.fog = false;
      this.flatShading = false;
      this.setValues(parameters);
    }
    copy(source) {
      super.copy(source);
      this.bumpMap = source.bumpMap;
      this.bumpScale = source.bumpScale;
      this.normalMap = source.normalMap;
      this.normalMapType = source.normalMapType;
      this.normalScale.copy(source.normalScale);
      this.displacementMap = source.displacementMap;
      this.displacementScale = source.displacementScale;
      this.displacementBias = source.displacementBias;
      this.wireframe = source.wireframe;
      this.wireframeLinewidth = source.wireframeLinewidth;
      this.flatShading = source.flatShading;
      return this;
    }
  };
  MeshNormalMaterial.prototype.isMeshNormalMaterial = true;
  var MeshLambertMaterial = class extends Material {
    constructor(parameters) {
      super();
      this.type = "MeshLambertMaterial";
      this.color = new Color(16777215);
      this.map = null;
      this.lightMap = null;
      this.lightMapIntensity = 1;
      this.aoMap = null;
      this.aoMapIntensity = 1;
      this.emissive = new Color(0);
      this.emissiveIntensity = 1;
      this.emissiveMap = null;
      this.specularMap = null;
      this.alphaMap = null;
      this.envMap = null;
      this.combine = MultiplyOperation;
      this.reflectivity = 1;
      this.refractionRatio = 0.98;
      this.wireframe = false;
      this.wireframeLinewidth = 1;
      this.wireframeLinecap = "round";
      this.wireframeLinejoin = "round";
      this.setValues(parameters);
    }
    copy(source) {
      super.copy(source);
      this.color.copy(source.color);
      this.map = source.map;
      this.lightMap = source.lightMap;
      this.lightMapIntensity = source.lightMapIntensity;
      this.aoMap = source.aoMap;
      this.aoMapIntensity = source.aoMapIntensity;
      this.emissive.copy(source.emissive);
      this.emissiveMap = source.emissiveMap;
      this.emissiveIntensity = source.emissiveIntensity;
      this.specularMap = source.specularMap;
      this.alphaMap = source.alphaMap;
      this.envMap = source.envMap;
      this.combine = source.combine;
      this.reflectivity = source.reflectivity;
      this.refractionRatio = source.refractionRatio;
      this.wireframe = source.wireframe;
      this.wireframeLinewidth = source.wireframeLinewidth;
      this.wireframeLinecap = source.wireframeLinecap;
      this.wireframeLinejoin = source.wireframeLinejoin;
      return this;
    }
  };
  MeshLambertMaterial.prototype.isMeshLambertMaterial = true;
  var MeshMatcapMaterial = class extends Material {
    constructor(parameters) {
      super();
      this.defines = { "MATCAP": "" };
      this.type = "MeshMatcapMaterial";
      this.color = new Color(16777215);
      this.matcap = null;
      this.map = null;
      this.bumpMap = null;
      this.bumpScale = 1;
      this.normalMap = null;
      this.normalMapType = TangentSpaceNormalMap;
      this.normalScale = new Vector2(1, 1);
      this.displacementMap = null;
      this.displacementScale = 1;
      this.displacementBias = 0;
      this.alphaMap = null;
      this.flatShading = false;
      this.setValues(parameters);
    }
    copy(source) {
      super.copy(source);
      this.defines = { "MATCAP": "" };
      this.color.copy(source.color);
      this.matcap = source.matcap;
      this.map = source.map;
      this.bumpMap = source.bumpMap;
      this.bumpScale = source.bumpScale;
      this.normalMap = source.normalMap;
      this.normalMapType = source.normalMapType;
      this.normalScale.copy(source.normalScale);
      this.displacementMap = source.displacementMap;
      this.displacementScale = source.displacementScale;
      this.displacementBias = source.displacementBias;
      this.alphaMap = source.alphaMap;
      this.flatShading = source.flatShading;
      return this;
    }
  };
  MeshMatcapMaterial.prototype.isMeshMatcapMaterial = true;
  var LineDashedMaterial = class extends LineBasicMaterial {
    constructor(parameters) {
      super();
      this.type = "LineDashedMaterial";
      this.scale = 1;
      this.dashSize = 3;
      this.gapSize = 1;
      this.setValues(parameters);
    }
    copy(source) {
      super.copy(source);
      this.scale = source.scale;
      this.dashSize = source.dashSize;
      this.gapSize = source.gapSize;
      return this;
    }
  };
  LineDashedMaterial.prototype.isLineDashedMaterial = true;
  var materialLib = {
    ShadowMaterial,
    SpriteMaterial,
    RawShaderMaterial,
    ShaderMaterial,
    PointsMaterial,
    MeshPhysicalMaterial,
    MeshStandardMaterial,
    MeshPhongMaterial,
    MeshToonMaterial,
    MeshNormalMaterial,
    MeshLambertMaterial,
    MeshDepthMaterial,
    MeshDistanceMaterial,
    MeshBasicMaterial,
    MeshMatcapMaterial,
    LineDashedMaterial,
    LineBasicMaterial,
    Material
  };
  Material.fromType = function(type) {
    return new materialLib[type]();
  };
  var AnimationUtils = {
    // same as Array.prototype.slice, but also works on typed arrays
    arraySlice: function(array, from, to) {
      if (AnimationUtils.isTypedArray(array)) {
        return new array.constructor(array.subarray(from, to !== void 0 ? to : array.length));
      }
      return array.slice(from, to);
    },
    // converts an array to a specific type
    convertArray: function(array, type, forceClone) {
      if (!array || // let 'undefined' and 'null' pass
      !forceClone && array.constructor === type)
        return array;
      if (typeof type.BYTES_PER_ELEMENT === "number") {
        return new type(array);
      }
      return Array.prototype.slice.call(array);
    },
    isTypedArray: function(object) {
      return ArrayBuffer.isView(object) && !(object instanceof DataView);
    },
    // returns an array by which times and values can be sorted
    getKeyframeOrder: function(times) {
      function compareTime(i, j) {
        return times[i] - times[j];
      }
      const n = times.length;
      const result = new Array(n);
      for (let i = 0; i !== n; ++i)
        result[i] = i;
      result.sort(compareTime);
      return result;
    },
    // uses the array previously returned by 'getKeyframeOrder' to sort data
    sortedArray: function(values, stride, order) {
      const nValues = values.length;
      const result = new values.constructor(nValues);
      for (let i = 0, dstOffset = 0; dstOffset !== nValues; ++i) {
        const srcOffset = order[i] * stride;
        for (let j = 0; j !== stride; ++j) {
          result[dstOffset++] = values[srcOffset + j];
        }
      }
      return result;
    },
    // function for parsing AOS keyframe formats
    flattenJSON: function(jsonKeys, times, values, valuePropertyName) {
      let i = 1, key = jsonKeys[0];
      while (key !== void 0 && key[valuePropertyName] === void 0) {
        key = jsonKeys[i++];
      }
      if (key === void 0)
        return;
      let value = key[valuePropertyName];
      if (value === void 0)
        return;
      if (Array.isArray(value)) {
        do {
          value = key[valuePropertyName];
          if (value !== void 0) {
            times.push(key.time);
            values.push.apply(values, value);
          }
          key = jsonKeys[i++];
        } while (key !== void 0);
      } else if (value.toArray !== void 0) {
        do {
          value = key[valuePropertyName];
          if (value !== void 0) {
            times.push(key.time);
            value.toArray(values, values.length);
          }
          key = jsonKeys[i++];
        } while (key !== void 0);
      } else {
        do {
          value = key[valuePropertyName];
          if (value !== void 0) {
            times.push(key.time);
            values.push(value);
          }
          key = jsonKeys[i++];
        } while (key !== void 0);
      }
    },
    subclip: function(sourceClip, name, startFrame, endFrame, fps = 30) {
      const clip = sourceClip.clone();
      clip.name = name;
      const tracks = [];
      for (let i = 0; i < clip.tracks.length; ++i) {
        const track = clip.tracks[i];
        const valueSize = track.getValueSize();
        const times = [];
        const values = [];
        for (let j = 0; j < track.times.length; ++j) {
          const frame = track.times[j] * fps;
          if (frame < startFrame || frame >= endFrame)
            continue;
          times.push(track.times[j]);
          for (let k = 0; k < valueSize; ++k) {
            values.push(track.values[j * valueSize + k]);
          }
        }
        if (times.length === 0)
          continue;
        track.times = AnimationUtils.convertArray(times, track.times.constructor);
        track.values = AnimationUtils.convertArray(values, track.values.constructor);
        tracks.push(track);
      }
      clip.tracks = tracks;
      let minStartTime = Infinity;
      for (let i = 0; i < clip.tracks.length; ++i) {
        if (minStartTime > clip.tracks[i].times[0]) {
          minStartTime = clip.tracks[i].times[0];
        }
      }
      for (let i = 0; i < clip.tracks.length; ++i) {
        clip.tracks[i].shift(-1 * minStartTime);
      }
      clip.resetDuration();
      return clip;
    },
    makeClipAdditive: function(targetClip, referenceFrame = 0, referenceClip = targetClip, fps = 30) {
      if (fps <= 0)
        fps = 30;
      const numTracks = referenceClip.tracks.length;
      const referenceTime = referenceFrame / fps;
      for (let i = 0; i < numTracks; ++i) {
        const referenceTrack = referenceClip.tracks[i];
        const referenceTrackType = referenceTrack.ValueTypeName;
        if (referenceTrackType === "bool" || referenceTrackType === "string")
          continue;
        const targetTrack = targetClip.tracks.find(function(track) {
          return track.name === referenceTrack.name && track.ValueTypeName === referenceTrackType;
        });
        if (targetTrack === void 0)
          continue;
        let referenceOffset = 0;
        const referenceValueSize = referenceTrack.getValueSize();
        if (referenceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {
          referenceOffset = referenceValueSize / 3;
        }
        let targetOffset = 0;
        const targetValueSize = targetTrack.getValueSize();
        if (targetTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {
          targetOffset = targetValueSize / 3;
        }
        const lastIndex = referenceTrack.times.length - 1;
        let referenceValue;
        if (referenceTime <= referenceTrack.times[0]) {
          const startIndex = referenceOffset;
          const endIndex = referenceValueSize - referenceOffset;
          referenceValue = AnimationUtils.arraySlice(referenceTrack.values, startIndex, endIndex);
        } else if (referenceTime >= referenceTrack.times[lastIndex]) {
          const startIndex = lastIndex * referenceValueSize + referenceOffset;
          const endIndex = startIndex + referenceValueSize - referenceOffset;
          referenceValue = AnimationUtils.arraySlice(referenceTrack.values, startIndex, endIndex);
        } else {
          const interpolant = referenceTrack.createInterpolant();
          const startIndex = referenceOffset;
          const endIndex = referenceValueSize - referenceOffset;
          interpolant.evaluate(referenceTime);
          referenceValue = AnimationUtils.arraySlice(interpolant.resultBuffer, startIndex, endIndex);
        }
        if (referenceTrackType === "quaternion") {
          const referenceQuat = new Quaternion().fromArray(referenceValue).normalize().conjugate();
          referenceQuat.toArray(referenceValue);
        }
        const numTimes = targetTrack.times.length;
        for (let j = 0; j < numTimes; ++j) {
          const valueStart = j * targetValueSize + targetOffset;
          if (referenceTrackType === "quaternion") {
            Quaternion.multiplyQuaternionsFlat(
              targetTrack.values,
              valueStart,
              referenceValue,
              0,
              targetTrack.values,
              valueStart
            );
          } else {
            const valueEnd = targetValueSize - targetOffset * 2;
            for (let k = 0; k < valueEnd; ++k) {
              targetTrack.values[valueStart + k] -= referenceValue[k];
            }
          }
        }
      }
      targetClip.blendMode = AdditiveAnimationBlendMode;
      return targetClip;
    }
  };
  var Interpolant = class {
    constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
      this.parameterPositions = parameterPositions;
      this._cachedIndex = 0;
      this.resultBuffer = resultBuffer !== void 0 ? resultBuffer : new sampleValues.constructor(sampleSize);
      this.sampleValues = sampleValues;
      this.valueSize = sampleSize;
      this.settings = null;
      this.DefaultSettings_ = {};
    }
    evaluate(t) {
      const pp = this.parameterPositions;
      let i1 = this._cachedIndex, t1 = pp[i1], t0 = pp[i1 - 1];
      validate_interval: {
        seek: {
          let right;
          linear_scan: {
            forward_scan:
              if (!(t < t1)) {
                for (let giveUpAt = i1 + 2; ; ) {
                  if (t1 === void 0) {
                    if (t < t0)
                      break forward_scan;
                    i1 = pp.length;
                    this._cachedIndex = i1;
                    return this.afterEnd_(i1 - 1, t, t0);
                  }
                  if (i1 === giveUpAt)
                    break;
                  t0 = t1;
                  t1 = pp[++i1];
                  if (t < t1) {
                    break seek;
                  }
                }
                right = pp.length;
                break linear_scan;
              }
            if (!(t >= t0)) {
              const t1global = pp[1];
              if (t < t1global) {
                i1 = 2;
                t0 = t1global;
              }
              for (let giveUpAt = i1 - 2; ; ) {
                if (t0 === void 0) {
                  this._cachedIndex = 0;
                  return this.beforeStart_(0, t, t1);
                }
                if (i1 === giveUpAt)
                  break;
                t1 = t0;
                t0 = pp[--i1 - 1];
                if (t >= t0) {
                  break seek;
                }
              }
              right = i1;
              i1 = 0;
              break linear_scan;
            }
            break validate_interval;
          }
          while (i1 < right) {
            const mid = i1 + right >>> 1;
            if (t < pp[mid]) {
              right = mid;
            } else {
              i1 = mid + 1;
            }
          }
          t1 = pp[i1];
          t0 = pp[i1 - 1];
          if (t0 === void 0) {
            this._cachedIndex = 0;
            return this.beforeStart_(0, t, t1);
          }
          if (t1 === void 0) {
            i1 = pp.length;
            this._cachedIndex = i1;
            return this.afterEnd_(i1 - 1, t0, t);
          }
        }
        this._cachedIndex = i1;
        this.intervalChanged_(i1, t0, t1);
      }
      return this.interpolate_(i1, t0, t, t1);
    }
    getSettings_() {
      return this.settings || this.DefaultSettings_;
    }
    copySampleValue_(index) {
      const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset = index * stride;
      for (let i = 0; i !== stride; ++i) {
        result[i] = values[offset + i];
      }
      return result;
    }
    // Template methods for derived classes:
    interpolate_() {
      throw new Error("call to abstract method");
    }
    intervalChanged_() {
    }
  };
  Interpolant.prototype.beforeStart_ = Interpolant.prototype.copySampleValue_;
  Interpolant.prototype.afterEnd_ = Interpolant.prototype.copySampleValue_;
  var CubicInterpolant = class extends Interpolant {
    constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
      super(parameterPositions, sampleValues, sampleSize, resultBuffer);
      this._weightPrev = -0;
      this._offsetPrev = -0;
      this._weightNext = -0;
      this._offsetNext = -0;
      this.DefaultSettings_ = {
        endingStart: ZeroCurvatureEnding,
        endingEnd: ZeroCurvatureEnding
      };
    }
    intervalChanged_(i1, t0, t1) {
      const pp = this.parameterPositions;
      let iPrev = i1 - 2, iNext = i1 + 1, tPrev = pp[iPrev], tNext = pp[iNext];
      if (tPrev === void 0) {
        switch (this.getSettings_().endingStart) {
          case ZeroSlopeEnding:
            iPrev = i1;
            tPrev = 2 * t0 - t1;
            break;
          case WrapAroundEnding:
            iPrev = pp.length - 2;
            tPrev = t0 + pp[iPrev] - pp[iPrev + 1];
            break;
          default:
            iPrev = i1;
            tPrev = t1;
        }
      }
      if (tNext === void 0) {
        switch (this.getSettings_().endingEnd) {
          case ZeroSlopeEnding:
            iNext = i1;
            tNext = 2 * t1 - t0;
            break;
          case WrapAroundEnding:
            iNext = 1;
            tNext = t1 + pp[1] - pp[0];
            break;
          default:
            iNext = i1 - 1;
            tNext = t0;
        }
      }
      const halfDt = (t1 - t0) * 0.5, stride = this.valueSize;
      this._weightPrev = halfDt / (t0 - tPrev);
      this._weightNext = halfDt / (tNext - t1);
      this._offsetPrev = iPrev * stride;
      this._offsetNext = iNext * stride;
    }
    interpolate_(i1, t0, t, t1) {
      const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, o1 = i1 * stride, o0 = o1 - stride, oP = this._offsetPrev, oN = this._offsetNext, wP = this._weightPrev, wN = this._weightNext, p = (t - t0) / (t1 - t0), pp = p * p, ppp = pp * p;
      const sP = -wP * ppp + 2 * wP * pp - wP * p;
      const s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p + 1;
      const s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p;
      const sN = wN * ppp - wN * pp;
      for (let i = 0; i !== stride; ++i) {
        result[i] = sP * values[oP + i] + s0 * values[o0 + i] + s1 * values[o1 + i] + sN * values[oN + i];
      }
      return result;
    }
  };
  var LinearInterpolant = class extends Interpolant {
    constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
      super(parameterPositions, sampleValues, sampleSize, resultBuffer);
    }
    interpolate_(i1, t0, t, t1) {
      const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset1 = i1 * stride, offset0 = offset1 - stride, weight1 = (t - t0) / (t1 - t0), weight0 = 1 - weight1;
      for (let i = 0; i !== stride; ++i) {
        result[i] = values[offset0 + i] * weight0 + values[offset1 + i] * weight1;
      }
      return result;
    }
  };
  var DiscreteInterpolant = class extends Interpolant {
    constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
      super(parameterPositions, sampleValues, sampleSize, resultBuffer);
    }
    interpolate_(i1) {
      return this.copySampleValue_(i1 - 1);
    }
  };
  var KeyframeTrack = class {
    constructor(name, times, values, interpolation) {
      if (name === void 0)
        throw new Error("THREE.KeyframeTrack: track name is undefined");
      if (times === void 0 || times.length === 0)
        throw new Error("THREE.KeyframeTrack: no keyframes in track named " + name);
      this.name = name;
      this.times = AnimationUtils.convertArray(times, this.TimeBufferType);
      this.values = AnimationUtils.convertArray(values, this.ValueBufferType);
      this.setInterpolation(interpolation || this.DefaultInterpolation);
    }
    // Serialization (in static context, because of constructor invocation
    // and automatic invocation of .toJSON):
    static toJSON(track) {
      const trackType = track.constructor;
      let json;
      if (trackType.toJSON !== this.toJSON) {
        json = trackType.toJSON(track);
      } else {
        json = {
          "name": track.name,
          "times": AnimationUtils.convertArray(track.times, Array),
          "values": AnimationUtils.convertArray(track.values, Array)
        };
        const interpolation = track.getInterpolation();
        if (interpolation !== track.DefaultInterpolation) {
          json.interpolation = interpolation;
        }
      }
      json.type = track.ValueTypeName;
      return json;
    }
    InterpolantFactoryMethodDiscrete(result) {
      return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), result);
    }
    InterpolantFactoryMethodLinear(result) {
      return new LinearInterpolant(this.times, this.values, this.getValueSize(), result);
    }
    InterpolantFactoryMethodSmooth(result) {
      return new CubicInterpolant(this.times, this.values, this.getValueSize(), result);
    }
    setInterpolation(interpolation) {
      let factoryMethod;
      switch (interpolation) {
        case InterpolateDiscrete:
          factoryMethod = this.InterpolantFactoryMethodDiscrete;
          break;
        case InterpolateLinear:
          factoryMethod = this.InterpolantFactoryMethodLinear;
          break;
        case InterpolateSmooth:
          factoryMethod = this.InterpolantFactoryMethodSmooth;
          break;
      }
      if (factoryMethod === void 0) {
        const message = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
        if (this.createInterpolant === void 0) {
          if (interpolation !== this.DefaultInterpolation) {
            this.setInterpolation(this.DefaultInterpolation);
          } else {
            throw new Error(message);
          }
        }
        console.warn("THREE.KeyframeTrack:", message);
        return this;
      }
      this.createInterpolant = factoryMethod;
      return this;
    }
    getInterpolation() {
      switch (this.createInterpolant) {
        case this.InterpolantFactoryMethodDiscrete:
          return InterpolateDiscrete;
        case this.InterpolantFactoryMethodLinear:
          return InterpolateLinear;
        case this.InterpolantFactoryMethodSmooth:
          return InterpolateSmooth;
      }
    }
    getValueSize() {
      return this.values.length / this.times.length;
    }
    // move all keyframes either forwards or backwards in time
    shift(timeOffset) {
      if (timeOffset !== 0) {
        const times = this.times;
        for (let i = 0, n = times.length; i !== n; ++i) {
          times[i] += timeOffset;
        }
      }
      return this;
    }
    // scale all keyframe times by a factor (useful for frame <-> seconds conversions)
    scale(timeScale) {
      if (timeScale !== 1) {
        const times = this.times;
        for (let i = 0, n = times.length; i !== n; ++i) {
          times[i] *= timeScale;
        }
      }
      return this;
    }
    // removes keyframes before and after animation without changing any values within the range [startTime, endTime].
    // IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
    trim(startTime, endTime) {
      const times = this.times, nKeys = times.length;
      let from = 0, to = nKeys - 1;
      while (from !== nKeys && times[from] < startTime) {
        ++from;
      }
      while (to !== -1 && times[to] > endTime) {
        --to;
      }
      ++to;
      if (from !== 0 || to !== nKeys) {
        if (from >= to) {
          to = Math.max(to, 1);
          from = to - 1;
        }
        const stride = this.getValueSize();
        this.times = AnimationUtils.arraySlice(times, from, to);
        this.values = AnimationUtils.arraySlice(this.values, from * stride, to * stride);
      }
      return this;
    }
    // ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
    validate() {
      let valid = true;
      const valueSize = this.getValueSize();
      if (valueSize - Math.floor(valueSize) !== 0) {
        console.error("THREE.KeyframeTrack: Invalid value size in track.", this);
        valid = false;
      }
      const times = this.times, values = this.values, nKeys = times.length;
      if (nKeys === 0) {
        console.error("THREE.KeyframeTrack: Track is empty.", this);
        valid = false;
      }
      let prevTime = null;
      for (let i = 0; i !== nKeys; i++) {
        const currTime = times[i];
        if (typeof currTime === "number" && isNaN(currTime)) {
          console.error("THREE.KeyframeTrack: Time is not a valid number.", this, i, currTime);
          valid = false;
          break;
        }
        if (prevTime !== null && prevTime > currTime) {
          console.error("THREE.KeyframeTrack: Out of order keys.", this, i, currTime, prevTime);
          valid = false;
          break;
        }
        prevTime = currTime;
      }
      if (values !== void 0) {
        if (AnimationUtils.isTypedArray(values)) {
          for (let i = 0, n = values.length; i !== n; ++i) {
            const value = values[i];
            if (isNaN(value)) {
              console.error("THREE.KeyframeTrack: Value is not a valid number.", this, i, value);
              valid = false;
              break;
            }
          }
        }
      }
      return valid;
    }
    // removes equivalent sequential keys as common in morph target sequences
    // (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
    optimize() {
      const times = AnimationUtils.arraySlice(this.times), values = AnimationUtils.arraySlice(this.values), stride = this.getValueSize(), smoothInterpolation = this.getInterpolation() === InterpolateSmooth, lastIndex = times.length - 1;
      let writeIndex = 1;
      for (let i = 1; i < lastIndex; ++i) {
        let keep = false;
        const time = times[i];
        const timeNext = times[i + 1];
        if (time !== timeNext && (i !== 1 || time !== times[0])) {
          if (!smoothInterpolation) {
            const offset = i * stride, offsetP = offset - stride, offsetN = offset + stride;
            for (let j = 0; j !== stride; ++j) {
              const value = values[offset + j];
              if (value !== values[offsetP + j] || value !== values[offsetN + j]) {
                keep = true;
                break;
              }
            }
          } else {
            keep = true;
          }
        }
        if (keep) {
          if (i !== writeIndex) {
            times[writeIndex] = times[i];
            const readOffset = i * stride, writeOffset = writeIndex * stride;
            for (let j = 0; j !== stride; ++j) {
              values[writeOffset + j] = values[readOffset + j];
            }
          }
          ++writeIndex;
        }
      }
      if (lastIndex > 0) {
        times[writeIndex] = times[lastIndex];
        for (let readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++j) {
          values[writeOffset + j] = values[readOffset + j];
        }
        ++writeIndex;
      }
      if (writeIndex !== times.length) {
        this.times = AnimationUtils.arraySlice(times, 0, writeIndex);
        this.values = AnimationUtils.arraySlice(values, 0, writeIndex * stride);
      } else {
        this.times = times;
        this.values = values;
      }
      return this;
    }
    clone() {
      const times = AnimationUtils.arraySlice(this.times, 0);
      const values = AnimationUtils.arraySlice(this.values, 0);
      const TypedKeyframeTrack = this.constructor;
      const track = new TypedKeyframeTrack(this.name, times, values);
      track.createInterpolant = this.createInterpolant;
      return track;
    }
  };
  KeyframeTrack.prototype.TimeBufferType = Float32Array;
  KeyframeTrack.prototype.ValueBufferType = Float32Array;
  KeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
  var BooleanKeyframeTrack = class extends KeyframeTrack {
  };
  BooleanKeyframeTrack.prototype.ValueTypeName = "bool";
  BooleanKeyframeTrack.prototype.ValueBufferType = Array;
  BooleanKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
  BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0;
  BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
  var ColorKeyframeTrack = class extends KeyframeTrack {
  };
  ColorKeyframeTrack.prototype.ValueTypeName = "color";
  var NumberKeyframeTrack = class extends KeyframeTrack {
  };
  NumberKeyframeTrack.prototype.ValueTypeName = "number";
  var QuaternionLinearInterpolant = class extends Interpolant {
    constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
      super(parameterPositions, sampleValues, sampleSize, resultBuffer);
    }
    interpolate_(i1, t0, t, t1) {
      const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, alpha = (t - t0) / (t1 - t0);
      let offset = i1 * stride;
      for (let end = offset + stride; offset !== end; offset += 4) {
        Quaternion.slerpFlat(result, 0, values, offset - stride, values, offset, alpha);
      }
      return result;
    }
  };
  var QuaternionKeyframeTrack = class extends KeyframeTrack {
    InterpolantFactoryMethodLinear(result) {
      return new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), result);
    }
  };
  QuaternionKeyframeTrack.prototype.ValueTypeName = "quaternion";
  QuaternionKeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
  QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
  var StringKeyframeTrack = class extends KeyframeTrack {
  };
  StringKeyframeTrack.prototype.ValueTypeName = "string";
  StringKeyframeTrack.prototype.ValueBufferType = Array;
  StringKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
  StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0;
  StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
  var VectorKeyframeTrack = class extends KeyframeTrack {
  };
  VectorKeyframeTrack.prototype.ValueTypeName = "vector";
  var AnimationClip = class {
    constructor(name, duration = -1, tracks, blendMode = NormalAnimationBlendMode) {
      this.name = name;
      this.tracks = tracks;
      this.duration = duration;
      this.blendMode = blendMode;
      this.uuid = generateUUID();
      if (this.duration < 0) {
        this.resetDuration();
      }
    }
    static parse(json) {
      const tracks = [], jsonTracks = json.tracks, frameTime = 1 / (json.fps || 1);
      for (let i = 0, n = jsonTracks.length; i !== n; ++i) {
        tracks.push(parseKeyframeTrack(jsonTracks[i]).scale(frameTime));
      }
      const clip = new this(json.name, json.duration, tracks, json.blendMode);
      clip.uuid = json.uuid;
      return clip;
    }
    static toJSON(clip) {
      const tracks = [], clipTracks = clip.tracks;
      const json = {
        "name": clip.name,
        "duration": clip.duration,
        "tracks": tracks,
        "uuid": clip.uuid,
        "blendMode": clip.blendMode
      };
      for (let i = 0, n = clipTracks.length; i !== n; ++i) {
        tracks.push(KeyframeTrack.toJSON(clipTracks[i]));
      }
      return json;
    }
    static CreateFromMorphTargetSequence(name, morphTargetSequence, fps, noLoop) {
      const numMorphTargets = morphTargetSequence.length;
      const tracks = [];
      for (let i = 0; i < numMorphTargets; i++) {
        let times = [];
        let values = [];
        times.push(
          (i + numMorphTargets - 1) % numMorphTargets,
          i,
          (i + 1) % numMorphTargets
        );
        values.push(0, 1, 0);
        const order = AnimationUtils.getKeyframeOrder(times);
        times = AnimationUtils.sortedArray(times, 1, order);
        values = AnimationUtils.sortedArray(values, 1, order);
        if (!noLoop && times[0] === 0) {
          times.push(numMorphTargets);
          values.push(values[0]);
        }
        tracks.push(
          new NumberKeyframeTrack(
            ".morphTargetInfluences[" + morphTargetSequence[i].name + "]",
            times,
            values
          ).scale(1 / fps)
        );
      }
      return new this(name, -1, tracks);
    }
    static findByName(objectOrClipArray, name) {
      let clipArray = objectOrClipArray;
      if (!Array.isArray(objectOrClipArray)) {
        const o = objectOrClipArray;
        clipArray = o.geometry && o.geometry.animations || o.animations;
      }
      for (let i = 0; i < clipArray.length; i++) {
        if (clipArray[i].name === name) {
          return clipArray[i];
        }
      }
      return null;
    }
    static CreateClipsFromMorphTargetSequences(morphTargets, fps, noLoop) {
      const animationToMorphTargets = {};
      const pattern = /^([\w-]*?)([\d]+)$/;
      for (let i = 0, il = morphTargets.length; i < il; i++) {
        const morphTarget = morphTargets[i];
        const parts = morphTarget.name.match(pattern);
        if (parts && parts.length > 1) {
          const name = parts[1];
          let animationMorphTargets = animationToMorphTargets[name];
          if (!animationMorphTargets) {
            animationToMorphTargets[name] = animationMorphTargets = [];
          }
          animationMorphTargets.push(morphTarget);
        }
      }
      const clips = [];
      for (const name in animationToMorphTargets) {
        clips.push(this.CreateFromMorphTargetSequence(name, animationToMorphTargets[name], fps, noLoop));
      }
      return clips;
    }
    // parse the animation.hierarchy format
    static parseAnimation(animation, bones) {
      if (!animation) {
        console.error("THREE.AnimationClip: No animation in JSONLoader data.");
        return null;
      }
      const addNonemptyTrack = function(trackType, trackName, animationKeys, propertyName, destTracks) {
        if (animationKeys.length !== 0) {
          const times = [];
          const values = [];
          AnimationUtils.flattenJSON(animationKeys, times, values, propertyName);
          if (times.length !== 0) {
            destTracks.push(new trackType(trackName, times, values));
          }
        }
      };
      const tracks = [];
      const clipName = animation.name || "default";
      const fps = animation.fps || 30;
      const blendMode = animation.blendMode;
      let duration = animation.length || -1;
      const hierarchyTracks = animation.hierarchy || [];
      for (let h = 0; h < hierarchyTracks.length; h++) {
        const animationKeys = hierarchyTracks[h].keys;
        if (!animationKeys || animationKeys.length === 0)
          continue;
        if (animationKeys[0].morphTargets) {
          const morphTargetNames = {};
          let k;
          for (k = 0; k < animationKeys.length; k++) {
            if (animationKeys[k].morphTargets) {
              for (let m = 0; m < animationKeys[k].morphTargets.length; m++) {
                morphTargetNames[animationKeys[k].morphTargets[m]] = -1;
              }
            }
          }
          for (const morphTargetName in morphTargetNames) {
            const times = [];
            const values = [];
            for (let m = 0; m !== animationKeys[k].morphTargets.length; ++m) {
              const animationKey = animationKeys[k];
              times.push(animationKey.time);
              values.push(animationKey.morphTarget === morphTargetName ? 1 : 0);
            }
            tracks.push(new NumberKeyframeTrack(".morphTargetInfluence[" + morphTargetName + "]", times, values));
          }
          duration = morphTargetNames.length * fps;
        } else {
          const boneName = ".bones[" + bones[h].name + "]";
          addNonemptyTrack(
            VectorKeyframeTrack,
            boneName + ".position",
            animationKeys,
            "pos",
            tracks
          );
          addNonemptyTrack(
            QuaternionKeyframeTrack,
            boneName + ".quaternion",
            animationKeys,
            "rot",
            tracks
          );
          addNonemptyTrack(
            VectorKeyframeTrack,
            boneName + ".scale",
            animationKeys,
            "scl",
            tracks
          );
        }
      }
      if (tracks.length === 0) {
        return null;
      }
      const clip = new this(clipName, duration, tracks, blendMode);
      return clip;
    }
    resetDuration() {
      const tracks = this.tracks;
      let duration = 0;
      for (let i = 0, n = tracks.length; i !== n; ++i) {
        const track = this.tracks[i];
        duration = Math.max(duration, track.times[track.times.length - 1]);
      }
      this.duration = duration;
      return this;
    }
    trim() {
      for (let i = 0; i < this.tracks.length; i++) {
        this.tracks[i].trim(0, this.duration);
      }
      return this;
    }
    validate() {
      let valid = true;
      for (let i = 0; i < this.tracks.length; i++) {
        valid = valid && this.tracks[i].validate();
      }
      return valid;
    }
    optimize() {
      for (let i = 0; i < this.tracks.length; i++) {
        this.tracks[i].optimize();
      }
      return this;
    }
    clone() {
      const tracks = [];
      for (let i = 0; i < this.tracks.length; i++) {
        tracks.push(this.tracks[i].clone());
      }
      return new this.constructor(this.name, this.duration, tracks, this.blendMode);
    }
    toJSON() {
      return this.constructor.toJSON(this);
    }
  };
  function getTrackTypeForValueTypeName(typeName) {
    switch (typeName.toLowerCase()) {
      case "scalar":
      case "double":
      case "float":
      case "number":
      case "integer":
        return NumberKeyframeTrack;
      case "vector":
      case "vector2":
      case "vector3":
      case "vector4":
        return VectorKeyframeTrack;
      case "color":
        return ColorKeyframeTrack;
      case "quaternion":
        return QuaternionKeyframeTrack;
      case "bool":
      case "boolean":
        return BooleanKeyframeTrack;
      case "string":
        return StringKeyframeTrack;
    }
    throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + typeName);
  }
  function parseKeyframeTrack(json) {
    if (json.type === void 0) {
      throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
    }
    const trackType = getTrackTypeForValueTypeName(json.type);
    if (json.times === void 0) {
      const times = [], values = [];
      AnimationUtils.flattenJSON(json.keys, times, values, "value");
      json.times = times;
      json.values = values;
    }
    if (trackType.parse !== void 0) {
      return trackType.parse(json);
    } else {
      return new trackType(json.name, json.times, json.values, json.interpolation);
    }
  }
  var Cache = {
    enabled: false,
    files: {},
    add: function(key, file) {
      if (this.enabled === false)
        return;
      this.files[key] = file;
    },
    get: function(key) {
      if (this.enabled === false)
        return;
      return this.files[key];
    },
    remove: function(key) {
      delete this.files[key];
    },
    clear: function() {
      this.files = {};
    }
  };
  var LoadingManager = class {
    constructor(onLoad, onProgress, onError) {
      const scope = this;
      let isLoading = false;
      let itemsLoaded = 0;
      let itemsTotal = 0;
      let urlModifier = void 0;
      const handlers = [];
      this.onStart = void 0;
      this.onLoad = onLoad;
      this.onProgress = onProgress;
      this.onError = onError;
      this.itemStart = function(url) {
        itemsTotal++;
        if (isLoading === false) {
          if (scope.onStart !== void 0) {
            scope.onStart(url, itemsLoaded, itemsTotal);
          }
        }
        isLoading = true;
      };
      this.itemEnd = function(url) {
        itemsLoaded++;
        if (scope.onProgress !== void 0) {
          scope.onProgress(url, itemsLoaded, itemsTotal);
        }
        if (itemsLoaded === itemsTotal) {
          isLoading = false;
          if (scope.onLoad !== void 0) {
            scope.onLoad();
          }
        }
      };
      this.itemError = function(url) {
        if (scope.onError !== void 0) {
          scope.onError(url);
        }
      };
      this.resolveURL = function(url) {
        if (urlModifier) {
          return urlModifier(url);
        }
        return url;
      };
      this.setURLModifier = function(transform) {
        urlModifier = transform;
        return this;
      };
      this.addHandler = function(regex, loader) {
        handlers.push(regex, loader);
        return this;
      };
      this.removeHandler = function(regex) {
        const index = handlers.indexOf(regex);
        if (index !== -1) {
          handlers.splice(index, 2);
        }
        return this;
      };
      this.getHandler = function(file) {
        for (let i = 0, l = handlers.length; i < l; i += 2) {
          const regex = handlers[i];
          const loader = handlers[i + 1];
          if (regex.global)
            regex.lastIndex = 0;
          if (regex.test(file)) {
            return loader;
          }
        }
        return null;
      };
    }
  };
  var DefaultLoadingManager = new LoadingManager();
  var Loader = class {
    constructor(manager) {
      this.manager = manager !== void 0 ? manager : DefaultLoadingManager;
      this.crossOrigin = "anonymous";
      this.withCredentials = false;
      this.path = "";
      this.resourcePath = "";
      this.requestHeader = {};
    }
    load() {
    }
    loadAsync(url, onProgress) {
      const scope = this;
      return new Promise(function(resolve, reject) {
        scope.load(url, resolve, onProgress, reject);
      });
    }
    parse() {
    }
    setCrossOrigin(crossOrigin) {
      this.crossOrigin = crossOrigin;
      return this;
    }
    setWithCredentials(value) {
      this.withCredentials = value;
      return this;
    }
    setPath(path) {
      this.path = path;
      return this;
    }
    setResourcePath(resourcePath) {
      this.resourcePath = resourcePath;
      return this;
    }
    setRequestHeader(requestHeader) {
      this.requestHeader = requestHeader;
      return this;
    }
  };
  var loading = {};
  var FileLoader = class extends Loader {
    constructor(manager) {
      super(manager);
    }
    load(url, onLoad, onProgress, onError) {
      if (url === void 0)
        url = "";
      if (this.path !== void 0)
        url = this.path + url;
      url = this.manager.resolveURL(url);
      const cached = Cache.get(url);
      if (cached !== void 0) {
        this.manager.itemStart(url);
        setTimeout(() => {
          if (onLoad)
            onLoad(cached);
          this.manager.itemEnd(url);
        }, 0);
        return cached;
      }
      if (loading[url] !== void 0) {
        loading[url].push({
          onLoad,
          onProgress,
          onError
        });
        return;
      }
      loading[url] = [];
      loading[url].push({
        onLoad,
        onProgress,
        onError
      });
      const req = new Request(url, {
        headers: new Headers(this.requestHeader),
        credentials: this.withCredentials ? "include" : "same-origin"
        // An abort controller could be added within a future PR
      });
      const mimeType = this.mimeType;
      const responseType = this.responseType;
      fetch(req).then((response) => {
        if (response.status === 200 || response.status === 0) {
          if (response.status === 0) {
            console.warn("THREE.FileLoader: HTTP Status 0 received.");
          }
          if (typeof ReadableStream === "undefined" || response.body === void 0 || response.body.getReader === void 0) {
            return response;
          }
          const callbacks = loading[url];
          const reader = response.body.getReader();
          const contentLength = response.headers.get("Content-Length");
          const total = contentLength ? parseInt(contentLength) : 0;
          const lengthComputable = total !== 0;
          let loaded = 0;
          const stream = new ReadableStream({
            start(controller) {
              readData();
              function readData() {
                reader.read().then(({ done, value }) => {
                  if (done) {
                    controller.close();
                  } else {
                    loaded += value.byteLength;
                    const event = new ProgressEvent("progress", { lengthComputable, loaded, total });
                    for (let i = 0, il = callbacks.length; i < il; i++) {
                      const callback = callbacks[i];
                      if (callback.onProgress)
                        callback.onProgress(event);
                    }
                    controller.enqueue(value);
                    readData();
                  }
                });
              }
            }
          });
          return new Response(stream);
        } else {
          throw Error(`fetch for "${response.url}" responded with ${response.status}: ${response.statusText}`);
        }
      }).then((response) => {
        switch (responseType) {
          case "arraybuffer":
            return response.arrayBuffer();
          case "blob":
            return response.blob();
          case "document":
            return response.text().then((text) => {
              const parser = new DOMParser();
              return parser.parseFromString(text, mimeType);
            });
          case "json":
            return response.json();
          default:
            if (mimeType === void 0) {
              return response.text();
            } else {
              const re = /charset="?([^;"\s]*)"?/i;
              const exec = re.exec(mimeType);
              const label = exec && exec[1] ? exec[1].toLowerCase() : void 0;
              const decoder = new TextDecoder(label);
              return response.arrayBuffer().then((ab) => decoder.decode(ab));
            }
        }
      }).then((data) => {
        Cache.add(url, data);
        const callbacks = loading[url];
        delete loading[url];
        for (let i = 0, il = callbacks.length; i < il; i++) {
          const callback = callbacks[i];
          if (callback.onLoad)
            callback.onLoad(data);
        }
      }).catch((err) => {
        const callbacks = loading[url];
        if (callbacks === void 0) {
          this.manager.itemError(url);
          throw err;
        }
        delete loading[url];
        for (let i = 0, il = callbacks.length; i < il; i++) {
          const callback = callbacks[i];
          if (callback.onError)
            callback.onError(err);
        }
        this.manager.itemError(url);
      }).finally(() => {
        this.manager.itemEnd(url);
      });
      this.manager.itemStart(url);
    }
    setResponseType(value) {
      this.responseType = value;
      return this;
    }
    setMimeType(value) {
      this.mimeType = value;
      return this;
    }
  };
  var ImageLoader = class extends Loader {
    constructor(manager) {
      super(manager);
    }
    load(url, onLoad, onProgress, onError) {
      if (this.path !== void 0)
        url = this.path + url;
      url = this.manager.resolveURL(url);
      const scope = this;
      const cached = Cache.get(url);
      if (cached !== void 0) {
        scope.manager.itemStart(url);
        setTimeout(function() {
          if (onLoad)
            onLoad(cached);
          scope.manager.itemEnd(url);
        }, 0);
        return cached;
      }
      const image = createElementNS("img");
      function onImageLoad() {
        removeEventListeners();
        Cache.add(url, this);
        if (onLoad)
          onLoad(this);
        scope.manager.itemEnd(url);
      }
      function onImageError(event) {
        removeEventListeners();
        if (onError)
          onError(event);
        scope.manager.itemError(url);
        scope.manager.itemEnd(url);
      }
      function removeEventListeners() {
        image.removeEventListener("load", onImageLoad, false);
        image.removeEventListener("error", onImageError, false);
      }
      image.addEventListener("load", onImageLoad, false);
      image.addEventListener("error", onImageError, false);
      if (url.slice(0, 5) !== "data:") {
        if (this.crossOrigin !== void 0)
          image.crossOrigin = this.crossOrigin;
      }
      scope.manager.itemStart(url);
      image.src = url;
      return image;
    }
  };
  var CubeTextureLoader = class extends Loader {
    constructor(manager) {
      super(manager);
    }
    load(urls, onLoad, onProgress, onError) {
      const texture = new CubeTexture();
      const loader = new ImageLoader(this.manager);
      loader.setCrossOrigin(this.crossOrigin);
      loader.setPath(this.path);
      let loaded = 0;
      function loadTexture(i) {
        loader.load(urls[i], function(image) {
          texture.images[i] = image;
          loaded++;
          if (loaded === 6) {
            texture.needsUpdate = true;
            if (onLoad)
              onLoad(texture);
          }
        }, void 0, onError);
      }
      for (let i = 0; i < urls.length; ++i) {
        loadTexture(i);
      }
      return texture;
    }
  };
  var TextureLoader = class extends Loader {
    constructor(manager) {
      super(manager);
    }
    load(url, onLoad, onProgress, onError) {
      const texture = new Texture();
      const loader = new ImageLoader(this.manager);
      loader.setCrossOrigin(this.crossOrigin);
      loader.setPath(this.path);
      loader.load(url, function(image) {
        texture.image = image;
        texture.needsUpdate = true;
        if (onLoad !== void 0) {
          onLoad(texture);
        }
      }, onProgress, onError);
      return texture;
    }
  };
  var Light = class extends Object3D {
    constructor(color, intensity = 1) {
      super();
      this.type = "Light";
      this.color = new Color(color);
      this.intensity = intensity;
    }
    dispose() {
    }
    copy(source) {
      super.copy(source);
      this.color.copy(source.color);
      this.intensity = source.intensity;
      return this;
    }
    toJSON(meta) {
      const data = super.toJSON(meta);
      data.object.color = this.color.getHex();
      data.object.intensity = this.intensity;
      if (this.groundColor !== void 0)
        data.object.groundColor = this.groundColor.getHex();
      if (this.distance !== void 0)
        data.object.distance = this.distance;
      if (this.angle !== void 0)
        data.object.angle = this.angle;
      if (this.decay !== void 0)
        data.object.decay = this.decay;
      if (this.penumbra !== void 0)
        data.object.penumbra = this.penumbra;
      if (this.shadow !== void 0)
        data.object.shadow = this.shadow.toJSON();
      return data;
    }
  };
  Light.prototype.isLight = true;
  var HemisphereLight = class extends Light {
    constructor(skyColor, groundColor, intensity) {
      super(skyColor, intensity);
      this.type = "HemisphereLight";
      this.position.copy(Object3D.DefaultUp);
      this.updateMatrix();
      this.groundColor = new Color(groundColor);
    }
    copy(source) {
      Light.prototype.copy.call(this, source);
      this.groundColor.copy(source.groundColor);
      return this;
    }
  };
  HemisphereLight.prototype.isHemisphereLight = true;
  var _projScreenMatrix$1 = /* @__PURE__ */ new Matrix4();
  var _lightPositionWorld$1 = /* @__PURE__ */ new Vector3();
  var _lookTarget$1 = /* @__PURE__ */ new Vector3();
  var LightShadow = class {
    constructor(camera) {
      this.camera = camera;
      this.bias = 0;
      this.normalBias = 0;
      this.radius = 1;
      this.blurSamples = 8;
      this.mapSize = new Vector2(512, 512);
      this.map = null;
      this.mapPass = null;
      this.matrix = new Matrix4();
      this.autoUpdate = true;
      this.needsUpdate = false;
      this._frustum = new Frustum();
      this._frameExtents = new Vector2(1, 1);
      this._viewportCount = 1;
      this._viewports = [
        new Vector4(0, 0, 1, 1)
      ];
    }
    getViewportCount() {
      return this._viewportCount;
    }
    getFrustum() {
      return this._frustum;
    }
    updateMatrices(light) {
      const shadowCamera = this.camera;
      const shadowMatrix = this.matrix;
      _lightPositionWorld$1.setFromMatrixPosition(light.matrixWorld);
      shadowCamera.position.copy(_lightPositionWorld$1);
      _lookTarget$1.setFromMatrixPosition(light.target.matrixWorld);
      shadowCamera.lookAt(_lookTarget$1);
      shadowCamera.updateMatrixWorld();
      _projScreenMatrix$1.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);
      this._frustum.setFromProjectionMatrix(_projScreenMatrix$1);
      shadowMatrix.set(
        0.5,
        0,
        0,
        0.5,
        0,
        0.5,
        0,
        0.5,
        0,
        0,
        0.5,
        0.5,
        0,
        0,
        0,
        1
      );
      shadowMatrix.multiply(shadowCamera.projectionMatrix);
      shadowMatrix.multiply(shadowCamera.matrixWorldInverse);
    }
    getViewport(viewportIndex) {
      return this._viewports[viewportIndex];
    }
    getFrameExtents() {
      return this._frameExtents;
    }
    dispose() {
      if (this.map) {
        this.map.dispose();
      }
      if (this.mapPass) {
        this.mapPass.dispose();
      }
    }
    copy(source) {
      this.camera = source.camera.clone();
      this.bias = source.bias;
      this.radius = source.radius;
      this.mapSize.copy(source.mapSize);
      return this;
    }
    clone() {
      return new this.constructor().copy(this);
    }
    toJSON() {
      const object = {};
      if (this.bias !== 0)
        object.bias = this.bias;
      if (this.normalBias !== 0)
        object.normalBias = this.normalBias;
      if (this.radius !== 1)
        object.radius = this.radius;
      if (this.mapSize.x !== 512 || this.mapSize.y !== 512)
        object.mapSize = this.mapSize.toArray();
      object.camera = this.camera.toJSON(false).object;
      delete object.camera.matrix;
      return object;
    }
  };
  var SpotLightShadow = class extends LightShadow {
    constructor() {
      super(new PerspectiveCamera(50, 1, 0.5, 500));
      this.focus = 1;
    }
    updateMatrices(light) {
      const camera = this.camera;
      const fov2 = RAD2DEG * 2 * light.angle * this.focus;
      const aspect2 = this.mapSize.width / this.mapSize.height;
      const far = light.distance || camera.far;
      if (fov2 !== camera.fov || aspect2 !== camera.aspect || far !== camera.far) {
        camera.fov = fov2;
        camera.aspect = aspect2;
        camera.far = far;
        camera.updateProjectionMatrix();
      }
      super.updateMatrices(light);
    }
    copy(source) {
      super.copy(source);
      this.focus = source.focus;
      return this;
    }
  };
  SpotLightShadow.prototype.isSpotLightShadow = true;
  var SpotLight = class extends Light {
    constructor(color, intensity, distance = 0, angle = Math.PI / 3, penumbra = 0, decay = 1) {
      super(color, intensity);
      this.type = "SpotLight";
      this.position.copy(Object3D.DefaultUp);
      this.updateMatrix();
      this.target = new Object3D();
      this.distance = distance;
      this.angle = angle;
      this.penumbra = penumbra;
      this.decay = decay;
      this.shadow = new SpotLightShadow();
    }
    get power() {
      return this.intensity * Math.PI;
    }
    set power(power) {
      this.intensity = power / Math.PI;
    }
    dispose() {
      this.shadow.dispose();
    }
    copy(source) {
      super.copy(source);
      this.distance = source.distance;
      this.angle = source.angle;
      this.penumbra = source.penumbra;
      this.decay = source.decay;
      this.target = source.target.clone();
      this.shadow = source.shadow.clone();
      return this;
    }
  };
  SpotLight.prototype.isSpotLight = true;
  var _projScreenMatrix = /* @__PURE__ */ new Matrix4();
  var _lightPositionWorld = /* @__PURE__ */ new Vector3();
  var _lookTarget = /* @__PURE__ */ new Vector3();
  var PointLightShadow = class extends LightShadow {
    constructor() {
      super(new PerspectiveCamera(90, 1, 0.5, 500));
      this._frameExtents = new Vector2(4, 2);
      this._viewportCount = 6;
      this._viewports = [
        // These viewports map a cube-map onto a 2D texture with the
        // following orientation:
        //
        //  xzXZ
        //   y Y
        //
        // X - Positive x direction
        // x - Negative x direction
        // Y - Positive y direction
        // y - Negative y direction
        // Z - Positive z direction
        // z - Negative z direction
        // positive X
        new Vector4(2, 1, 1, 1),
        // negative X
        new Vector4(0, 1, 1, 1),
        // positive Z
        new Vector4(3, 1, 1, 1),
        // negative Z
        new Vector4(1, 1, 1, 1),
        // positive Y
        new Vector4(3, 0, 1, 1),
        // negative Y
        new Vector4(1, 0, 1, 1)
      ];
      this._cubeDirections = [
        new Vector3(1, 0, 0),
        new Vector3(-1, 0, 0),
        new Vector3(0, 0, 1),
        new Vector3(0, 0, -1),
        new Vector3(0, 1, 0),
        new Vector3(0, -1, 0)
      ];
      this._cubeUps = [
        new Vector3(0, 1, 0),
        new Vector3(0, 1, 0),
        new Vector3(0, 1, 0),
        new Vector3(0, 1, 0),
        new Vector3(0, 0, 1),
        new Vector3(0, 0, -1)
      ];
    }
    updateMatrices(light, viewportIndex = 0) {
      const camera = this.camera;
      const shadowMatrix = this.matrix;
      const far = light.distance || camera.far;
      if (far !== camera.far) {
        camera.far = far;
        camera.updateProjectionMatrix();
      }
      _lightPositionWorld.setFromMatrixPosition(light.matrixWorld);
      camera.position.copy(_lightPositionWorld);
      _lookTarget.copy(camera.position);
      _lookTarget.add(this._cubeDirections[viewportIndex]);
      camera.up.copy(this._cubeUps[viewportIndex]);
      camera.lookAt(_lookTarget);
      camera.updateMatrixWorld();
      shadowMatrix.makeTranslation(-_lightPositionWorld.x, -_lightPositionWorld.y, -_lightPositionWorld.z);
      _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
      this._frustum.setFromProjectionMatrix(_projScreenMatrix);
    }
  };
  PointLightShadow.prototype.isPointLightShadow = true;
  var PointLight = class extends Light {
    constructor(color, intensity, distance = 0, decay = 1) {
      super(color, intensity);
      this.type = "PointLight";
      this.distance = distance;
      this.decay = decay;
      this.shadow = new PointLightShadow();
    }
    get power() {
      return this.intensity * 4 * Math.PI;
    }
    set power(power) {
      this.intensity = power / (4 * Math.PI);
    }
    dispose() {
      this.shadow.dispose();
    }
    copy(source) {
      super.copy(source);
      this.distance = source.distance;
      this.decay = source.decay;
      this.shadow = source.shadow.clone();
      return this;
    }
  };
  PointLight.prototype.isPointLight = true;
  var DirectionalLightShadow = class extends LightShadow {
    constructor() {
      super(new OrthographicCamera(-5, 5, 5, -5, 0.5, 500));
    }
  };
  DirectionalLightShadow.prototype.isDirectionalLightShadow = true;
  var DirectionalLight = class extends Light {
    constructor(color, intensity) {
      super(color, intensity);
      this.type = "DirectionalLight";
      this.position.copy(Object3D.DefaultUp);
      this.updateMatrix();
      this.target = new Object3D();
      this.shadow = new DirectionalLightShadow();
    }
    dispose() {
      this.shadow.dispose();
    }
    copy(source) {
      super.copy(source);
      this.target = source.target.clone();
      this.shadow = source.shadow.clone();
      return this;
    }
  };
  DirectionalLight.prototype.isDirectionalLight = true;
  var AmbientLight = class extends Light {
    constructor(color, intensity) {
      super(color, intensity);
      this.type = "AmbientLight";
    }
  };
  AmbientLight.prototype.isAmbientLight = true;
  var RectAreaLight = class extends Light {
    constructor(color, intensity, width = 10, height = 10) {
      super(color, intensity);
      this.type = "RectAreaLight";
      this.width = width;
      this.height = height;
    }
    get power() {
      return this.intensity * this.width * this.height * Math.PI;
    }
    set power(power) {
      this.intensity = power / (this.width * this.height * Math.PI);
    }
    copy(source) {
      super.copy(source);
      this.width = source.width;
      this.height = source.height;
      return this;
    }
    toJSON(meta) {
      const data = super.toJSON(meta);
      data.object.width = this.width;
      data.object.height = this.height;
      return data;
    }
  };
  RectAreaLight.prototype.isRectAreaLight = true;
  var SphericalHarmonics3 = class {
    constructor() {
      this.coefficients = [];
      for (let i = 0; i < 9; i++) {
        this.coefficients.push(new Vector3());
      }
    }
    set(coefficients) {
      for (let i = 0; i < 9; i++) {
        this.coefficients[i].copy(coefficients[i]);
      }
      return this;
    }
    zero() {
      for (let i = 0; i < 9; i++) {
        this.coefficients[i].set(0, 0, 0);
      }
      return this;
    }
    // get the radiance in the direction of the normal
    // target is a Vector3
    getAt(normal, target) {
      const x = normal.x, y = normal.y, z = normal.z;
      const coeff = this.coefficients;
      target.copy(coeff[0]).multiplyScalar(0.282095);
      target.addScaledVector(coeff[1], 0.488603 * y);
      target.addScaledVector(coeff[2], 0.488603 * z);
      target.addScaledVector(coeff[3], 0.488603 * x);
      target.addScaledVector(coeff[4], 1.092548 * (x * y));
      target.addScaledVector(coeff[5], 1.092548 * (y * z));
      target.addScaledVector(coeff[6], 0.315392 * (3 * z * z - 1));
      target.addScaledVector(coeff[7], 1.092548 * (x * z));
      target.addScaledVector(coeff[8], 0.546274 * (x * x - y * y));
      return target;
    }
    // get the irradiance (radiance convolved with cosine lobe) in the direction of the normal
    // target is a Vector3
    // https://graphics.stanford.edu/papers/envmap/envmap.pdf
    getIrradianceAt(normal, target) {
      const x = normal.x, y = normal.y, z = normal.z;
      const coeff = this.coefficients;
      target.copy(coeff[0]).multiplyScalar(0.886227);
      target.addScaledVector(coeff[1], 2 * 0.511664 * y);
      target.addScaledVector(coeff[2], 2 * 0.511664 * z);
      target.addScaledVector(coeff[3], 2 * 0.511664 * x);
      target.addScaledVector(coeff[4], 2 * 0.429043 * x * y);
      target.addScaledVector(coeff[5], 2 * 0.429043 * y * z);
      target.addScaledVector(coeff[6], 0.743125 * z * z - 0.247708);
      target.addScaledVector(coeff[7], 2 * 0.429043 * x * z);
      target.addScaledVector(coeff[8], 0.429043 * (x * x - y * y));
      return target;
    }
    add(sh) {
      for (let i = 0; i < 9; i++) {
        this.coefficients[i].add(sh.coefficients[i]);
      }
      return this;
    }
    addScaledSH(sh, s) {
      for (let i = 0; i < 9; i++) {
        this.coefficients[i].addScaledVector(sh.coefficients[i], s);
      }
      return this;
    }
    scale(s) {
      for (let i = 0; i < 9; i++) {
        this.coefficients[i].multiplyScalar(s);
      }
      return this;
    }
    lerp(sh, alpha) {
      for (let i = 0; i < 9; i++) {
        this.coefficients[i].lerp(sh.coefficients[i], alpha);
      }
      return this;
    }
    equals(sh) {
      for (let i = 0; i < 9; i++) {
        if (!this.coefficients[i].equals(sh.coefficients[i])) {
          return false;
        }
      }
      return true;
    }
    copy(sh) {
      return this.set(sh.coefficients);
    }
    clone() {
      return new this.constructor().copy(this);
    }
    fromArray(array, offset = 0) {
      const coefficients = this.coefficients;
      for (let i = 0; i < 9; i++) {
        coefficients[i].fromArray(array, offset + i * 3);
      }
      return this;
    }
    toArray(array = [], offset = 0) {
      const coefficients = this.coefficients;
      for (let i = 0; i < 9; i++) {
        coefficients[i].toArray(array, offset + i * 3);
      }
      return array;
    }
    // evaluate the basis functions
    // shBasis is an Array[ 9 ]
    static getBasisAt(normal, shBasis) {
      const x = normal.x, y = normal.y, z = normal.z;
      shBasis[0] = 0.282095;
      shBasis[1] = 0.488603 * y;
      shBasis[2] = 0.488603 * z;
      shBasis[3] = 0.488603 * x;
      shBasis[4] = 1.092548 * x * y;
      shBasis[5] = 1.092548 * y * z;
      shBasis[6] = 0.315392 * (3 * z * z - 1);
      shBasis[7] = 1.092548 * x * z;
      shBasis[8] = 0.546274 * (x * x - y * y);
    }
  };
  SphericalHarmonics3.prototype.isSphericalHarmonics3 = true;
  var LightProbe = class extends Light {
    constructor(sh = new SphericalHarmonics3(), intensity = 1) {
      super(void 0, intensity);
      this.sh = sh;
    }
    copy(source) {
      super.copy(source);
      this.sh.copy(source.sh);
      return this;
    }
    fromJSON(json) {
      this.intensity = json.intensity;
      this.sh.fromArray(json.sh);
      return this;
    }
    toJSON(meta) {
      const data = super.toJSON(meta);
      data.object.sh = this.sh.toArray();
      return data;
    }
  };
  LightProbe.prototype.isLightProbe = true;
  var LoaderUtils = class {
    static decodeText(array) {
      if (typeof TextDecoder !== "undefined") {
        return new TextDecoder().decode(array);
      }
      let s = "";
      for (let i = 0, il = array.length; i < il; i++) {
        s += String.fromCharCode(array[i]);
      }
      try {
        return decodeURIComponent(escape(s));
      } catch (e) {
        return s;
      }
    }
    static extractUrlBase(url) {
      const index = url.lastIndexOf("/");
      if (index === -1)
        return "./";
      return url.slice(0, index + 1);
    }
    static resolveURL(url, path) {
      if (typeof url !== "string" || url === "")
        return "";
      if (/^https?:\/\//i.test(path) && /^\//.test(url)) {
        path = path.replace(/(^https?:\/\/[^\/]+).*/i, "$1");
      }
      if (/^(https?:)?\/\//i.test(url))
        return url;
      if (/^data:.*,.*$/i.test(url))
        return url;
      if (/^blob:.*$/i.test(url))
        return url;
      return path + url;
    }
  };
  var InstancedBufferGeometry = class extends BufferGeometry {
    constructor() {
      super();
      this.type = "InstancedBufferGeometry";
      this.instanceCount = Infinity;
    }
    copy(source) {
      super.copy(source);
      this.instanceCount = source.instanceCount;
      return this;
    }
    clone() {
      return new this.constructor().copy(this);
    }
    toJSON() {
      const data = super.toJSON(this);
      data.instanceCount = this.instanceCount;
      data.isInstancedBufferGeometry = true;
      return data;
    }
  };
  InstancedBufferGeometry.prototype.isInstancedBufferGeometry = true;
  var ImageBitmapLoader = class extends Loader {
    constructor(manager) {
      super(manager);
      if (typeof createImageBitmap === "undefined") {
        console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported.");
      }
      if (typeof fetch === "undefined") {
        console.warn("THREE.ImageBitmapLoader: fetch() not supported.");
      }
      this.options = { premultiplyAlpha: "none" };
    }
    setOptions(options) {
      this.options = options;
      return this;
    }
    load(url, onLoad, onProgress, onError) {
      if (url === void 0)
        url = "";
      if (this.path !== void 0)
        url = this.path + url;
      url = this.manager.resolveURL(url);
      const scope = this;
      const cached = Cache.get(url);
      if (cached !== void 0) {
        scope.manager.itemStart(url);
        setTimeout(function() {
          if (onLoad)
            onLoad(cached);
          scope.manager.itemEnd(url);
        }, 0);
        return cached;
      }
      const fetchOptions = {};
      fetchOptions.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include";
      fetchOptions.headers = this.requestHeader;
      fetch(url, fetchOptions).then(function(res) {
        return res.blob();
      }).then(function(blob) {
        return createImageBitmap(blob, Object.assign(scope.options, { colorSpaceConversion: "none" }));
      }).then(function(imageBitmap) {
        Cache.add(url, imageBitmap);
        if (onLoad)
          onLoad(imageBitmap);
        scope.manager.itemEnd(url);
      }).catch(function(e) {
        if (onError)
          onError(e);
        scope.manager.itemError(url);
        scope.manager.itemEnd(url);
      });
      scope.manager.itemStart(url);
    }
  };
  ImageBitmapLoader.prototype.isImageBitmapLoader = true;
  var _context;
  var AudioContext = {
    getContext: function() {
      if (_context === void 0) {
        _context = new (window.AudioContext || window.webkitAudioContext)();
      }
      return _context;
    },
    setContext: function(value) {
      _context = value;
    }
  };
  var AudioLoader = class extends Loader {
    constructor(manager) {
      super(manager);
    }
    load(url, onLoad, onProgress, onError) {
      const scope = this;
      const loader = new FileLoader(this.manager);
      loader.setResponseType("arraybuffer");
      loader.setPath(this.path);
      loader.setRequestHeader(this.requestHeader);
      loader.setWithCredentials(this.withCredentials);
      loader.load(url, function(buffer) {
        try {
          const bufferCopy = buffer.slice(0);
          const context = AudioContext.getContext();
          context.decodeAudioData(bufferCopy, function(audioBuffer) {
            onLoad(audioBuffer);
          });
        } catch (e) {
          if (onError) {
            onError(e);
          } else {
            console.error(e);
          }
          scope.manager.itemError(url);
        }
      }, onProgress, onError);
    }
  };
  var HemisphereLightProbe = class extends LightProbe {
    constructor(skyColor, groundColor, intensity = 1) {
      super(void 0, intensity);
      const color1 = new Color().set(skyColor);
      const color2 = new Color().set(groundColor);
      const sky = new Vector3(color1.r, color1.g, color1.b);
      const ground = new Vector3(color2.r, color2.g, color2.b);
      const c0 = Math.sqrt(Math.PI);
      const c1 = c0 * Math.sqrt(0.75);
      this.sh.coefficients[0].copy(sky).add(ground).multiplyScalar(c0);
      this.sh.coefficients[1].copy(sky).sub(ground).multiplyScalar(c1);
    }
  };
  HemisphereLightProbe.prototype.isHemisphereLightProbe = true;
  var AmbientLightProbe = class extends LightProbe {
    constructor(color, intensity = 1) {
      super(void 0, intensity);
      const color1 = new Color().set(color);
      this.sh.coefficients[0].set(color1.r, color1.g, color1.b).multiplyScalar(2 * Math.sqrt(Math.PI));
    }
  };
  AmbientLightProbe.prototype.isAmbientLightProbe = true;
  var Audio = class extends Object3D {
    constructor(listener) {
      super();
      this.type = "Audio";
      this.listener = listener;
      this.context = listener.context;
      this.gain = this.context.createGain();
      this.gain.connect(listener.getInput());
      this.autoplay = false;
      this.buffer = null;
      this.detune = 0;
      this.loop = false;
      this.loopStart = 0;
      this.loopEnd = 0;
      this.offset = 0;
      this.duration = void 0;
      this.playbackRate = 1;
      this.isPlaying = false;
      this.hasPlaybackControl = true;
      this.source = null;
      this.sourceType = "empty";
      this._startedAt = 0;
      this._progress = 0;
      this._connected = false;
      this.filters = [];
    }
    getOutput() {
      return this.gain;
    }
    setNodeSource(audioNode) {
      this.hasPlaybackControl = false;
      this.sourceType = "audioNode";
      this.source = audioNode;
      this.connect();
      return this;
    }
    setMediaElementSource(mediaElement) {
      this.hasPlaybackControl = false;
      this.sourceType = "mediaNode";
      this.source = this.context.createMediaElementSource(mediaElement);
      this.connect();
      return this;
    }
    setMediaStreamSource(mediaStream) {
      this.hasPlaybackControl = false;
      this.sourceType = "mediaStreamNode";
      this.source = this.context.createMediaStreamSource(mediaStream);
      this.connect();
      return this;
    }
    setBuffer(audioBuffer) {
      this.buffer = audioBuffer;
      this.sourceType = "buffer";
      if (this.autoplay)
        this.play();
      return this;
    }
    play(delay = 0) {
      if (this.isPlaying === true) {
        console.warn("THREE.Audio: Audio is already playing.");
        return;
      }
      if (this.hasPlaybackControl === false) {
        console.warn("THREE.Audio: this Audio has no playback control.");
        return;
      }
      this._startedAt = this.context.currentTime + delay;
      const source = this.context.createBufferSource();
      source.buffer = this.buffer;
      source.loop = this.loop;
      source.loopStart = this.loopStart;
      source.loopEnd = this.loopEnd;
      source.onended = this.onEnded.bind(this);
      source.start(this._startedAt, this._progress + this.offset, this.duration);
      this.isPlaying = true;
      this.source = source;
      this.setDetune(this.detune);
      this.setPlaybackRate(this.playbackRate);
      return this.connect();
    }
    pause() {
      if (this.hasPlaybackControl === false) {
        console.warn("THREE.Audio: this Audio has no playback control.");
        return;
      }
      if (this.isPlaying === true) {
        this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate;
        if (this.loop === true) {
          this._progress = this._progress % (this.duration || this.buffer.duration);
        }
        this.source.stop();
        this.source.onended = null;
        this.isPlaying = false;
      }
      return this;
    }
    stop() {
      if (this.hasPlaybackControl === false) {
        console.warn("THREE.Audio: this Audio has no playback control.");
        return;
      }
      this._progress = 0;
      this.source.stop();
      this.source.onended = null;
      this.isPlaying = false;
      return this;
    }
    connect() {
      if (this.filters.length > 0) {
        this.source.connect(this.filters[0]);
        for (let i = 1, l = this.filters.length; i < l; i++) {
          this.filters[i - 1].connect(this.filters[i]);
        }
        this.filters[this.filters.length - 1].connect(this.getOutput());
      } else {
        this.source.connect(this.getOutput());
      }
      this._connected = true;
      return this;
    }
    disconnect() {
      if (this.filters.length > 0) {
        this.source.disconnect(this.filters[0]);
        for (let i = 1, l = this.filters.length; i < l; i++) {
          this.filters[i - 1].disconnect(this.filters[i]);
        }
        this.filters[this.filters.length - 1].disconnect(this.getOutput());
      } else {
        this.source.disconnect(this.getOutput());
      }
      this._connected = false;
      return this;
    }
    getFilters() {
      return this.filters;
    }
    setFilters(value) {
      if (!value)
        value = [];
      if (this._connected === true) {
        this.disconnect();
        this.filters = value.slice();
        this.connect();
      } else {
        this.filters = value.slice();
      }
      return this;
    }
    setDetune(value) {
      this.detune = value;
      if (this.source.detune === void 0)
        return;
      if (this.isPlaying === true) {
        this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01);
      }
      return this;
    }
    getDetune() {
      return this.detune;
    }
    getFilter() {
      return this.getFilters()[0];
    }
    setFilter(filter) {
      return this.setFilters(filter ? [filter] : []);
    }
    setPlaybackRate(value) {
      if (this.hasPlaybackControl === false) {
        console.warn("THREE.Audio: this Audio has no playback control.");
        return;
      }
      this.playbackRate = value;
      if (this.isPlaying === true) {
        this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01);
      }
      return this;
    }
    getPlaybackRate() {
      return this.playbackRate;
    }
    onEnded() {
      this.isPlaying = false;
    }
    getLoop() {
      if (this.hasPlaybackControl === false) {
        console.warn("THREE.Audio: this Audio has no playback control.");
        return false;
      }
      return this.loop;
    }
    setLoop(value) {
      if (this.hasPlaybackControl === false) {
        console.warn("THREE.Audio: this Audio has no playback control.");
        return;
      }
      this.loop = value;
      if (this.isPlaying === true) {
        this.source.loop = this.loop;
      }
      return this;
    }
    setLoopStart(value) {
      this.loopStart = value;
      return this;
    }
    setLoopEnd(value) {
      this.loopEnd = value;
      return this;
    }
    getVolume() {
      return this.gain.gain.value;
    }
    setVolume(value) {
      this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
      return this;
    }
  };
  var AudioAnalyser = class {
    constructor(audio, fftSize = 2048) {
      this.analyser = audio.context.createAnalyser();
      this.analyser.fftSize = fftSize;
      this.data = new Uint8Array(this.analyser.frequencyBinCount);
      audio.getOutput().connect(this.analyser);
    }
    getFrequencyData() {
      this.analyser.getByteFrequencyData(this.data);
      return this.data;
    }
    getAverageFrequency() {
      let value = 0;
      const data = this.getFrequencyData();
      for (let i = 0; i < data.length; i++) {
        value += data[i];
      }
      return value / data.length;
    }
  };
  var PropertyMixer = class {
    constructor(binding, typeName, valueSize) {
      this.binding = binding;
      this.valueSize = valueSize;
      let mixFunction, mixFunctionAdditive, setIdentity;
      switch (typeName) {
        case "quaternion":
          mixFunction = this._slerp;
          mixFunctionAdditive = this._slerpAdditive;
          setIdentity = this._setAdditiveIdentityQuaternion;
          this.buffer = new Float64Array(valueSize * 6);
          this._workIndex = 5;
          break;
        case "string":
        case "bool":
          mixFunction = this._select;
          mixFunctionAdditive = this._select;
          setIdentity = this._setAdditiveIdentityOther;
          this.buffer = new Array(valueSize * 5);
          break;
        default:
          mixFunction = this._lerp;
          mixFunctionAdditive = this._lerpAdditive;
          setIdentity = this._setAdditiveIdentityNumeric;
          this.buffer = new Float64Array(valueSize * 5);
      }
      this._mixBufferRegion = mixFunction;
      this._mixBufferRegionAdditive = mixFunctionAdditive;
      this._setIdentity = setIdentity;
      this._origIndex = 3;
      this._addIndex = 4;
      this.cumulativeWeight = 0;
      this.cumulativeWeightAdditive = 0;
      this.useCount = 0;
      this.referenceCount = 0;
    }
    // accumulate data in the 'incoming' region into 'accu<i>'
    accumulate(accuIndex, weight) {
      const buffer = this.buffer, stride = this.valueSize, offset = accuIndex * stride + stride;
      let currentWeight = this.cumulativeWeight;
      if (currentWeight === 0) {
        for (let i = 0; i !== stride; ++i) {
          buffer[offset + i] = buffer[i];
        }
        currentWeight = weight;
      } else {
        currentWeight += weight;
        const mix = weight / currentWeight;
        this._mixBufferRegion(buffer, offset, 0, mix, stride);
      }
      this.cumulativeWeight = currentWeight;
    }
    // accumulate data in the 'incoming' region into 'add'
    accumulateAdditive(weight) {
      const buffer = this.buffer, stride = this.valueSize, offset = stride * this._addIndex;
      if (this.cumulativeWeightAdditive === 0) {
        this._setIdentity();
      }
      this._mixBufferRegionAdditive(buffer, offset, 0, weight, stride);
      this.cumulativeWeightAdditive += weight;
    }
    // apply the state of 'accu<i>' to the binding when accus differ
    apply(accuIndex) {
      const stride = this.valueSize, buffer = this.buffer, offset = accuIndex * stride + stride, weight = this.cumulativeWeight, weightAdditive = this.cumulativeWeightAdditive, binding = this.binding;
      this.cumulativeWeight = 0;
      this.cumulativeWeightAdditive = 0;
      if (weight < 1) {
        const originalValueOffset = stride * this._origIndex;
        this._mixBufferRegion(
          buffer,
          offset,
          originalValueOffset,
          1 - weight,
          stride
        );
      }
      if (weightAdditive > 0) {
        this._mixBufferRegionAdditive(buffer, offset, this._addIndex * stride, 1, stride);
      }
      for (let i = stride, e = stride + stride; i !== e; ++i) {
        if (buffer[i] !== buffer[i + stride]) {
          binding.setValue(buffer, offset);
          break;
        }
      }
    }
    // remember the state of the bound property and copy it to both accus
    saveOriginalState() {
      const binding = this.binding;
      const buffer = this.buffer, stride = this.valueSize, originalValueOffset = stride * this._origIndex;
      binding.getValue(buffer, originalValueOffset);
      for (let i = stride, e = originalValueOffset; i !== e; ++i) {
        buffer[i] = buffer[originalValueOffset + i % stride];
      }
      this._setIdentity();
      this.cumulativeWeight = 0;
      this.cumulativeWeightAdditive = 0;
    }
    // apply the state previously taken via 'saveOriginalState' to the binding
    restoreOriginalState() {
      const originalValueOffset = this.valueSize * 3;
      this.binding.setValue(this.buffer, originalValueOffset);
    }
    _setAdditiveIdentityNumeric() {
      const startIndex = this._addIndex * this.valueSize;
      const endIndex = startIndex + this.valueSize;
      for (let i = startIndex; i < endIndex; i++) {
        this.buffer[i] = 0;
      }
    }
    _setAdditiveIdentityQuaternion() {
      this._setAdditiveIdentityNumeric();
      this.buffer[this._addIndex * this.valueSize + 3] = 1;
    }
    _setAdditiveIdentityOther() {
      const startIndex = this._origIndex * this.valueSize;
      const targetIndex = this._addIndex * this.valueSize;
      for (let i = 0; i < this.valueSize; i++) {
        this.buffer[targetIndex + i] = this.buffer[startIndex + i];
      }
    }
    // mix functions
    _select(buffer, dstOffset, srcOffset, t, stride) {
      if (t >= 0.5) {
        for (let i = 0; i !== stride; ++i) {
          buffer[dstOffset + i] = buffer[srcOffset + i];
        }
      }
    }
    _slerp(buffer, dstOffset, srcOffset, t) {
      Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t);
    }
    _slerpAdditive(buffer, dstOffset, srcOffset, t, stride) {
      const workOffset = this._workIndex * stride;
      Quaternion.multiplyQuaternionsFlat(buffer, workOffset, buffer, dstOffset, buffer, srcOffset);
      Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, workOffset, t);
    }
    _lerp(buffer, dstOffset, srcOffset, t, stride) {
      const s = 1 - t;
      for (let i = 0; i !== stride; ++i) {
        const j = dstOffset + i;
        buffer[j] = buffer[j] * s + buffer[srcOffset + i] * t;
      }
    }
    _lerpAdditive(buffer, dstOffset, srcOffset, t, stride) {
      for (let i = 0; i !== stride; ++i) {
        const j = dstOffset + i;
        buffer[j] = buffer[j] + buffer[srcOffset + i] * t;
      }
    }
  };
  var _RESERVED_CHARS_RE = "\\[\\]\\.:\\/";
  var _reservedRe = new RegExp("[" + _RESERVED_CHARS_RE + "]", "g");
  var _wordChar = "[^" + _RESERVED_CHARS_RE + "]";
  var _wordCharOrDot = "[^" + _RESERVED_CHARS_RE.replace("\\.", "") + "]";
  var _directoryRe = /((?:WC+[\/:])*)/.source.replace("WC", _wordChar);
  var _nodeRe = /(WCOD+)?/.source.replace("WCOD", _wordCharOrDot);
  var _objectRe = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", _wordChar);
  var _propertyRe = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", _wordChar);
  var _trackRe = new RegExp(
    "^" + _directoryRe + _nodeRe + _objectRe + _propertyRe + "$"
  );
  var _supportedObjectNames = ["material", "materials", "bones"];
  var Composite = class {
    constructor(targetGroup, path, optionalParsedPath) {
      const parsedPath = optionalParsedPath || PropertyBinding.parseTrackName(path);
      this._targetGroup = targetGroup;
      this._bindings = targetGroup.subscribe_(path, parsedPath);
    }
    getValue(array, offset) {
      this.bind();
      const firstValidIndex = this._targetGroup.nCachedObjects_, binding = this._bindings[firstValidIndex];
      if (binding !== void 0)
        binding.getValue(array, offset);
    }
    setValue(array, offset) {
      const bindings = this._bindings;
      for (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
        bindings[i].setValue(array, offset);
      }
    }
    bind() {
      const bindings = this._bindings;
      for (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
        bindings[i].bind();
      }
    }
    unbind() {
      const bindings = this._bindings;
      for (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
        bindings[i].unbind();
      }
    }
  };
  var PropertyBinding = class _PropertyBinding {
    constructor(rootNode, path, parsedPath) {
      this.path = path;
      this.parsedPath = parsedPath || _PropertyBinding.parseTrackName(path);
      this.node = _PropertyBinding.findNode(rootNode, this.parsedPath.nodeName) || rootNode;
      this.rootNode = rootNode;
      this.getValue = this._getValue_unbound;
      this.setValue = this._setValue_unbound;
    }
    static create(root, path, parsedPath) {
      if (!(root && root.isAnimationObjectGroup)) {
        return new _PropertyBinding(root, path, parsedPath);
      } else {
        return new _PropertyBinding.Composite(root, path, parsedPath);
      }
    }
    /**
     * Replaces spaces with underscores and removes unsupported characters from
     * node names, to ensure compatibility with parseTrackName().
     *
     * @param {string} name Node name to be sanitized.
     * @return {string}
     */
    static sanitizeNodeName(name) {
      return name.replace(/\s/g, "_").replace(_reservedRe, "");
    }
    static parseTrackName(trackName) {
      const matches = _trackRe.exec(trackName);
      if (matches === null) {
        throw new Error("PropertyBinding: Cannot parse trackName: " + trackName);
      }
      const results = {
        // directoryName: matches[ 1 ], // (tschw) currently unused
        nodeName: matches[2],
        objectName: matches[3],
        objectIndex: matches[4],
        propertyName: matches[5],
        // required
        propertyIndex: matches[6]
      };
      const lastDot = results.nodeName && results.nodeName.lastIndexOf(".");
      if (lastDot !== void 0 && lastDot !== -1) {
        const objectName = results.nodeName.substring(lastDot + 1);
        if (_supportedObjectNames.indexOf(objectName) !== -1) {
          results.nodeName = results.nodeName.substring(0, lastDot);
          results.objectName = objectName;
        }
      }
      if (results.propertyName === null || results.propertyName.length === 0) {
        throw new Error("PropertyBinding: can not parse propertyName from trackName: " + trackName);
      }
      return results;
    }
    static findNode(root, nodeName) {
      if (nodeName === void 0 || nodeName === "" || nodeName === "." || nodeName === -1 || nodeName === root.name || nodeName === root.uuid) {
        return root;
      }
      if (root.skeleton) {
        const bone = root.skeleton.getBoneByName(nodeName);
        if (bone !== void 0) {
          return bone;
        }
      }
      if (root.children) {
        const searchNodeSubtree = function(children) {
          for (let i = 0; i < children.length; i++) {
            const childNode = children[i];
            if (childNode.name === nodeName || childNode.uuid === nodeName) {
              return childNode;
            }
            const result = searchNodeSubtree(childNode.children);
            if (result)
              return result;
          }
          return null;
        };
        const subTreeNode = searchNodeSubtree(root.children);
        if (subTreeNode) {
          return subTreeNode;
        }
      }
      return null;
    }
    // these are used to "bind" a nonexistent property
    _getValue_unavailable() {
    }
    _setValue_unavailable() {
    }
    // Getters
    _getValue_direct(buffer, offset) {
      buffer[offset] = this.targetObject[this.propertyName];
    }
    _getValue_array(buffer, offset) {
      const source = this.resolvedProperty;
      for (let i = 0, n = source.length; i !== n; ++i) {
        buffer[offset++] = source[i];
      }
    }
    _getValue_arrayElement(buffer, offset) {
      buffer[offset] = this.resolvedProperty[this.propertyIndex];
    }
    _getValue_toArray(buffer, offset) {
      this.resolvedProperty.toArray(buffer, offset);
    }
    // Direct
    _setValue_direct(buffer, offset) {
      this.targetObject[this.propertyName] = buffer[offset];
    }
    _setValue_direct_setNeedsUpdate(buffer, offset) {
      this.targetObject[this.propertyName] = buffer[offset];
      this.targetObject.needsUpdate = true;
    }
    _setValue_direct_setMatrixWorldNeedsUpdate(buffer, offset) {
      this.targetObject[this.propertyName] = buffer[offset];
      this.targetObject.matrixWorldNeedsUpdate = true;
    }
    // EntireArray
    _setValue_array(buffer, offset) {
      const dest = this.resolvedProperty;
      for (let i = 0, n = dest.length; i !== n; ++i) {
        dest[i] = buffer[offset++];
      }
    }
    _setValue_array_setNeedsUpdate(buffer, offset) {
      const dest = this.resolvedProperty;
      for (let i = 0, n = dest.length; i !== n; ++i) {
        dest[i] = buffer[offset++];
      }
      this.targetObject.needsUpdate = true;
    }
    _setValue_array_setMatrixWorldNeedsUpdate(buffer, offset) {
      const dest = this.resolvedProperty;
      for (let i = 0, n = dest.length; i !== n; ++i) {
        dest[i] = buffer[offset++];
      }
      this.targetObject.matrixWorldNeedsUpdate = true;
    }
    // ArrayElement
    _setValue_arrayElement(buffer, offset) {
      this.resolvedProperty[this.propertyIndex] = buffer[offset];
    }
    _setValue_arrayElement_setNeedsUpdate(buffer, offset) {
      this.resolvedProperty[this.propertyIndex] = buffer[offset];
      this.targetObject.needsUpdate = true;
    }
    _setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer, offset) {
      this.resolvedProperty[this.propertyIndex] = buffer[offset];
      this.targetObject.matrixWorldNeedsUpdate = true;
    }
    // HasToFromArray
    _setValue_fromArray(buffer, offset) {
      this.resolvedProperty.fromArray(buffer, offset);
    }
    _setValue_fromArray_setNeedsUpdate(buffer, offset) {
      this.resolvedProperty.fromArray(buffer, offset);
      this.targetObject.needsUpdate = true;
    }
    _setValue_fromArray_setMatrixWorldNeedsUpdate(buffer, offset) {
      this.resolvedProperty.fromArray(buffer, offset);
      this.targetObject.matrixWorldNeedsUpdate = true;
    }
    _getValue_unbound(targetArray, offset) {
      this.bind();
      this.getValue(targetArray, offset);
    }
    _setValue_unbound(sourceArray, offset) {
      this.bind();
      this.setValue(sourceArray, offset);
    }
    // create getter / setter pair for a property in the scene graph
    bind() {
      let targetObject = this.node;
      const parsedPath = this.parsedPath;
      const objectName = parsedPath.objectName;
      const propertyName = parsedPath.propertyName;
      let propertyIndex = parsedPath.propertyIndex;
      if (!targetObject) {
        targetObject = _PropertyBinding.findNode(this.rootNode, parsedPath.nodeName) || this.rootNode;
        this.node = targetObject;
      }
      this.getValue = this._getValue_unavailable;
      this.setValue = this._setValue_unavailable;
      if (!targetObject) {
        console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
        return;
      }
      if (objectName) {
        let objectIndex = parsedPath.objectIndex;
        switch (objectName) {
          case "materials":
            if (!targetObject.material) {
              console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
              return;
            }
            if (!targetObject.material.materials) {
              console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
              return;
            }
            targetObject = targetObject.material.materials;
            break;
          case "bones":
            if (!targetObject.skeleton) {
              console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
              return;
            }
            targetObject = targetObject.skeleton.bones;
            for (let i = 0; i < targetObject.length; i++) {
              if (targetObject[i].name === objectIndex) {
                objectIndex = i;
                break;
              }
            }
            break;
          default:
            if (targetObject[objectName] === void 0) {
              console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
              return;
            }
            targetObject = targetObject[objectName];
        }
        if (objectIndex !== void 0) {
          if (targetObject[objectIndex] === void 0) {
            console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, targetObject);
            return;
          }
          targetObject = targetObject[objectIndex];
        }
      }
      const nodeProperty = targetObject[propertyName];
      if (nodeProperty === void 0) {
        const nodeName = parsedPath.nodeName;
        console.error("THREE.PropertyBinding: Trying to update property for track: " + nodeName + "." + propertyName + " but it wasn't found.", targetObject);
        return;
      }
      let versioning = this.Versioning.None;
      this.targetObject = targetObject;
      if (targetObject.needsUpdate !== void 0) {
        versioning = this.Versioning.NeedsUpdate;
      } else if (targetObject.matrixWorldNeedsUpdate !== void 0) {
        versioning = this.Versioning.MatrixWorldNeedsUpdate;
      }
      let bindingType = this.BindingType.Direct;
      if (propertyIndex !== void 0) {
        if (propertyName === "morphTargetInfluences") {
          if (!targetObject.geometry) {
            console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
            return;
          }
          if (targetObject.geometry.isBufferGeometry) {
            if (!targetObject.geometry.morphAttributes) {
              console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
              return;
            }
            if (targetObject.morphTargetDictionary[propertyIndex] !== void 0) {
              propertyIndex = targetObject.morphTargetDictionary[propertyIndex];
            }
          } else {
            console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.", this);
            return;
          }
        }
        bindingType = this.BindingType.ArrayElement;
        this.resolvedProperty = nodeProperty;
        this.propertyIndex = propertyIndex;
      } else if (nodeProperty.fromArray !== void 0 && nodeProperty.toArray !== void 0) {
        bindingType = this.BindingType.HasFromToArray;
        this.resolvedProperty = nodeProperty;
      } else if (Array.isArray(nodeProperty)) {
        bindingType = this.BindingType.EntireArray;
        this.resolvedProperty = nodeProperty;
      } else {
        this.propertyName = propertyName;
      }
      this.getValue = this.GetterByBindingType[bindingType];
      this.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning];
    }
    unbind() {
      this.node = null;
      this.getValue = this._getValue_unbound;
      this.setValue = this._setValue_unbound;
    }
  };
  PropertyBinding.Composite = Composite;
  PropertyBinding.prototype.BindingType = {
    Direct: 0,
    EntireArray: 1,
    ArrayElement: 2,
    HasFromToArray: 3
  };
  PropertyBinding.prototype.Versioning = {
    None: 0,
    NeedsUpdate: 1,
    MatrixWorldNeedsUpdate: 2
  };
  PropertyBinding.prototype.GetterByBindingType = [
    PropertyBinding.prototype._getValue_direct,
    PropertyBinding.prototype._getValue_array,
    PropertyBinding.prototype._getValue_arrayElement,
    PropertyBinding.prototype._getValue_toArray
  ];
  PropertyBinding.prototype.SetterByBindingTypeAndVersioning = [
    [
      // Direct
      PropertyBinding.prototype._setValue_direct,
      PropertyBinding.prototype._setValue_direct_setNeedsUpdate,
      PropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate
    ],
    [
      // EntireArray
      PropertyBinding.prototype._setValue_array,
      PropertyBinding.prototype._setValue_array_setNeedsUpdate,
      PropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate
    ],
    [
      // ArrayElement
      PropertyBinding.prototype._setValue_arrayElement,
      PropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate,
      PropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate
    ],
    [
      // HasToFromArray
      PropertyBinding.prototype._setValue_fromArray,
      PropertyBinding.prototype._setValue_fromArray_setNeedsUpdate,
      PropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate
    ]
  ];
  var AnimationObjectGroup = class {
    constructor() {
      this.uuid = generateUUID();
      this._objects = Array.prototype.slice.call(arguments);
      this.nCachedObjects_ = 0;
      const indices = {};
      this._indicesByUUID = indices;
      for (let i = 0, n = arguments.length; i !== n; ++i) {
        indices[arguments[i].uuid] = i;
      }
      this._paths = [];
      this._parsedPaths = [];
      this._bindings = [];
      this._bindingsIndicesByPath = {};
      const scope = this;
      this.stats = {
        objects: {
          get total() {
            return scope._objects.length;
          },
          get inUse() {
            return this.total - scope.nCachedObjects_;
          }
        },
        get bindingsPerObject() {
          return scope._bindings.length;
        }
      };
    }
    add() {
      const objects = this._objects, indicesByUUID = this._indicesByUUID, paths = this._paths, parsedPaths = this._parsedPaths, bindings = this._bindings, nBindings = bindings.length;
      let knownObject = void 0, nObjects = objects.length, nCachedObjects = this.nCachedObjects_;
      for (let i = 0, n = arguments.length; i !== n; ++i) {
        const object = arguments[i], uuid2 = object.uuid;
        let index = indicesByUUID[uuid2];
        if (index === void 0) {
          index = nObjects++;
          indicesByUUID[uuid2] = index;
          objects.push(object);
          for (let j = 0, m = nBindings; j !== m; ++j) {
            bindings[j].push(new PropertyBinding(object, paths[j], parsedPaths[j]));
          }
        } else if (index < nCachedObjects) {
          knownObject = objects[index];
          const firstActiveIndex = --nCachedObjects, lastCachedObject = objects[firstActiveIndex];
          indicesByUUID[lastCachedObject.uuid] = index;
          objects[index] = lastCachedObject;
          indicesByUUID[uuid2] = firstActiveIndex;
          objects[firstActiveIndex] = object;
          for (let j = 0, m = nBindings; j !== m; ++j) {
            const bindingsForPath = bindings[j], lastCached = bindingsForPath[firstActiveIndex];
            let binding = bindingsForPath[index];
            bindingsForPath[index] = lastCached;
            if (binding === void 0) {
              binding = new PropertyBinding(object, paths[j], parsedPaths[j]);
            }
            bindingsForPath[firstActiveIndex] = binding;
          }
        } else if (objects[index] !== knownObject) {
          console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.");
        }
      }
      this.nCachedObjects_ = nCachedObjects;
    }
    remove() {
      const objects = this._objects, indicesByUUID = this._indicesByUUID, bindings = this._bindings, nBindings = bindings.length;
      let nCachedObjects = this.nCachedObjects_;
      for (let i = 0, n = arguments.length; i !== n; ++i) {
        const object = arguments[i], uuid2 = object.uuid, index = indicesByUUID[uuid2];
        if (index !== void 0 && index >= nCachedObjects) {
          const lastCachedIndex = nCachedObjects++, firstActiveObject = objects[lastCachedIndex];
          indicesByUUID[firstActiveObject.uuid] = index;
          objects[index] = firstActiveObject;
          indicesByUUID[uuid2] = lastCachedIndex;
          objects[lastCachedIndex] = object;
          for (let j = 0, m = nBindings; j !== m; ++j) {
            const bindingsForPath = bindings[j], firstActive = bindingsForPath[lastCachedIndex], binding = bindingsForPath[index];
            bindingsForPath[index] = firstActive;
            bindingsForPath[lastCachedIndex] = binding;
          }
        }
      }
      this.nCachedObjects_ = nCachedObjects;
    }
    // remove & forget
    uncache() {
      const objects = this._objects, indicesByUUID = this._indicesByUUID, bindings = this._bindings, nBindings = bindings.length;
      let nCachedObjects = this.nCachedObjects_, nObjects = objects.length;
      for (let i = 0, n = arguments.length; i !== n; ++i) {
        const object = arguments[i], uuid2 = object.uuid, index = indicesByUUID[uuid2];
        if (index !== void 0) {
          delete indicesByUUID[uuid2];
          if (index < nCachedObjects) {
            const firstActiveIndex = --nCachedObjects, lastCachedObject = objects[firstActiveIndex], lastIndex = --nObjects, lastObject = objects[lastIndex];
            indicesByUUID[lastCachedObject.uuid] = index;
            objects[index] = lastCachedObject;
            indicesByUUID[lastObject.uuid] = firstActiveIndex;
            objects[firstActiveIndex] = lastObject;
            objects.pop();
            for (let j = 0, m = nBindings; j !== m; ++j) {
              const bindingsForPath = bindings[j], lastCached = bindingsForPath[firstActiveIndex], last = bindingsForPath[lastIndex];
              bindingsForPath[index] = lastCached;
              bindingsForPath[firstActiveIndex] = last;
              bindingsForPath.pop();
            }
          } else {
            const lastIndex = --nObjects, lastObject = objects[lastIndex];
            if (lastIndex > 0) {
              indicesByUUID[lastObject.uuid] = index;
            }
            objects[index] = lastObject;
            objects.pop();
            for (let j = 0, m = nBindings; j !== m; ++j) {
              const bindingsForPath = bindings[j];
              bindingsForPath[index] = bindingsForPath[lastIndex];
              bindingsForPath.pop();
            }
          }
        }
      }
      this.nCachedObjects_ = nCachedObjects;
    }
    // Internal interface used by befriended PropertyBinding.Composite:
    subscribe_(path, parsedPath) {
      const indicesByPath = this._bindingsIndicesByPath;
      let index = indicesByPath[path];
      const bindings = this._bindings;
      if (index !== void 0)
        return bindings[index];
      const paths = this._paths, parsedPaths = this._parsedPaths, objects = this._objects, nObjects = objects.length, nCachedObjects = this.nCachedObjects_, bindingsForPath = new Array(nObjects);
      index = bindings.length;
      indicesByPath[path] = index;
      paths.push(path);
      parsedPaths.push(parsedPath);
      bindings.push(bindingsForPath);
      for (let i = nCachedObjects, n = objects.length; i !== n; ++i) {
        const object = objects[i];
        bindingsForPath[i] = new PropertyBinding(object, path, parsedPath);
      }
      return bindingsForPath;
    }
    unsubscribe_(path) {
      const indicesByPath = this._bindingsIndicesByPath, index = indicesByPath[path];
      if (index !== void 0) {
        const paths = this._paths, parsedPaths = this._parsedPaths, bindings = this._bindings, lastBindingsIndex = bindings.length - 1, lastBindings = bindings[lastBindingsIndex], lastBindingsPath = path[lastBindingsIndex];
        indicesByPath[lastBindingsPath] = index;
        bindings[index] = lastBindings;
        bindings.pop();
        parsedPaths[index] = parsedPaths[lastBindingsIndex];
        parsedPaths.pop();
        paths[index] = paths[lastBindingsIndex];
        paths.pop();
      }
    }
  };
  AnimationObjectGroup.prototype.isAnimationObjectGroup = true;
  var AnimationAction = class {
    constructor(mixer, clip, localRoot = null, blendMode = clip.blendMode) {
      this._mixer = mixer;
      this._clip = clip;
      this._localRoot = localRoot;
      this.blendMode = blendMode;
      const tracks = clip.tracks, nTracks = tracks.length, interpolants = new Array(nTracks);
      const interpolantSettings = {
        endingStart: ZeroCurvatureEnding,
        endingEnd: ZeroCurvatureEnding
      };
      for (let i = 0; i !== nTracks; ++i) {
        const interpolant = tracks[i].createInterpolant(null);
        interpolants[i] = interpolant;
        interpolant.settings = interpolantSettings;
      }
      this._interpolantSettings = interpolantSettings;
      this._interpolants = interpolants;
      this._propertyBindings = new Array(nTracks);
      this._cacheIndex = null;
      this._byClipCacheIndex = null;
      this._timeScaleInterpolant = null;
      this._weightInterpolant = null;
      this.loop = LoopRepeat;
      this._loopCount = -1;
      this._startTime = null;
      this.time = 0;
      this.timeScale = 1;
      this._effectiveTimeScale = 1;
      this.weight = 1;
      this._effectiveWeight = 1;
      this.repetitions = Infinity;
      this.paused = false;
      this.enabled = true;
      this.clampWhenFinished = false;
      this.zeroSlopeAtStart = true;
      this.zeroSlopeAtEnd = true;
    }
    // State & Scheduling
    play() {
      this._mixer._activateAction(this);
      return this;
    }
    stop() {
      this._mixer._deactivateAction(this);
      return this.reset();
    }
    reset() {
      this.paused = false;
      this.enabled = true;
      this.time = 0;
      this._loopCount = -1;
      this._startTime = null;
      return this.stopFading().stopWarping();
    }
    isRunning() {
      return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
    }
    // return true when play has been called
    isScheduled() {
      return this._mixer._isActiveAction(this);
    }
    startAt(time) {
      this._startTime = time;
      return this;
    }
    setLoop(mode, repetitions) {
      this.loop = mode;
      this.repetitions = repetitions;
      return this;
    }
    // Weight
    // set the weight stopping any scheduled fading
    // although .enabled = false yields an effective weight of zero, this
    // method does *not* change .enabled, because it would be confusing
    setEffectiveWeight(weight) {
      this.weight = weight;
      this._effectiveWeight = this.enabled ? weight : 0;
      return this.stopFading();
    }
    // return the weight considering fading and .enabled
    getEffectiveWeight() {
      return this._effectiveWeight;
    }
    fadeIn(duration) {
      return this._scheduleFading(duration, 0, 1);
    }
    fadeOut(duration) {
      return this._scheduleFading(duration, 1, 0);
    }
    crossFadeFrom(fadeOutAction, duration, warp) {
      fadeOutAction.fadeOut(duration);
      this.fadeIn(duration);
      if (warp) {
        const fadeInDuration = this._clip.duration, fadeOutDuration = fadeOutAction._clip.duration, startEndRatio = fadeOutDuration / fadeInDuration, endStartRatio = fadeInDuration / fadeOutDuration;
        fadeOutAction.warp(1, startEndRatio, duration);
        this.warp(endStartRatio, 1, duration);
      }
      return this;
    }
    crossFadeTo(fadeInAction, duration, warp) {
      return fadeInAction.crossFadeFrom(this, duration, warp);
    }
    stopFading() {
      const weightInterpolant = this._weightInterpolant;
      if (weightInterpolant !== null) {
        this._weightInterpolant = null;
        this._mixer._takeBackControlInterpolant(weightInterpolant);
      }
      return this;
    }
    // Time Scale Control
    // set the time scale stopping any scheduled warping
    // although .paused = true yields an effective time scale of zero, this
    // method does *not* change .paused, because it would be confusing
    setEffectiveTimeScale(timeScale) {
      this.timeScale = timeScale;
      this._effectiveTimeScale = this.paused ? 0 : timeScale;
      return this.stopWarping();
    }
    // return the time scale considering warping and .paused
    getEffectiveTimeScale() {
      return this._effectiveTimeScale;
    }
    setDuration(duration) {
      this.timeScale = this._clip.duration / duration;
      return this.stopWarping();
    }
    syncWith(action) {
      this.time = action.time;
      this.timeScale = action.timeScale;
      return this.stopWarping();
    }
    halt(duration) {
      return this.warp(this._effectiveTimeScale, 0, duration);
    }
    warp(startTimeScale, endTimeScale, duration) {
      const mixer = this._mixer, now3 = mixer.time, timeScale = this.timeScale;
      let interpolant = this._timeScaleInterpolant;
      if (interpolant === null) {
        interpolant = mixer._lendControlInterpolant();
        this._timeScaleInterpolant = interpolant;
      }
      const times = interpolant.parameterPositions, values = interpolant.sampleValues;
      times[0] = now3;
      times[1] = now3 + duration;
      values[0] = startTimeScale / timeScale;
      values[1] = endTimeScale / timeScale;
      return this;
    }
    stopWarping() {
      const timeScaleInterpolant = this._timeScaleInterpolant;
      if (timeScaleInterpolant !== null) {
        this._timeScaleInterpolant = null;
        this._mixer._takeBackControlInterpolant(timeScaleInterpolant);
      }
      return this;
    }
    // Object Accessors
    getMixer() {
      return this._mixer;
    }
    getClip() {
      return this._clip;
    }
    getRoot() {
      return this._localRoot || this._mixer._root;
    }
    // Interna
    _update(time, deltaTime, timeDirection, accuIndex) {
      if (!this.enabled) {
        this._updateWeight(time);
        return;
      }
      const startTime = this._startTime;
      if (startTime !== null) {
        const timeRunning = (time - startTime) * timeDirection;
        if (timeRunning < 0 || timeDirection === 0) {
          return;
        }
        this._startTime = null;
        deltaTime = timeDirection * timeRunning;
      }
      deltaTime *= this._updateTimeScale(time);
      const clipTime = this._updateTime(deltaTime);
      const weight = this._updateWeight(time);
      if (weight > 0) {
        const interpolants = this._interpolants;
        const propertyMixers = this._propertyBindings;
        switch (this.blendMode) {
          case AdditiveAnimationBlendMode:
            for (let j = 0, m = interpolants.length; j !== m; ++j) {
              interpolants[j].evaluate(clipTime);
              propertyMixers[j].accumulateAdditive(weight);
            }
            break;
          case NormalAnimationBlendMode:
          default:
            for (let j = 0, m = interpolants.length; j !== m; ++j) {
              interpolants[j].evaluate(clipTime);
              propertyMixers[j].accumulate(accuIndex, weight);
            }
        }
      }
    }
    _updateWeight(time) {
      let weight = 0;
      if (this.enabled) {
        weight = this.weight;
        const interpolant = this._weightInterpolant;
        if (interpolant !== null) {
          const interpolantValue = interpolant.evaluate(time)[0];
          weight *= interpolantValue;
          if (time > interpolant.parameterPositions[1]) {
            this.stopFading();
            if (interpolantValue === 0) {
              this.enabled = false;
            }
          }
        }
      }
      this._effectiveWeight = weight;
      return weight;
    }
    _updateTimeScale(time) {
      let timeScale = 0;
      if (!this.paused) {
        timeScale = this.timeScale;
        const interpolant = this._timeScaleInterpolant;
        if (interpolant !== null) {
          const interpolantValue = interpolant.evaluate(time)[0];
          timeScale *= interpolantValue;
          if (time > interpolant.parameterPositions[1]) {
            this.stopWarping();
            if (timeScale === 0) {
              this.paused = true;
            } else {
              this.timeScale = timeScale;
            }
          }
        }
      }
      this._effectiveTimeScale = timeScale;
      return timeScale;
    }
    _updateTime(deltaTime) {
      const duration = this._clip.duration;
      const loop = this.loop;
      let time = this.time + deltaTime;
      let loopCount = this._loopCount;
      const pingPong = loop === LoopPingPong;
      if (deltaTime === 0) {
        if (loopCount === -1)
          return time;
        return pingPong && (loopCount & 1) === 1 ? duration - time : time;
      }
      if (loop === LoopOnce) {
        if (loopCount === -1) {
          this._loopCount = 0;
          this._setEndings(true, true, false);
        }
        handle_stop: {
          if (time >= duration) {
            time = duration;
          } else if (time < 0) {
            time = 0;
          } else {
            this.time = time;
            break handle_stop;
          }
          if (this.clampWhenFinished)
            this.paused = true;
          else
            this.enabled = false;
          this.time = time;
          this._mixer.dispatchEvent({
            type: "finished",
            action: this,
            direction: deltaTime < 0 ? -1 : 1
          });
        }
      } else {
        if (loopCount === -1) {
          if (deltaTime >= 0) {
            loopCount = 0;
            this._setEndings(true, this.repetitions === 0, pingPong);
          } else {
            this._setEndings(this.repetitions === 0, true, pingPong);
          }
        }
        if (time >= duration || time < 0) {
          const loopDelta = Math.floor(time / duration);
          time -= duration * loopDelta;
          loopCount += Math.abs(loopDelta);
          const pending = this.repetitions - loopCount;
          if (pending <= 0) {
            if (this.clampWhenFinished)
              this.paused = true;
            else
              this.enabled = false;
            time = deltaTime > 0 ? duration : 0;
            this.time = time;
            this._mixer.dispatchEvent({
              type: "finished",
              action: this,
              direction: deltaTime > 0 ? 1 : -1
            });
          } else {
            if (pending === 1) {
              const atStart = deltaTime < 0;
              this._setEndings(atStart, !atStart, pingPong);
            } else {
              this._setEndings(false, false, pingPong);
            }
            this._loopCount = loopCount;
            this.time = time;
            this._mixer.dispatchEvent({
              type: "loop",
              action: this,
              loopDelta
            });
          }
        } else {
          this.time = time;
        }
        if (pingPong && (loopCount & 1) === 1) {
          return duration - time;
        }
      }
      return time;
    }
    _setEndings(atStart, atEnd, pingPong) {
      const settings = this._interpolantSettings;
      if (pingPong) {
        settings.endingStart = ZeroSlopeEnding;
        settings.endingEnd = ZeroSlopeEnding;
      } else {
        if (atStart) {
          settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;
        } else {
          settings.endingStart = WrapAroundEnding;
        }
        if (atEnd) {
          settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;
        } else {
          settings.endingEnd = WrapAroundEnding;
        }
      }
    }
    _scheduleFading(duration, weightNow, weightThen) {
      const mixer = this._mixer, now3 = mixer.time;
      let interpolant = this._weightInterpolant;
      if (interpolant === null) {
        interpolant = mixer._lendControlInterpolant();
        this._weightInterpolant = interpolant;
      }
      const times = interpolant.parameterPositions, values = interpolant.sampleValues;
      times[0] = now3;
      values[0] = weightNow;
      times[1] = now3 + duration;
      values[1] = weightThen;
      return this;
    }
  };
  var AnimationMixer = class extends EventDispatcher {
    constructor(root) {
      super();
      this._root = root;
      this._initMemoryManager();
      this._accuIndex = 0;
      this.time = 0;
      this.timeScale = 1;
    }
    _bindAction(action, prototypeAction) {
      const root = action._localRoot || this._root, tracks = action._clip.tracks, nTracks = tracks.length, bindings = action._propertyBindings, interpolants = action._interpolants, rootUuid = root.uuid, bindingsByRoot = this._bindingsByRootAndName;
      let bindingsByName = bindingsByRoot[rootUuid];
      if (bindingsByName === void 0) {
        bindingsByName = {};
        bindingsByRoot[rootUuid] = bindingsByName;
      }
      for (let i = 0; i !== nTracks; ++i) {
        const track = tracks[i], trackName = track.name;
        let binding = bindingsByName[trackName];
        if (binding !== void 0) {
          ++binding.referenceCount;
          bindings[i] = binding;
        } else {
          binding = bindings[i];
          if (binding !== void 0) {
            if (binding._cacheIndex === null) {
              ++binding.referenceCount;
              this._addInactiveBinding(binding, rootUuid, trackName);
            }
            continue;
          }
          const path = prototypeAction && prototypeAction._propertyBindings[i].binding.parsedPath;
          binding = new PropertyMixer(
            PropertyBinding.create(root, trackName, path),
            track.ValueTypeName,
            track.getValueSize()
          );
          ++binding.referenceCount;
          this._addInactiveBinding(binding, rootUuid, trackName);
          bindings[i] = binding;
        }
        interpolants[i].resultBuffer = binding.buffer;
      }
    }
    _activateAction(action) {
      if (!this._isActiveAction(action)) {
        if (action._cacheIndex === null) {
          const rootUuid = (action._localRoot || this._root).uuid, clipUuid = action._clip.uuid, actionsForClip = this._actionsByClip[clipUuid];
          this._bindAction(
            action,
            actionsForClip && actionsForClip.knownActions[0]
          );
          this._addInactiveAction(action, clipUuid, rootUuid);
        }
        const bindings = action._propertyBindings;
        for (let i = 0, n = bindings.length; i !== n; ++i) {
          const binding = bindings[i];
          if (binding.useCount++ === 0) {
            this._lendBinding(binding);
            binding.saveOriginalState();
          }
        }
        this._lendAction(action);
      }
    }
    _deactivateAction(action) {
      if (this._isActiveAction(action)) {
        const bindings = action._propertyBindings;
        for (let i = 0, n = bindings.length; i !== n; ++i) {
          const binding = bindings[i];
          if (--binding.useCount === 0) {
            binding.restoreOriginalState();
            this._takeBackBinding(binding);
          }
        }
        this._takeBackAction(action);
      }
    }
    // Memory manager
    _initMemoryManager() {
      this._actions = [];
      this._nActiveActions = 0;
      this._actionsByClip = {};
      this._bindings = [];
      this._nActiveBindings = 0;
      this._bindingsByRootAndName = {};
      this._controlInterpolants = [];
      this._nActiveControlInterpolants = 0;
      const scope = this;
      this.stats = {
        actions: {
          get total() {
            return scope._actions.length;
          },
          get inUse() {
            return scope._nActiveActions;
          }
        },
        bindings: {
          get total() {
            return scope._bindings.length;
          },
          get inUse() {
            return scope._nActiveBindings;
          }
        },
        controlInterpolants: {
          get total() {
            return scope._controlInterpolants.length;
          },
          get inUse() {
            return scope._nActiveControlInterpolants;
          }
        }
      };
    }
    // Memory management for AnimationAction objects
    _isActiveAction(action) {
      const index = action._cacheIndex;
      return index !== null && index < this._nActiveActions;
    }
    _addInactiveAction(action, clipUuid, rootUuid) {
      const actions = this._actions, actionsByClip = this._actionsByClip;
      let actionsForClip = actionsByClip[clipUuid];
      if (actionsForClip === void 0) {
        actionsForClip = {
          knownActions: [action],
          actionByRoot: {}
        };
        action._byClipCacheIndex = 0;
        actionsByClip[clipUuid] = actionsForClip;
      } else {
        const knownActions = actionsForClip.knownActions;
        action._byClipCacheIndex = knownActions.length;
        knownActions.push(action);
      }
      action._cacheIndex = actions.length;
      actions.push(action);
      actionsForClip.actionByRoot[rootUuid] = action;
    }
    _removeInactiveAction(action) {
      const actions = this._actions, lastInactiveAction = actions[actions.length - 1], cacheIndex = action._cacheIndex;
      lastInactiveAction._cacheIndex = cacheIndex;
      actions[cacheIndex] = lastInactiveAction;
      actions.pop();
      action._cacheIndex = null;
      const clipUuid = action._clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid], knownActionsForClip = actionsForClip.knownActions, lastKnownAction = knownActionsForClip[knownActionsForClip.length - 1], byClipCacheIndex = action._byClipCacheIndex;
      lastKnownAction._byClipCacheIndex = byClipCacheIndex;
      knownActionsForClip[byClipCacheIndex] = lastKnownAction;
      knownActionsForClip.pop();
      action._byClipCacheIndex = null;
      const actionByRoot = actionsForClip.actionByRoot, rootUuid = (action._localRoot || this._root).uuid;
      delete actionByRoot[rootUuid];
      if (knownActionsForClip.length === 0) {
        delete actionsByClip[clipUuid];
      }
      this._removeInactiveBindingsForAction(action);
    }
    _removeInactiveBindingsForAction(action) {
      const bindings = action._propertyBindings;
      for (let i = 0, n = bindings.length; i !== n; ++i) {
        const binding = bindings[i];
        if (--binding.referenceCount === 0) {
          this._removeInactiveBinding(binding);
        }
      }
    }
    _lendAction(action) {
      const actions = this._actions, prevIndex = action._cacheIndex, lastActiveIndex = this._nActiveActions++, firstInactiveAction = actions[lastActiveIndex];
      action._cacheIndex = lastActiveIndex;
      actions[lastActiveIndex] = action;
      firstInactiveAction._cacheIndex = prevIndex;
      actions[prevIndex] = firstInactiveAction;
    }
    _takeBackAction(action) {
      const actions = this._actions, prevIndex = action._cacheIndex, firstInactiveIndex = --this._nActiveActions, lastActiveAction = actions[firstInactiveIndex];
      action._cacheIndex = firstInactiveIndex;
      actions[firstInactiveIndex] = action;
      lastActiveAction._cacheIndex = prevIndex;
      actions[prevIndex] = lastActiveAction;
    }
    // Memory management for PropertyMixer objects
    _addInactiveBinding(binding, rootUuid, trackName) {
      const bindingsByRoot = this._bindingsByRootAndName, bindings = this._bindings;
      let bindingByName = bindingsByRoot[rootUuid];
      if (bindingByName === void 0) {
        bindingByName = {};
        bindingsByRoot[rootUuid] = bindingByName;
      }
      bindingByName[trackName] = binding;
      binding._cacheIndex = bindings.length;
      bindings.push(binding);
    }
    _removeInactiveBinding(binding) {
      const bindings = this._bindings, propBinding = binding.binding, rootUuid = propBinding.rootNode.uuid, trackName = propBinding.path, bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid], lastInactiveBinding = bindings[bindings.length - 1], cacheIndex = binding._cacheIndex;
      lastInactiveBinding._cacheIndex = cacheIndex;
      bindings[cacheIndex] = lastInactiveBinding;
      bindings.pop();
      delete bindingByName[trackName];
      if (Object.keys(bindingByName).length === 0) {
        delete bindingsByRoot[rootUuid];
      }
    }
    _lendBinding(binding) {
      const bindings = this._bindings, prevIndex = binding._cacheIndex, lastActiveIndex = this._nActiveBindings++, firstInactiveBinding = bindings[lastActiveIndex];
      binding._cacheIndex = lastActiveIndex;
      bindings[lastActiveIndex] = binding;
      firstInactiveBinding._cacheIndex = prevIndex;
      bindings[prevIndex] = firstInactiveBinding;
    }
    _takeBackBinding(binding) {
      const bindings = this._bindings, prevIndex = binding._cacheIndex, firstInactiveIndex = --this._nActiveBindings, lastActiveBinding = bindings[firstInactiveIndex];
      binding._cacheIndex = firstInactiveIndex;
      bindings[firstInactiveIndex] = binding;
      lastActiveBinding._cacheIndex = prevIndex;
      bindings[prevIndex] = lastActiveBinding;
    }
    // Memory management of Interpolants for weight and time scale
    _lendControlInterpolant() {
      const interpolants = this._controlInterpolants, lastActiveIndex = this._nActiveControlInterpolants++;
      let interpolant = interpolants[lastActiveIndex];
      if (interpolant === void 0) {
        interpolant = new LinearInterpolant(
          new Float32Array(2),
          new Float32Array(2),
          1,
          this._controlInterpolantsResultBuffer
        );
        interpolant.__cacheIndex = lastActiveIndex;
        interpolants[lastActiveIndex] = interpolant;
      }
      return interpolant;
    }
    _takeBackControlInterpolant(interpolant) {
      const interpolants = this._controlInterpolants, prevIndex = interpolant.__cacheIndex, firstInactiveIndex = --this._nActiveControlInterpolants, lastActiveInterpolant = interpolants[firstInactiveIndex];
      interpolant.__cacheIndex = firstInactiveIndex;
      interpolants[firstInactiveIndex] = interpolant;
      lastActiveInterpolant.__cacheIndex = prevIndex;
      interpolants[prevIndex] = lastActiveInterpolant;
    }
    // return an action for a clip optionally using a custom root target
    // object (this method allocates a lot of dynamic memory in case a
    // previously unknown clip/root combination is specified)
    clipAction(clip, optionalRoot, blendMode) {
      const root = optionalRoot || this._root, rootUuid = root.uuid;
      let clipObject = typeof clip === "string" ? AnimationClip.findByName(root, clip) : clip;
      const clipUuid = clipObject !== null ? clipObject.uuid : clip;
      const actionsForClip = this._actionsByClip[clipUuid];
      let prototypeAction = null;
      if (blendMode === void 0) {
        if (clipObject !== null) {
          blendMode = clipObject.blendMode;
        } else {
          blendMode = NormalAnimationBlendMode;
        }
      }
      if (actionsForClip !== void 0) {
        const existingAction = actionsForClip.actionByRoot[rootUuid];
        if (existingAction !== void 0 && existingAction.blendMode === blendMode) {
          return existingAction;
        }
        prototypeAction = actionsForClip.knownActions[0];
        if (clipObject === null)
          clipObject = prototypeAction._clip;
      }
      if (clipObject === null)
        return null;
      const newAction = new AnimationAction(this, clipObject, optionalRoot, blendMode);
      this._bindAction(newAction, prototypeAction);
      this._addInactiveAction(newAction, clipUuid, rootUuid);
      return newAction;
    }
    // get an existing action
    existingAction(clip, optionalRoot) {
      const root = optionalRoot || this._root, rootUuid = root.uuid, clipObject = typeof clip === "string" ? AnimationClip.findByName(root, clip) : clip, clipUuid = clipObject ? clipObject.uuid : clip, actionsForClip = this._actionsByClip[clipUuid];
      if (actionsForClip !== void 0) {
        return actionsForClip.actionByRoot[rootUuid] || null;
      }
      return null;
    }
    // deactivates all previously scheduled actions
    stopAllAction() {
      const actions = this._actions, nActions = this._nActiveActions;
      for (let i = nActions - 1; i >= 0; --i) {
        actions[i].stop();
      }
      return this;
    }
    // advance the time and update apply the animation
    update(deltaTime) {
      deltaTime *= this.timeScale;
      const actions = this._actions, nActions = this._nActiveActions, time = this.time += deltaTime, timeDirection = Math.sign(deltaTime), accuIndex = this._accuIndex ^= 1;
      for (let i = 0; i !== nActions; ++i) {
        const action = actions[i];
        action._update(time, deltaTime, timeDirection, accuIndex);
      }
      const bindings = this._bindings, nBindings = this._nActiveBindings;
      for (let i = 0; i !== nBindings; ++i) {
        bindings[i].apply(accuIndex);
      }
      return this;
    }
    // Allows you to seek to a specific time in an animation.
    setTime(timeInSeconds) {
      this.time = 0;
      for (let i = 0; i < this._actions.length; i++) {
        this._actions[i].time = 0;
      }
      return this.update(timeInSeconds);
    }
    // return this mixer's root target object
    getRoot() {
      return this._root;
    }
    // free all resources specific to a particular clip
    uncacheClip(clip) {
      const actions = this._actions, clipUuid = clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid];
      if (actionsForClip !== void 0) {
        const actionsToRemove = actionsForClip.knownActions;
        for (let i = 0, n = actionsToRemove.length; i !== n; ++i) {
          const action = actionsToRemove[i];
          this._deactivateAction(action);
          const cacheIndex = action._cacheIndex, lastInactiveAction = actions[actions.length - 1];
          action._cacheIndex = null;
          action._byClipCacheIndex = null;
          lastInactiveAction._cacheIndex = cacheIndex;
          actions[cacheIndex] = lastInactiveAction;
          actions.pop();
          this._removeInactiveBindingsForAction(action);
        }
        delete actionsByClip[clipUuid];
      }
    }
    // free all resources specific to a particular root target object
    uncacheRoot(root) {
      const rootUuid = root.uuid, actionsByClip = this._actionsByClip;
      for (const clipUuid in actionsByClip) {
        const actionByRoot = actionsByClip[clipUuid].actionByRoot, action = actionByRoot[rootUuid];
        if (action !== void 0) {
          this._deactivateAction(action);
          this._removeInactiveAction(action);
        }
      }
      const bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid];
      if (bindingByName !== void 0) {
        for (const trackName in bindingByName) {
          const binding = bindingByName[trackName];
          binding.restoreOriginalState();
          this._removeInactiveBinding(binding);
        }
      }
    }
    // remove a targeted clip from the cache
    uncacheAction(clip, optionalRoot) {
      const action = this.existingAction(clip, optionalRoot);
      if (action !== null) {
        this._deactivateAction(action);
        this._removeInactiveAction(action);
      }
    }
  };
  AnimationMixer.prototype._controlInterpolantsResultBuffer = new Float32Array(1);
  var Uniform = class _Uniform {
    constructor(value) {
      if (typeof value === "string") {
        console.warn("THREE.Uniform: Type parameter is no longer needed.");
        value = arguments[1];
      }
      this.value = value;
    }
    clone() {
      return new _Uniform(this.value.clone === void 0 ? this.value : this.value.clone());
    }
  };
  var InstancedInterleavedBuffer = class extends InterleavedBuffer {
    constructor(array, stride, meshPerAttribute = 1) {
      super(array, stride);
      this.meshPerAttribute = meshPerAttribute;
    }
    copy(source) {
      super.copy(source);
      this.meshPerAttribute = source.meshPerAttribute;
      return this;
    }
    clone(data) {
      const ib = super.clone(data);
      ib.meshPerAttribute = this.meshPerAttribute;
      return ib;
    }
    toJSON(data) {
      const json = super.toJSON(data);
      json.isInstancedInterleavedBuffer = true;
      json.meshPerAttribute = this.meshPerAttribute;
      return json;
    }
  };
  InstancedInterleavedBuffer.prototype.isInstancedInterleavedBuffer = true;
  var GLBufferAttribute = class {
    constructor(buffer, type, itemSize, elementSize, count) {
      this.buffer = buffer;
      this.type = type;
      this.itemSize = itemSize;
      this.elementSize = elementSize;
      this.count = count;
      this.version = 0;
    }
    set needsUpdate(value) {
      if (value === true)
        this.version++;
    }
    setBuffer(buffer) {
      this.buffer = buffer;
      return this;
    }
    setType(type, elementSize) {
      this.type = type;
      this.elementSize = elementSize;
      return this;
    }
    setItemSize(itemSize) {
      this.itemSize = itemSize;
      return this;
    }
    setCount(count) {
      this.count = count;
      return this;
    }
  };
  GLBufferAttribute.prototype.isGLBufferAttribute = true;
  var Spherical = class {
    constructor(radius = 1, phi = 0, theta = 0) {
      this.radius = radius;
      this.phi = phi;
      this.theta = theta;
      return this;
    }
    set(radius, phi, theta) {
      this.radius = radius;
      this.phi = phi;
      this.theta = theta;
      return this;
    }
    copy(other) {
      this.radius = other.radius;
      this.phi = other.phi;
      this.theta = other.theta;
      return this;
    }
    // restrict phi to be between EPS and PI-EPS
    makeSafe() {
      const EPS = 1e-6;
      this.phi = Math.max(EPS, Math.min(Math.PI - EPS, this.phi));
      return this;
    }
    setFromVector3(v) {
      return this.setFromCartesianCoords(v.x, v.y, v.z);
    }
    setFromCartesianCoords(x, y, z) {
      this.radius = Math.sqrt(x * x + y * y + z * z);
      if (this.radius === 0) {
        this.theta = 0;
        this.phi = 0;
      } else {
        this.theta = Math.atan2(x, z);
        this.phi = Math.acos(clamp(y / this.radius, -1, 1));
      }
      return this;
    }
    clone() {
      return new this.constructor().copy(this);
    }
  };
  var _vector$4 = /* @__PURE__ */ new Vector2();
  var Box2 = class {
    constructor(min = new Vector2(Infinity, Infinity), max = new Vector2(-Infinity, -Infinity)) {
      this.min = min;
      this.max = max;
    }
    set(min, max) {
      this.min.copy(min);
      this.max.copy(max);
      return this;
    }
    setFromPoints(points) {
      this.makeEmpty();
      for (let i = 0, il = points.length; i < il; i++) {
        this.expandByPoint(points[i]);
      }
      return this;
    }
    setFromCenterAndSize(center, size) {
      const halfSize = _vector$4.copy(size).multiplyScalar(0.5);
      this.min.copy(center).sub(halfSize);
      this.max.copy(center).add(halfSize);
      return this;
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(box) {
      this.min.copy(box.min);
      this.max.copy(box.max);
      return this;
    }
    makeEmpty() {
      this.min.x = this.min.y = Infinity;
      this.max.x = this.max.y = -Infinity;
      return this;
    }
    isEmpty() {
      return this.max.x < this.min.x || this.max.y < this.min.y;
    }
    getCenter(target) {
      return this.isEmpty() ? target.set(0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
    }
    getSize(target) {
      return this.isEmpty() ? target.set(0, 0) : target.subVectors(this.max, this.min);
    }
    expandByPoint(point) {
      this.min.min(point);
      this.max.max(point);
      return this;
    }
    expandByVector(vector) {
      this.min.sub(vector);
      this.max.add(vector);
      return this;
    }
    expandByScalar(scalar) {
      this.min.addScalar(-scalar);
      this.max.addScalar(scalar);
      return this;
    }
    containsPoint(point) {
      return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y ? false : true;
    }
    containsBox(box) {
      return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y;
    }
    getParameter(point, target) {
      return target.set(
        (point.x - this.min.x) / (this.max.x - this.min.x),
        (point.y - this.min.y) / (this.max.y - this.min.y)
      );
    }
    intersectsBox(box) {
      return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y ? false : true;
    }
    clampPoint(point, target) {
      return target.copy(point).clamp(this.min, this.max);
    }
    distanceToPoint(point) {
      const clampedPoint = _vector$4.copy(point).clamp(this.min, this.max);
      return clampedPoint.sub(point).length();
    }
    intersect(box) {
      this.min.max(box.min);
      this.max.min(box.max);
      return this;
    }
    union(box) {
      this.min.min(box.min);
      this.max.max(box.max);
      return this;
    }
    translate(offset) {
      this.min.add(offset);
      this.max.add(offset);
      return this;
    }
    equals(box) {
      return box.min.equals(this.min) && box.max.equals(this.max);
    }
  };
  Box2.prototype.isBox2 = true;
  var _startP = /* @__PURE__ */ new Vector3();
  var _startEnd = /* @__PURE__ */ new Vector3();
  var Line3 = class {
    constructor(start2 = new Vector3(), end = new Vector3()) {
      this.start = start2;
      this.end = end;
    }
    set(start2, end) {
      this.start.copy(start2);
      this.end.copy(end);
      return this;
    }
    copy(line) {
      this.start.copy(line.start);
      this.end.copy(line.end);
      return this;
    }
    getCenter(target) {
      return target.addVectors(this.start, this.end).multiplyScalar(0.5);
    }
    delta(target) {
      return target.subVectors(this.end, this.start);
    }
    distanceSq() {
      return this.start.distanceToSquared(this.end);
    }
    distance() {
      return this.start.distanceTo(this.end);
    }
    at(t, target) {
      return this.delta(target).multiplyScalar(t).add(this.start);
    }
    closestPointToPointParameter(point, clampToLine) {
      _startP.subVectors(point, this.start);
      _startEnd.subVectors(this.end, this.start);
      const startEnd2 = _startEnd.dot(_startEnd);
      const startEnd_startP = _startEnd.dot(_startP);
      let t = startEnd_startP / startEnd2;
      if (clampToLine) {
        t = clamp(t, 0, 1);
      }
      return t;
    }
    closestPointToPoint(point, clampToLine, target) {
      const t = this.closestPointToPointParameter(point, clampToLine);
      return this.delta(target).multiplyScalar(t).add(this.start);
    }
    applyMatrix4(matrix) {
      this.start.applyMatrix4(matrix);
      this.end.applyMatrix4(matrix);
      return this;
    }
    equals(line) {
      return line.start.equals(this.start) && line.end.equals(this.end);
    }
    clone() {
      return new this.constructor().copy(this);
    }
  };
  var _vector$2 = /* @__PURE__ */ new Vector3();
  var _boneMatrix = /* @__PURE__ */ new Matrix4();
  var _matrixWorldInv = /* @__PURE__ */ new Matrix4();
  var SkeletonHelper = class extends LineSegments {
    constructor(object) {
      const bones = getBoneList(object);
      const geometry = new BufferGeometry();
      const vertices = [];
      const colors = [];
      const color1 = new Color(0, 0, 1);
      const color2 = new Color(0, 1, 0);
      for (let i = 0; i < bones.length; i++) {
        const bone = bones[i];
        if (bone.parent && bone.parent.isBone) {
          vertices.push(0, 0, 0);
          vertices.push(0, 0, 0);
          colors.push(color1.r, color1.g, color1.b);
          colors.push(color2.r, color2.g, color2.b);
        }
      }
      geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
      geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
      const material = new LineBasicMaterial({ vertexColors: true, depthTest: false, depthWrite: false, toneMapped: false, transparent: true });
      super(geometry, material);
      this.type = "SkeletonHelper";
      this.isSkeletonHelper = true;
      this.root = object;
      this.bones = bones;
      this.matrix = object.matrixWorld;
      this.matrixAutoUpdate = false;
    }
    updateMatrixWorld(force) {
      const bones = this.bones;
      const geometry = this.geometry;
      const position = geometry.getAttribute("position");
      _matrixWorldInv.copy(this.root.matrixWorld).invert();
      for (let i = 0, j = 0; i < bones.length; i++) {
        const bone = bones[i];
        if (bone.parent && bone.parent.isBone) {
          _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.matrixWorld);
          _vector$2.setFromMatrixPosition(_boneMatrix);
          position.setXYZ(j, _vector$2.x, _vector$2.y, _vector$2.z);
          _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.parent.matrixWorld);
          _vector$2.setFromMatrixPosition(_boneMatrix);
          position.setXYZ(j + 1, _vector$2.x, _vector$2.y, _vector$2.z);
          j += 2;
        }
      }
      geometry.getAttribute("position").needsUpdate = true;
      super.updateMatrixWorld(force);
    }
  };
  function getBoneList(object) {
    const boneList = [];
    if (object.isBone === true) {
      boneList.push(object);
    }
    for (let i = 0; i < object.children.length; i++) {
      boneList.push.apply(boneList, getBoneList(object.children[i]));
    }
    return boneList;
  }
  var GridHelper = class extends LineSegments {
    constructor(size = 10, divisions = 10, color1 = 4473924, color2 = 8947848) {
      color1 = new Color(color1);
      color2 = new Color(color2);
      const center = divisions / 2;
      const step = size / divisions;
      const halfSize = size / 2;
      const vertices = [], colors = [];
      for (let i = 0, j = 0, k = -halfSize; i <= divisions; i++, k += step) {
        vertices.push(-halfSize, 0, k, halfSize, 0, k);
        vertices.push(k, 0, -halfSize, k, 0, halfSize);
        const color = i === center ? color1 : color2;
        color.toArray(colors, j);
        j += 3;
        color.toArray(colors, j);
        j += 3;
        color.toArray(colors, j);
        j += 3;
        color.toArray(colors, j);
        j += 3;
      }
      const geometry = new BufferGeometry();
      geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
      geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
      const material = new LineBasicMaterial({ vertexColors: true, toneMapped: false });
      super(geometry, material);
      this.type = "GridHelper";
    }
  };
  var _buffer = new ArrayBuffer(4);
  var _floatView = new Float32Array(_buffer);
  var _uint32View = new Uint32Array(_buffer);
  var _baseTable = new Uint32Array(512);
  var _shiftTable = new Uint32Array(512);
  for (let i = 0; i < 256; ++i) {
    const e = i - 127;
    if (e < -27) {
      _baseTable[i] = 0;
      _baseTable[i | 256] = 32768;
      _shiftTable[i] = 24;
      _shiftTable[i | 256] = 24;
    } else if (e < -14) {
      _baseTable[i] = 1024 >> -e - 14;
      _baseTable[i | 256] = 1024 >> -e - 14 | 32768;
      _shiftTable[i] = -e - 1;
      _shiftTable[i | 256] = -e - 1;
    } else if (e <= 15) {
      _baseTable[i] = e + 15 << 10;
      _baseTable[i | 256] = e + 15 << 10 | 32768;
      _shiftTable[i] = 13;
      _shiftTable[i | 256] = 13;
    } else if (e < 128) {
      _baseTable[i] = 31744;
      _baseTable[i | 256] = 64512;
      _shiftTable[i] = 24;
      _shiftTable[i | 256] = 24;
    } else {
      _baseTable[i] = 31744;
      _baseTable[i | 256] = 64512;
      _shiftTable[i] = 13;
      _shiftTable[i | 256] = 13;
    }
  }
  var _mantissaTable = new Uint32Array(2048);
  var _exponentTable = new Uint32Array(64);
  var _offsetTable = new Uint32Array(64);
  for (let i = 1; i < 1024; ++i) {
    let m = i << 13;
    let e = 0;
    while ((m & 8388608) === 0) {
      m <<= 1;
      e -= 8388608;
    }
    m &= ~8388608;
    e += 947912704;
    _mantissaTable[i] = m | e;
  }
  for (let i = 1024; i < 2048; ++i) {
    _mantissaTable[i] = 939524096 + (i - 1024 << 13);
  }
  for (let i = 1; i < 31; ++i) {
    _exponentTable[i] = i << 23;
  }
  _exponentTable[31] = 1199570944;
  _exponentTable[32] = 2147483648;
  for (let i = 33; i < 63; ++i) {
    _exponentTable[i] = 2147483648 + (i - 32 << 23);
  }
  _exponentTable[63] = 3347054592;
  for (let i = 1; i < 64; ++i) {
    if (i !== 32) {
      _offsetTable[i] = 1024;
    }
  }
  Curve.create = function(construct, getPoint) {
    console.log("THREE.Curve.create() has been deprecated");
    construct.prototype = Object.create(Curve.prototype);
    construct.prototype.constructor = construct;
    construct.prototype.getPoint = getPoint;
    return construct;
  };
  Path.prototype.fromPoints = function(points) {
    console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints().");
    return this.setFromPoints(points);
  };
  GridHelper.prototype.setColors = function() {
    console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.");
  };
  SkeletonHelper.prototype.update = function() {
    console.error("THREE.SkeletonHelper: update() no longer needs to be called.");
  };
  Loader.prototype.extractUrlBase = function(url) {
    console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.");
    return LoaderUtils.extractUrlBase(url);
  };
  Loader.Handlers = {
    add: function() {
      console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.");
    },
    get: function() {
      console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.");
    }
  };
  Box2.prototype.center = function(optionalTarget) {
    console.warn("THREE.Box2: .center() has been renamed to .getCenter().");
    return this.getCenter(optionalTarget);
  };
  Box2.prototype.empty = function() {
    console.warn("THREE.Box2: .empty() has been renamed to .isEmpty().");
    return this.isEmpty();
  };
  Box2.prototype.isIntersectionBox = function(box) {
    console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().");
    return this.intersectsBox(box);
  };
  Box2.prototype.size = function(optionalTarget) {
    console.warn("THREE.Box2: .size() has been renamed to .getSize().");
    return this.getSize(optionalTarget);
  };
  Box3.prototype.center = function(optionalTarget) {
    console.warn("THREE.Box3: .center() has been renamed to .getCenter().");
    return this.getCenter(optionalTarget);
  };
  Box3.prototype.empty = function() {
    console.warn("THREE.Box3: .empty() has been renamed to .isEmpty().");
    return this.isEmpty();
  };
  Box3.prototype.isIntersectionBox = function(box) {
    console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().");
    return this.intersectsBox(box);
  };
  Box3.prototype.isIntersectionSphere = function(sphere) {
    console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().");
    return this.intersectsSphere(sphere);
  };
  Box3.prototype.size = function(optionalTarget) {
    console.warn("THREE.Box3: .size() has been renamed to .getSize().");
    return this.getSize(optionalTarget);
  };
  Euler.prototype.toVector3 = function() {
    console.error("THREE.Euler: .toVector3() has been removed. Use Vector3.setFromEuler() instead");
  };
  Sphere.prototype.empty = function() {
    console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty().");
    return this.isEmpty();
  };
  Frustum.prototype.setFromMatrix = function(m) {
    console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix().");
    return this.setFromProjectionMatrix(m);
  };
  Line3.prototype.center = function(optionalTarget) {
    console.warn("THREE.Line3: .center() has been renamed to .getCenter().");
    return this.getCenter(optionalTarget);
  };
  Matrix3.prototype.flattenToArrayOffset = function(array, offset) {
    console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
    return this.toArray(array, offset);
  };
  Matrix3.prototype.multiplyVector3 = function(vector) {
    console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.");
    return vector.applyMatrix3(this);
  };
  Matrix3.prototype.multiplyVector3Array = function() {
    console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.");
  };
  Matrix3.prototype.applyToBufferAttribute = function(attribute) {
    console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead.");
    return attribute.applyMatrix3(this);
  };
  Matrix3.prototype.applyToVector3Array = function() {
    console.error("THREE.Matrix3: .applyToVector3Array() has been removed.");
  };
  Matrix3.prototype.getInverse = function(matrix) {
    console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.");
    return this.copy(matrix).invert();
  };
  Matrix4.prototype.extractPosition = function(m) {
    console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().");
    return this.copyPosition(m);
  };
  Matrix4.prototype.flattenToArrayOffset = function(array, offset) {
    console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
    return this.toArray(array, offset);
  };
  Matrix4.prototype.getPosition = function() {
    console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.");
    return new Vector3().setFromMatrixColumn(this, 3);
  };
  Matrix4.prototype.setRotationFromQuaternion = function(q) {
    console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().");
    return this.makeRotationFromQuaternion(q);
  };
  Matrix4.prototype.multiplyToArray = function() {
    console.warn("THREE.Matrix4: .multiplyToArray() has been removed.");
  };
  Matrix4.prototype.multiplyVector3 = function(vector) {
    console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.");
    return vector.applyMatrix4(this);
  };
  Matrix4.prototype.multiplyVector4 = function(vector) {
    console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.");
    return vector.applyMatrix4(this);
  };
  Matrix4.prototype.multiplyVector3Array = function() {
    console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.");
  };
  Matrix4.prototype.rotateAxis = function(v) {
    console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.");
    v.transformDirection(this);
  };
  Matrix4.prototype.crossVector = function(vector) {
    console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.");
    return vector.applyMatrix4(this);
  };
  Matrix4.prototype.translate = function() {
    console.error("THREE.Matrix4: .translate() has been removed.");
  };
  Matrix4.prototype.rotateX = function() {
    console.error("THREE.Matrix4: .rotateX() has been removed.");
  };
  Matrix4.prototype.rotateY = function() {
    console.error("THREE.Matrix4: .rotateY() has been removed.");
  };
  Matrix4.prototype.rotateZ = function() {
    console.error("THREE.Matrix4: .rotateZ() has been removed.");
  };
  Matrix4.prototype.rotateByAxis = function() {
    console.error("THREE.Matrix4: .rotateByAxis() has been removed.");
  };
  Matrix4.prototype.applyToBufferAttribute = function(attribute) {
    console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead.");
    return attribute.applyMatrix4(this);
  };
  Matrix4.prototype.applyToVector3Array = function() {
    console.error("THREE.Matrix4: .applyToVector3Array() has been removed.");
  };
  Matrix4.prototype.makeFrustum = function(left, right, bottom, top, near, far) {
    console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.");
    return this.makePerspective(left, right, top, bottom, near, far);
  };
  Matrix4.prototype.getInverse = function(matrix) {
    console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.");
    return this.copy(matrix).invert();
  };
  Plane.prototype.isIntersectionLine = function(line) {
    console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().");
    return this.intersectsLine(line);
  };
  Quaternion.prototype.multiplyVector3 = function(vector) {
    console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.");
    return vector.applyQuaternion(this);
  };
  Quaternion.prototype.inverse = function() {
    console.warn("THREE.Quaternion: .inverse() has been renamed to invert().");
    return this.invert();
  };
  Ray.prototype.isIntersectionBox = function(box) {
    console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().");
    return this.intersectsBox(box);
  };
  Ray.prototype.isIntersectionPlane = function(plane) {
    console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().");
    return this.intersectsPlane(plane);
  };
  Ray.prototype.isIntersectionSphere = function(sphere) {
    console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().");
    return this.intersectsSphere(sphere);
  };
  Triangle.prototype.area = function() {
    console.warn("THREE.Triangle: .area() has been renamed to .getArea().");
    return this.getArea();
  };
  Triangle.prototype.barycoordFromPoint = function(point, target) {
    console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().");
    return this.getBarycoord(point, target);
  };
  Triangle.prototype.midpoint = function(target) {
    console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint().");
    return this.getMidpoint(target);
  };
  Triangle.prototypenormal = function(target) {
    console.warn("THREE.Triangle: .normal() has been renamed to .getNormal().");
    return this.getNormal(target);
  };
  Triangle.prototype.plane = function(target) {
    console.warn("THREE.Triangle: .plane() has been renamed to .getPlane().");
    return this.getPlane(target);
  };
  Triangle.barycoordFromPoint = function(point, a, b, c, target) {
    console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().");
    return Triangle.getBarycoord(point, a, b, c, target);
  };
  Triangle.normal = function(a, b, c, target) {
    console.warn("THREE.Triangle: .normal() has been renamed to .getNormal().");
    return Triangle.getNormal(a, b, c, target);
  };
  Shape.prototype.extractAllPoints = function(divisions) {
    console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.");
    return this.extractPoints(divisions);
  };
  Shape.prototype.extrude = function(options) {
    console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.");
    return new ExtrudeGeometry(this, options);
  };
  Shape.prototype.makeGeometry = function(options) {
    console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.");
    return new ShapeGeometry(this, options);
  };
  Vector2.prototype.fromAttribute = function(attribute, index, offset) {
    console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().");
    return this.fromBufferAttribute(attribute, index, offset);
  };
  Vector2.prototype.distanceToManhattan = function(v) {
    console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().");
    return this.manhattanDistanceTo(v);
  };
  Vector2.prototype.lengthManhattan = function() {
    console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().");
    return this.manhattanLength();
  };
  Vector3.prototype.setEulerFromRotationMatrix = function() {
    console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.");
  };
  Vector3.prototype.setEulerFromQuaternion = function() {
    console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.");
  };
  Vector3.prototype.getPositionFromMatrix = function(m) {
    console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().");
    return this.setFromMatrixPosition(m);
  };
  Vector3.prototype.getScaleFromMatrix = function(m) {
    console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().");
    return this.setFromMatrixScale(m);
  };
  Vector3.prototype.getColumnFromMatrix = function(index, matrix) {
    console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().");
    return this.setFromMatrixColumn(matrix, index);
  };
  Vector3.prototype.applyProjection = function(m) {
    console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.");
    return this.applyMatrix4(m);
  };
  Vector3.prototype.fromAttribute = function(attribute, index, offset) {
    console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().");
    return this.fromBufferAttribute(attribute, index, offset);
  };
  Vector3.prototype.distanceToManhattan = function(v) {
    console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().");
    return this.manhattanDistanceTo(v);
  };
  Vector3.prototype.lengthManhattan = function() {
    console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().");
    return this.manhattanLength();
  };
  Vector4.prototype.fromAttribute = function(attribute, index, offset) {
    console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().");
    return this.fromBufferAttribute(attribute, index, offset);
  };
  Vector4.prototype.lengthManhattan = function() {
    console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().");
    return this.manhattanLength();
  };
  Object3D.prototype.getChildByName = function(name) {
    console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().");
    return this.getObjectByName(name);
  };
  Object3D.prototype.renderDepth = function() {
    console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.");
  };
  Object3D.prototype.translate = function(distance, axis) {
    console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.");
    return this.translateOnAxis(axis, distance);
  };
  Object3D.prototype.getWorldRotation = function() {
    console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.");
  };
  Object3D.prototype.applyMatrix = function(matrix) {
    console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4().");
    return this.applyMatrix4(matrix);
  };
  Object.defineProperties(Object3D.prototype, {
    eulerOrder: {
      get: function() {
        console.warn("THREE.Object3D: .eulerOrder is now .rotation.order.");
        return this.rotation.order;
      },
      set: function(value) {
        console.warn("THREE.Object3D: .eulerOrder is now .rotation.order.");
        this.rotation.order = value;
      }
    },
    useQuaternion: {
      get: function() {
        console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
      },
      set: function() {
        console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
      }
    }
  });
  Mesh.prototype.setDrawMode = function() {
    console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.");
  };
  Object.defineProperties(Mesh.prototype, {
    drawMode: {
      get: function() {
        console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode.");
        return TrianglesDrawMode;
      },
      set: function() {
        console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.");
      }
    }
  });
  SkinnedMesh.prototype.initBones = function() {
    console.error("THREE.SkinnedMesh: initBones() has been removed.");
  };
  PerspectiveCamera.prototype.setLens = function(focalLength, filmGauge) {
    console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup.");
    if (filmGauge !== void 0)
      this.filmGauge = filmGauge;
    this.setFocalLength(focalLength);
  };
  Object.defineProperties(Light.prototype, {
    onlyShadow: {
      set: function() {
        console.warn("THREE.Light: .onlyShadow has been removed.");
      }
    },
    shadowCameraFov: {
      set: function(value) {
        console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov.");
        this.shadow.camera.fov = value;
      }
    },
    shadowCameraLeft: {
      set: function(value) {
        console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left.");
        this.shadow.camera.left = value;
      }
    },
    shadowCameraRight: {
      set: function(value) {
        console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right.");
        this.shadow.camera.right = value;
      }
    },
    shadowCameraTop: {
      set: function(value) {
        console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top.");
        this.shadow.camera.top = value;
      }
    },
    shadowCameraBottom: {
      set: function(value) {
        console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.");
        this.shadow.camera.bottom = value;
      }
    },
    shadowCameraNear: {
      set: function(value) {
        console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near.");
        this.shadow.camera.near = value;
      }
    },
    shadowCameraFar: {
      set: function(value) {
        console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far.");
        this.shadow.camera.far = value;
      }
    },
    shadowCameraVisible: {
      set: function() {
        console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.");
      }
    },
    shadowBias: {
      set: function(value) {
        console.warn("THREE.Light: .shadowBias is now .shadow.bias.");
        this.shadow.bias = value;
      }
    },
    shadowDarkness: {
      set: function() {
        console.warn("THREE.Light: .shadowDarkness has been removed.");
      }
    },
    shadowMapWidth: {
      set: function(value) {
        console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.");
        this.shadow.mapSize.width = value;
      }
    },
    shadowMapHeight: {
      set: function(value) {
        console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.");
        this.shadow.mapSize.height = value;
      }
    }
  });
  Object.defineProperties(BufferAttribute.prototype, {
    length: {
      get: function() {
        console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead.");
        return this.array.length;
      }
    },
    dynamic: {
      get: function() {
        console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.");
        return this.usage === DynamicDrawUsage;
      },
      set: function() {
        console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.");
        this.setUsage(DynamicDrawUsage);
      }
    }
  });
  BufferAttribute.prototype.setDynamic = function(value) {
    console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead.");
    this.setUsage(value === true ? DynamicDrawUsage : StaticDrawUsage);
    return this;
  };
  BufferAttribute.prototype.copyIndicesArray = function() {
    console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.");
  }, BufferAttribute.prototype.setArray = function() {
    console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers");
  };
  BufferGeometry.prototype.addIndex = function(index) {
    console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().");
    this.setIndex(index);
  };
  BufferGeometry.prototype.addAttribute = function(name, attribute) {
    console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute().");
    if (!(attribute && attribute.isBufferAttribute) && !(attribute && attribute.isInterleavedBufferAttribute)) {
      console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).");
      return this.setAttribute(name, new BufferAttribute(arguments[1], arguments[2]));
    }
    if (name === "index") {
      console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.");
      this.setIndex(attribute);
      return this;
    }
    return this.setAttribute(name, attribute);
  };
  BufferGeometry.prototype.addDrawCall = function(start2, count, indexOffset) {
    if (indexOffset !== void 0) {
      console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.");
    }
    console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup().");
    this.addGroup(start2, count);
  };
  BufferGeometry.prototype.clearDrawCalls = function() {
    console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().");
    this.clearGroups();
  };
  BufferGeometry.prototype.computeOffsets = function() {
    console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.");
  };
  BufferGeometry.prototype.removeAttribute = function(name) {
    console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute().");
    return this.deleteAttribute(name);
  };
  BufferGeometry.prototype.applyMatrix = function(matrix) {
    console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4().");
    return this.applyMatrix4(matrix);
  };
  Object.defineProperties(BufferGeometry.prototype, {
    drawcalls: {
      get: function() {
        console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups.");
        return this.groups;
      }
    },
    offsets: {
      get: function() {
        console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups.");
        return this.groups;
      }
    }
  });
  InterleavedBuffer.prototype.setDynamic = function(value) {
    console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead.");
    this.setUsage(value === true ? DynamicDrawUsage : StaticDrawUsage);
    return this;
  };
  InterleavedBuffer.prototype.setArray = function() {
    console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers");
  };
  ExtrudeGeometry.prototype.getArrays = function() {
    console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.");
  };
  ExtrudeGeometry.prototype.addShapeList = function() {
    console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.");
  };
  ExtrudeGeometry.prototype.addShape = function() {
    console.error("THREE.ExtrudeGeometry: .addShape() has been removed.");
  };
  Scene.prototype.dispose = function() {
    console.error("THREE.Scene: .dispose() has been removed.");
  };
  Uniform.prototype.onUpdate = function() {
    console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.");
    return this;
  };
  Object.defineProperties(Material.prototype, {
    wrapAround: {
      get: function() {
        console.warn("THREE.Material: .wrapAround has been removed.");
      },
      set: function() {
        console.warn("THREE.Material: .wrapAround has been removed.");
      }
    },
    overdraw: {
      get: function() {
        console.warn("THREE.Material: .overdraw has been removed.");
      },
      set: function() {
        console.warn("THREE.Material: .overdraw has been removed.");
      }
    },
    wrapRGB: {
      get: function() {
        console.warn("THREE.Material: .wrapRGB has been removed.");
        return new Color();
      }
    },
    shading: {
      get: function() {
        console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
      },
      set: function(value) {
        console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
        this.flatShading = value === FlatShading;
      }
    },
    stencilMask: {
      get: function() {
        console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead.");
        return this.stencilFuncMask;
      },
      set: function(value) {
        console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead.");
        this.stencilFuncMask = value;
      }
    },
    vertexTangents: {
      get: function() {
        console.warn("THREE." + this.type + ": .vertexTangents has been removed.");
      },
      set: function() {
        console.warn("THREE." + this.type + ": .vertexTangents has been removed.");
      }
    }
  });
  Object.defineProperties(ShaderMaterial.prototype, {
    derivatives: {
      get: function() {
        console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.");
        return this.extensions.derivatives;
      },
      set: function(value) {
        console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.");
        this.extensions.derivatives = value;
      }
    }
  });
  WebGLRenderer.prototype.clearTarget = function(renderTarget, color, depth, stencil) {
    console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead.");
    this.setRenderTarget(renderTarget);
    this.clear(color, depth, stencil);
  };
  WebGLRenderer.prototype.animate = function(callback) {
    console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop().");
    this.setAnimationLoop(callback);
  };
  WebGLRenderer.prototype.getCurrentRenderTarget = function() {
    console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().");
    return this.getRenderTarget();
  };
  WebGLRenderer.prototype.getMaxAnisotropy = function() {
    console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().");
    return this.capabilities.getMaxAnisotropy();
  };
  WebGLRenderer.prototype.getPrecision = function() {
    console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.");
    return this.capabilities.precision;
  };
  WebGLRenderer.prototype.resetGLState = function() {
    console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset().");
    return this.state.reset();
  };
  WebGLRenderer.prototype.supportsFloatTextures = function() {
    console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' ).");
    return this.extensions.get("OES_texture_float");
  };
  WebGLRenderer.prototype.supportsHalfFloatTextures = function() {
    console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' ).");
    return this.extensions.get("OES_texture_half_float");
  };
  WebGLRenderer.prototype.supportsStandardDerivatives = function() {
    console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' ).");
    return this.extensions.get("OES_standard_derivatives");
  };
  WebGLRenderer.prototype.supportsCompressedTextureS3TC = function() {
    console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' ).");
    return this.extensions.get("WEBGL_compressed_texture_s3tc");
  };
  WebGLRenderer.prototype.supportsCompressedTexturePVRTC = function() {
    console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' ).");
    return this.extensions.get("WEBGL_compressed_texture_pvrtc");
  };
  WebGLRenderer.prototype.supportsBlendMinMax = function() {
    console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' ).");
    return this.extensions.get("EXT_blend_minmax");
  };
  WebGLRenderer.prototype.supportsVertexTextures = function() {
    console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.");
    return this.capabilities.vertexTextures;
  };
  WebGLRenderer.prototype.supportsInstancedArrays = function() {
    console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' ).");
    return this.extensions.get("ANGLE_instanced_arrays");
  };
  WebGLRenderer.prototype.enableScissorTest = function(boolean) {
    console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().");
    this.setScissorTest(boolean);
  };
  WebGLRenderer.prototype.initMaterial = function() {
    console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.");
  };
  WebGLRenderer.prototype.addPrePlugin = function() {
    console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.");
  };
  WebGLRenderer.prototype.addPostPlugin = function() {
    console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.");
  };
  WebGLRenderer.prototype.updateShadowMap = function() {
    console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.");
  };
  WebGLRenderer.prototype.setFaceCulling = function() {
    console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.");
  };
  WebGLRenderer.prototype.allocTextureUnit = function() {
    console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.");
  };
  WebGLRenderer.prototype.setTexture = function() {
    console.warn("THREE.WebGLRenderer: .setTexture() has been removed.");
  };
  WebGLRenderer.prototype.setTexture2D = function() {
    console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.");
  };
  WebGLRenderer.prototype.setTextureCube = function() {
    console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.");
  };
  WebGLRenderer.prototype.getActiveMipMapLevel = function() {
    console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel().");
    return this.getActiveMipmapLevel();
  };
  Object.defineProperties(WebGLRenderer.prototype, {
    shadowMapEnabled: {
      get: function() {
        return this.shadowMap.enabled;
      },
      set: function(value) {
        console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.");
        this.shadowMap.enabled = value;
      }
    },
    shadowMapType: {
      get: function() {
        return this.shadowMap.type;
      },
      set: function(value) {
        console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.");
        this.shadowMap.type = value;
      }
    },
    shadowMapCullFace: {
      get: function() {
        console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
        return void 0;
      },
      set: function() {
        console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
      }
    },
    context: {
      get: function() {
        console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead.");
        return this.getContext();
      }
    },
    vr: {
      get: function() {
        console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr");
        return this.xr;
      }
    },
    gammaInput: {
      get: function() {
        console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.");
        return false;
      },
      set: function() {
        console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.");
      }
    },
    gammaOutput: {
      get: function() {
        console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.");
        return false;
      },
      set: function(value) {
        console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.");
        this.outputEncoding = value === true ? sRGBEncoding : LinearEncoding;
      }
    },
    toneMappingWhitePoint: {
      get: function() {
        console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.");
        return 1;
      },
      set: function() {
        console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.");
      }
    },
    gammaFactor: {
      get: function() {
        console.warn("THREE.WebGLRenderer: .gammaFactor has been removed.");
        return 2;
      },
      set: function() {
        console.warn("THREE.WebGLRenderer: .gammaFactor has been removed.");
      }
    }
  });
  Object.defineProperties(WebGLShadowMap.prototype, {
    cullFace: {
      get: function() {
        console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
        return void 0;
      },
      set: function() {
        console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
      }
    },
    renderReverseSided: {
      get: function() {
        console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
        return void 0;
      },
      set: function() {
        console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
      }
    },
    renderSingleSided: {
      get: function() {
        console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
        return void 0;
      },
      set: function() {
        console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
      }
    }
  });
  Object.defineProperties(WebGLRenderTarget.prototype, {
    wrapS: {
      get: function() {
        console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.");
        return this.texture.wrapS;
      },
      set: function(value) {
        console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.");
        this.texture.wrapS = value;
      }
    },
    wrapT: {
      get: function() {
        console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.");
        return this.texture.wrapT;
      },
      set: function(value) {
        console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.");
        this.texture.wrapT = value;
      }
    },
    magFilter: {
      get: function() {
        console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.");
        return this.texture.magFilter;
      },
      set: function(value) {
        console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.");
        this.texture.magFilter = value;
      }
    },
    minFilter: {
      get: function() {
        console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.");
        return this.texture.minFilter;
      },
      set: function(value) {
        console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.");
        this.texture.minFilter = value;
      }
    },
    anisotropy: {
      get: function() {
        console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.");
        return this.texture.anisotropy;
      },
      set: function(value) {
        console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.");
        this.texture.anisotropy = value;
      }
    },
    offset: {
      get: function() {
        console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset.");
        return this.texture.offset;
      },
      set: function(value) {
        console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset.");
        this.texture.offset = value;
      }
    },
    repeat: {
      get: function() {
        console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat.");
        return this.texture.repeat;
      },
      set: function(value) {
        console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat.");
        this.texture.repeat = value;
      }
    },
    format: {
      get: function() {
        console.warn("THREE.WebGLRenderTarget: .format is now .texture.format.");
        return this.texture.format;
      },
      set: function(value) {
        console.warn("THREE.WebGLRenderTarget: .format is now .texture.format.");
        this.texture.format = value;
      }
    },
    type: {
      get: function() {
        console.warn("THREE.WebGLRenderTarget: .type is now .texture.type.");
        return this.texture.type;
      },
      set: function(value) {
        console.warn("THREE.WebGLRenderTarget: .type is now .texture.type.");
        this.texture.type = value;
      }
    },
    generateMipmaps: {
      get: function() {
        console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.");
        return this.texture.generateMipmaps;
      },
      set: function(value) {
        console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.");
        this.texture.generateMipmaps = value;
      }
    }
  });
  Audio.prototype.load = function(file) {
    console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
    const scope = this;
    const audioLoader = new AudioLoader();
    audioLoader.load(file, function(buffer) {
      scope.setBuffer(buffer);
    });
    return this;
  };
  AudioAnalyser.prototype.getData = function() {
    console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData().");
    return this.getFrequencyData();
  };
  CubeCamera.prototype.updateCubeMap = function(renderer, scene) {
    console.warn("THREE.CubeCamera: .updateCubeMap() is now .update().");
    return this.update(renderer, scene);
  };
  CubeCamera.prototype.clear = function(renderer, color, depth, stencil) {
    console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear().");
    return this.renderTarget.clear(renderer, color, depth, stencil);
  };
  ImageUtils.crossOrigin = void 0;
  ImageUtils.loadTexture = function(url, mapping, onLoad, onError) {
    console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
    const loader = new TextureLoader();
    loader.setCrossOrigin(this.crossOrigin);
    const texture = loader.load(url, onLoad, void 0, onError);
    if (mapping)
      texture.mapping = mapping;
    return texture;
  };
  ImageUtils.loadTextureCube = function(urls, mapping, onLoad, onError) {
    console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
    const loader = new CubeTextureLoader();
    loader.setCrossOrigin(this.crossOrigin);
    const texture = loader.load(urls, onLoad, void 0, onError);
    if (mapping)
      texture.mapping = mapping;
    return texture;
  };
  ImageUtils.loadCompressedTexture = function() {
    console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.");
  };
  ImageUtils.loadCompressedTextureCube = function() {
    console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.");
  };
  if (typeof __THREE_DEVTOOLS__ !== "undefined") {
    __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: {
      revision: REVISION
    } }));
  }
  if (typeof window !== "undefined") {
    if (window.__THREE__) {
      console.warn("WARNING: Multiple instances of Three.js being imported.");
    } else {
      window.__THREE__ = REVISION;
    }
  }

  // node_modules/three/examples/jsm/controls/OrbitControls.js
  var _changeEvent = { type: "change" };
  var _startEvent = { type: "start" };
  var _endEvent = { type: "end" };
  var OrbitControls = class extends EventDispatcher {
    constructor(object, domElement) {
      super();
      if (domElement === void 0)
        console.warn('THREE.OrbitControls: The second parameter "domElement" is now mandatory.');
      if (domElement === document)
        console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.');
      this.object = object;
      this.domElement = domElement;
      this.domElement.style.touchAction = "none";
      this.enabled = true;
      this.target = new Vector3();
      this.minDistance = 0;
      this.maxDistance = Infinity;
      this.minZoom = 0;
      this.maxZoom = Infinity;
      this.minPolarAngle = 0;
      this.maxPolarAngle = Math.PI;
      this.minAzimuthAngle = -Infinity;
      this.maxAzimuthAngle = Infinity;
      this.enableDamping = false;
      this.dampingFactor = 0.05;
      this.enableZoom = true;
      this.zoomSpeed = 1;
      this.enableRotate = true;
      this.rotateSpeed = 1;
      this.enablePan = true;
      this.panSpeed = 1;
      this.screenSpacePanning = true;
      this.keyPanSpeed = 7;
      this.autoRotate = false;
      this.autoRotateSpeed = 2;
      this.keys = { LEFT: "ArrowLeft", UP: "ArrowUp", RIGHT: "ArrowRight", BOTTOM: "ArrowDown" };
      this.mouseButtons = { LEFT: MOUSE.ROTATE, MIDDLE: MOUSE.DOLLY, RIGHT: MOUSE.PAN };
      this.touches = { ONE: TOUCH.ROTATE, TWO: TOUCH.DOLLY_PAN };
      this.target0 = this.target.clone();
      this.position0 = this.object.position.clone();
      this.zoom0 = this.object.zoom;
      this._domElementKeyEvents = null;
      this.getPolarAngle = function() {
        return spherical.phi;
      };
      this.getAzimuthalAngle = function() {
        return spherical.theta;
      };
      this.getDistance = function() {
        return this.object.position.distanceTo(this.target);
      };
      this.listenToKeyEvents = function(domElement2) {
        domElement2.addEventListener("keydown", onKeyDown);
        this._domElementKeyEvents = domElement2;
      };
      this.saveState = function() {
        scope.target0.copy(scope.target);
        scope.position0.copy(scope.object.position);
        scope.zoom0 = scope.object.zoom;
      };
      this.reset = function() {
        scope.target.copy(scope.target0);
        scope.object.position.copy(scope.position0);
        scope.object.zoom = scope.zoom0;
        scope.object.updateProjectionMatrix();
        scope.dispatchEvent(_changeEvent);
        scope.update();
        state = STATE.NONE;
      };
      this.update = function() {
        const offset = new Vector3();
        const quat = new Quaternion().setFromUnitVectors(object.up, new Vector3(0, 1, 0));
        const quatInverse = quat.clone().invert();
        const lastPosition = new Vector3();
        const lastQuaternion = new Quaternion();
        const twoPI = 2 * Math.PI;
        return function update() {
          const position = scope.object.position;
          offset.copy(position).sub(scope.target);
          offset.applyQuaternion(quat);
          spherical.setFromVector3(offset);
          if (scope.autoRotate && state === STATE.NONE) {
            rotateLeft(getAutoRotationAngle());
          }
          if (scope.enableDamping) {
            spherical.theta += sphericalDelta.theta * scope.dampingFactor;
            spherical.phi += sphericalDelta.phi * scope.dampingFactor;
          } else {
            spherical.theta += sphericalDelta.theta;
            spherical.phi += sphericalDelta.phi;
          }
          let min = scope.minAzimuthAngle;
          let max = scope.maxAzimuthAngle;
          if (isFinite(min) && isFinite(max)) {
            if (min < -Math.PI)
              min += twoPI;
            else if (min > Math.PI)
              min -= twoPI;
            if (max < -Math.PI)
              max += twoPI;
            else if (max > Math.PI)
              max -= twoPI;
            if (min <= max) {
              spherical.theta = Math.max(min, Math.min(max, spherical.theta));
            } else {
              spherical.theta = spherical.theta > (min + max) / 2 ? Math.max(min, spherical.theta) : Math.min(max, spherical.theta);
            }
          }
          spherical.phi = Math.max(scope.minPolarAngle, Math.min(scope.maxPolarAngle, spherical.phi));
          spherical.makeSafe();
          spherical.radius *= scale;
          spherical.radius = Math.max(scope.minDistance, Math.min(scope.maxDistance, spherical.radius));
          if (scope.enableDamping === true) {
            scope.target.addScaledVector(panOffset, scope.dampingFactor);
          } else {
            scope.target.add(panOffset);
          }
          offset.setFromSpherical(spherical);
          offset.applyQuaternion(quatInverse);
          position.copy(scope.target).add(offset);
          scope.object.lookAt(scope.target);
          if (scope.enableDamping === true) {
            sphericalDelta.theta *= 1 - scope.dampingFactor;
            sphericalDelta.phi *= 1 - scope.dampingFactor;
            panOffset.multiplyScalar(1 - scope.dampingFactor);
          } else {
            sphericalDelta.set(0, 0, 0);
            panOffset.set(0, 0, 0);
          }
          scale = 1;
          if (zoomChanged || lastPosition.distanceToSquared(scope.object.position) > EPS || 8 * (1 - lastQuaternion.dot(scope.object.quaternion)) > EPS) {
            scope.dispatchEvent(_changeEvent);
            lastPosition.copy(scope.object.position);
            lastQuaternion.copy(scope.object.quaternion);
            zoomChanged = false;
            return true;
          }
          return false;
        };
      }();
      this.dispose = function() {
        scope.domElement.removeEventListener("contextmenu", onContextMenu);
        scope.domElement.removeEventListener("pointerdown", onPointerDown);
        scope.domElement.removeEventListener("pointercancel", onPointerCancel);
        scope.domElement.removeEventListener("wheel", onMouseWheel);
        scope.domElement.removeEventListener("pointermove", onPointerMove);
        scope.domElement.removeEventListener("pointerup", onPointerUp);
        if (scope._domElementKeyEvents !== null) {
          scope._domElementKeyEvents.removeEventListener("keydown", onKeyDown);
        }
      };
      const scope = this;
      const STATE = {
        NONE: -1,
        ROTATE: 0,
        DOLLY: 1,
        PAN: 2,
        TOUCH_ROTATE: 3,
        TOUCH_PAN: 4,
        TOUCH_DOLLY_PAN: 5,
        TOUCH_DOLLY_ROTATE: 6
      };
      let state = STATE.NONE;
      const EPS = 1e-6;
      const spherical = new Spherical();
      const sphericalDelta = new Spherical();
      let scale = 1;
      const panOffset = new Vector3();
      let zoomChanged = false;
      const rotateStart = new Vector2();
      const rotateEnd = new Vector2();
      const rotateDelta = new Vector2();
      const panStart = new Vector2();
      const panEnd = new Vector2();
      const panDelta = new Vector2();
      const dollyStart = new Vector2();
      const dollyEnd = new Vector2();
      const dollyDelta = new Vector2();
      const pointers = [];
      const pointerPositions = {};
      function getAutoRotationAngle() {
        return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;
      }
      function getZoomScale() {
        return Math.pow(0.95, scope.zoomSpeed);
      }
      function rotateLeft(angle) {
        sphericalDelta.theta -= angle;
      }
      function rotateUp(angle) {
        sphericalDelta.phi -= angle;
      }
      const panLeft = function() {
        const v = new Vector3();
        return function panLeft2(distance, objectMatrix) {
          v.setFromMatrixColumn(objectMatrix, 0);
          v.multiplyScalar(-distance);
          panOffset.add(v);
        };
      }();
      const panUp = function() {
        const v = new Vector3();
        return function panUp2(distance, objectMatrix) {
          if (scope.screenSpacePanning === true) {
            v.setFromMatrixColumn(objectMatrix, 1);
          } else {
            v.setFromMatrixColumn(objectMatrix, 0);
            v.crossVectors(scope.object.up, v);
          }
          v.multiplyScalar(distance);
          panOffset.add(v);
        };
      }();
      const pan = function() {
        const offset = new Vector3();
        return function pan2(deltaX, deltaY) {
          const element = scope.domElement;
          if (scope.object.isPerspectiveCamera) {
            const position = scope.object.position;
            offset.copy(position).sub(scope.target);
            let targetDistance = offset.length();
            targetDistance *= Math.tan(scope.object.fov / 2 * Math.PI / 180);
            panLeft(2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix);
            panUp(2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix);
          } else if (scope.object.isOrthographicCamera) {
            panLeft(deltaX * (scope.object.right - scope.object.left) / scope.object.zoom / element.clientWidth, scope.object.matrix);
            panUp(deltaY * (scope.object.top - scope.object.bottom) / scope.object.zoom / element.clientHeight, scope.object.matrix);
          } else {
            console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.");
            scope.enablePan = false;
          }
        };
      }();
      function dollyOut(dollyScale) {
        if (scope.object.isPerspectiveCamera) {
          scale /= dollyScale;
        } else if (scope.object.isOrthographicCamera) {
          scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom * dollyScale));
          scope.object.updateProjectionMatrix();
          zoomChanged = true;
        } else {
          console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.");
          scope.enableZoom = false;
        }
      }
      function dollyIn(dollyScale) {
        if (scope.object.isPerspectiveCamera) {
          scale *= dollyScale;
        } else if (scope.object.isOrthographicCamera) {
          scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom / dollyScale));
          scope.object.updateProjectionMatrix();
          zoomChanged = true;
        } else {
          console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.");
          scope.enableZoom = false;
        }
      }
      function handleMouseDownRotate(event) {
        rotateStart.set(event.clientX, event.clientY);
      }
      function handleMouseDownDolly(event) {
        dollyStart.set(event.clientX, event.clientY);
      }
      function handleMouseDownPan(event) {
        panStart.set(event.clientX, event.clientY);
      }
      function handleMouseMoveRotate(event) {
        rotateEnd.set(event.clientX, event.clientY);
        rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);
        const element = scope.domElement;
        rotateLeft(2 * Math.PI * rotateDelta.x / element.clientHeight);
        rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);
        rotateStart.copy(rotateEnd);
        scope.update();
      }
      function handleMouseMoveDolly(event) {
        dollyEnd.set(event.clientX, event.clientY);
        dollyDelta.subVectors(dollyEnd, dollyStart);
        if (dollyDelta.y > 0) {
          dollyOut(getZoomScale());
        } else if (dollyDelta.y < 0) {
          dollyIn(getZoomScale());
        }
        dollyStart.copy(dollyEnd);
        scope.update();
      }
      function handleMouseMovePan(event) {
        panEnd.set(event.clientX, event.clientY);
        panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);
        pan(panDelta.x, panDelta.y);
        panStart.copy(panEnd);
        scope.update();
      }
      function handleMouseWheel(event) {
        if (event.deltaY < 0) {
          dollyIn(getZoomScale());
        } else if (event.deltaY > 0) {
          dollyOut(getZoomScale());
        }
        scope.update();
      }
      function handleKeyDown(event) {
        let needsUpdate = false;
        switch (event.code) {
          case scope.keys.UP:
            pan(0, scope.keyPanSpeed);
            needsUpdate = true;
            break;
          case scope.keys.BOTTOM:
            pan(0, -scope.keyPanSpeed);
            needsUpdate = true;
            break;
          case scope.keys.LEFT:
            pan(scope.keyPanSpeed, 0);
            needsUpdate = true;
            break;
          case scope.keys.RIGHT:
            pan(-scope.keyPanSpeed, 0);
            needsUpdate = true;
            break;
        }
        if (needsUpdate) {
          event.preventDefault();
          scope.update();
        }
      }
      function handleTouchStartRotate() {
        if (pointers.length === 1) {
          rotateStart.set(pointers[0].pageX, pointers[0].pageY);
        } else {
          const x = 0.5 * (pointers[0].pageX + pointers[1].pageX);
          const y = 0.5 * (pointers[0].pageY + pointers[1].pageY);
          rotateStart.set(x, y);
        }
      }
      function handleTouchStartPan() {
        if (pointers.length === 1) {
          panStart.set(pointers[0].pageX, pointers[0].pageY);
        } else {
          const x = 0.5 * (pointers[0].pageX + pointers[1].pageX);
          const y = 0.5 * (pointers[0].pageY + pointers[1].pageY);
          panStart.set(x, y);
        }
      }
      function handleTouchStartDolly() {
        const dx = pointers[0].pageX - pointers[1].pageX;
        const dy = pointers[0].pageY - pointers[1].pageY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        dollyStart.set(0, distance);
      }
      function handleTouchStartDollyPan() {
        if (scope.enableZoom)
          handleTouchStartDolly();
        if (scope.enablePan)
          handleTouchStartPan();
      }
      function handleTouchStartDollyRotate() {
        if (scope.enableZoom)
          handleTouchStartDolly();
        if (scope.enableRotate)
          handleTouchStartRotate();
      }
      function handleTouchMoveRotate(event) {
        if (pointers.length == 1) {
          rotateEnd.set(event.pageX, event.pageY);
        } else {
          const position = getSecondPointerPosition(event);
          const x = 0.5 * (event.pageX + position.x);
          const y = 0.5 * (event.pageY + position.y);
          rotateEnd.set(x, y);
        }
        rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);
        const element = scope.domElement;
        rotateLeft(2 * Math.PI * rotateDelta.x / element.clientHeight);
        rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);
        rotateStart.copy(rotateEnd);
      }
      function handleTouchMovePan(event) {
        if (pointers.length === 1) {
          panEnd.set(event.pageX, event.pageY);
        } else {
          const position = getSecondPointerPosition(event);
          const x = 0.5 * (event.pageX + position.x);
          const y = 0.5 * (event.pageY + position.y);
          panEnd.set(x, y);
        }
        panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);
        pan(panDelta.x, panDelta.y);
        panStart.copy(panEnd);
      }
      function handleTouchMoveDolly(event) {
        const position = getSecondPointerPosition(event);
        const dx = event.pageX - position.x;
        const dy = event.pageY - position.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        dollyEnd.set(0, distance);
        dollyDelta.set(0, Math.pow(dollyEnd.y / dollyStart.y, scope.zoomSpeed));
        dollyOut(dollyDelta.y);
        dollyStart.copy(dollyEnd);
      }
      function handleTouchMoveDollyPan(event) {
        if (scope.enableZoom)
          handleTouchMoveDolly(event);
        if (scope.enablePan)
          handleTouchMovePan(event);
      }
      function handleTouchMoveDollyRotate(event) {
        if (scope.enableZoom)
          handleTouchMoveDolly(event);
        if (scope.enableRotate)
          handleTouchMoveRotate(event);
      }
      function onPointerDown(event) {
        if (scope.enabled === false)
          return;
        if (pointers.length === 0) {
          scope.domElement.setPointerCapture(event.pointerId);
          scope.domElement.addEventListener("pointermove", onPointerMove);
          scope.domElement.addEventListener("pointerup", onPointerUp);
        }
        addPointer(event);
        if (event.pointerType === "touch") {
          onTouchStart(event);
        } else {
          onMouseDown(event);
        }
      }
      function onPointerMove(event) {
        if (scope.enabled === false)
          return;
        if (event.pointerType === "touch") {
          onTouchMove(event);
        } else {
          onMouseMove(event);
        }
      }
      function onPointerUp(event) {
        removePointer(event);
        if (pointers.length === 0) {
          scope.domElement.releasePointerCapture(event.pointerId);
          scope.domElement.removeEventListener("pointermove", onPointerMove);
          scope.domElement.removeEventListener("pointerup", onPointerUp);
        }
        scope.dispatchEvent(_endEvent);
        state = STATE.NONE;
      }
      function onPointerCancel(event) {
        removePointer(event);
      }
      function onMouseDown(event) {
        let mouseAction;
        switch (event.button) {
          case 0:
            mouseAction = scope.mouseButtons.LEFT;
            break;
          case 1:
            mouseAction = scope.mouseButtons.MIDDLE;
            break;
          case 2:
            mouseAction = scope.mouseButtons.RIGHT;
            break;
          default:
            mouseAction = -1;
        }
        switch (mouseAction) {
          case MOUSE.DOLLY:
            if (scope.enableZoom === false)
              return;
            handleMouseDownDolly(event);
            state = STATE.DOLLY;
            break;
          case MOUSE.ROTATE:
            if (event.ctrlKey || event.metaKey || event.shiftKey) {
              if (scope.enablePan === false)
                return;
              handleMouseDownPan(event);
              state = STATE.PAN;
            } else {
              if (scope.enableRotate === false)
                return;
              handleMouseDownRotate(event);
              state = STATE.ROTATE;
            }
            break;
          case MOUSE.PAN:
            if (event.ctrlKey || event.metaKey || event.shiftKey) {
              if (scope.enableRotate === false)
                return;
              handleMouseDownRotate(event);
              state = STATE.ROTATE;
            } else {
              if (scope.enablePan === false)
                return;
              handleMouseDownPan(event);
              state = STATE.PAN;
            }
            break;
          default:
            state = STATE.NONE;
        }
        if (state !== STATE.NONE) {
          scope.dispatchEvent(_startEvent);
        }
      }
      function onMouseMove(event) {
        if (scope.enabled === false)
          return;
        switch (state) {
          case STATE.ROTATE:
            if (scope.enableRotate === false)
              return;
            handleMouseMoveRotate(event);
            break;
          case STATE.DOLLY:
            if (scope.enableZoom === false)
              return;
            handleMouseMoveDolly(event);
            break;
          case STATE.PAN:
            if (scope.enablePan === false)
              return;
            handleMouseMovePan(event);
            break;
        }
      }
      function onMouseWheel(event) {
        if (scope.enabled === false || scope.enableZoom === false || state !== STATE.NONE)
          return;
        event.preventDefault();
        scope.dispatchEvent(_startEvent);
        handleMouseWheel(event);
        scope.dispatchEvent(_endEvent);
      }
      function onKeyDown(event) {
        if (scope.enabled === false || scope.enablePan === false)
          return;
        handleKeyDown(event);
      }
      function onTouchStart(event) {
        trackPointer(event);
        switch (pointers.length) {
          case 1:
            switch (scope.touches.ONE) {
              case TOUCH.ROTATE:
                if (scope.enableRotate === false)
                  return;
                handleTouchStartRotate();
                state = STATE.TOUCH_ROTATE;
                break;
              case TOUCH.PAN:
                if (scope.enablePan === false)
                  return;
                handleTouchStartPan();
                state = STATE.TOUCH_PAN;
                break;
              default:
                state = STATE.NONE;
            }
            break;
          case 2:
            switch (scope.touches.TWO) {
              case TOUCH.DOLLY_PAN:
                if (scope.enableZoom === false && scope.enablePan === false)
                  return;
                handleTouchStartDollyPan();
                state = STATE.TOUCH_DOLLY_PAN;
                break;
              case TOUCH.DOLLY_ROTATE:
                if (scope.enableZoom === false && scope.enableRotate === false)
                  return;
                handleTouchStartDollyRotate();
                state = STATE.TOUCH_DOLLY_ROTATE;
                break;
              default:
                state = STATE.NONE;
            }
            break;
          default:
            state = STATE.NONE;
        }
        if (state !== STATE.NONE) {
          scope.dispatchEvent(_startEvent);
        }
      }
      function onTouchMove(event) {
        trackPointer(event);
        switch (state) {
          case STATE.TOUCH_ROTATE:
            if (scope.enableRotate === false)
              return;
            handleTouchMoveRotate(event);
            scope.update();
            break;
          case STATE.TOUCH_PAN:
            if (scope.enablePan === false)
              return;
            handleTouchMovePan(event);
            scope.update();
            break;
          case STATE.TOUCH_DOLLY_PAN:
            if (scope.enableZoom === false && scope.enablePan === false)
              return;
            handleTouchMoveDollyPan(event);
            scope.update();
            break;
          case STATE.TOUCH_DOLLY_ROTATE:
            if (scope.enableZoom === false && scope.enableRotate === false)
              return;
            handleTouchMoveDollyRotate(event);
            scope.update();
            break;
          default:
            state = STATE.NONE;
        }
      }
      function onContextMenu(event) {
        if (scope.enabled === false)
          return;
        event.preventDefault();
      }
      function addPointer(event) {
        pointers.push(event);
      }
      function removePointer(event) {
        delete pointerPositions[event.pointerId];
        for (let i = 0; i < pointers.length; i++) {
          if (pointers[i].pointerId == event.pointerId) {
            pointers.splice(i, 1);
            return;
          }
        }
      }
      function trackPointer(event) {
        let position = pointerPositions[event.pointerId];
        if (position === void 0) {
          position = new Vector2();
          pointerPositions[event.pointerId] = position;
        }
        position.set(event.pageX, event.pageY);
      }
      function getSecondPointerPosition(event) {
        const pointer = event.pointerId === pointers[0].pointerId ? pointers[1] : pointers[0];
        return pointerPositions[pointer.pointerId];
      }
      scope.domElement.addEventListener("contextmenu", onContextMenu);
      scope.domElement.addEventListener("pointerdown", onPointerDown);
      scope.domElement.addEventListener("pointercancel", onPointerCancel);
      scope.domElement.addEventListener("wheel", onMouseWheel, { passive: false });
      this.update();
    }
  };

  // app/javascript/editor/helpers/point.js
  var Point = class {
    constructor(x, y) {
      this.x = x;
      this.y = y;
    }
  };

  // app/javascript/editor/helpers/point_helper.js
  var PointHelper = class {
    static samePoint(point, otherPoint) {
      return Math.abs(point.x - otherPoint.x) + Math.abs(point.y - otherPoint.y) < 1e-6;
    }
  };

  // app/javascript/editor/acelan_script/graphic_result.js
  var import_lodash = __toESM(require_lodash());

  // app/javascript/editor/helpers/graphic_result_helper.js
  var GraphicResultHelper = class {
    buildFigures(n, w, h, r) {
      const result = [];
      for (let i = 0; i < n; i++) {
        for (let j = 0; j < n; j++) {
          const x = w / 2 + i * w;
          const y = -h / 2 - j * h;
          result.push(this.getRect(w, h, x, y));
        }
      }
      for (let i = 0; i < n; i++) {
        for (let j = 0; j < n; j++) {
          const x = w / 2 + i * w;
          const y = -h / 2 - j * h;
          result.push(this.getCircle(r, x, y));
        }
      }
      for (let i = 0; i < n; i++) {
        for (let j = 0; j < n; j++) {
          const x = w / 2 + i * w;
          const y = -h / 2 - j * h;
          result.push(this.getRhombus(r, x, y));
        }
      }
      for (let i = 0; i < n; i++) {
        for (let j = 0; j < n; j++) {
          const x = i * w;
          const y = -j * h;
          result.push(this.getDots(w, h, r, x, y));
        }
      }
      for (let i = 0; i < n; i++) {
        for (let j = 0; j < n; j++) {
          const x = i * w;
          const y = -j * h;
          result.push(this.getLines(w, h, r, x, y));
        }
      }
      for (let i = 0; i < n; i++) {
        for (let j = 0; j < n; j++) {
          const x = w / 2 + i * w;
          const y = -h / 2 - j * h;
          result.push(this.getArcs(w, h, r, x, y));
        }
      }
      return result;
    }
    getCircle(r, x, y) {
      return {
        type: "circle",
        x,
        y,
        radius: r
      };
    }
    getRect(w, h, x, y) {
      return {
        type: "rect",
        x,
        y,
        width: w,
        height: h
      };
    }
    getRhombus(r, x, y) {
      return {
        type: "rhombus",
        side: r,
        x,
        y
      };
    }
    getDots(w, h, r, x, y) {
      return {
        type: "nodes",
        w,
        h,
        r,
        x,
        y
      };
    }
    getLines(w, h, r, x, y) {
      return {
        type: "edges",
        w,
        h,
        r,
        x,
        y
      };
    }
    getArcs(w, h, r, x, y, startAngle, endAngle) {
      return {
        type: "arcs",
        w,
        h,
        r,
        x,
        y,
        startAngle,
        endAngle
      };
    }
  };

  // app/javascript/editor/acelan_script/graphic_result.js
  var GraphicResult = class {
    constructor({ data }) {
      const graphicResultHelper = new GraphicResultHelper();
      this.data = {};
      this.data.figures = graphicResultHelper.buildFigures(data.n, data.w, data.h, data.r);
      this.data.labelsType = data.type;
      this.points = [];
      this.rayPoints = [];
      this.elementLabelPoints = [];
      this.elementPoints = [];
    }
    render() {
      const width = 740;
      const height = 700;
      const scene = new Scene();
      const camera = new PerspectiveCamera(45, width / height, 0.1, 500);
      const renderer = new WebGLRenderer();
      const controls = new OrbitControls(camera, renderer.domElement);
      renderer.setSize(width, height);
      controls.update();
      this.index = 0;
      this.data.figures.forEach((f) => {
        switch (f.type) {
          case "rect":
            let rect = this.drawRect(f);
            scene.add(rect);
            break;
          case "circle":
            let circle = this.drawCircle(f);
            scene.add(circle);
            break;
          case "rhombus":
            let rhombus = this.drawRhombus(f);
            scene.add(rhombus);
            break;
          case "nodes":
            const sVertices = this.getSquareVertices(f);
            const cVertices = this.getCircleVertices(f);
            const rVertices = this.getRhombusVertices(f);
            this.fillPointsArray(f);
            let squareDots = this.drawPoints(sVertices);
            scene.add(squareDots);
            let circleDots = this.drawPoints(cVertices);
            scene.add(circleDots);
            let rhombusDots = this.drawPoints(rVertices);
            scene.add(rhombusDots);
            break;
          case "edges":
            let lines = this.drawLines(f);
            lines.forEach(
              (element) => scene.add(element)
            );
            break;
          case "arcs":
            let arcs = this.drawArc(f);
            arcs.forEach(
              (element) => scene.add(element)
            );
            break;
        }
      });
      switch (this.data.labelsType) {
        case "nodes":
          const uniquePoints = import_lodash.default.uniqWith(this.points, PointHelper.samePoint);
          this.drawLabels(scene, uniquePoints);
          break;
        case "edges":
          const uniqueEdgePoints = import_lodash.default.uniqWith(this.createEdgesPoints(), PointHelper.samePoint);
          this.drawLabels(scene, uniqueEdgePoints);
          break;
        case "elements":
          this.drawLabels(scene, this.createElementsPoints());
          break;
      }
      camera.position.z = 30;
      function animate() {
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
      }
      animate();
      return renderer.domElement;
    }
    save(blockContent) {
      return this.data;
    }
    // MARK: - Draw figures
    drawCircle(figure) {
      const geometry = new CircleGeometry(figure.radius, 200);
      const material = new MeshBasicMaterial({ color: 11341571 });
      const circle = new Mesh(geometry, material);
      circle.position.x = figure.x;
      circle.position.y = figure.y;
      return circle;
    }
    drawRect(figure) {
      const geometry = new PlaneGeometry(figure.width, figure.height);
      const material = new MeshBasicMaterial({ color: 32931, side: DoubleSide, wireframe: false });
      const rect = new Mesh(geometry, material);
      rect.position.x = figure.x;
      rect.position.y = figure.y;
      return rect;
    }
    drawRhombus(figure) {
      const geometry = new PlaneGeometry(figure.side, figure.side);
      const material = new MeshBasicMaterial({ color: 11341571, side: DoubleSide, wireframe: false });
      const rect = new Mesh(geometry, material);
      rect.position.x = figure.x;
      rect.position.y = figure.y;
      rect.rotateZ(45 * Math.PI / 180);
      return rect;
    }
    // MARK: - Points coordinates via 'vertices' (x, y, z)
    getSquareVertices(figure) {
      return [
        figure.x,
        figure.y,
        0,
        figure.w / 2 + figure.x,
        figure.y,
        0,
        figure.w + figure.x,
        figure.y,
        0,
        figure.x + figure.w,
        -figure.h / 2 + figure.y,
        0,
        figure.w + figure.x,
        -figure.h + figure.y,
        0,
        figure.w / 2 + figure.x,
        figure.y - figure.h,
        0,
        figure.x,
        -figure.h + figure.y,
        0,
        figure.x,
        -figure.h / 2 + figure.y,
        0
      ];
    }
    getRhombusVertices(figure) {
      return [
        figure.w / 2 - figure.r / (Math.sqrt(2) * 2) + figure.x,
        -figure.h / 2 + figure.r / (Math.sqrt(2) * 2) + figure.y,
        0,
        figure.w / 2 + figure.x,
        -figure.h / 2 + figure.y + figure.r / Math.sqrt(2),
        0,
        figure.w / 2 + figure.r / (Math.sqrt(2) * 2) + figure.x,
        -figure.h / 2 + figure.r / (Math.sqrt(2) * 2) + figure.y,
        0,
        figure.w / 2 + figure.r / Math.sqrt(2) + figure.x,
        -figure.h / 2 + figure.y,
        0,
        figure.w / 2 + figure.r / (Math.sqrt(2) * 2) + figure.x,
        -figure.h / 2 - figure.r / (Math.sqrt(2) * 2) + figure.y,
        0,
        figure.w / 2 + figure.x,
        -figure.h / 2 + figure.y - figure.r / Math.sqrt(2),
        0,
        figure.w / 2 - figure.r / (Math.sqrt(2) * 2) + figure.x,
        -figure.h / 2 - figure.r / (Math.sqrt(2) * 2) + figure.y,
        0,
        figure.w / 2 - figure.r / Math.sqrt(2) + figure.x,
        -figure.h / 2 + figure.y,
        0
      ];
    }
    getCircleVertices(figure) {
      return [
        figure.w / 2 + figure.r * Math.cos(135 * Math.PI / 180) + figure.x,
        -figure.h / 2 + figure.r * Math.sin(135 * Math.PI / 180) + figure.y,
        0,
        figure.w / 2 + figure.x,
        -figure.h / 2 + figure.y + figure.r,
        0,
        figure.w / 2 + figure.r * Math.cos(45 * Math.PI / 180) + figure.x,
        -figure.h / 2 + figure.r * Math.sin(45 * Math.PI / 180) + figure.y,
        0,
        figure.w / 2 + figure.r + figure.x,
        -figure.h / 2 + figure.y,
        0,
        figure.w / 2 + figure.r * Math.cos(315 * Math.PI / 180) + figure.x,
        -figure.h / 2 + figure.r * Math.sin(315 * Math.PI / 180) + figure.y,
        0,
        figure.w / 2 + figure.x,
        -figure.h / 2 + figure.y - figure.r,
        0,
        figure.w / 2 + figure.r * Math.cos(225 * Math.PI / 180) + figure.x,
        -figure.h / 2 + figure.r * Math.sin(225 * Math.PI / 180) + figure.y,
        0,
        figure.w / 2 - figure.r + figure.x,
        -figure.h / 2 + figure.y,
        0
      ];
    }
    // MARK: - Nodes
    createNodesPoints(vertices) {
      const vArray = [];
      for (let i = 0; i < vertices.length; i += 3) {
        vArray.push(new Point(vertices[i], vertices[i + 1]));
      }
      return vArray;
    }
    // MARK: - Edges
    getExternalRayPoints(figure) {
      let externalRayVertices = [];
      const sVertices = this.getSquareVertices(figure);
      const cVertices = this.getCircleVertices(figure);
      for (let i = 0; i < sVertices.length; i += 3) {
        let x = (sVertices[i] + cVertices[i]) / 2;
        let y = (sVertices[i + 1] + cVertices[i + 1]) / 2;
        externalRayVertices.push(new Point(x, y));
      }
      return externalRayVertices;
    }
    getInternalRayPoints(figure) {
      let internalRayVertices = [];
      const cVertices = this.getCircleVertices(figure);
      const rVertices = this.getRhombusVertices(figure);
      for (let i = 0; i < cVertices.length; i += 3) {
        let x = (cVertices[i] + rVertices[i]) / 2;
        let y = (cVertices[i + 1] + rVertices[i + 1]) / 2;
        internalRayVertices.push(new Point(x, y));
      }
      return internalRayVertices;
    }
    createEdgesPoints() {
      const edgesPoints = [];
      let x = 0;
      let y = 0;
      for (let i = 0; i < this.points.length; i++) {
        if ((i + 1) % 8 === 0) {
          x = (this.points[i].x + this.points[i + 1 - 8].x) / 2;
          y = (this.points[i].y + this.points[i + 1 - 8].y) / 2;
          edgesPoints.push(new Point(x, y));
          if (i + 1 === this.points.length) {
            break;
          }
          continue;
        }
        x = (this.points[i].x + this.points[i + 1].x) / 2;
        y = (this.points[i].y + this.points[i + 1].y) / 2;
        edgesPoints.push(new Point(x, y));
      }
      for (let i = 0; i < this.rayPoints.length; i++) {
        edgesPoints.push(new Point(this.rayPoints[i].x, this.rayPoints[i].y));
      }
      return edgesPoints;
    }
    // MARK: - Elements
    getExternalElementsPoints(figure) {
      let points = [];
      const sVertices = this.getSquareVertices(figure);
      const cVertices = this.getCircleVertices(figure);
      for (let i = 0; i < sVertices.length - 3; i += 3) {
        let firstX = sVertices[i];
        let firstY = sVertices[i + 1];
        let secondX = cVertices[i];
        let secondY = cVertices[i + 1];
        let thirdX = sVertices[i + 3];
        let thirdY = sVertices[i + 3 + 1];
        let fourthX = cVertices[i + 3];
        let fourthY = cVertices[i + 3 + 1];
        let elementPoints = [
          firstX,
          firstY,
          0,
          secondX,
          secondY,
          0,
          thirdX,
          thirdY,
          0,
          fourthX,
          fourthY,
          0
        ];
        this.elementPoints.push(...elementPoints);
        let x = (firstX + secondX + thirdX + fourthX) / 4;
        let y = (firstY + secondY + thirdY + fourthY) / 4;
        points.push(new Point(x, y));
      }
      let lastX = (sVertices[sVertices.length - 3] + cVertices[cVertices.length - 3] + sVertices[0] + cVertices[3]) / 4;
      let lastY = (sVertices[sVertices.length - 2] + cVertices[cVertices.length - 2] + sVertices[1] + cVertices[4]) / 4;
      points.push(new Point(lastX, lastY));
      return points;
    }
    getInternalElementsPoints(figure) {
      let points = [];
      const cVertices = this.getCircleVertices(figure);
      const rVertices = this.getRhombusVertices(figure);
      for (let i = 0; i < cVertices.length - 3; i += 3) {
        let x = (cVertices[i] + rVertices[i] + cVertices[i + 3] + rVertices[i + 3]) / 4;
        let y = (cVertices[i + 1] + rVertices[i + 1] + cVertices[i + 1 + 3] + rVertices[i + 1 + 3]) / 4;
        points.push(new Point(x, y));
      }
      let lastX = (cVertices[cVertices.length - 3] + rVertices[rVertices.length - 3] + cVertices[0] + rVertices[3]) / 4;
      let lastY = (cVertices[cVertices.length - 2] + rVertices[rVertices.length - 2] + cVertices[1] + rVertices[4]) / 4;
      points.push(new Point(lastX, lastY));
      let sPoints = this.createNodesPoints(this.getSquareVertices(figure));
      let centerX = 0;
      let centerY = 0;
      for (let i = 0; i < sPoints.length; i++) {
        centerX += sPoints[i].x;
        centerY += sPoints[i].y;
      }
      points.push(new Point(centerX / sPoints.length, centerY / sPoints.length));
      return points;
    }
    createElementsPoints() {
      let points = [];
      for (let i = 0; i < this.elementLabelPoints.length; i++) {
        points.push(new Point(this.elementLabelPoints[i].x, this.elementLabelPoints[i].y));
      }
      return points;
    }
    // MARK: - Labels creation
    drawLabels(scene, points) {
      for (let i = 0; i < points.length; i++) {
        this.createLabel(scene, points[i].x, points[i].y, i + 1);
      }
    }
    createLabel(scene, x, y, name) {
      let canvas = document.createElement("canvas");
      canvas.width = 256;
      canvas.height = 216;
      let ctx = canvas.getContext("2d");
      ctx.font = "48pt Arial";
      ctx.fillStyle = "white";
      ctx.textAlign = "center";
      ctx.fillText(name, 128, 48);
      let tex = new Texture(canvas);
      tex.needsUpdate = true;
      let spriteMat = new SpriteMaterial({
        map: tex
      });
      let sprite = new Sprite(spriteMat);
      switch (this.data.labelsType) {
        case "nodes":
          sprite.position.x = x - 0.1;
          sprite.position.y = y - 0.2;
          break;
        case "edges":
          sprite.position.x = x;
          sprite.position.y = y - 0.25;
          break;
        case "elements":
          sprite.position.x = x;
          sprite.position.y = y - 0.25;
          break;
      }
      scene.add(sprite);
    }
    fillPointsArray(figure) {
      this.points.push(...this.createNodesPoints(this.getSquareVertices(figure)));
      this.points.push(...this.createNodesPoints(this.getCircleVertices(figure)));
      this.points.push(...this.createNodesPoints(this.getRhombusVertices(figure)));
      this.rayPoints.push(...this.getExternalRayPoints(figure));
      this.rayPoints.push(...this.getInternalRayPoints(figure));
      this.elementLabelPoints.push(...this.getExternalElementsPoints(figure));
      this.elementLabelPoints.push(...this.getInternalElementsPoints(figure));
    }
    drawPoints(vertices) {
      const geometry = new BufferGeometry();
      geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
      const points = new Points(
        geometry,
        new PointsMaterial({
          size: 0.25
        })
      );
      return points;
    }
    drawLines(figure) {
      const lines = [];
      const sVertices = this.getSquareVertices(figure);
      const cVertices = this.getCircleVertices(figure);
      const rVertices = this.getRhombusVertices(figure);
      lines.push(this.drawLine(new Vector2(sVertices[0], sVertices[1]), new Vector2(sVertices[3], sVertices[4])));
      lines.push(this.drawLine(new Vector2(sVertices[3], sVertices[4]), new Vector2(sVertices[6], sVertices[7])));
      lines.push(this.drawLine(new Vector2(sVertices[6], sVertices[7]), new Vector2(sVertices[9], sVertices[10])));
      lines.push(this.drawLine(new Vector2(sVertices[9], sVertices[10]), new Vector2(sVertices[12], sVertices[13])));
      lines.push(this.drawLine(new Vector2(sVertices[12], sVertices[13]), new Vector2(sVertices[15], sVertices[16])));
      lines.push(this.drawLine(new Vector2(sVertices[15], sVertices[16]), new Vector2(sVertices[18], sVertices[19])));
      lines.push(this.drawLine(new Vector2(sVertices[18], sVertices[19]), new Vector2(sVertices[21], sVertices[22])));
      lines.push(this.drawLine(new Vector2(sVertices[21], sVertices[22]), new Vector2(sVertices[0], sVertices[1])));
      lines.push(this.drawLine(new Vector2(rVertices[0], rVertices[1]), new Vector2(rVertices[3], rVertices[4])));
      lines.push(this.drawLine(new Vector2(rVertices[3], rVertices[4]), new Vector2(rVertices[6], rVertices[7])));
      lines.push(this.drawLine(new Vector2(rVertices[6], rVertices[7]), new Vector2(rVertices[9], rVertices[10])));
      lines.push(this.drawLine(new Vector2(rVertices[9], rVertices[10]), new Vector2(rVertices[12], rVertices[13])));
      lines.push(this.drawLine(new Vector2(rVertices[12], rVertices[13]), new Vector2(rVertices[15], rVertices[16])));
      lines.push(this.drawLine(new Vector2(rVertices[15], rVertices[16]), new Vector2(rVertices[18], rVertices[19])));
      lines.push(this.drawLine(new Vector2(rVertices[18], rVertices[19]), new Vector2(rVertices[21], rVertices[22])));
      lines.push(this.drawLine(new Vector2(rVertices[21], rVertices[22]), new Vector2(rVertices[0], rVertices[1])));
      lines.push(this.drawLine(new Vector2(sVertices[0], sVertices[1]), new Vector2(cVertices[0], cVertices[1])));
      lines.push(this.drawLine(new Vector2(sVertices[3], sVertices[4]), new Vector2(cVertices[3], cVertices[4])));
      lines.push(this.drawLine(new Vector2(sVertices[6], sVertices[7]), new Vector2(cVertices[6], cVertices[7])));
      lines.push(this.drawLine(new Vector2(sVertices[9], sVertices[10]), new Vector2(cVertices[9], cVertices[10])));
      lines.push(this.drawLine(new Vector2(sVertices[12], sVertices[13]), new Vector2(cVertices[12], cVertices[13])));
      lines.push(this.drawLine(new Vector2(sVertices[15], sVertices[16]), new Vector2(cVertices[15], cVertices[16])));
      lines.push(this.drawLine(new Vector2(sVertices[18], sVertices[19]), new Vector2(cVertices[18], cVertices[19])));
      lines.push(this.drawLine(new Vector2(sVertices[21], sVertices[22]), new Vector2(cVertices[21], cVertices[22])));
      lines.push(this.drawLine(new Vector2(cVertices[0], cVertices[1]), new Vector2(rVertices[0], rVertices[1])));
      lines.push(this.drawLine(new Vector2(cVertices[3], cVertices[4]), new Vector2(rVertices[3], rVertices[4])));
      lines.push(this.drawLine(new Vector2(cVertices[6], cVertices[7]), new Vector2(rVertices[6], rVertices[7])));
      lines.push(this.drawLine(new Vector2(cVertices[9], cVertices[10]), new Vector2(rVertices[9], rVertices[10])));
      lines.push(this.drawLine(new Vector2(cVertices[12], cVertices[13]), new Vector2(rVertices[12], rVertices[13])));
      lines.push(this.drawLine(new Vector2(cVertices[15], cVertices[16]), new Vector2(rVertices[15], rVertices[16])));
      lines.push(this.drawLine(new Vector2(cVertices[18], cVertices[19]), new Vector2(rVertices[18], rVertices[19])));
      lines.push(this.drawLine(new Vector2(cVertices[21], cVertices[22]), new Vector2(rVertices[21], rVertices[22])));
      return lines;
    }
    drawLine(startPoint, endPoint) {
      const points = [];
      points.push(startPoint);
      points.push(endPoint);
      const geometry = new BufferGeometry().setFromPoints(points);
      const material = new LineBasicMaterial({ color: 16777215 });
      const line = new Line(geometry, material);
      return line;
    }
    drawArc(figure) {
      let ellipses = [];
      for (let i = 0; i < 9; i++) {
        const curve = new EllipseCurve(
          figure.x,
          figure.y,
          // ax, aY
          figure.r,
          figure.r,
          // xRadius, yRadius
          i * Math.PI / 4,
          (i + 1) * Math.PI / 4,
          // aStartAngle, aEndAngle
          false,
          // aClockwise
          0
          // aRotation
        );
        const points = curve.getPoints(50);
        const geometry = new BufferGeometry().setFromPoints(points);
        const material = new LineBasicMaterial({ color: 16777215 });
        ellipses.push(new Line(geometry, material));
      }
      return ellipses;
    }
    // MARK: - These things draw shapes as you ask.
    getPlane(N, a, b, wireframe) {
      const geometry = new PlaneGeometry(1, 1);
      const material = new MeshBasicMaterial({ color: 0, side: DoubleSide, wireframe });
      const plane = new Mesh(geometry, material);
      plane.position.x = -N / 2 + 1 / 2 + b;
      plane.position.y = N / 2 - 1 / 2 - a;
      return plane;
    }
    getItem(N, a, b) {
      let plane = this.getPlane(N, a, b, false);
      let index = this.index;
      if (this.data.rects[index] !== void 0) {
        plane.add(this.getRect(index));
        if (this.data.circles[index] !== void 0) {
          plane.add(this.getCircle(index));
        }
      } else {
        if (this.data.circles[index] !== void 0) {
          plane.add(this.getCircle(index));
        }
      }
      this.index++;
      return plane;
    }
    getCircle(index) {
      const geometry = new CircleGeometry(this.data.circles[index].radius, 32);
      const material = new MeshBasicMaterial({ color: 16766720 });
      const circle = new Mesh(geometry, material);
      return circle;
    }
    getRect(index) {
      const geometry = new PlaneGeometry(this.data.rects[index].width, this.data.rects[index].height);
      const material = new MeshBasicMaterial({ color: 49151, side: DoubleSide, wireframe: false });
      const rect = new Mesh(geometry, material);
      return rect;
    }
  };

  // app/javascript/editor/acelan_script/error_result.js
  var ErrorResult = class {
    constructor({ data }) {
      this.data = data;
    }
    render() {
      const textResult = document.createElement("label");
      textResult.classList.add("text-red-700");
      textResult.innerText = this.data?.message;
      return textResult;
    }
    save(blockContent) {
      return {
        message: blockContent.innerText
      };
    }
  };

  // app/javascript/editor/acelan_script/text_result.js
  var TextResult = class {
    constructor({ data }) {
      this.data = data;
    }
    render() {
      const textResult = document.createElement("label");
      textResult.innerText = this.data?.text;
      return textResult;
    }
    save(blockContent) {
      return {
        text: blockContent.innerText
      };
    }
  };

  // app/javascript/editor/acelan_script/progress_display_block.js
  var ProgressDisplayBlock = class {
    constructor({ data }) {
      this.data = data;
    }
    render() {
      const progressDisplayBlock = document.createElement("label");
      progressDisplayBlock.innerText = this.data?.progress;
      return progressDisplayBlock;
    }
    save(blockContent) {
      return {
        progress: blockContent.innerText
      };
    }
  };

  // app/javascript/editor/acelan_script/demo_result.js
  var DemoResult = class {
    constructor({ data }) {
      this.data = data;
    }
    render() {
      const textResult = document.createElement("label");
      textResult.classList.add("text-red-700");
      textResult.innerText = this.data?.message;
      return textResult;
    }
    save(blockContent) {
      return {
        message: this.data?.message
      };
    }
  };

  // app/javascript/controllers/script_controller.js
  var script_controller_default = class extends Controller {
    connect() {
    }
    initialize() {
      const configuration = {
        holder: "editor",
        tools: {
          script: AcelanScript,
          graphicResult: GraphicResult,
          errorResult: ErrorResult,
          textResult: TextResult,
          progressDisplayBlock: ProgressDisplayBlock,
          demoResult: DemoResult
        },
        data: {
          blocks: []
        }
      };
      this.editor = new import_editorjs.default(configuration);
      window.editor = this.editor;
    }
    run() {
      this.editor.save().then((savedData) => {
        savedData.blocks = savedData.blocks.filter((x) => x.type === "script");
        const networkHelper = new NetworkHelper();
        const promises = savedData.blocks.map((block) => {
          return networkHelper.performScript(block.data.script, block.id);
        });
        Promise.all(promises).then((results) => {
          const count = results.length;
          this.editor.save().then((savedData2) => {
            let progressDB = {
              type: "progressDisplayBlock",
              data: {
                progress: `\u0412 \u043E\u0447\u0435\u0440\u0435\u0434\u0438 ${count} \u0437\u0430\u0434\u0430\u0447, \u043E\u0448\u0438\u0431\u043E\u043A 0`
              }
            };
            let indexPDB;
            if ((indexPDB = savedData2.blocks.findIndex((x) => x.type === "progressDisplayBlock")) === -1) {
              savedData2.blocks.unshift(progressDB);
            } else {
              savedData2.blocks[indexPDB].data.progress = `\u0412 \u043E\u0447\u0435\u0440\u0435\u0434\u0438 ${count} \u0437\u0430\u0434\u0430\u0447, \u043E\u0448\u0438\u0431\u043E\u043A 0`;
            }
            cleanScript(savedData2);
            this.editor.render(savedData2);
          });
        });
      });
    }
  };
  function cleanScript(savedData) {
    let savedDataBlocksLength = savedData.blocks.length;
    for (let j = 0; j < savedDataBlocksLength; j++) {
      let block = savedData.blocks.shift();
      if (block.type === "script") {
        let a = block.data.script.split("\n");
        let z = a.length;
        for (let i = 0; i < z; i++) {
          if (parseInt(a[i])) {
            a.splice(i, 1);
            i -= 1;
          }
        }
        block.data.script = a.join("\n");
        savedData.blocks.push(block);
      } else {
        savedData.blocks.push(block);
      }
    }
  }

  // app/javascript/controllers/index.js
  application.register("dashboard", dashboard_controller_default);
  application.register("home", home_controller_default);
  application.register("material-form", material_form_controller_default);
  application.register("materials", materials_controller_default);
  application.register("script", script_controller_default);

  // node_modules/@rails/actioncable/app/assets/javascripts/actioncable.esm.js
  var adapters = {
    logger: self.console,
    WebSocket: self.WebSocket
  };
  var logger = {
    log(...messages) {
      if (this.enabled) {
        messages.push(Date.now());
        adapters.logger.log("[ActionCable]", ...messages);
      }
    }
  };
  var now2 = () => (/* @__PURE__ */ new Date()).getTime();
  var secondsSince2 = (time) => (now2() - time) / 1e3;
  var ConnectionMonitor2 = class {
    constructor(connection) {
      this.visibilityDidChange = this.visibilityDidChange.bind(this);
      this.connection = connection;
      this.reconnectAttempts = 0;
    }
    start() {
      if (!this.isRunning()) {
        this.startedAt = now2();
        delete this.stoppedAt;
        this.startPolling();
        addEventListener("visibilitychange", this.visibilityDidChange);
        logger.log(`ConnectionMonitor started. stale threshold = ${this.constructor.staleThreshold} s`);
      }
    }
    stop() {
      if (this.isRunning()) {
        this.stoppedAt = now2();
        this.stopPolling();
        removeEventListener("visibilitychange", this.visibilityDidChange);
        logger.log("ConnectionMonitor stopped");
      }
    }
    isRunning() {
      return this.startedAt && !this.stoppedAt;
    }
    recordPing() {
      this.pingedAt = now2();
    }
    recordConnect() {
      this.reconnectAttempts = 0;
      this.recordPing();
      delete this.disconnectedAt;
      logger.log("ConnectionMonitor recorded connect");
    }
    recordDisconnect() {
      this.disconnectedAt = now2();
      logger.log("ConnectionMonitor recorded disconnect");
    }
    startPolling() {
      this.stopPolling();
      this.poll();
    }
    stopPolling() {
      clearTimeout(this.pollTimeout);
    }
    poll() {
      this.pollTimeout = setTimeout(() => {
        this.reconnectIfStale();
        this.poll();
      }, this.getPollInterval());
    }
    getPollInterval() {
      const { staleThreshold, reconnectionBackoffRate } = this.constructor;
      const backoff = Math.pow(1 + reconnectionBackoffRate, Math.min(this.reconnectAttempts, 10));
      const jitterMax = this.reconnectAttempts === 0 ? 1 : reconnectionBackoffRate;
      const jitter = jitterMax * Math.random();
      return staleThreshold * 1e3 * backoff * (1 + jitter);
    }
    reconnectIfStale() {
      if (this.connectionIsStale()) {
        logger.log(`ConnectionMonitor detected stale connection. reconnectAttempts = ${this.reconnectAttempts}, time stale = ${secondsSince2(this.refreshedAt)} s, stale threshold = ${this.constructor.staleThreshold} s`);
        this.reconnectAttempts++;
        if (this.disconnectedRecently()) {
          logger.log(`ConnectionMonitor skipping reopening recent disconnect. time disconnected = ${secondsSince2(this.disconnectedAt)} s`);
        } else {
          logger.log("ConnectionMonitor reopening");
          this.connection.reopen();
        }
      }
    }
    get refreshedAt() {
      return this.pingedAt ? this.pingedAt : this.startedAt;
    }
    connectionIsStale() {
      return secondsSince2(this.refreshedAt) > this.constructor.staleThreshold;
    }
    disconnectedRecently() {
      return this.disconnectedAt && secondsSince2(this.disconnectedAt) < this.constructor.staleThreshold;
    }
    visibilityDidChange() {
      if (document.visibilityState === "visible") {
        setTimeout(() => {
          if (this.connectionIsStale() || !this.connection.isOpen()) {
            logger.log(`ConnectionMonitor reopening stale connection on visibilitychange. visibilityState = ${document.visibilityState}`);
            this.connection.reopen();
          }
        }, 200);
      }
    }
  };
  ConnectionMonitor2.staleThreshold = 6;
  ConnectionMonitor2.reconnectionBackoffRate = 0.15;
  var INTERNAL = {
    message_types: {
      welcome: "welcome",
      disconnect: "disconnect",
      ping: "ping",
      confirmation: "confirm_subscription",
      rejection: "reject_subscription"
    },
    disconnect_reasons: {
      unauthorized: "unauthorized",
      invalid_request: "invalid_request",
      server_restart: "server_restart"
    },
    default_mount_path: "/cable",
    protocols: ["actioncable-v1-json", "actioncable-unsupported"]
  };
  var { message_types: message_types2, protocols: protocols2 } = INTERNAL;
  var supportedProtocols2 = protocols2.slice(0, protocols2.length - 1);
  var indexOf2 = [].indexOf;
  var Connection2 = class {
    constructor(consumer2) {
      this.open = this.open.bind(this);
      this.consumer = consumer2;
      this.subscriptions = this.consumer.subscriptions;
      this.monitor = new ConnectionMonitor2(this);
      this.disconnected = true;
    }
    send(data) {
      if (this.isOpen()) {
        this.webSocket.send(JSON.stringify(data));
        return true;
      } else {
        return false;
      }
    }
    open() {
      if (this.isActive()) {
        logger.log(`Attempted to open WebSocket, but existing socket is ${this.getState()}`);
        return false;
      } else {
        logger.log(`Opening WebSocket, current state is ${this.getState()}, subprotocols: ${protocols2}`);
        if (this.webSocket) {
          this.uninstallEventHandlers();
        }
        this.webSocket = new adapters.WebSocket(this.consumer.url, protocols2);
        this.installEventHandlers();
        this.monitor.start();
        return true;
      }
    }
    close({ allowReconnect } = {
      allowReconnect: true
    }) {
      if (!allowReconnect) {
        this.monitor.stop();
      }
      if (this.isOpen()) {
        return this.webSocket.close();
      }
    }
    reopen() {
      logger.log(`Reopening WebSocket, current state is ${this.getState()}`);
      if (this.isActive()) {
        try {
          return this.close();
        } catch (error2) {
          logger.log("Failed to reopen WebSocket", error2);
        } finally {
          logger.log(`Reopening WebSocket in ${this.constructor.reopenDelay}ms`);
          setTimeout(this.open, this.constructor.reopenDelay);
        }
      } else {
        return this.open();
      }
    }
    getProtocol() {
      if (this.webSocket) {
        return this.webSocket.protocol;
      }
    }
    isOpen() {
      return this.isState("open");
    }
    isActive() {
      return this.isState("open", "connecting");
    }
    isProtocolSupported() {
      return indexOf2.call(supportedProtocols2, this.getProtocol()) >= 0;
    }
    isState(...states) {
      return indexOf2.call(states, this.getState()) >= 0;
    }
    getState() {
      if (this.webSocket) {
        for (let state in adapters.WebSocket) {
          if (adapters.WebSocket[state] === this.webSocket.readyState) {
            return state.toLowerCase();
          }
        }
      }
      return null;
    }
    installEventHandlers() {
      for (let eventName in this.events) {
        const handler = this.events[eventName].bind(this);
        this.webSocket[`on${eventName}`] = handler;
      }
    }
    uninstallEventHandlers() {
      for (let eventName in this.events) {
        this.webSocket[`on${eventName}`] = function() {
        };
      }
    }
  };
  Connection2.reopenDelay = 500;
  Connection2.prototype.events = {
    message(event) {
      if (!this.isProtocolSupported()) {
        return;
      }
      const { identifier, message, reason, reconnect, type } = JSON.parse(event.data);
      switch (type) {
        case message_types2.welcome:
          this.monitor.recordConnect();
          return this.subscriptions.reload();
        case message_types2.disconnect:
          logger.log(`Disconnecting. Reason: ${reason}`);
          return this.close({
            allowReconnect: reconnect
          });
        case message_types2.ping:
          return this.monitor.recordPing();
        case message_types2.confirmation:
          this.subscriptions.confirmSubscription(identifier);
          return this.subscriptions.notify(identifier, "connected");
        case message_types2.rejection:
          return this.subscriptions.reject(identifier);
        default:
          return this.subscriptions.notify(identifier, "received", message);
      }
    },
    open() {
      logger.log(`WebSocket onopen event, using '${this.getProtocol()}' subprotocol`);
      this.disconnected = false;
      if (!this.isProtocolSupported()) {
        logger.log("Protocol is unsupported. Stopping monitor and disconnecting.");
        return this.close({
          allowReconnect: false
        });
      }
    },
    close(event) {
      logger.log("WebSocket onclose event");
      if (this.disconnected) {
        return;
      }
      this.disconnected = true;
      this.monitor.recordDisconnect();
      return this.subscriptions.notifyAll("disconnected", {
        willAttemptReconnect: this.monitor.isRunning()
      });
    },
    error() {
      logger.log("WebSocket onerror event");
    }
  };
  var extend3 = function(object, properties) {
    if (properties != null) {
      for (let key in properties) {
        const value = properties[key];
        object[key] = value;
      }
    }
    return object;
  };
  var Subscription2 = class {
    constructor(consumer2, params = {}, mixin) {
      this.consumer = consumer2;
      this.identifier = JSON.stringify(params);
      extend3(this, mixin);
    }
    perform(action, data = {}) {
      data.action = action;
      return this.send(data);
    }
    send(data) {
      return this.consumer.send({
        command: "message",
        identifier: this.identifier,
        data: JSON.stringify(data)
      });
    }
    unsubscribe() {
      return this.consumer.subscriptions.remove(this);
    }
  };
  var SubscriptionGuarantor2 = class {
    constructor(subscriptions) {
      this.subscriptions = subscriptions;
      this.pendingSubscriptions = [];
    }
    guarantee(subscription) {
      if (this.pendingSubscriptions.indexOf(subscription) == -1) {
        logger.log(`SubscriptionGuarantor guaranteeing ${subscription.identifier}`);
        this.pendingSubscriptions.push(subscription);
      } else {
        logger.log(`SubscriptionGuarantor already guaranteeing ${subscription.identifier}`);
      }
      this.startGuaranteeing();
    }
    forget(subscription) {
      logger.log(`SubscriptionGuarantor forgetting ${subscription.identifier}`);
      this.pendingSubscriptions = this.pendingSubscriptions.filter((s) => s !== subscription);
    }
    startGuaranteeing() {
      this.stopGuaranteeing();
      this.retrySubscribing();
    }
    stopGuaranteeing() {
      clearTimeout(this.retryTimeout);
    }
    retrySubscribing() {
      this.retryTimeout = setTimeout(() => {
        if (this.subscriptions && typeof this.subscriptions.subscribe === "function") {
          this.pendingSubscriptions.map((subscription) => {
            logger.log(`SubscriptionGuarantor resubscribing ${subscription.identifier}`);
            this.subscriptions.subscribe(subscription);
          });
        }
      }, 500);
    }
  };
  var Subscriptions2 = class {
    constructor(consumer2) {
      this.consumer = consumer2;
      this.guarantor = new SubscriptionGuarantor2(this);
      this.subscriptions = [];
    }
    create(channelName, mixin) {
      const channel = channelName;
      const params = typeof channel === "object" ? channel : {
        channel
      };
      const subscription = new Subscription2(this.consumer, params, mixin);
      return this.add(subscription);
    }
    add(subscription) {
      this.subscriptions.push(subscription);
      this.consumer.ensureActiveConnection();
      this.notify(subscription, "initialized");
      this.subscribe(subscription);
      return subscription;
    }
    remove(subscription) {
      this.forget(subscription);
      if (!this.findAll(subscription.identifier).length) {
        this.sendCommand(subscription, "unsubscribe");
      }
      return subscription;
    }
    reject(identifier) {
      return this.findAll(identifier).map((subscription) => {
        this.forget(subscription);
        this.notify(subscription, "rejected");
        return subscription;
      });
    }
    forget(subscription) {
      this.guarantor.forget(subscription);
      this.subscriptions = this.subscriptions.filter((s) => s !== subscription);
      return subscription;
    }
    findAll(identifier) {
      return this.subscriptions.filter((s) => s.identifier === identifier);
    }
    reload() {
      return this.subscriptions.map((subscription) => this.subscribe(subscription));
    }
    notifyAll(callbackName, ...args) {
      return this.subscriptions.map((subscription) => this.notify(subscription, callbackName, ...args));
    }
    notify(subscription, callbackName, ...args) {
      let subscriptions;
      if (typeof subscription === "string") {
        subscriptions = this.findAll(subscription);
      } else {
        subscriptions = [subscription];
      }
      return subscriptions.map((subscription2) => typeof subscription2[callbackName] === "function" ? subscription2[callbackName](...args) : void 0);
    }
    subscribe(subscription) {
      if (this.sendCommand(subscription, "subscribe")) {
        this.guarantor.guarantee(subscription);
      }
    }
    confirmSubscription(identifier) {
      logger.log(`Subscription confirmed ${identifier}`);
      this.findAll(identifier).map((subscription) => this.guarantor.forget(subscription));
    }
    sendCommand(subscription, command) {
      const { identifier } = subscription;
      return this.consumer.send({
        command,
        identifier
      });
    }
  };
  var Consumer2 = class {
    constructor(url) {
      this._url = url;
      this.subscriptions = new Subscriptions2(this);
      this.connection = new Connection2(this);
    }
    get url() {
      return createWebSocketURL2(this._url);
    }
    send(data) {
      return this.connection.send(data);
    }
    connect() {
      return this.connection.open();
    }
    disconnect() {
      return this.connection.close({
        allowReconnect: false
      });
    }
    ensureActiveConnection() {
      if (!this.connection.isActive()) {
        return this.connection.open();
      }
    }
  };
  function createWebSocketURL2(url) {
    if (typeof url === "function") {
      url = url();
    }
    if (url && !/^wss?:/i.test(url)) {
      const a = document.createElement("a");
      a.href = url;
      a.href = a.href;
      a.protocol = a.protocol.replace("http", "ws");
      return a.href;
    } else {
      return url;
    }
  }
  function createConsumer3(url = getConfig2("url") || INTERNAL.default_mount_path) {
    return new Consumer2(url);
  }
  function getConfig2(name) {
    const element = document.head.querySelector(`meta[name='action-cable-${name}']`);
    if (element) {
      return element.getAttribute("content");
    }
  }

  // app/javascript/channels/consumer.js
  var consumer_default = createConsumer3();

  // app/javascript/channels/send_scripts_channel.js
  consumer_default.subscriptions.create("SendScriptsChannel", {
    // Called once when the subscription is created.
    initialized() {
    },
    connected() {
      console.log("SendScriptsChannel connected");
    },
    disconnected() {
      console.log("SendScriptsChannel disconnected");
    },
    received(data) {
      if (window.editor != null) {
        window.editor.save().then((savedData) => {
          cleanScript2(savedData);
          if (data.status === "up_error" || data.status === "up_success") {
            if (savedData.blocks[0].type !== "textResult" || savedData.blocks[0].type !== "errorResult")
              savedData.blocks.unshift(data.result);
          } else {
            let indexPDB;
            if ((indexPDB = savedData.blocks.findIndex((x) => x.type === "progressDisplayBlock")) !== -1) {
              let pdb = savedData.blocks[indexPDB].data.progress?.split(" ");
              let count = parseInt(pdb[2]);
              let err = parseInt(pdb[5]);
              if (data.result.type === "errorResult") {
                err += 1;
              }
              savedData.blocks[indexPDB].data.progress = `\u0412 \u043E\u0447\u0435\u0440\u0435\u0434\u0438 ${count - 1} \u0437\u0430\u0434\u0430\u0447, \u043E\u0448\u0438\u0431\u043E\u043A ${err}`;
            }
            savedData = addResult(savedData, data.result, data.key);
          }
          window.editor.render(savedData);
        });
      }
      function cleanScript2(savedData) {
        let savedDataBlocksLength = savedData.blocks.length;
        for (let j = 0; j < savedDataBlocksLength; j++) {
          let block = savedData.blocks.shift();
          if (block.type === "script") {
            let a = block.data.script.split("\n");
            let z = a.length;
            for (let i = 0; i < z; i++) {
              if (parseInt(a[i])) {
                a.splice(i, 1);
                i -= 1;
              }
            }
            block.data.script = a.join("\n");
            savedData.blocks.push(block);
          } else {
            savedData.blocks.push(block);
          }
        }
      }
      function addResult(savedData, result, key) {
        const scriptId = savedData.blocks.findIndex((x) => x.id === key);
        if (scriptId === savedData.blocks.length - 1) {
          savedData.blocks.push(result);
        } else {
          const deleteCount = savedData.blocks[scriptId + 1].type === result.type ? 1 : 0;
          savedData.blocks.splice(scriptId + 1, deleteCount, result);
        }
        return savedData;
      }
    }
  });
})();
/*! Bundled license information:

@editorjs/editorjs/dist/editor.js:
  (*! For license information please see editor.js.LICENSE.txt *)

lodash/lodash.js:
  (**
   * @license
   * Lodash <https://lodash.com/>
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   *)

three/build/three.module.js:
  (**
   * @license
   * Copyright 2010-2022 Three.js Authors
   * SPDX-License-Identifier: MIT
   *)
*/
//# sourceMappingURL=application.js.map
